/// This module shows how to create a custom intent from pre-existing actions.
/// Upgrade and Restrict are part of the AccountActions package.
/// Here we use them to compose a new intent.
/// 
/// This intent represents a "one last upgrade".
/// An enforceable promise from the team to the users making the package immutable after some final adjustments.

module account_examples::upgrade_and_restrict;

use std::string::String;
use sui::{
    package::{UpgradeTicket, UpgradeReceipt},
    clock::Clock,
};
use account_protocol::{
    executable::Executable,
    account::{Account, Auth},
};
use account_multisig::multisig::{Multisig, Approvals};
use account_actions::package_upgrade;
use account_examples::version;

// === Structs ===

/// Intent witness
public struct FinalUpgradeIntent() has copy, drop;


// === Public Functions ===

/// step 1: propose an Upgrade by passing the digest of the package build
public fun request_final_upgrade(
    auth: Auth,
    outcome: Approvals,
    multisig: &mut Account<Multisig, Approvals>, 
    key: String,
    execution_time: u64,
    expiration_time: u64,
    description: String,
    package_name: String,
    digest: vector<u8>,
    clock: &Clock,
    ctx: &mut TxContext
) {
    multisig.verify(auth);

    let mut intent = multisig.create_intent(
        key,
        description,
        vector[execution_time],
        expiration_time,
        b"".to_string(),
        outcome,
        version::current(),
        FinalUpgradeIntent(),
        ctx
    );
    // first we would like to upgrade
    package_upgrade::new_upgrade(&mut intent, multisig, package_name, digest, clock, version::current(), FinalUpgradeIntent());
    // then we would like to make the package immutable (destroy the upgrade cap)
    package_upgrade::new_restrict(&mut intent, multisig, package_name, 255, version::current(), FinalUpgradeIntent());
    // add the intent to the multisig
    multisig.add_intent(intent, version::current(), FinalUpgradeIntent());
}

/// step 2: multiple members have to approve the intent (account_multisig::multisig::approve_intent)
/// step 3: execute the intent and return the Executable (account_multisig::multisig::execute_intent)

/// step 4: destroy Upgrade and return the UpgradeTicket for upgrading
public fun execute_upgrade(
    executable: &mut Executable,
    multisig: &mut Account<Multisig, Approvals>,
    clock: &Clock,
): UpgradeTicket {
    package_upgrade::do_upgrade(executable, multisig, clock, version::current(), FinalUpgradeIntent())
} 

/// Need to consume the ticket to upgrade the package before completing the intent.

/// step 5: consume the receipt to commit the upgrade
public fun complete_upgrade(
    executable: Executable,
    multisig: &mut Account<Multisig, Approvals>,
    receipt: UpgradeReceipt,
) {
    package_upgrade::confirm_upgrade(&executable, multisig, receipt, version::current(), FinalUpgradeIntent());
    multisig.confirm_execution(executable, version::current(), FinalUpgradeIntent());
}

/// step 6: restrict the upgrade policy (destroy the upgrade cap)
public fun execute_restrict(
    mut executable: Executable,
    multisig: &mut Account<Multisig, Approvals>,
) {
    package_upgrade::do_restrict(&mut executable, multisig, version::current(), FinalUpgradeIntent());
    multisig.confirm_execution(executable, version::current(), FinalUpgradeIntent());
}

/// step 7: destroy the intent to get the Expired hot potato as there is no execution left
/// and delete the actions from Expired in their own module 
/// This module demonstrates how to create an intent with a custom action.
/// Here there is no action interface as the action is directly handled as part of the intent.
/// This means that the action cannot be reused in another module.

module account_examples::access_control_simplified;

use std::string::String;
use account_protocol::{
    account::{Account, Auth},
    intents::Expired,
    executable::Executable,
};
use account_multisig::multisig::{Multisig, Approvals};
use account_examples::version;

// === Constants ===

const MAX_FEE: u64 = 10000; // 100%

// === Structs ===

/// Intent structs must have copy and drop only
public struct UpdateFeeIntent() has copy, drop;

/// Action structs must have store only 
public struct UpdateFeeAction has store {
    fee: u64,
}

/// Your protocol
public struct Protocol has key {
    id: UID,
    // add bunch of fields
    fee: u64,
}

// === Public functions ===

fun init(ctx: &mut TxContext) {
    transfer::share_object(Protocol {
        id: object::new(ctx),
        fee: 0,
    });
}    

/*
* the rest of the protocol implementation 
* { ... }
*/

// === Public functions ===

/// step 1: propose to update the version
public fun request_update_fee(
    auth: Auth,
    outcome: Approvals,
    multisig: &mut Account<Multisig, Approvals>,
    key: String,
    execution_time: u64,
    expiration_time: u64,
    description: String,
    fee: u64,
    ctx: &mut TxContext
) {
    multisig.verify(auth);

    assert!(fee <= MAX_FEE);
    let mut intent = multisig.create_intent(
        key,
        description,
        vector[execution_time], // executed once only
        expiration_time,
        b"".to_string(),
        outcome,
        version::current(),
        UpdateFeeIntent(),
        ctx
    );

    multisig.add_action(&mut intent, UpdateFeeAction { fee }, version::current(), UpdateFeeIntent());
    multisig.add_intent(intent, version::current(), UpdateFeeIntent());
}

/// step 2: multiple members have to approve the intent (account_multisig::multisig::approve_intent)
/// step 3: execute the intent and return the action (account_protocol::account::execute_intent)

/// step 4: execute the intent and destroy the executable
public fun execute_update_fee(
    mut executable: Executable,
    multisig: &Account<Multisig, Approvals>,
    protocol: &mut Protocol,
) {
    let update_fee: &UpdateFeeAction = multisig.process_action(&mut executable, version::current(), UpdateFeeIntent());
    protocol.fee = update_fee.fee;
    multisig.confirm_execution(executable, version::current(), UpdateFeeIntent());
}

/// step 5: destroy the intent to get the Expired hot potato as there is no execution left

/// step 6: delete the actions from Expired
public fun delete_update_fee(expired: &mut Expired) {
    let UpdateFeeAction { .. } = expired.remove_action();
}/// This module demonstrates how to create an intent with a custom action.
/// Here the action accessors are public but protected by an Intent and an Executable.
/// This means that any package can reuse this action for implementing its own intent.

module account_examples::access_control_composable;

use std::string::String;
use account_protocol::{
    account::{Account, Auth},
    intents::{Intent, Expired},
    executable::Executable,
    version_witness::VersionWitness,
};
use account_examples::version;

// === Constants ===

const MAX_FEE: u64 = 10000; // 100%

// === Structs ===

/// Intent structs must have copy and drop only
public struct UpdateFeeIntent() has copy, drop;

/// Action structs must have store only 
public struct UpdateFeeAction has store {
    fee: u64,
}

public struct Protocol has key {
    id: UID,
    // add bunch of fields
    fee: u64,
}

// === Public functions ===

fun init(ctx: &mut TxContext) {
    transfer::share_object(Protocol {
        id: object::new(ctx),
        fee: 0,
    });
}    

/*
* the rest of the protocol implementation 
* { ... }
*/

/// step 1: request to update the fee
public fun request_update_fee<Config, Outcome>(
    auth: Auth,
    outcome: Outcome,
    account: &mut Account<Config, Outcome>,
    key: String,
    execution_time: u64,
    expiration_time: u64,
    description: String,
    fee: u64,
    ctx: &mut TxContext
) {
    account.verify(auth);

    let mut intent = account.create_intent(
        key,
        description,
        vector[execution_time], // executed once only
        expiration_time,
        b"".to_string(),
        outcome,
        version::current(),
        UpdateFeeIntent(),
        ctx
    );

    new_update_fee(&mut intent, account, fee, version::current(), UpdateFeeIntent());
    account.add_intent(intent, version::current(), UpdateFeeIntent());
}

/// step 2: resolve the intent according to the account config
/// step 3: execute the proposal and return the action (package::account_config::execute_intent)

/// step 4: execute the intent using the Executable
public fun execute_update_fee<Config, Outcome>(
    mut executable: Executable,
    account: &mut Account<Config, Outcome>,
    protocol: &mut Protocol,
) {
    update_fee(protocol, &mut executable, account, version::current(), UpdateFeeIntent());
    account.confirm_execution(executable, version::current(), UpdateFeeIntent());
}

/// step 5: destroy the intent to get the Expired hot potato as there is no execution left
/// and delete the actions from Expired in their own module 

// Action functions

/// These functions are public and necessitate both a witness and a "VersionWitness" 
/// to ensure correct implementation of the intents that could be defined.
/// 
/// The action can only be instantiated within an intent.
/// And it can be accessed (and executed) only through the acquisition of an Executable.
/// 
/// This is the pattern that should be used to make actions available to other packages.

public fun new_update_fee<Config, Outcome, IW: drop>(
    intent: &mut Intent<Outcome>,
    account: &mut Account<Config, Outcome>,
    fee: u64,
    version_witness: VersionWitness,
    intent_witness: IW,    
) {
    assert!(fee <= MAX_FEE);
    account.add_action(intent, UpdateFeeAction { fee }, version_witness, intent_witness);
}

public fun update_fee<Config, Outcome, IW: drop>(
    protocol: &mut Protocol,
    executable: &mut Executable,
    account: &mut Account<Config, Outcome>,
    version_witness: VersionWitness,
    intent_witness: IW,
) {
    let update_fee: &UpdateFeeAction = account.process_action(executable, version_witness, intent_witness);
    protocol.fee = update_fee.fee;
}
    
public fun delete_update_fee(expired: &mut Expired) {
    let UpdateFeeAction { .. } = expired.remove_action();
}/// This module tracks the version of the package by implementing the version_witness type.
/// A new version type should be defined for each new version of the package.

module account_examples::version;

// === Imports ===

use account_protocol::version_witness::{Self, VersionWitness};

// === Constants ===

const VERSION: u64 = 1; // bump this when the package is upgraded

// === Structs ===

// define a new version struct for each new version of the package
public struct V1() has drop;

public(package) fun current(): VersionWitness {
    version_witness::new(V1()) // modify with the new version struct
}

// === Public functions ===

public fun get(): u64 {
    VERSION
}
/// This module tracks the version of the package by implementing the version_witness type.
/// A new version type should be defined for each new version of the package.

module account_actions::version;

// === Imports ===

use account_protocol::version_witness::{Self, VersionWitness};

// === Constants ===

const VERSION: u64 = 1; // bump this when the package is upgraded

// === Structs ===

// define a new version struct for each new version of the package
public struct V1() has drop;

public(package) fun current(): VersionWitness {
    version_witness::new(V1()) // modify with the new version struct
}

// === Public functions ===

public fun get(): u64 {
    VERSION
}
/// Authenticated users can place nfts from their kiosk into the account's without passing through the intent process.
/// Nfts can be transferred into any other Kiosk. Upon resolution, the recipient must execute the transfer.
/// The functions take the caller's kiosk and the account's kiosk to execute.
/// Nfts can be listed for sale in the kiosk, and then purchased by anyone.
/// Authorized addresses can withdraw the profits from the kiosk to the Account.

module account_actions::kiosk;

// === Imports ===

use std::string::String;
use sui::{
    coin,
    sui::SUI,
    kiosk::{Self, Kiosk, KioskOwnerCap},
    transfer_policy::{TransferPolicy, TransferRequest},
};
use kiosk::{kiosk_lock_rule, royalty_rule, personal_kiosk_rule};
use account_protocol::{
    account::{Account, Auth},
    intents::{Expired, Intent},
    executable::Executable,
    version_witness::VersionWitness,
};
use account_actions::version;

// === Errors ===

const EWrongReceiver: u64 = 0;

// === Structs ===    

/// Dynamic Object Field key for the KioskOwnerCap
public struct KioskOwnerKey(String) has copy, drop, store;

/// Action transferring nfts from the account's kiosk to another one
public struct TakeAction has store {
    // name of the Kiosk
    name: String,
    // id of the nfts to transfer
    nft_id: ID,
    // owner of the receiver kiosk
    recipient: address,
}
/// Action listing nfts for purchase
public struct ListAction has store {
    // name of the Kiosk
    name: String,
    // id of the nft to list
    nft_id: ID,
    // listing price of the nft
    price: u64
}

// === Public functions ===

/// Creates a new Kiosk and locks the KioskOwnerCap in the Account
#[allow(lint(share_owned))]
public fun open<Config>(
    auth: Auth,
    account: &mut Account<Config>, 
    name: String, 
    ctx: &mut TxContext
) {
    account.verify(auth);

    let (mut kiosk, kiosk_owner_cap) = kiosk::new(ctx);
    kiosk.set_owner_custom(&kiosk_owner_cap, account.addr());

    account.add_managed_asset(KioskOwnerKey(name), kiosk_owner_cap, version::current());
    transfer::public_share_object(kiosk);
}

/// Checks if a Kiosk exists for a given name.
public fun has_lock<Config>(
    account: &Account<Config>,
    name: String
): bool {
    account.has_managed_asset(KioskOwnerKey(name))
}

/// Deposits from another Kiosk, no need for intent.
/// Optional royalty, lock and personal kiosk rules are automatically resolved for the type.
/// Additional rules may be confirmed after in the PTB.
public fun place<Config, Nft: key + store>(
    auth: Auth,
    account: &mut Account<Config>, 
    account_kiosk: &mut Kiosk, 
    sender_kiosk: &mut Kiosk, 
    sender_cap: &KioskOwnerCap, 
    policy: &mut TransferPolicy<Nft>,
    name: String,
    nft_id: ID,
    ctx: &mut TxContext
): TransferRequest<Nft> {
    account.verify(auth);

    let cap: &KioskOwnerCap = account.borrow_managed_asset(KioskOwnerKey(name), version::current());

    sender_kiosk.list<Nft>(sender_cap, nft_id, 0);
    let (nft, mut request) = sender_kiosk.purchase<Nft>(nft_id, coin::zero<SUI>(ctx));

    if (policy.has_rule<Nft, kiosk_lock_rule::Rule>()) {
        account_kiosk.lock(cap, policy, nft);
        kiosk_lock_rule::prove(&mut request, account_kiosk);
    } else {
        account_kiosk.place(cap, nft);
    };

    if (policy.has_rule<Nft, royalty_rule::Rule>()) {
        // can't read royalty rule on-chain because transfer_policy::get_rule not implemented
        // so we can't throw an error if there is a minimum floor price set
        royalty_rule::pay(policy, &mut request, coin::zero<SUI>(ctx));
    }; 

    if (policy.has_rule<Nft, personal_kiosk_rule::Rule>()) {
        personal_kiosk_rule::prove(account_kiosk, &mut request);
    };
    // the request can be filled with arbitrary rules and must be confirmed afterwards
    request
}

/// Authenticated users can delist nfts
public fun delist<Config, Nft: key + store>(
    auth: Auth,
    account: &mut Account<Config>, 
    kiosk: &mut Kiosk, 
    name: String,
    nft_id: ID,
) {
    account.verify(auth);

    let cap: &KioskOwnerCap = account.borrow_managed_asset(KioskOwnerKey(name), version::current());
    kiosk.delist<Nft>(cap, nft_id);
}

/// Authenticated users can withdraw the profits to the account
public fun withdraw_profits<Config>(
    auth: Auth,
    account: &mut Account<Config>,
    kiosk: &mut Kiosk,
    name: String,
    ctx: &mut TxContext
) {
    account.verify(auth);

    let cap: &KioskOwnerCap = account.borrow_managed_asset(KioskOwnerKey(name), version::current());

    let profits_mut = kiosk.profits_mut(cap);
    let profits_value = profits_mut.value();
    let profits = profits_mut.split(profits_value);

    account.keep(coin::from_balance<SUI>(profits, ctx));
}

/// Closes the kiosk if empty
public fun close<Config>(
    auth: Auth,
    account: &mut Account<Config>,
    name: String,
    kiosk: Kiosk,
    ctx: &mut TxContext
) {
    account.verify(auth);

    let cap: KioskOwnerCap = account.remove_managed_asset(KioskOwnerKey(name), version::current());
    let profits = kiosk.close_and_withdraw(cap, ctx);
    
    account.keep(profits);
}

// Intent functions

/// Creates a new TakeAction and adds it to an intent.
public fun new_take<Outcome, IW: drop>(
    intent: &mut Intent<Outcome>,
    name: String,
    nft_id: ID,
    recipient: address,
    intent_witness: IW,
) {
    intent.add_action(TakeAction { name, nft_id, recipient }, intent_witness);
}

/// Processes a TakeAction, resolves the rules and places the nft into the recipient's kiosk.
public fun do_take<Config, Outcome: store, Nft: key + store, IW: drop>(
    executable: &mut Executable<Outcome>,
    account: &mut Account<Config>,
    account_kiosk: &mut Kiosk, 
    recipient_kiosk: &mut Kiosk, 
    recipient_cap: &KioskOwnerCap, 
    policy: &mut TransferPolicy<Nft>,
    version_witness: VersionWitness,
    intent_witness: IW,
    ctx: &mut TxContext
): TransferRequest<Nft> {
    executable.intent().assert_is_account(account.addr());

    let action: &TakeAction = executable.next_action(intent_witness);
    assert!(action.recipient == ctx.sender(), EWrongReceiver);

    let cap: &KioskOwnerCap = account.borrow_managed_asset(KioskOwnerKey(action.name), version_witness);

    account_kiosk.list<Nft>(cap, action.nft_id, 0);
    let (nft, mut request) = account_kiosk.purchase<Nft>(action.nft_id, coin::zero<SUI>(ctx));

    if (policy.has_rule<Nft, kiosk_lock_rule::Rule>()) {
        recipient_kiosk.lock(recipient_cap, policy, nft);
        kiosk_lock_rule::prove(&mut request, recipient_kiosk);
    } else {
        recipient_kiosk.place(recipient_cap, nft);
    };

    if (policy.has_rule<Nft, royalty_rule::Rule>()) {
        royalty_rule::pay(policy, &mut request, coin::zero<SUI>(ctx));
    }; 

    if (policy.has_rule<Nft, personal_kiosk_rule::Rule>()) {
        personal_kiosk_rule::prove(account_kiosk, &mut request);
    };
    // the request can be filled with arbitrary rules and must be confirmed afterwards
    request 
}

/// Deletes a TakeAction from an expired intent.
public fun delete_take(expired: &mut Expired) {
    let TakeAction { .. } = expired.remove_action();
}

/// Creates a new ListAction and adds it to an intent.
public fun new_list<Outcome, IW: drop>(
    intent: &mut Intent<Outcome>,
    name: String,
    nft_id: ID,
    price: u64,
    intent_witness: IW,
) {
    intent.add_action(ListAction { name, nft_id, price }, intent_witness);
}

/// Processes a ListAction and lists the nft for purchase.
public fun do_list<Config, Outcome: store, Nft: key + store, IW: drop>(
    executable: &mut Executable<Outcome>,
    account: &mut Account<Config>,
    kiosk: &mut Kiosk,  
    version_witness: VersionWitness,
    intent_witness: IW,
) {
    executable.intent().assert_is_account(account.addr());
    
    let action: &ListAction = executable.next_action(intent_witness);
    let cap: &KioskOwnerCap = account.borrow_managed_asset(KioskOwnerKey(action.name), version_witness);

    kiosk.list<Nft>(cap, action.nft_id, action.price);
}

/// Deletes a ListAction from an expired intent.
public fun delete_list(expired: &mut Expired) {
    let ListAction { .. } = expired.remove_action();
}
/// Package managers can lock UpgradeCaps in the account. Caps can't be unlocked, this is to enforce the policies.
/// Any rule can be defined for the upgrade lock. The module provide a timelock rule by default, based on execution time.
/// Upon locking, the user can define an optional timelock corresponding to the minimum delay between an upgrade proposal and its execution.
/// The account can decide to make the policy more restrictive or destroy the Cap, to make the package immutable.

module account_actions::package_upgrade;

// === Imports ===

use std::string::String;
use sui::{
    package::{Self, UpgradeCap, UpgradeTicket, UpgradeReceipt},
    clock::Clock,
    vec_map::{Self, VecMap},
};
use account_protocol::{
    account::{Account, Auth},
    intents::{Expired, Intent},
    executable::Executable,
    version_witness::VersionWitness,
};
use account_actions::{
    version,
};

// === Error ===

const ELockAlreadyExists: u64 = 0;
const EUpgradeTooEarly: u64 = 1;
const EPackageDoesntExist: u64 = 2;

// === Structs ===

/// Dynamic Object Field key for the UpgradeCap.
public struct UpgradeCapKey(String) has copy, drop, store;
/// Dynamic field key for the UpgradeRules.
public struct UpgradeRulesKey(String) has copy, drop, store;
/// Dynamic field key for the UpgradeIndex.
public struct UpgradeIndexKey() has copy, drop, store;

/// Dynamic field wrapper defining an optional timelock.
public struct UpgradeRules has store {
    // minimum delay between proposal and execution
    delay_ms: u64,
} 

/// Map tracking the latest upgraded package address for a package name.
public struct UpgradeIndex has store {
    // map of package name to address
    packages_info: VecMap<String, address>,
}

/// Action to upgrade a package using a locked UpgradeCap.
public struct UpgradeAction has store {
    // name of the package
    name: String,
    // digest of the package build we want to publish
    digest: vector<u8>,
}
/// Action to commit an upgrade.
public struct CommitAction has store {
    // name of the package
    name: String,
}
/// Action to restrict the policy of a locked UpgradeCap.
public struct RestrictAction has store {
    // name of the package
    name: String,
    // downgrades to this policy
    policy: u8,
}

// === Public Functions ===

/// Attaches the UpgradeCap as a Dynamic Object Field to the account.
public fun lock_cap<Config>(
    auth: Auth,
    account: &mut Account<Config>,
    cap: UpgradeCap,
    name: String, // name of the package
    delay_ms: u64, // minimum delay between proposal and execution
) {
    account.verify(auth);
    assert!(!has_cap(account, name), ELockAlreadyExists);

    if (!account.has_managed_data(UpgradeIndexKey()))
        account.add_managed_data(UpgradeIndexKey(), UpgradeIndex { packages_info: vec_map::empty() }, version::current());

    let upgrade_index_mut: &mut UpgradeIndex = account.borrow_managed_data_mut(UpgradeIndexKey(), version::current());
    upgrade_index_mut.packages_info.insert(name, cap.package().to_address());
    
    account.add_managed_asset(UpgradeCapKey(name), cap, version::current());
    account.add_managed_data(UpgradeRulesKey(name), UpgradeRules { delay_ms }, version::current());
}

/// Returns true if the account has an UpgradeCap for a given package name.
public fun has_cap<Config>(
    account: &Account<Config>, 
    name: String
): bool {
    account.has_managed_asset(UpgradeCapKey(name))
}

/// Returns the address of the package for a given package name.
public fun get_cap_package<Config>(
    account: &Account<Config>, 
    name: String
): address {
    account.borrow_managed_asset<_, _, UpgradeCap>(UpgradeCapKey(name), version::current()).package().to_address()
} 

/// Returns the version of the UpgradeCap for a given package name.
public fun get_cap_version<Config>(
    account: &Account<Config>, 
    name: String
): u64 {
    account.borrow_managed_asset<_, _, UpgradeCap>(UpgradeCapKey(name), version::current()).version()
} 

/// Returns the policy of the UpgradeCap for a given package name.
public fun get_cap_policy<Config>(
    account: &Account<Config>, 
    name: String
): u8 {
    account.borrow_managed_asset<_, _, UpgradeCap>(UpgradeCapKey(name), version::current()).policy()
} 

/// Returns the timelock of the UpgradeRules for a given package name.
public fun get_time_delay<Config>(
    account: &Account<Config>, 
    name: String
): u64 {
    account.borrow_managed_data<_, _, UpgradeRules>(UpgradeRulesKey(name), version::current()).delay_ms
}

/// Returns the map of package names to package addresses.
public fun get_packages_info<Config>(
    account: &Account<Config>
): &VecMap<String, address> {
    &account.borrow_managed_data<_, _, UpgradeIndex>(UpgradeIndexKey(), version::current()).packages_info
}

/// Returns true if the package is managed by the account.
public fun is_package_managed<Config>(
    account: &Account<Config>,
    package_addr: address
): bool {
    if (!account.has_managed_data(UpgradeIndexKey())) return false;
    let index: &UpgradeIndex = account.borrow_managed_data(UpgradeIndexKey(), version::current());
    
    let mut i = 0;
    while (i < index.packages_info.size()) {
        let (_, value) = index.packages_info.get_entry_by_idx(i);
        if (value == package_addr) return true;
        i = i + 1;
    };

    false
}

/// Returns the address of the package for a given package name.
public fun get_package_addr<Config>(
    account: &Account<Config>,
    package_name: String
): address {
    let index: &UpgradeIndex = account.borrow_managed_data(UpgradeIndexKey(), version::current());
    *index.packages_info.get(&package_name)
}

/// Returns the package name for a given package address.
#[allow(unused_assignment)] // false positive
public fun get_package_name<Config>(
    account: &Account<Config>,
    package_addr: address
): String {
    let index: &UpgradeIndex = account.borrow_managed_data(UpgradeIndexKey(), version::current());
    let (mut i, mut package_name) = (0, b"".to_string());
    loop {
        let (name, addr) = index.packages_info.get_entry_by_idx(i);
        package_name = *name;
        if (addr == package_addr) break package_name;
        
        i = i + 1;
        if (i == index.packages_info.size()) abort EPackageDoesntExist;
    };
    
    package_name
} 

// Intent functions

/// Creates a new UpgradeAction and adds it to an intent.
public fun new_upgrade<Outcome, IW: drop>(
    intent: &mut Intent<Outcome>,
    name: String,
    digest: vector<u8>, 
    intent_witness: IW,
) {
    intent.add_action(UpgradeAction { name, digest }, intent_witness);
}    

/// Processes an UpgradeAction and returns a UpgradeTicket.
public fun do_upgrade<Config, Outcome: store, IW: drop>(
    executable: &mut Executable<Outcome>,
    account: &mut Account<Config>,
    clock: &Clock,
    version_witness: VersionWitness,
    intent_witness: IW,
): UpgradeTicket {
    executable.intent().assert_is_account(account.addr());

    let action: &UpgradeAction = executable.next_action(intent_witness);
    assert!(
        clock.timestamp_ms() >= executable.intent().creation_time() + get_time_delay(account, action.name), 
        EUpgradeTooEarly
    );

    let cap: &mut UpgradeCap = account.borrow_managed_asset_mut(UpgradeCapKey(action.name), version_witness);
    let policy = cap.policy();

    cap.authorize_upgrade(policy, action.digest) // return ticket
}    

/// Deletes an UpgradeAction from an expired intent.
public fun delete_upgrade(expired: &mut Expired) {
    let UpgradeAction { .. } = expired.remove_action();
}

/// Creates a new CommitAction and adds it to an intent.
public fun new_commit<Outcome, IW: drop>(
    intent: &mut Intent<Outcome>,
    name: String,
    intent_witness: IW,
) {
    intent.add_action(CommitAction { name }, intent_witness);
}    

// must be called after UpgradeAction is processed, there cannot be any other action processed before
/// Commits an upgrade and updates the index with the new package address.
public fun do_commit<Config, Outcome: store, IW: drop>(
    executable: &mut Executable<Outcome>,
    account: &mut Account<Config>,
    receipt: UpgradeReceipt,
    version_witness: VersionWitness,
    intent_witness: IW,
) {
    executable.intent().assert_is_account(account.addr());

    let action: &CommitAction = executable.next_action(intent_witness);

    let cap_mut: &mut UpgradeCap = account.borrow_managed_asset_mut(UpgradeCapKey(action.name), version_witness);
    cap_mut.commit_upgrade(receipt);
    let new_package_addr = cap_mut.package().to_address();

    // update the index with the new package address
    let index_mut: &mut UpgradeIndex = account.borrow_managed_data_mut(UpgradeIndexKey(), version_witness);
    *index_mut.packages_info.get_mut(&action.name) = new_package_addr;
}

public fun delete_commit(expired: &mut Expired) {
    let CommitAction { .. } = expired.remove_action();
}

/// Creates a new RestrictAction and adds it to an intent.
public fun new_restrict<Outcome, IW: drop>(
    intent: &mut Intent<Outcome>,
    name: String,
    policy: u8, 
    intent_witness: IW,
) {
    intent.add_action(RestrictAction { name, policy }, intent_witness);
}    

/// Processes a RestrictAction and updates the UpgradeCap policy.
public fun do_restrict<Config, Outcome: store, IW: drop>(
    executable: &mut Executable<Outcome>,
    account: &mut Account<Config>,
    version_witness: VersionWitness,
    intent_witness: IW,
) {
    executable.intent().assert_is_account(account.addr());
    
    let action: &RestrictAction = executable.next_action(intent_witness);

    if (action.policy == package::additive_policy()) {
        let cap_mut: &mut UpgradeCap = account.borrow_managed_asset_mut(UpgradeCapKey(action.name), version_witness);
        cap_mut.only_additive_upgrades();
    } else if (action.policy == package::dep_only_policy()) {
        let cap_mut: &mut UpgradeCap = account.borrow_managed_asset_mut(UpgradeCapKey(action.name), version_witness);
        cap_mut.only_dep_upgrades();
    } else {
        let cap: UpgradeCap = account.remove_managed_asset(UpgradeCapKey(action.name), version_witness);
        package::make_immutable(cap);
    };
}

/// Deletes a RestrictAction from an expired intent.
public fun delete_restrict(expired: &mut Expired) {
    let RestrictAction { .. } = expired.remove_action();
}

// === Package Funtions ===

/// Borrows the UpgradeCap for a given package address.
public(package) fun borrow_cap<Config>(
    account: &Account<Config>, 
    package_addr: address
): &UpgradeCap {
    let name = get_package_name(account, package_addr);
    account.borrow_managed_asset(UpgradeCapKey(name), version::current())
}/// Members can create multiple vaults with different balances and managers (using roles).
/// This allows for a more flexible and granular way to manage funds.

module account_actions::vault;

// === Imports ===

use std::{
    string::String,
    type_name::{Self, TypeName},
};
use sui::{
    bag::{Self, Bag},
    balance::Balance,
    coin::{Self, Coin},
};
use account_protocol::{
    account::{Account, Auth},
    intents::{Expired, Intent},
    executable::Executable,
    version_witness::VersionWitness,
};
use account_actions::version;

// === Errors ===

const EVaultNotEmpty: u64 = 0;

// === Structs ===

/// Dynamic Field key for the Vault.
public struct VaultKey(String) has copy, drop, store;
/// Dynamic field holding a budget with different coin types, key is name
public struct Vault has store {
    // heterogeneous array of Balances, TypeName -> Balance<CoinType>
    bag: Bag
}

/// Action to deposit an amount of this coin to the targeted Vault.
public struct DepositAction<phantom CoinType> has store {
    // vault name
    name: String,
    // exact amount to be deposited
    amount: u64,
}
/// Action to be used within intent making good use of the returned coin, similar to owned::withdraw.
public struct SpendAction<phantom CoinType> has store {
    // vault name
    name: String,
    // amount to withdraw
    amount: u64,
}

// === Public Functions ===

/// Authorized address can open a vault.
public fun open<Config>(
    auth: Auth,
    account: &mut Account<Config>,
    name: String,
    ctx: &mut TxContext
) {
    account.verify(auth);

    account.add_managed_data(VaultKey(name), Vault { bag: bag::new(ctx) }, version::current());
}

/// Deposits coins owned by a an authorized address into a vault.
public fun deposit<Config, CoinType: drop>(
    auth: Auth,
    account: &mut Account<Config>,
    name: String, 
    coin: Coin<CoinType>, 
) {
    account.verify(auth);

    let vault: &mut Vault = 
        account.borrow_managed_data_mut(VaultKey(name), version::current());

    if (vault.coin_type_exists<CoinType>()) {
        let balance_mut = vault.bag.borrow_mut<_, Balance<_>>(type_name::get<CoinType>());
        balance_mut.join(coin.into_balance());
    } else {
        vault.bag.add(type_name::get<CoinType>(), coin.into_balance());
    };
}

/// Closes the vault if empty.
public fun close<Config>(
    auth: Auth,
    account: &mut Account<Config>,
    name: String,
) {
    account.verify(auth);

    let Vault { bag } = 
        account.remove_managed_data(VaultKey(name), version::current());
    assert!(bag.is_empty(), EVaultNotEmpty);
    bag.destroy_empty();
}

/// Returns true if the vault exists.
public fun has_vault<Config>(
    account: &Account<Config>, 
    name: String
): bool {
    account.has_managed_data(VaultKey(name))
}

/// Returns a reference to the vault.
public fun borrow_vault<Config>(
    account: &Account<Config>, 
    name: String
): &Vault {
    account.borrow_managed_data(VaultKey(name), version::current())
}

/// Returns the number of coin types in the vault.
public fun size(vault: &Vault): u64 {
    vault.bag.length()
}

/// Returns true if the coin type exists in the vault.
public fun coin_type_exists<CoinType: drop>(vault: &Vault): bool {
    vault.bag.contains(type_name::get<CoinType>())
}

/// Returns the value of the coin type in the vault.
public fun coin_type_value<CoinType: drop>(vault: &Vault): u64 {
    vault.bag.borrow<TypeName, Balance<CoinType>>(type_name::get<CoinType>()).value()
}

// Intent functions

/// Creates a DepositAction and adds it to an intent.
public fun new_deposit<Outcome, CoinType, IW: drop>(
    intent: &mut Intent<Outcome>,
    name: String,
    amount: u64,
    intent_witness: IW,
) {
    intent.add_action(DepositAction<CoinType> { name, amount }, intent_witness);
}

/// Processes a DepositAction and deposits a coin to the vault.
public fun do_deposit<Config, Outcome: store, CoinType: drop, IW: drop>(
    executable: &mut Executable<Outcome>,
    account: &mut Account<Config>,
    coin: Coin<CoinType>,
    version_witness: VersionWitness,
    intent_witness: IW,
) {
    executable.intent().assert_is_account(account.addr());

    let action: &DepositAction<CoinType> = executable.next_action(intent_witness);
    assert!(action.amount == coin.value());
        
    let vault: &mut Vault = account.borrow_managed_data_mut(VaultKey(action.name), version_witness);
    if (!vault.coin_type_exists<CoinType>()) {
        vault.bag.add(type_name::get<CoinType>(), coin.into_balance());
    } else {
        let balance_mut = vault.bag.borrow_mut<_, Balance<_>>(type_name::get<CoinType>());
        balance_mut.join(coin.into_balance());
    };
}

/// Deletes a DepositAction from an expired intent.
public fun delete_deposit<CoinType>(expired: &mut Expired) {
    let DepositAction<CoinType> { .. } = expired.remove_action();
}

/// Creates a SpendAction and adds it to an intent.
public fun new_spend<Outcome, CoinType, IW: drop>(
    intent: &mut Intent<Outcome>,
    name: String,
    amount: u64,
    intent_witness: IW,
) {
    intent.add_action(SpendAction<CoinType> { name, amount }, intent_witness);
}

/// Processes a SpendAction and takes a coin from the vault.
public fun do_spend<Config, Outcome: store, CoinType: drop, IW: drop>(
    executable: &mut Executable<Outcome>,
    account: &mut Account<Config>,
    version_witness: VersionWitness,
    intent_witness: IW,
    ctx: &mut TxContext
): Coin<CoinType> {
    executable.intent().assert_is_account(account.addr());
    
    let action: &SpendAction<CoinType> = executable.next_action(intent_witness);
        
    let vault: &mut Vault = account.borrow_managed_data_mut(VaultKey(action.name), version_witness);
    let balance_mut = vault.bag.borrow_mut<_, Balance<_>>(type_name::get<CoinType>());
    let coin = coin::take(balance_mut, action.amount, ctx);

    if (balance_mut.value() == 0) 
        vault.bag.remove<_, Balance<CoinType>>(type_name::get<CoinType>()).destroy_zero();
        
    coin
}

/// Deletes a SpendAction from an expired intent.
public fun delete_spend<CoinType>(expired: &mut Expired) {
    let SpendAction<CoinType> { .. } = expired.remove_action();
}
/// Authenticated users can lock a TreasuryCap in the Account to restrict minting and burning operations,
/// as well as modifying the CoinMetadata.

module account_actions::currency;

// === Imports ===

use std::{
    string::String,
    ascii,
};
use sui::coin::{Coin, TreasuryCap, CoinMetadata};
use account_protocol::{
    account::{Account, Auth},
    intents::{Expired, Intent},
    executable::Executable,
    version_witness::VersionWitness,
};
use account_actions::{
    currency,
    version
};

// === Errors ===

const ENoChange: u64 = 0;
const EWrongValue: u64 = 1;
const EMintDisabled: u64 = 2;
const EBurnDisabled: u64 = 3;
const ECannotUpdateName: u64 = 4;
const ECannotUpdateSymbol: u64 = 5;
const ECannotUpdateDescription: u64 = 6;
const ECannotUpdateIcon: u64 = 7;
const EMaxSupply: u64 = 8;

// === Structs ===    

/// Dynamic Object Field key for the TreasuryCap.
public struct TreasuryCapKey<phantom CoinType>() has copy, drop, store;
/// Dynamic Field key for the CurrencyRules.
public struct CurrencyRulesKey<phantom CoinType>() has copy, drop, store;
/// Dynamic Field wrapper restricting access to a TreasuryCap, permissions are disabled forever if set.
public struct CurrencyRules<phantom CoinType> has store {
    // coin can have a fixed supply, can_mint must be true to be able to mint more
    max_supply: Option<u64>,
    // total amount minted
    total_minted: u64,
    // total amount burned
    total_burned: u64,
    // permissions
    can_mint: bool,
    can_burn: bool,
    can_update_symbol: bool,
    can_update_name: bool,
    can_update_description: bool,
    can_update_icon: bool,
}

/// Action disabling permissions marked as true, cannot be reenabled.
public struct DisableAction<phantom CoinType> has store {
    mint: bool,
    burn: bool,
    update_symbol: bool,
    update_name: bool,
    update_description: bool,
    update_icon: bool,
}
/// Action minting new coins.
public struct MintAction<phantom CoinType> has store {
    amount: u64,
}
/// Action burning coins.
public struct BurnAction<phantom CoinType> has store {
    amount: u64,
}
/// Action updating a CoinMetadata object using a locked TreasuryCap.
public struct UpdateAction<phantom CoinType> has store { 
    symbol: Option<ascii::String>,
    name: Option<String>,
    description: Option<String>,
    icon_url: Option<ascii::String>,
}

// === Public functions ===

/// Authenticated users can lock a TreasuryCap.
public fun lock_cap<Config, CoinType>(
    auth: Auth,
    account: &mut Account<Config>,
    treasury_cap: TreasuryCap<CoinType>,
    max_supply: Option<u64>,
) {
    account.verify(auth);

    let rules = CurrencyRules<CoinType> { 
        max_supply,
        total_minted: 0,
        total_burned: 0,
        can_mint: true,
        can_burn: true,
        can_update_symbol: true,
        can_update_name: true,
        can_update_description: true,
        can_update_icon: true,
    };
    account.add_managed_data(CurrencyRulesKey<CoinType>(), rules, version::current());
    account.add_managed_asset(TreasuryCapKey<CoinType>(), treasury_cap, version::current());
}

/// Checks if a TreasuryCap exists for a given coin type.
public fun has_cap<Config, CoinType>(
    account: &Account<Config>
): bool {
    account.has_managed_asset(TreasuryCapKey<CoinType>())
}

/// Borrows the CurrencyRules for a given coin type.
public fun borrow_rules<Config, CoinType>(
    account: &Account<Config>
): &CurrencyRules<CoinType> {
    account.borrow_managed_data(CurrencyRulesKey<CoinType>(), version::current())
}

/// Returns the total supply of a given coin type.
public fun coin_type_supply<Config, CoinType>(account: &Account<Config>): u64 {
    let cap: &TreasuryCap<CoinType> = 
        account.borrow_managed_asset(TreasuryCapKey<CoinType>(), version::current());
    cap.total_supply()
}

/// Returns the maximum supply of a given coin type.
public fun max_supply<CoinType>(lock: &CurrencyRules<CoinType>): Option<u64> {
    lock.max_supply
}

/// Returns the total amount minted of a given coin type.
public fun total_minted<CoinType>(lock: &CurrencyRules<CoinType>): u64 {
    lock.total_minted
}

/// Returns the total amount burned of a given coin type.
public fun total_burned<CoinType>(lock: &CurrencyRules<CoinType>): u64 {
    lock.total_burned
}

/// Returns true if the coin type can mint.
public fun can_mint<CoinType>(lock: &CurrencyRules<CoinType>): bool {
    lock.can_mint
}

/// Returns true if the coin type can burn.
public fun can_burn<CoinType>(lock: &CurrencyRules<CoinType>): bool {
    lock.can_burn
}

/// Returns true if the coin type can update the symbol.
public fun can_update_symbol<CoinType>(lock: &CurrencyRules<CoinType>): bool {
    lock.can_update_symbol
}

/// Returns true if the coin type can update the name.
public fun can_update_name<CoinType>(lock: &CurrencyRules<CoinType>): bool {
    lock.can_update_name
}

/// Returns true if the coin type can update the description.
public fun can_update_description<CoinType>(lock: &CurrencyRules<CoinType>): bool {
    lock.can_update_description
}

/// Returns true if the coin type can update the icon.
public fun can_update_icon<CoinType>(lock: &CurrencyRules<CoinType>): bool {
    lock.can_update_icon
}

/// Anyone can burn coins they own if enabled.
public fun public_burn<Config, CoinType>(
    account: &mut Account<Config>, 
    coin: Coin<CoinType>
) {
    let rules_mut: &mut CurrencyRules<CoinType> = 
        account.borrow_managed_data_mut(CurrencyRulesKey<CoinType>(), version::current());
    assert!(rules_mut.can_burn, EBurnDisabled);
    rules_mut.total_burned = rules_mut.total_burned + coin.value();

    let cap_mut: &mut TreasuryCap<CoinType> = 
        account.borrow_managed_asset_mut(TreasuryCapKey<CoinType>(), version::current());
    cap_mut.burn(coin);
}

// Intent functions

/// Creates a DisableAction and adds it to an intent.
public fun new_disable<Outcome, CoinType, IW: drop>(
    intent: &mut Intent<Outcome>,
    mint: bool,
    burn: bool,
    update_symbol: bool,
    update_name: bool,
    update_description: bool,
    update_icon: bool,
    intent_witness: IW,
) {
    assert!(mint || burn || update_symbol || update_name || update_description || update_icon, ENoChange);
    
    intent.add_action(DisableAction<CoinType> { mint, burn, update_symbol, update_name, update_description, update_icon }, intent_witness);
}

/// Processes a DisableAction and disables the permissions marked as true.
public fun do_disable<Config, Outcome: store, CoinType, IW: drop>(
    executable: &mut Executable<Outcome>,
    account: &mut Account<Config>,
    version_witness: VersionWitness,
    intent_witness: IW,
) {
    executable.intent().assert_is_account(account.addr());

    let action: &DisableAction<CoinType> = executable.next_action(intent_witness);

    let (mint, burn, update_symbol, update_name, update_description, update_icon) = 
        (action.mint, action.burn, action.update_symbol, action.update_name, action.update_description, action.update_icon);
    
    let rules_mut: &mut CurrencyRules<CoinType> = 
        account.borrow_managed_data_mut(CurrencyRulesKey<CoinType>(), version_witness);
    
    // if disabled, can be true or false, it has no effect
    if (mint) rules_mut.can_mint = false;
    if (burn) rules_mut.can_burn = false;
    if (update_symbol) rules_mut.can_update_symbol = false;
    if (update_name) rules_mut.can_update_name = false;
    if (update_description) rules_mut.can_update_description = false;
    if (update_icon) rules_mut.can_update_icon = false;
}

/// Deletes a DisableAction from an expired intent.
public fun delete_disable<CoinType>(expired: &mut Expired) {
    let DisableAction<CoinType> { .. } = expired.remove_action();
}

/// Creates an UpdateAction and adds it to an intent.
public fun new_update<Outcome, CoinType, IW: drop>(
    intent: &mut Intent<Outcome>,
    symbol: Option<ascii::String>,
    name: Option<String>,
    description: Option<String>,
    icon_url: Option<ascii::String>,
    intent_witness: IW,
) {
    assert!(symbol.is_some() || name.is_some() || description.is_some() || icon_url.is_some(), ENoChange);

    intent.add_action(UpdateAction<CoinType> { symbol, name, description, icon_url }, intent_witness);
}

/// Processes an UpdateAction, updates the CoinMetadata.
public fun do_update<Config, Outcome: store, CoinType, IW: drop>(
    executable: &mut Executable<Outcome>,
    account: &mut Account<Config>,
    metadata: &mut CoinMetadata<CoinType>,
    version_witness: VersionWitness,
    intent_witness: IW,
) {
    executable.intent().assert_is_account(account.addr());

    let action: &UpdateAction<CoinType> = executable.next_action(intent_witness);
    let (symbol, name, description, icon_url) = (action.symbol, action.name, action.description, action.icon_url);
    let rules_mut: &mut CurrencyRules<CoinType> = 
        account.borrow_managed_data_mut(CurrencyRulesKey<CoinType>(), version_witness);

    if (!rules_mut.can_update_symbol) assert!(symbol.is_none(), ECannotUpdateSymbol);
    if (!rules_mut.can_update_name) assert!(name.is_none(), ECannotUpdateName);
    if (!rules_mut.can_update_description) assert!(description.is_none(), ECannotUpdateDescription);
    if (!rules_mut.can_update_icon) assert!(icon_url.is_none(), ECannotUpdateIcon);
    
    let (default_symbol, default_name, default_description, default_icon_url) = 
        (metadata.get_symbol(), metadata.get_name(), metadata.get_description(), metadata.get_icon_url().extract().inner_url());
    let cap: &TreasuryCap<CoinType> = 
        account.borrow_managed_asset(TreasuryCapKey<CoinType>(), version_witness);

    cap.update_symbol(metadata, symbol.get_with_default(default_symbol));
    cap.update_name(metadata, name.get_with_default(default_name));
    cap.update_description(metadata, description.get_with_default(default_description));
    cap.update_icon_url(metadata, icon_url.get_with_default(default_icon_url));
}

/// Deletes an UpdateAction from an expired intent.
public fun delete_update<CoinType>(expired: &mut Expired) {
    let UpdateAction<CoinType> { .. } = expired.remove_action();
}

/// Creates a MintAction and adds it to an intent.
public fun new_mint<Outcome, CoinType, IW: drop>(
    intent: &mut Intent<Outcome>,
    amount: u64,
    intent_witness: IW,
) {
    intent.add_action(MintAction<CoinType> { amount }, intent_witness);
}

/// Processes a MintAction, mints and returns new coins.
public fun do_mint<Config, Outcome: store, CoinType, IW: drop>(
    executable: &mut Executable<Outcome>, 
    account: &mut Account<Config>,
    version_witness: VersionWitness,
    intent_witness: IW, 
    ctx: &mut TxContext
): Coin<CoinType> {
    executable.intent().assert_is_account(account.addr());

    let action: &MintAction<CoinType> = executable.next_action(intent_witness);
    
    let total_supply = currency::coin_type_supply<_, CoinType>(account);
    let rules_mut: &mut CurrencyRules<CoinType> = 
        account.borrow_managed_data_mut(CurrencyRulesKey<CoinType>(), version_witness);

    assert!(rules_mut.can_mint, EMintDisabled);
    if (rules_mut.max_supply.is_some()) assert!(action.amount + total_supply <= *rules_mut.max_supply.borrow(), EMaxSupply);
    
    rules_mut.total_minted = rules_mut.total_minted + action.amount;

    let cap_mut: &mut TreasuryCap<CoinType> = 
        account.borrow_managed_asset_mut(TreasuryCapKey<CoinType>(), version_witness);
        
    cap_mut.mint(action.amount, ctx)  
}

/// Deletes a MintAction from an expired intent.
public fun delete_mint<CoinType>(expired: &mut Expired) {
    let MintAction<CoinType> { .. } = expired.remove_action();
}

/// Creates a BurnAction and adds it to an intent.
public fun new_burn<Outcome, CoinType, IW: drop>(
    intent: &mut Intent<Outcome>,
    amount: u64, 
    intent_witness: IW,
) {
    intent.add_action(BurnAction<CoinType> { amount }, intent_witness);
}

/// Processes a BurnAction, burns coins and returns the amount burned.
public fun do_burn<Config, Outcome: store, CoinType, IW: drop>(
    executable: &mut Executable<Outcome>, 
    account: &mut Account<Config>,
    coin: Coin<CoinType>,
    version_witness: VersionWitness,
    intent_witness: IW, 
) {
    executable.intent().assert_is_account(account.addr());

    let action: &BurnAction<CoinType> = executable.next_action(intent_witness);
    assert!(action.amount == coin.value(), EWrongValue);
        
    let rules_mut: &mut CurrencyRules<CoinType> = 
        account.borrow_managed_data_mut(CurrencyRulesKey<CoinType>(), version_witness);
    assert!(rules_mut.can_burn, EBurnDisabled);
    
    rules_mut.total_burned = rules_mut.total_burned + action.amount;

    let cap_mut: &mut TreasuryCap<CoinType> = 
        account.borrow_managed_asset_mut(TreasuryCapKey<CoinType>(), version_witness);
        
    cap_mut.burn(coin);
}

/// Deletes a BurnAction from an expired intent.
public fun delete_burn<CoinType>(expired: &mut Expired) {
    let BurnAction<CoinType> { .. } = expired.remove_action();
}

// === Test functions ===

#[test_only] 
public fun toggle_can_mint<Config, CoinType>(account: &mut Account<Config>) {
    let rules_mut: &mut CurrencyRules<CoinType> = account.borrow_managed_data_mut(CurrencyRulesKey<CoinType>(), version::current());
    rules_mut.can_mint = !rules_mut.can_mint;
}

#[test_only] 
public fun toggle_can_burn<Config, CoinType>(account: &mut Account<Config>) {
    let rules_mut: &mut CurrencyRules<CoinType> = account.borrow_managed_data_mut(CurrencyRulesKey<CoinType>(), version::current());
    rules_mut.can_burn = !rules_mut.can_burn;
}

#[test_only] 
public fun toggle_can_update_symbol<Config, CoinType>(account: &mut Account<Config>) {
    let rules_mut: &mut CurrencyRules<CoinType> = account.borrow_managed_data_mut(CurrencyRulesKey<CoinType>(), version::current());
    rules_mut.can_update_symbol = !rules_mut.can_update_symbol;
}

#[test_only] 
public fun toggle_can_update_name<Config, CoinType>(account: &mut Account<Config>) {
    let rules_mut: &mut CurrencyRules<CoinType> = account.borrow_managed_data_mut(CurrencyRulesKey<CoinType>(), version::current());
    rules_mut.can_update_name = !rules_mut.can_update_name;
}

#[test_only] 
public fun toggle_can_update_description<Config, CoinType>(account: &mut Account<Config>) {
    let rules_mut: &mut CurrencyRules<CoinType> = account.borrow_managed_data_mut(CurrencyRulesKey<CoinType>(), version::current());
    rules_mut.can_update_description = !rules_mut.can_update_description;
}

#[test_only] 
public fun toggle_can_update_icon<Config, CoinType>(account: &mut Account<Config>) {
    let rules_mut: &mut CurrencyRules<CoinType> = account.borrow_managed_data_mut(CurrencyRulesKey<CoinType>(), version::current());
    rules_mut.can_update_icon = !rules_mut.can_update_icon;
}/// This module defines apis to transfer assets owned or managed by the account.
/// The intents can implement transfers for any action type (e.g. see owned or vault).

module account_actions::transfer;

// === Imports ===

use account_protocol::{
    intents::{Expired, Intent},
    executable::Executable,
};

// === Structs ===

/// Action used in combination with other actions (like WithdrawAction) to transfer objects to a recipient.
public struct TransferAction has store {
    // address to transfer to
    recipient: address,
}

// === Public functions ===

/// Creates a TransferAction and adds it to an intent.
public fun new_transfer<Outcome, IW: drop>(
    intent: &mut Intent<Outcome>,
    recipient: address,
    intent_witness: IW,
) {
    intent.add_action(TransferAction { recipient }, intent_witness);
}

/// Processes a TransferAction and transfers an object to a recipient.
public fun do_transfer<Outcome: store, T: key + store, IW: drop>(
    executable: &mut Executable<Outcome>, 
    object: T,
    intent_witness: IW,
) {
    let action: &TransferAction = executable.next_action(intent_witness);
    transfer::public_transfer(object, action.recipient);
}

/// Deletes a TransferAction from an expired intent.
public fun delete_transfer(expired: &mut Expired) {
    let TransferAction { .. } = expired.remove_action();
}
/// Developers can restrict access to functions in their own package with a Cap that can be locked into an Account. 
/// The Cap can be borrowed upon approval and used in other move calls within the same ptb before being returned.
/// 
/// The Cap pattern uses the object type as a proof of access, the object ID is never checked.
/// Therefore, only one Cap of a given type can be locked into the Smart Account.
/// And any Cap of that type can be returned to the Smart Account after being borrowed.
/// 
/// A good practice to follow is to use a different Cap type for each function that needs to be restricted.
/// This way, the Cap borrowed can't be misused in another function, by the person executing the intent.
/// 
/// e.g.
/// 
/// public struct AdminCap has key, store {}
/// 
/// public fun foo(_: &AdminCap) { ... }

module account_actions::access_control;

// === Imports ===

use account_protocol::{
    account::{Account, Auth},
    intents::{Expired, Intent},
    executable::Executable,
    version_witness::VersionWitness,
};
use account_actions::version;

// === Errors ===

const ENoReturn: u64 = 0;

// === Structs ===    

/// Dynamic Object Field key for the Cap.
public struct CapKey<phantom Cap>() has copy, drop, store;

/// Action giving access to the Cap.
public struct BorrowAction<phantom Cap> has store {}
/// This hot potato is created upon approval to ensure the cap is returned.
public struct ReturnAction<phantom Cap> has store {}

// === Public functions ===

/// Authenticated user can lock a Cap, the Cap must have at least store ability.
public fun lock_cap<Config, Cap: key + store>(
    auth: Auth,
    account: &mut Account<Config>,
    cap: Cap,
) {
    account.verify(auth);
    account.add_managed_asset(CapKey<Cap>(), cap, version::current());
}

/// Checks if there is a Cap locked for a given type.
public fun has_lock<Config, Cap>(
    account: &Account<Config>
): bool {
    account.has_managed_asset(CapKey<Cap>())
}

// Intent functions

/// Creates and returns a BorrowAction.
public fun new_borrow<Outcome, Cap, IW: drop>(
    intent: &mut Intent<Outcome>, 
    intent_witness: IW,    
) {
    intent.add_action(BorrowAction<Cap> {}, intent_witness);
}

/// Processes a BorrowAction and returns a Borrowed hot potato and the Cap.
public fun do_borrow<Config, Outcome: store, Cap: key + store, IW: drop>(
    executable: &mut Executable<Outcome>, 
    account: &mut Account<Config>,
    version_witness: VersionWitness,
    intent_witness: IW, 
): Cap {
    executable.intent().assert_is_account(account.addr());
    // ensures there is a ReturnAction in the intent
    assert!(executable.contains_action<_, ReturnAction<Cap>>(), ENoReturn);

    let _action: &BorrowAction<Cap> = executable.next_action(intent_witness);
    
    account.remove_managed_asset(CapKey<Cap>(), version_witness)
}

/// Deletes a BorrowAction from an expired intent.
public fun delete_borrow<Cap>(expired: &mut Expired) {
    let BorrowAction<Cap> { .. } = expired.remove_action();
}

/// Creates and returns a ReturnAction.
public fun new_return<Outcome, Cap, IW: drop>(
    intent: &mut Intent<Outcome>, 
    intent_witness: IW,
) {
    intent.add_action(ReturnAction<Cap> {}, intent_witness);
}

/// Returns a Cap to the Account and validates the ReturnAction.
public fun do_return<Config, Outcome: store, Cap: key + store, IW: drop>(
    executable: &mut Executable<Outcome>,
    account: &mut Account<Config>,
    cap: Cap,
    version_witness: VersionWitness,
    intent_witness: IW,
) {
    executable.intent().assert_is_account(account.addr());
    
    let _action: &ReturnAction<Cap> = executable.next_action(intent_witness);
    account.add_managed_asset(CapKey<Cap>(), cap, version_witness);
}

/// Deletes a ReturnAction from an expired intent.
public fun delete_return<Cap>(expired: &mut Expired) {
    let ReturnAction<Cap> { .. } = expired.remove_action();
}/// This module provides the apis to create a vesting.
/// A vesting has an amount to be paid at each interval, until the balance is empty.
/// It can be cancelled at any time by the account members.

module account_actions::vesting;

// === Imports ===

use sui::{
    balance::Balance,
    coin::{Self, Coin},
    clock::Clock,
};
use account_protocol::{
    account::{Account, Auth},
    intents::{Expired, Intent},
    executable::Executable,
};

// === Errors ===

const EBalanceNotEmpty: u64 = 0;
const ETooEarly: u64 = 1;
const EWrongStream: u64 = 2;
const EVestingOver: u64 = 3;

// === Structs ===

/// Balance is locked and unlocked gradually to be claimed by the recipient.
public struct Vesting<phantom CoinType> has key {
    id: UID,
    // remaining balance to be sent
    balance: Balance<CoinType>,
    // timestamp of the last payment
    last_claimed: u64,
    // timestamp when coins can start to be claimed
    start_timestamp: u64,
    // timestamp when balance is totally unlocked
    end_timestamp: u64,
    // address to pay
    recipient: address,
}

/// Cap enabling bearer to claim the vesting.
/// Helper object for discoverability.
public struct ClaimCap has key {
    id: UID,
    // id of the vesting to claim
    vesting_id: ID,
}

/// Action creating a vesting.
/// Associated balance is managed in other action modules.
public struct VestAction has store {
    // timestamp when coins can start to be claimed
    start_timestamp: u64,
    // timestamp when balance is totally unlocked
    end_timestamp: u64,
    // address to pay
    recipient: address,
}

// === Public Functions ===

// Bearer of ClaimCap can claim the vesting.
public fun claim<CoinType>(vesting: &mut Vesting<CoinType>, cap: &ClaimCap, clock: &Clock, ctx: &mut TxContext) {
    assert!(cap.vesting_id == vesting.id.to_inner(), EWrongStream);
    assert!(clock.timestamp_ms() > vesting.start_timestamp, ETooEarly);
    assert!(vesting.balance.value() != 0, EVestingOver);

    let amount = if (clock.timestamp_ms() > vesting.end_timestamp) {
        vesting.balance.value()
    } else {
        let duration_remaining = vesting.end_timestamp - vesting.last_claimed;
        let duration_claimable = clock.timestamp_ms() - vesting.last_claimed;
        
        if (duration_remaining != 0) vesting.balance.value() * duration_claimable / duration_remaining else 0
    };

    let coin = coin::from_balance(vesting.balance.split(amount), ctx);
    transfer::public_transfer(coin, vesting.recipient);

    vesting.last_claimed = clock.timestamp_ms();
}

// Authorized address can cancel the vesting.
public fun cancel_payment<Config, CoinType>(
    auth: Auth,
    vesting: Vesting<CoinType>, 
    account: &Account<Config>,
    ctx: &mut TxContext
) {
    account.verify(auth);

    let Vesting { id, balance, .. } = vesting;
    id.delete();

    account.keep(coin::from_balance(balance, ctx));
}

// Destroys the vesting when balance is empty.
public fun destroy_empty<CoinType>(vesting: Vesting<CoinType>) {
    let Vesting { id, balance, .. } = vesting;
    
    assert!(balance.value() == 0, EBalanceNotEmpty);
    balance.destroy_zero();
    id.delete();
}

// Destroys the claim cap.
public use fun destroy_cap as ClaimCap.destroy;
public fun destroy_cap(cap: ClaimCap) {
    let ClaimCap { id, .. } = cap;
    id.delete();
}

// Intent functions

/// Creates a VestAction and adds it to an intent.
public fun new_vest<Outcome, IW: drop>(
    intent: &mut Intent<Outcome>,
    start_timestamp: u64,
    end_timestamp: u64,
    recipient: address,
    intent_witness: IW,
) {
    intent.add_action(VestAction { start_timestamp, end_timestamp, recipient }, intent_witness);
}

/// Processes a VestAction and creates a vesting.
public fun do_vest<Outcome: store, CoinType, IW: drop>(
    executable: &mut Executable<Outcome>, 
    coin: Coin<CoinType>,
    intent_witness: IW,
    ctx: &mut TxContext
) {    
    let action: &VestAction = executable.next_action(intent_witness);
    let vesting_id = object::new(ctx);

    transfer::transfer(
        ClaimCap { id: object::new(ctx), vesting_id: vesting_id.to_inner() }, 
        action.recipient
    );

    transfer::share_object(Vesting<CoinType> { 
        id: vesting_id, 
        balance: coin.into_balance(), 
        last_claimed: action.start_timestamp,
        start_timestamp: action.start_timestamp,
        end_timestamp: action.end_timestamp,
        recipient: action.recipient
    });
}

/// Deletes a VestAction from an expired intent.
public fun delete_vest(expired: &mut Expired) {
    let VestAction { .. } = expired.remove_action();
}

// === View Functions ===

/// Returns the balance value of a vesting.
public fun balance_value<CoinType>(self: &Vesting<CoinType>): u64 {
    self.balance.value()
}

/// Returns the last claimed timestamp of a vesting.
public fun last_claimed<CoinType>(self: &Vesting<CoinType>): u64 {
    self.last_claimed
}

/// Returns the start timestamp of a vesting.
public fun start_timestamp<CoinType>(self: &Vesting<CoinType>): u64 {
    self.start_timestamp
}

/// Returns the end timestamp of a vesting.
public fun end_timestamp<CoinType>(self: &Vesting<CoinType>): u64 {
    self.end_timestamp
}

/// Returns the recipient of a vesting.
public fun recipient<CoinType>(self: &Vesting<CoinType>): address {
    self.recipient
}

// === Test functions ===

#[test_only]
public fun create_vesting_for_testing<CoinType>(
    coin: Coin<CoinType>, 
    start_timestamp: u64,
    end_timestamp: u64,
    recipient: address,
    ctx: &mut TxContext
): (ClaimCap, Vesting<CoinType>) {
    let id = object::new(ctx);
    (
        ClaimCap {
            id: object::new(ctx),
            vesting_id: id.to_inner()
        },
        Vesting {
            id,
            balance: coin.into_balance(),
            last_claimed: 0,
            start_timestamp,
            end_timestamp,
            recipient
        }
    )
}module account_actions::owned_intents;

// === Imports ===

use std::string::String;
use sui::{
    transfer::Receiving,
    coin::Coin,
};
use account_protocol::{
    account::{Account, Auth},
    executable::Executable,
    owned,
    intents::Params,
    intent_interface,
};
use account_actions::{
    transfer as acc_transfer,
    vesting,
    vault,
    version,
};

// === Aliases ===

use fun intent_interface::process_intent as Account.process_intent;

// === Errors ===

const EObjectsRecipientsNotSameLength: u64 = 0;
const ENoVault: u64 = 1;

// === Structs ===

/// Intent Witness defining the intent to withdraw a coin and deposit it into a vault.
public struct WithdrawAndTransferToVaultIntent() has copy, drop;
/// Intent Witness defining the intent to withdraw and transfer multiple objects.
public struct WithdrawAndTransferIntent() has copy, drop;
/// Intent Witness defining the intent to withdraw a coin and create a vesting.
public struct WithdrawAndVestIntent() has copy, drop;

// === Public functions ===

/// Creates a WithdrawAndTransferToVaultIntent and adds it to an Account.
public fun request_withdraw_and_transfer_to_vault<Config, Outcome: store, CoinType: drop>(
    auth: Auth,
    account: &mut Account<Config>, 
    params: Params,
    outcome: Outcome,
    coin_id: ID,
    coin_amount: u64,
    vault_name: String,
    ctx: &mut TxContext
) {
    account.verify(auth);
    params.assert_single_execution();
    assert!(vault::has_vault(account, vault_name), ENoVault);

    intent_interface::build_intent!(
        account,
        params,
        outcome,
        b"".to_string(),
        version::current(),
        WithdrawAndTransferToVaultIntent(),
        ctx,
        |intent, iw| {
            owned::new_withdraw(intent, account, coin_id, iw);
            vault::new_deposit<_, CoinType, _>(intent, vault_name, coin_amount, iw);
        }
    );
}

/// Executes a WithdrawAndTransferToVaultIntent, deposits a coin owned by the account into a vault.
public fun execute_withdraw_and_transfer_to_vault<Config, Outcome: store, CoinType: drop>(
    executable: &mut Executable<Outcome>, 
    account: &mut Account<Config>, 
    receiving: Receiving<Coin<CoinType>>,
) {
    account.process_intent!(
        executable,
        version::current(),
        WithdrawAndTransferToVaultIntent(),
        |executable, iw| {
            let object = owned::do_withdraw(executable, account, receiving, iw);
            vault::do_deposit<_, _, CoinType, _>(executable, account, object, version::current(), iw);
        }
    );
}

/// Creates a WithdrawAndTransferIntent and adds it to an Account.
public fun request_withdraw_and_transfer<Config, Outcome: store>(
    auth: Auth,
    account: &mut Account<Config>, 
    params: Params,
    outcome: Outcome,
    object_ids: vector<ID>,
    recipients: vector<address>,
    ctx: &mut TxContext
) {
    account.verify(auth);
    params.assert_single_execution();
    assert!(object_ids.length() == recipients.length(), EObjectsRecipientsNotSameLength);

    intent_interface::build_intent!(
        account,
        params,
        outcome,
        b"".to_string(),
        version::current(),
        WithdrawAndTransferIntent(),
        ctx,
        |intent, iw| object_ids.zip_do!(recipients, |object_id, recipient| {
            owned::new_withdraw(intent, account, object_id, iw);
            acc_transfer::new_transfer(intent, recipient, iw);
        })
    );
}

/// Executes a WithdrawAndTransferIntent, transfers an object owned by the account. Can be looped over.
public fun execute_withdraw_and_transfer<Config, Outcome: store, T: key + store>(
    executable: &mut Executable<Outcome>, 
    account: &mut Account<Config>, 
    receiving: Receiving<T>,
) {
    account.process_intent!(
        executable,
        version::current(),
        WithdrawAndTransferIntent(),
        |executable, iw| {
            let object = owned::do_withdraw(executable, account, receiving, iw);
            acc_transfer::do_transfer(executable, object, iw);
        }
    );
}

/// Creates a WithdrawAndVestIntent and adds it to an Account.
public fun request_withdraw_and_vest<Config, Outcome: store>(
    auth: Auth,
    account: &mut Account<Config>, 
    params: Params,
    outcome: Outcome,
    coin_id: ID, // coin owned by the account, must have the total amount to be paid
    start_timestamp: u64,
    end_timestamp: u64,
    recipient: address,
    ctx: &mut TxContext
) {
    account.verify(auth);
    params.assert_single_execution();

    intent_interface::build_intent!(
        account,
        params,
        outcome,
        b"".to_string(),
        version::current(),
        WithdrawAndVestIntent(),
        ctx,
        |intent, iw| {
            owned::new_withdraw(intent, account, coin_id, iw);
            vesting::new_vest(intent, start_timestamp, end_timestamp, recipient, iw);
        }
    );
}

/// Executes a WithdrawAndVestIntent, withdraws a coin and creates a vesting.
public fun execute_withdraw_and_vest<Config, Outcome: store, C: drop>(
    executable: &mut Executable<Outcome>, 
    account: &mut Account<Config>, 
    receiving: Receiving<Coin<C>>,
    ctx: &mut TxContext
) {
    account.process_intent!(
        executable,
        version::current(),
        WithdrawAndVestIntent(),
        |executable, iw| {
            let coin = owned::do_withdraw(executable, account, receiving, iw);
            vesting::do_vest(executable, coin, iw, ctx);
        }
    );
}module account_actions::kiosk_intents;

// === Imports ===

use std::string::String;
use sui::{
    kiosk::{Kiosk, KioskOwnerCap},
    transfer_policy::{TransferPolicy, TransferRequest},
};
use account_protocol::{
    account::{Account, Auth},
    intents::Params,
    executable::Executable,
    intent_interface,
};
use account_actions::{
    kiosk as acc_kiosk,
    version,
};

// === Aliases ===

use fun intent_interface::build_intent as Account.build_intent;
use fun intent_interface::process_intent as Account.process_intent;

// === Errors ===

const ENoLock: u64 = 0;
const ENftsPricesNotSameLength: u64 = 1;

// === Structs ===

/// Intent Witness defining the intent to take nfts from a kiosk managed by a account to another kiosk.
public struct TakeNftsIntent() has copy, drop;
/// Intent Witness defining the intent to list nfts in a kiosk managed by a account.
public struct ListNftsIntent() has copy, drop;

// === Public functions ===

/// Creates a TakeNftsIntent and adds it to an Account.
public fun request_take_nfts<Config, Outcome: store>(
    auth: Auth,
    account: &mut Account<Config>,
    params: Params,
    outcome: Outcome,
    kiosk_name: String,
    nft_ids: vector<ID>,
    recipient: address,
    ctx: &mut TxContext
) {
    account.verify(auth);
    params.assert_single_execution();
    assert!(acc_kiosk::has_lock(account, kiosk_name), ENoLock);

    account.build_intent!(
        params,
        outcome, 
        kiosk_name,
        version::current(),
        TakeNftsIntent(),
        ctx,
        |intent, iw| nft_ids.do!(|nft_id| acc_kiosk::new_take(intent, kiosk_name, nft_id, recipient, iw))
    );
}

/// Executes a TakeNftsIntent, takes nfts from a kiosk managed by a account to another kiosk. Can be looped over.
public fun execute_take_nfts<Config, Outcome: store, Nft: key + store>(
    executable: &mut Executable<Outcome>,
    account: &mut Account<Config>,
    account_kiosk: &mut Kiosk, 
    recipient_kiosk: &mut Kiosk, 
    recipient_cap: &KioskOwnerCap, 
    policy: &mut TransferPolicy<Nft>,
    ctx: &mut TxContext
): TransferRequest<Nft> {
    account.process_intent!(
        executable,
        version::current(),
        TakeNftsIntent(),
        |executable, iw| acc_kiosk::do_take<_, _, Nft, _>(
            executable, 
            account, 
            account_kiosk, 
            recipient_kiosk, 
            recipient_cap, 
            policy, 
            version::current(), 
            iw, 
            ctx
        ),
    )
}

/// Creates a ListNftsIntent and adds it to an Account.
public fun request_list_nfts<Config, Outcome: store>(
    auth: Auth,
    account: &mut Account<Config>,
    params: Params,
    outcome: Outcome,
    kiosk_name: String,
    nft_ids: vector<ID>,
    prices: vector<u64>,
    ctx: &mut TxContext
) {
    account.verify(auth);
    assert!(acc_kiosk::has_lock(account, kiosk_name), ENoLock);
    assert!(nft_ids.length() == prices.length(), ENftsPricesNotSameLength);

    account.build_intent!(
        params,
        outcome,
        kiosk_name,
        version::current(),
        ListNftsIntent(),
        ctx,
        |intent, iw| nft_ids.zip_do!(prices, |nft_id, price| acc_kiosk::new_list(intent, kiosk_name, nft_id, price, iw))
    );
}

/// Executes a ListNftsIntent, lists nfts in a kiosk managed by a account. Can be looped over.
public fun execute_list_nfts<Config, Outcome: store, Nft: key + store>(
    executable: &mut Executable<Outcome>,
    account: &mut Account<Config>,
    kiosk: &mut Kiosk,
) {
    account.process_intent!(
        executable,
        version::current(),
        ListNftsIntent(),
        |executable, iw| acc_kiosk::do_list<_, _, Nft, _>(executable, account, kiosk, version::current(), iw),
    );
}module account_actions::package_upgrade_intents;

// === Imports ===

use std::string::String;
use sui::{
    package::{Self, UpgradeTicket, UpgradeReceipt},
    clock::Clock,
};
use account_protocol::{
    account::{Account, Auth},
    executable::Executable,
    intents::Params,
    intent_interface,
};
use account_actions::{
    package_upgrade,
    version,
};

// === Aliases ===

use fun intent_interface::build_intent as Account.build_intent;
use fun intent_interface::process_intent as Account.process_intent;

// === Errors ===

const EInvalidPolicy: u64 = 1;
const EPolicyShouldRestrict: u64 = 2;
const ENoLock: u64 = 3;
const ETimeDelay: u64 = 4;

// === Structs ===

/// Intent Witness defining the intent to upgrade a package.
public struct UpgradePackageIntent() has copy, drop;
/// Intent Witness defining the intent to restrict an UpgradeCap.
public struct RestrictPolicyIntent() has copy, drop;

// === Public Functions ===

/// Creates an UpgradePackageIntent and adds it to an Account.
public fun request_upgrade_package<Config, Outcome: store>(
    auth: Auth,
    account: &mut Account<Config>, 
    params: Params,
    outcome: Outcome,
    package_name: String,
    digest: vector<u8>,
    ctx: &mut TxContext
) {
    account.verify(auth);
    params.assert_single_execution();

    assert!(package_upgrade::has_cap(account, package_name), ENoLock);
    assert!(
        params.execution_times()[0] >= params.creation_time() + package_upgrade::get_time_delay(account, package_name), 
        ETimeDelay
    );

    account.build_intent!(
        params,
        outcome,
        package_name,
        version::current(),
        UpgradePackageIntent(),
        ctx,
        |intent, iw| {
            package_upgrade::new_upgrade(intent, package_name, digest, iw);
            package_upgrade::new_commit(intent, package_name, iw);
        },
    );
}

/// Executes an UpgradePackageIntent, returns the UpgradeTicket for upgrading.
public fun execute_upgrade_package<Config, Outcome: store>(
    executable: &mut Executable<Outcome>,
    account: &mut Account<Config>,
    clock: &Clock,
): UpgradeTicket {
    account.process_intent!(
        executable,
        version::current(),
        UpgradePackageIntent(),
        |executable, iw| package_upgrade::do_upgrade(executable, account, clock, version::current(), iw)
    )
}    

/// Need to consume the ticket to upgrade the package before completing the intent.

public fun execute_commit_upgrade<Config, Outcome: store>(
    executable: &mut Executable<Outcome>,
    account: &mut Account<Config>,
    receipt: UpgradeReceipt,
) {
    account.process_intent!(
        executable,
        version::current(),
        UpgradePackageIntent(),
        |executable, iw| package_upgrade::do_commit(executable, account, receipt, version::current(), iw)
    )
}

/// Creates a RestrictPolicyIntent and adds it to an Account.
public fun request_restrict_policy<Config, Outcome: store>(
    auth: Auth,
    account: &mut Account<Config>, 
    params: Params,
    outcome: Outcome,
    package_name: String,
    policy: u8,
    ctx: &mut TxContext
) {
    account.verify(auth);
    params.assert_single_execution();

    let current_policy = package_upgrade::get_cap_policy(account, package_name);
    assert!(policy > current_policy, EPolicyShouldRestrict);
    assert!(
        policy == package::additive_policy() ||
        policy == package::dep_only_policy() ||
        policy == 255, // make immutable
        EInvalidPolicy
    );

    account.build_intent!(
        params,
        outcome,
        package_name,
        version::current(),
        RestrictPolicyIntent(),
        ctx,
        |intent, iw| package_upgrade::new_restrict(intent, package_name, policy, iw),
    );
}

/// Restricts the upgrade policy.
public fun execute_restrict_policy<Config, Outcome: store>(
    executable: &mut Executable<Outcome>,
    account: &mut Account<Config>,
) {
    account.process_intent!(
        executable,
        version::current(),
        RestrictPolicyIntent(),
        |executable, iw| package_upgrade::do_restrict(executable, account, version::current(), iw)
    );
}module account_actions::empty_intents;

// === Imports ===

use account_protocol::{
    account::{Account, Auth},
    executable::Executable,
    intents::Params,
    intent_interface,
};
use account_actions::version;

// === Aliases ===

use fun intent_interface::build_intent as Account.build_intent;
use fun intent_interface::process_intent as Account.process_intent;

// === Structs ===    

/// Intent Witness defining an intent with no action.
public struct EmptyIntent() has copy, drop;

// === Public functions ===

/// Creates an EmptyIntent and adds it to an Account.
public fun request_empty<Config, Outcome: store>(
    auth: Auth,
    account: &mut Account<Config>,
    params: Params,
    outcome: Outcome,
    ctx: &mut TxContext
) {
    account.verify(auth);

    account.build_intent!(
        params,
        outcome, 
        b"".to_string(),
        version::current(),
        EmptyIntent(),
        ctx,
        |_intent, _iw| {},
    );
}

/// Executes an EmptyIntent (to be able to delete it)
public fun execute_empty<Config, Outcome: store>(
    executable: &mut Executable<Outcome>,
    account: &mut Account<Config>,
) {
    account.process_intent!(
        executable, 
        version::current(), 
        EmptyIntent(), 
        |_executable, _iw| {},
    )
}module account_actions::vault_intents;

// === Imports ===

use std::string::String;
use account_protocol::{
    account::{Account, Auth},
    executable::Executable,
    intents::Params,
    intent_interface,
};
use account_actions::{
    transfer as acc_transfer,
    vesting,
    vault,
    version,
};

// === Aliases ===

use fun intent_interface::build_intent as Account.build_intent;
use fun intent_interface::process_intent as Account.process_intent;

// === Errors ===

const ENotSameLength: u64 = 0;
const EInsufficientFunds: u64 = 1;
const ECoinTypeDoesntExist: u64 = 2;

// === Structs ===

/// Intent Witness defining the vault spend and transfer intent, and associated role.
public struct SpendAndTransferIntent() has copy, drop;
/// Intent Witness defining the vault spend and vesting intent, and associated role.
public struct SpendAndVestIntent() has copy, drop;

// === Public Functions ===

/// Creates a SpendAndTransferIntent and adds it to an Account.
public fun request_spend_and_transfer<Config, Outcome: store, CoinType: drop>(
    auth: Auth,
    account: &mut Account<Config>, 
    params: Params,
    outcome: Outcome,
    vault_name: String,
    amounts: vector<u64>,
    recipients: vector<address>,
    ctx: &mut TxContext
) {
    account.verify(auth);
    assert!(amounts.length() == recipients.length(), ENotSameLength);
    
    let vault = vault::borrow_vault(account, vault_name);
    assert!(vault.coin_type_exists<CoinType>(), ECoinTypeDoesntExist);
    assert!(
        amounts.fold!(0u64, |sum, amount| sum + amount) <= vault.coin_type_value<CoinType>(), 
        EInsufficientFunds
    );
    
    account.build_intent!(
        params,
        outcome,
        vault_name,
        version::current(),
        SpendAndTransferIntent(),
        ctx,
        |intent, iw| amounts.zip_do!(recipients, |amount, recipient| {
            vault::new_spend<_, CoinType, _>(intent, vault_name, amount, iw);
            acc_transfer::new_transfer(intent, recipient, iw);
        })
    );
}

/// Executes a SpendAndTransferIntent, transfers coins from the vault to the recipients. Can be looped over.
public fun execute_spend_and_transfer<Config, Outcome: store, CoinType: drop>(
    executable: &mut Executable<Outcome>, 
    account: &mut Account<Config>, 
    ctx: &mut TxContext
) {
    account.process_intent!(
        executable,
        version::current(),
        SpendAndTransferIntent(),
        |executable, iw| {
            let coin = vault::do_spend<_, _, CoinType, _>(executable, account, version::current(), iw, ctx);
            acc_transfer::do_transfer(executable, coin, iw);
        }
    );
}

/// Creates a SpendAndVestIntent and adds it to an Account.
public fun request_spend_and_vest<Config, Outcome: store, CoinType: drop>(
    auth: Auth,
    account: &mut Account<Config>, 
    params: Params,
    outcome: Outcome,
    vault_name: String, 
    coin_amount: u64, 
    start_timestamp: u64, 
    end_timestamp: u64, 
    recipient: address, 
    ctx: &mut TxContext
) {
    account.verify(auth);
    params.assert_single_execution();

    let vault = vault::borrow_vault(account, vault_name);
    assert!(vault.coin_type_exists<CoinType>(), ECoinTypeDoesntExist);
    assert!(vault.coin_type_value<CoinType>() >= coin_amount, EInsufficientFunds);

    account.build_intent!(
        params,
        outcome,
        vault_name,
        version::current(),
        SpendAndVestIntent(),
        ctx,
        |intent, iw| {
            vault::new_spend<_, CoinType, _>(intent, vault_name, coin_amount, iw);
            vesting::new_vest(intent, start_timestamp, end_timestamp, recipient, iw);
        }
    );
}

/// Executes a SpendAndVestIntent, create a vesting from a coin in the vault.
public fun execute_spend_and_vest<Config, Outcome: store, CoinType: drop>(
    executable: &mut Executable<Outcome>, 
    account: &mut Account<Config>, 
    ctx: &mut TxContext
) {
    account.process_intent!(
        executable,
        version::current(),
        SpendAndVestIntent(),
        |executable, iw| {
            let coin = vault::do_spend<_, _, CoinType, _>(executable, account, version::current(), iw, ctx);
            vesting::do_vest(executable, coin, iw, ctx);
        }
    );
}module account_actions::currency_intents;

// === Imports ===

use std::{
    ascii,
    string::String,
    type_name,
};
use sui::{
    transfer::Receiving,
    coin::{Coin, CoinMetadata},
};
use account_protocol::{
    account::{Account, Auth},
    executable::Executable,
    intents::Params,
    owned,
    intent_interface
};
use account_actions::{
    transfer as acc_transfer,
    vesting,
    version,
    currency,
};

// === Aliases ===

use fun intent_interface::build_intent as Account.build_intent;
use fun intent_interface::process_intent as Account.process_intent;

// === Errors ===

const EAmountsRecipentsNotSameLength: u64 = 0;
const EMaxSupply: u64 = 1;
const ENoLock: u64 = 2;
const ECannotUpdateSymbol: u64 = 3;
const ECannotUpdateName: u64 = 4;
const ECannotUpdateDescription: u64 = 5;
const ECannotUpdateIcon: u64 = 6;
const EMintDisabled: u64 = 7;
const EBurnDisabled: u64 = 8;

// === Structs ===

/// Intent Witness defining the intent to disable one or more permissions.
public struct DisableRulesIntent() has copy, drop;
/// Intent Witness defining the intent to update the CoinMetadata associated with a locked TreasuryCap.
public struct UpdateMetadataIntent() has copy, drop;
/// Intent Witness defining the intent to transfer a minted coin.
public struct MintAndTransferIntent() has copy, drop;
/// Intent Witness defining the intent to pay from a minted coin.
public struct MintAndVestIntent() has copy, drop;
/// Intent Witness defining the intent to burn coins from the account using a locked TreasuryCap.
public struct WithdrawAndBurnIntent() has copy, drop;

// === Public functions ===

/// Creates a DisableRulesIntent and adds it to an Account.
public fun request_disable_rules<Config, Outcome: store, CoinType>(
    auth: Auth,
    account: &mut Account<Config>,
    params: Params,
    outcome: Outcome,
    mint: bool,
    burn: bool,
    update_symbol: bool,
    update_name: bool,
    update_description: bool,
    update_icon: bool,
    ctx: &mut TxContext
) {
    account.verify(auth);
    params.assert_single_execution();
    assert!(currency::has_cap<_, CoinType>(account), ENoLock);

    account.build_intent!(
        params,
        outcome, 
        type_name_to_string<CoinType>(),
        version::current(),
        DisableRulesIntent(),   
        ctx,
        |intent, iw| currency::new_disable<_, CoinType, _>(
            intent, mint, burn, update_symbol, update_name, update_description, update_icon, iw
        ),
    );
}

/// Executes a DisableRulesIntent, disables rules for the coin forever.
public fun execute_disable_rules<Config, Outcome: store, CoinType>(
    executable: &mut Executable<Outcome>,
    account: &mut Account<Config>,
) {
    account.process_intent!(
        executable,
        version::current(),
        DisableRulesIntent(),
        |executable, iw| currency::do_disable<_, _, CoinType, _>(executable, account, version::current(), iw)
    );
}

/// Creates an UpdateMetadataIntent and adds it to an Account.
public fun request_update_metadata<Config, Outcome: store, CoinType>(
    auth: Auth,
    account: &mut Account<Config>,
    params: Params,
    outcome: Outcome,
    md_symbol: Option<ascii::String>,
    md_name: Option<String>,
    md_description: Option<String>,
    md_icon_url: Option<ascii::String>,
    ctx: &mut TxContext
) {
    account.verify(auth);
    params.assert_single_execution();

    let rules = currency::borrow_rules<_, CoinType>(account);
    if (!rules.can_update_symbol()) assert!(md_symbol.is_none(), ECannotUpdateSymbol);
    if (!rules.can_update_name()) assert!(md_name.is_none(), ECannotUpdateName);
    if (!rules.can_update_description()) assert!(md_description.is_none(), ECannotUpdateDescription);
    if (!rules.can_update_icon()) assert!(md_icon_url.is_none(), ECannotUpdateIcon);

    account.build_intent!(
        params,
        outcome, 
        type_name_to_string<CoinType>(),
        version::current(),
        UpdateMetadataIntent(),
        ctx,
        |intent, iw| currency::new_update<_, CoinType, _>(
            intent, md_symbol, md_name, md_description, md_icon_url, iw
        ),
    );
}

/// Executes an UpdateMetadataIntent, updates the CoinMetadata.
public fun execute_update_metadata<Config, Outcome: store, CoinType>(
    executable: &mut Executable<Outcome>,
    account: &mut Account<Config>,
    metadata: &mut CoinMetadata<CoinType>,
) {
    account.process_intent!(
        executable,
        version::current(),
        UpdateMetadataIntent(),
        |executable, iw| currency::do_update<_, _, CoinType, _>(executable, account, metadata, version::current(), iw)
    );
}

/// Creates a MintAndTransferIntent and adds it to an Account.
public fun request_mint_and_transfer<Config, Outcome: store, CoinType>(
    auth: Auth,
    account: &mut Account<Config>,
    params: Params,
    outcome: Outcome,
    amounts: vector<u64>,
    recipients: vector<address>,
    ctx: &mut TxContext
) {
    account.verify(auth);
    assert!(amounts.length() == recipients.length(), EAmountsRecipentsNotSameLength);

    let rules = currency::borrow_rules<_, CoinType>(account);
    assert!(rules.can_mint(), EMintDisabled);
    let sum = amounts.fold!(0, |sum, amount| sum + amount);
    if (rules.max_supply().is_some()) assert!(sum <= *rules.max_supply().borrow(), EMaxSupply);

    account.build_intent!(
        params,
        outcome, 
        type_name_to_string<CoinType>(),
        version::current(),
        MintAndTransferIntent(),
        ctx,
        |intent, iw| amounts.zip_do!(recipients, |amount, recipient| {
            currency::new_mint<_, CoinType, _>(intent, amount, iw);
            acc_transfer::new_transfer(intent, recipient, iw);
        })
    );
}

/// Executes a MintAndTransferIntent, sends managed coins. Can be looped over.
public fun execute_mint_and_transfer<Config, Outcome: store, CoinType>(
    executable: &mut Executable<Outcome>, 
    account: &mut Account<Config>, 
    ctx: &mut TxContext
) {
    account.process_intent!(
        executable,
        version::current(),
        MintAndTransferIntent(),
        |executable, iw| {
            let coin = currency::do_mint<_, _, CoinType, _>(executable, account, version::current(), iw, ctx);
            acc_transfer::do_transfer(executable, coin, iw);
        }
    );
}

/// Creates a MintAndVestIntent and adds it to an Account.
public fun request_mint_and_vest<Config, Outcome: store, CoinType>(
    auth: Auth,
    account: &mut Account<Config>, 
    params: Params,
    outcome: Outcome,
    total_amount: u64,
    start_timestamp: u64, 
    end_timestamp: u64, 
    recipient: address,
    ctx: &mut TxContext
) {
    account.verify(auth);
    params.assert_single_execution();

    let rules = currency::borrow_rules<_, CoinType>(account);
    assert!(rules.can_mint(), EMintDisabled);
    if (rules.max_supply().is_some()) assert!(total_amount <= *rules.max_supply().borrow(), EMaxSupply);

    account.build_intent!(
        params,
        outcome, 
        type_name_to_string<CoinType>(),
        version::current(),
        MintAndVestIntent(),
        ctx,
        |intent, iw| {
            currency::new_mint<_, CoinType, _>(intent, total_amount, iw);
            vesting::new_vest(intent, start_timestamp, end_timestamp, recipient, iw);
        }
    );
}

/// Executes a MintAndVestIntent, sends managed coins and creates a vesting.
public fun execute_mint_and_vest<Config, Outcome: store, CoinType>(
    executable: &mut Executable<Outcome>, 
    account: &mut Account<Config>, 
    ctx: &mut TxContext
) {
    account.process_intent!(
        executable,
        version::current(),
        MintAndVestIntent(),
        |executable, iw| {
            let coin = currency::do_mint<_, _, CoinType, _>(executable, account, version::current(), iw, ctx);
            vesting::do_vest(executable, coin, iw, ctx);
        }
    );
}

/// Creates a WithdrawAndBurnIntent and adds it to an Account.
public fun request_withdraw_and_burn<Config, Outcome: store, CoinType>(
    auth: Auth,
    account: &mut Account<Config>,
    params: Params,
    outcome: Outcome,
    coin_id: ID,
    amount: u64,
    ctx: &mut TxContext
) {
    account.verify(auth);
    params.assert_single_execution();

    let rules = currency::borrow_rules<_, CoinType>(account);
    assert!(rules.can_burn(), EBurnDisabled);

    intent_interface::build_intent!(
        account,
        params,
        outcome, 
        type_name_to_string<CoinType>(),
        version::current(),
        WithdrawAndBurnIntent(), 
        ctx,
        |intent, iw| {
            owned::new_withdraw(intent, account, coin_id, iw);
            currency::new_burn<_, CoinType, _>(intent, amount, iw);
        }
    );
}


/// Executes a WithdrawAndBurnIntent, burns a coin owned by the account.
public fun execute_withdraw_and_burn<Config, Outcome: store, CoinType>(
    executable: &mut Executable<Outcome>,
    account: &mut Account<Config>,
    receiving: Receiving<Coin<CoinType>>,
) {
    account.process_intent!(
        executable,
        version::current(),
        WithdrawAndBurnIntent(),
        |executable, iw| {
            let coin = owned::do_withdraw(executable, account, receiving, iw);
            currency::do_burn<_, _, CoinType, _>(executable, account, coin, version::current(), iw);
        }
    );
}

// === Private functions ===

fun type_name_to_string<T>(): String {
    type_name::get<T>().into_string().to_string()
}module account_actions::access_control_intents;

// === Imports ===

use std::{
    string::String,
    type_name,
};
use account_protocol::{
    account::{Account, Auth},
    executable::Executable,
    intents::Params,
    intent_interface,
};
use account_actions::{
    access_control as ac,
    version,
};

// === Aliases ===

use fun intent_interface::build_intent as Account.build_intent;
use fun intent_interface::process_intent as Account.process_intent;

// === Errors ===

const ENoLock: u64 = 0;

// === Structs ===    

/// Intent Witness defining the intent to borrow an access cap.
public struct BorrowCapIntent() has copy, drop;

// === Public functions ===

/// Creates a BorrowCapIntent and adds it to an Account.
public fun request_borrow_cap<Config, Outcome: store, Cap>(
    auth: Auth,
    account: &mut Account<Config>,
    params: Params,
    outcome: Outcome,
    ctx: &mut TxContext
) {
    account.verify(auth);
    assert!(ac::has_lock<_, Cap>(account), ENoLock);

    account.build_intent!(
        params,
        outcome, 
        type_name_to_string<Cap>(),
        version::current(),
        BorrowCapIntent(),
        ctx,
        |intent, iw| {
            ac::new_borrow<_, Cap, _>(intent, iw);
            ac::new_return<_, Cap, _>(intent, iw);
        },
    );
}

/// Executes a BorrowCapIntent, returns a cap and a hot potato.
public fun execute_borrow_cap<Config, Outcome: store, Cap: key + store>(
    executable: &mut Executable<Outcome>,
    account: &mut Account<Config>,
): Cap {
    account.process_intent!(
        executable, 
        version::current(), 
        BorrowCapIntent(), 
        |executable, iw| ac::do_borrow(executable, account, version::current(), iw),
    )
}

/// Completes a BorrowCapIntent, destroys the executable and returns the cap to the account if the matching hot potato is returned.
public fun execute_return_cap<Config, Outcome: store, Cap: key + store>(
    executable: &mut Executable<Outcome>,
    account: &mut Account<Config>,
    cap: Cap,
) {
    account.process_intent!(
        executable, 
        version::current(), 
        BorrowCapIntent(), 
        |executable, iw| ac::do_return(executable, account, cap, version::current(), iw),
    )
}

// === Private functions ===

fun type_name_to_string<T>(): String {
    type_name::get<T>().into_string().to_string()
}/// The Extensions shared object tracks a list of verified and whitelisted packages.
/// These are the only packages that can be added as dependencies to an account if it disallows unverified packages.

module account_extensions::extensions;

// === Imports ===

use std::string::String;

// === Errors ===

const EExtensionNotFound: u64 = 0;
const EExtensionAlreadyExists: u64 = 1;
const ECannotRemoveAccountProtocol: u64 = 2;

// === Structs ===

/// A list of verified and whitelisted packages
public struct Extensions has key {
    id: UID,
    inner: vector<Extension>,
}

/// A package with a name and all authorized versions
public struct Extension has copy, drop, store {
    name: String,
    history: vector<History>,
}

/// The address and version of a package
public struct History has copy, drop, store {
    addr: address,
    version: u64,
}

/// A capability to add and remove extensions
public struct AdminCap has key, store {
    id: UID,
}

// === Public functions ===

fun init(ctx: &mut TxContext) {
    transfer::transfer(AdminCap { id: object::new(ctx) }, ctx.sender());
    transfer::share_object(Extensions { 
        id: object::new(ctx),
        inner: vector::empty()  
    });
}

// === View functions ===

/// Returns the number of extensions in the list
public fun length(extensions: &Extensions): u64 {
    extensions.inner.length()
}

/// Returns the extension at the given index
public fun get_by_idx(extensions: &Extensions, idx: u64): &Extension {
    &extensions.inner[idx]
}

/// Returns the name of the extension
public fun name(extension: &Extension): String {
    extension.name
}

/// Returns the history of the extension
public fun history(extension: &Extension): vector<History> {
    extension.history
}

/// Returns the address of the history
public fun addr(history: &History): address {
    history.addr
}

/// Returns the version of the history
public fun version(history: &History): u64 {
    history.version
}

/// Returns the latest address and version for a given name
public fun get_latest_for_name(
    extensions: &Extensions, 
    name: String, 
): (address, u64) {
    let idx = get_idx_for_name(extensions, name);
    let history = extensions.inner[idx].history;
    let last_idx = history.length() - 1;

    (history[last_idx].addr, history[last_idx].version)
}

/// Returns true if the package (name, addr, version) is in the list
public fun is_extension(
    extensions: &Extensions, 
    name: String,
    addr: address,
    version: u64,
): bool {
    // check if the name exists
    let opt_idx = extensions.inner.find_index!(|extension| extension.name == name);
    if (opt_idx.is_none()) return false;
    let idx = opt_idx.destroy_some();
    // check if the address exists for the name
    let history = extensions.inner[idx].history;
    let opt_idx = history.find_index!(|h| h.addr == addr);
    if (opt_idx.is_none()) return false;
    let idx = opt_idx.destroy_some();
    // check if the version exists for the name and address
    history[idx].version == version
}

// === Admin functions ===

/// Adds a package to the list
public fun add(extensions: &mut Extensions, _: &AdminCap, name: String, addr: address, version: u64) {    
    assert!(!extensions.inner.any!(|extension| extension.name == name), EExtensionAlreadyExists);
    assert!(!extensions.inner.any!(|extension| extension.history.any!(|h| h.addr == addr)), EExtensionAlreadyExists);
    let extension = Extension { name, history: vector[History { addr, version }] };
    extensions.inner.push_back(extension);
}

/// Removes a package from the list
public fun remove(extensions: &mut Extensions, _: &AdminCap, name: String) {
    let idx = extensions.get_idx_for_name(name);
    assert!(idx > 0, ECannotRemoveAccountProtocol);
    extensions.inner.remove(idx);
}

/// Adds a new version to the history of a package
public fun update(extensions: &mut Extensions, _: &AdminCap, name: String, addr: address, version: u64) {
    let idx = extensions.get_idx_for_name(name);
    assert!(!extensions.inner[idx].history.any!(|h| h.addr == addr), EExtensionAlreadyExists);
    extensions.inner[idx].history.push_back(History { addr, version });
}

public entry fun new_admin(_: &AdminCap, recipient: address, ctx: &mut TxContext) {
    transfer::public_transfer(AdminCap { id: object::new(ctx) }, recipient);
}

// === Private functions ===

fun get_idx_for_name(extensions: &Extensions, name: String): u64 {
    let opt = extensions.inner.find_index!(|extension| extension.name == name);
    assert!(opt.is_some(), EExtensionNotFound);
    opt.destroy_some()
}

//**************************************************************************************************//
// Tests                                                                                            //
//**************************************************************************************************//

// === Test Helpers ===

#[test_only]
public fun init_for_testing(ctx: &mut TxContext) {
    init(ctx);
}

#[test_only]
public fun new_for_testing(ctx: &mut TxContext): Extensions {
    Extensions {
        id: object::new(ctx),
        inner: vector[]
    }
}

#[test_only]
public fun add_for_testing(extensions: &mut Extensions, name: String, addr: address, version: u64) {    
    assert!(!extensions.inner.any!(|extension| extension.name == name), EExtensionAlreadyExists);
    assert!(!extensions.inner.any!(|extension| extension.history.any!(|h| h.addr == addr)), EExtensionAlreadyExists);
    let extension = Extension { name, history: vector[History { addr, version }] };
    extensions.inner.push_back(extension);
}

#[test_only]
public fun remove_for_testing(extensions: &mut Extensions, name: String) {
    let idx = extensions.get_idx_for_name(name);
    assert!(idx > 0, ECannotRemoveAccountProtocol);
    extensions.inner.remove(idx);
}

#[test_only]
public fun update_for_testing(extensions: &mut Extensions, name: String, addr: address, version: u64) {
    let idx = extensions.get_idx_for_name(name);
    assert!(!extensions.inner[idx].history.any!(|h| h.addr == addr), EExtensionAlreadyExists);
    extensions.inner[idx].history.push_back(History { addr, version });
}

#[test_only]
public fun new_for_testing_with_addrs(addr1: address, addr2: address, addr3: address, ctx: &mut TxContext): Extensions {
    Extensions {
        id: object::new(ctx),
        inner: vector[
            Extension { name: b"AccountProtocol".to_string(), history: vector[History { addr: addr1, version: 1 }] },
            Extension { name: b"AccountConfig".to_string(), history: vector[History { addr: addr2, version: 1 }] },
            Extension { name: b"AccountActions".to_string(), history: vector[History { addr: addr3, version: 1 }] }
        ]
    }
}

#[test_only]
public struct Witness() has drop;

#[test_only]
public fun witness(): Witness {
    Witness()
}

// === Unit Tests ===

#[test_only]
use sui::test_utils::destroy;
#[test_only]
use sui::test_scenario as ts;

#[test]
fun test_init() {
    let mut scenario = ts::begin(@0xCAFE);
    init(scenario.ctx());
    scenario.next_tx(@0xCAFE);

    let cap = scenario.take_from_sender<AdminCap>();
    let extensions = scenario.take_shared<Extensions>();

    destroy(cap);
    destroy(extensions);
    scenario.end();
}

#[test]
fun test_getters() {
    let extensions = new_for_testing_with_addrs(@0x0, @0x1, @0x2, &mut tx_context::dummy());

    // assertions
    assert!(extensions.is_extension(b"AccountProtocol".to_string(), @0x0, 1));
    assert!(extensions.is_extension(b"AccountConfig".to_string(), @0x1, 1));

    assert!(extensions.length() == 3);
    assert!(extensions.get_by_idx(0).name() == b"AccountProtocol".to_string());
    assert!(extensions.get_by_idx(0).history()[0].addr() == @0x0);
    assert!(extensions.get_by_idx(0).history()[0].version() == 1);
    assert!(extensions.get_by_idx(1).name() == b"AccountConfig".to_string());
    assert!(extensions.get_by_idx(1).history()[0].addr() == @0x1);
    assert!(extensions.get_by_idx(1).history()[0].version() == 1);
    assert!(extensions.get_by_idx(2).name() == b"AccountActions".to_string());
    assert!(extensions.get_by_idx(2).history()[0].addr() == @0x2);
    assert!(extensions.get_by_idx(2).history()[0].version() == 1);

    destroy(extensions);
}

#[test]
fun test_get_latest_for_name() {
    let mut extensions = new_for_testing_with_addrs(@0x0, @0x1, @0x2, &mut tx_context::dummy());
    let cap = AdminCap { id: object::new(&mut tx_context::dummy()) };

    let (addr, version) = extensions.get_latest_for_name(b"AccountProtocol".to_string());
    assert!(addr == @0x0);
    assert!(version == 1);
    let (addr, version) = extensions.get_latest_for_name(b"AccountConfig".to_string());
    assert!(addr == @0x1);
    assert!(version == 1);
    let (addr, version) = extensions.get_latest_for_name(b"AccountActions".to_string());
    assert!(addr == @0x2);
    assert!(version == 1);
    // update
    extensions.update(&cap, b"AccountConfig".to_string(), @0x11, 2);
    extensions.update(&cap, b"AccountActions".to_string(), @0x21, 2);
    extensions.update(&cap, b"AccountActions".to_string(), @0x22, 3);
    let (addr, version) = extensions.get_latest_for_name(b"AccountProtocol".to_string());
    assert!(addr == @0x0);
    assert!(version == 1);
    let (addr, version) = extensions.get_latest_for_name(b"AccountConfig".to_string());
    assert!(addr == @0x11);
    assert!(version == 2);
    let (addr, version) = extensions.get_latest_for_name(b"AccountActions".to_string());
    assert!(addr == @0x22);
    assert!(version == 3);

    destroy(extensions);
    destroy(cap);
}

#[test]
fun test_is_extension() {
    let extensions = new_for_testing_with_addrs(@0x0, @0x1, @0x2, &mut tx_context::dummy());
    let cap = AdminCap { id: object::new(&mut tx_context::dummy()) };

    let (addr, version) = extensions.get_latest_for_name(b"AccountProtocol".to_string());
    assert!(addr == @0x0);
    assert!(version == 1);
    let (addr, version) = extensions.get_latest_for_name(b"AccountConfig".to_string());
    assert!(addr == @0x1);
    assert!(version == 1);
    let (addr, version) = extensions.get_latest_for_name(b"AccountActions".to_string());
    assert!(addr == @0x2);
    assert!(version == 1);

    // correct extensions
    assert!(extensions.is_extension(b"AccountProtocol".to_string(), @0x0, 1));
    assert!(extensions.is_extension(b"AccountConfig".to_string(), @0x1, 1));
    assert!(extensions.is_extension(b"AccountActions".to_string(), @0x2, 1));
    // incorrect names
    assert!(!extensions.is_extension(b"AccountProtoco".to_string(), @0x0, 1));
    assert!(!extensions.is_extension(b"AccountConfi".to_string(), @0x1, 1));
    assert!(!extensions.is_extension(b"AccountAction".to_string(), @0x2, 1));
    // incorrect addresses
    assert!(!extensions.is_extension(b"AccountProtocol".to_string(), @0x1, 1));
    assert!(!extensions.is_extension(b"AccountConfig".to_string(), @0x0, 1));
    assert!(!extensions.is_extension(b"AccountActions".to_string(), @0x0, 1));
    // incorrect versions
    assert!(!extensions.is_extension(b"AccountProtocol".to_string(), @0x0, 2));
    assert!(!extensions.is_extension(b"AccountConfig".to_string(), @0x1, 2));
    assert!(!extensions.is_extension(b"AccountActions".to_string(), @0x2, 2));

    destroy(extensions);
    destroy(cap);
}

#[test]
fun test_add_deps() {
    let mut extensions = new_for_testing(&mut tx_context::dummy());
    let cap = AdminCap { id: object::new(&mut tx_context::dummy()) };

    // add extension
    extensions.add(&cap, b"A".to_string(), @0xA, 1);
    extensions.add(&cap, b"B".to_string(), @0xB, 1);
    extensions.add(&cap, b"C".to_string(), @0xC, 1);
    // assertions
    assert!(extensions.is_extension(b"A".to_string(), @0xA, 1));
    assert!(extensions.is_extension(b"B".to_string(), @0xB, 1));
    assert!(extensions.is_extension(b"C".to_string(), @0xC, 1));

    destroy(extensions);
    destroy(cap);
}

#[test]
fun test_update_deps() {
    let mut extensions = new_for_testing_with_addrs(@0x0, @0x1, @0x2, &mut tx_context::dummy());
    let cap = AdminCap { id: object::new(&mut tx_context::dummy()) };

    // add extension (checked above)
    extensions.add(&cap, b"A".to_string(), @0xA, 1);
    extensions.add(&cap, b"B".to_string(), @0xB, 1);
    extensions.add(&cap, b"C".to_string(), @0xC, 1);
    // update deps
    extensions.update(&cap, b"B".to_string(), @0x1B, 2);
    extensions.update(&cap, b"C".to_string(), @0x1C, 2);
    extensions.update(&cap, b"C".to_string(), @0x2C, 3);
    // assertions
    assert!(extensions.get_by_idx(3).name() == b"A".to_string());
    assert!(extensions.get_by_idx(3).history()[0].addr() == @0xA);
    assert!(extensions.get_by_idx(3).history()[0].version() == 1);
    assert!(extensions.get_by_idx(4).name() == b"B".to_string());
    assert!(extensions.get_by_idx(4).history()[1].addr() == @0x1B);
    assert!(extensions.get_by_idx(4).history()[1].version() == 2);
    assert!(extensions.get_by_idx(5).name() == b"C".to_string());
    assert!(extensions.get_by_idx(5).history()[2].addr() == @0x2C);
    assert!(extensions.get_by_idx(5).history()[2].version() == 3);
    // verify core deps didn't change    
    assert!(extensions.length() == 6);
    assert!(extensions.get_by_idx(0).name() == b"AccountProtocol".to_string());
    assert!(extensions.get_by_idx(0).history()[0].addr() == @0x0);
    assert!(extensions.get_by_idx(0).history()[0].version() == 1);
    assert!(extensions.get_by_idx(1).name() == b"AccountConfig".to_string());
    assert!(extensions.get_by_idx(1).history()[0].addr() == @0x1);
    assert!(extensions.get_by_idx(1).history()[0].version() == 1);
    assert!(extensions.get_by_idx(2).name() == b"AccountActions".to_string());
    assert!(extensions.get_by_idx(2).history()[0].addr() == @0x2);
    assert!(extensions.get_by_idx(2).history()[0].version() == 1);

    destroy(extensions);
    destroy(cap);
}

#[test]
fun test_remove_deps() {
    let mut extensions = new_for_testing_with_addrs(@0x0, @0x1, @0x2, &mut tx_context::dummy());
    let cap = AdminCap { id: object::new(&mut tx_context::dummy()) };

    // add extension (checked above)
    extensions.add(&cap, b"A".to_string(), @0xA, 1);
    extensions.add(&cap, b"B".to_string(), @0xB, 1);
    extensions.add(&cap, b"C".to_string(), @0xC, 1);
    // update deps
    extensions.update(&cap, b"B".to_string(), @0x1B, 2);
    extensions.update(&cap, b"C".to_string(), @0x1C, 2);
    extensions.update(&cap, b"C".to_string(), @0x2C, 3);
    // remove deps
    extensions.remove(&cap, b"A".to_string());
    extensions.remove(&cap, b"B".to_string());
    extensions.remove(&cap, b"C".to_string());
    // assertions
    assert!(!extensions.is_extension(b"A".to_string(), @0xA, 1));
    assert!(!extensions.is_extension(b"B".to_string(), @0xB, 1));
    assert!(!extensions.is_extension(b"B".to_string(), @0x1B, 2));
    assert!(!extensions.is_extension(b"C".to_string(), @0xC, 1));
    assert!(!extensions.is_extension(b"C".to_string(), @0x1C, 2));
    assert!(!extensions.is_extension(b"C".to_string(), @0x2C, 3));

    destroy(extensions);
    destroy(cap);
}

#[test]
fun test_new_admin() {
    let mut scenario = ts::begin(@0xCAFE);
    let cap = AdminCap { id: object::new(scenario.ctx()) };
    new_admin(&cap, @0xB0B, scenario.ctx());
    scenario.next_tx(@0xB0B);
    // check it exists
    let new_cap = scenario.take_from_sender<AdminCap>();
    destroy(cap);
    destroy(new_cap);
    ts::end(scenario);
}

#[test, expected_failure(abort_code = ECannotRemoveAccountProtocol)]
fun test_error_remove_account_protocol() {
    let mut extensions = new_for_testing_with_addrs(@0x0, @0x1, @0x2, &mut tx_context::dummy());
    let cap = AdminCap { id: object::new(&mut tx_context::dummy()) };
    extensions.remove(&cap, b"AccountProtocol".to_string());
    destroy(extensions);
    destroy(cap);
}

#[test, expected_failure(abort_code = EExtensionAlreadyExists)]
fun test_error_add_extension_name_already_exists() {
    let mut extensions = new_for_testing_with_addrs(@0x0, @0x1, @0x2, &mut tx_context::dummy());
    let cap = AdminCap { id: object::new(&mut tx_context::dummy()) };
    extensions.add(&cap, b"AccountProtocol".to_string(), @0xA, 1);
    destroy(extensions);
    destroy(cap);
}

#[test, expected_failure(abort_code = EExtensionAlreadyExists)]
fun test_error_add_extension_address_already_exists() {
    let mut extensions = new_for_testing_with_addrs(@0x0, @0x1, @0x2, &mut tx_context::dummy());
    let cap = AdminCap { id: object::new(&mut tx_context::dummy()) };
    extensions.add(&cap, b"A".to_string(), @0x0, 1);
    destroy(extensions);
    destroy(cap);
}

#[test, expected_failure(abort_code = EExtensionNotFound)]
fun test_error_update_not_extension() {
    let mut extensions = new_for_testing_with_addrs(@0x0, @0x1, @0x2, &mut tx_context::dummy());
    let cap = AdminCap { id: object::new(&mut tx_context::dummy()) };
    extensions.update(&cap, b"A".to_string(), @0x0, 1);
    destroy(extensions);
    destroy(cap);
}

#[test, expected_failure(abort_code = EExtensionAlreadyExists)]
fun test_error_update_same_address() {
    let mut extensions = new_for_testing_with_addrs(@0x0, @0x1, @0x2, &mut tx_context::dummy());
    let cap = AdminCap { id: object::new(&mut tx_context::dummy()) };
    extensions.add(&cap, b"A".to_string(), @0xA, 1);
    extensions.update(&cap, b"A".to_string(), @0xA, 2);
    destroy(extensions);
    destroy(cap);
}

#[test, expected_failure(abort_code = EExtensionNotFound)]
fun test_error_remove_not_extension() {
    let mut extensions = new_for_testing_with_addrs(@0x0, @0x1, @0x2, &mut tx_context::dummy());
    let cap = AdminCap { id: object::new(&mut tx_context::dummy()) };
    extensions.remove(&cap, b"A".to_string());
    destroy(extensions);
    destroy(cap);
}/// Users have a non-transferable User account object used to track Accounts in which they are a member.
/// Each account type can define a way to send on-chain invites to Users.
/// Invited users can accept or refuse the invite, to add the Account id to their User account or not.
/// Alternatively, Account interfaces can define rules allowing users to join an Account without invite.
/// This avoid the need for an indexer as all data can be easily found on-chain.

module account_protocol::user;

// === Imports ===

use std::{
    string::String,
    type_name,
};
use sui::{
    vec_map::{Self, VecMap},
    table::{Self, Table},
};
use account_protocol::account::Account;

// === Errors ===

const ENotEmpty: u64 = 0;
const EAlreadyHasUser: u64 = 1;
const EAccountNotFound: u64 = 2;
const EAccountTypeDoesntExist: u64 = 3;
const EWrongUserId: u64 = 4;
const EAccountAlreadyRegistered: u64 = 5;
const EWrongNumberOfAccounts: u64 = 6;
const ENoAccountsToReorder: u64 = 7;

// === Struct ===

/// Shared object enforcing one account maximum per user
public struct Registry has key {
    id: UID,
    // address to User ID mapping
    users: Table<address, ID>,
}

/// Non-transferable user account for tracking Accounts
public struct User has key {
    id: UID,
    // account type to list of accounts that the user has joined
    accounts: VecMap<String, vector<address>>,
}

/// Invite object issued by an Account to a user
public struct Invite has key { 
    id: UID, 
    // Account that issued the invite
    account_addr: address,
    // Account type
    account_type: String,
}

// === Public functions ===

fun init(ctx: &mut TxContext) {
    transfer::share_object(Registry {
        id: object::new(ctx),
        users: table::new(ctx),
    });
}

/// Creates a soulbound User account (1 per address)
public fun new(ctx: &mut TxContext): User {
    User {
        id: object::new(ctx),
        accounts: vec_map::empty(),
    }
}

/// Can transfer the User object only if the other address has no User object yet
public fun transfer(registry: &mut Registry, user: User, recipient: address, ctx: &mut TxContext) {
    assert!(!registry.users.contains(recipient), EAlreadyHasUser);
    // if the sender is not in the registry, then the User has been just created
    if (registry.users.contains(ctx.sender())) {
        let id = registry.users.remove(ctx.sender());
        assert!(id == object::id(&user), EWrongUserId); // should never throw
    };

    registry.users.add(recipient, object::id(&user));
    transfer::transfer(user, recipient);
}

/// Must remove all Accounts before, for consistency
public fun destroy(registry: &mut Registry, user: User, ctx: &mut TxContext) {
    let User { id, accounts, .. } = user;
    assert!(accounts.is_empty(), ENotEmpty);

    id.delete();
    registry.users.remove(ctx.sender());
}

/// Invited user can register the Account in his User account
public fun accept_invite(user: &mut User, invite: Invite) {
    let Invite { id, account_addr, account_type } = invite;
    id.delete();
    
    if (user.accounts.contains(&account_type)) {
        assert!(!user.accounts[&account_type].contains(&account_addr), EAccountAlreadyRegistered);
        user.accounts.get_mut(&account_type).push_back(account_addr);
    } else {
        user.accounts.insert(account_type, vector<address>[account_addr]);
    }
}

/// Deletes the invite object
public fun refuse_invite(invite: Invite) {
    let Invite { id, .. } = invite;
    id.delete();
}

public fun reorder_accounts<Config>(user: &mut User, addrs: vector<address>) {
    let account_type = type_name::get<Config>().into_string().to_string();
    assert!(user.accounts.contains(&account_type), ENoAccountsToReorder);

    let accounts = user.accounts.get_mut(&account_type);
    assert!(accounts.length() == addrs.length(), EWrongNumberOfAccounts);

    let mut new_order = vector[];
    addrs.do!(|addr| {
        let (exists, idx) = accounts.index_of(&addr);
        assert!(exists, EAccountNotFound);
        accounts.swap_remove(idx);
        new_order.push_back(addr);
    });

    *accounts = new_order;
}
// === Config-only functions ===

public fun add_account<Config, CW: drop>(
    user: &mut User, 
    account: &Account<Config>, 
    config_witness: CW,
) {
    account.assert_is_config_module(config_witness);
    let account_type = type_name::get<Config>().into_string().to_string();

    if (user.accounts.contains(&account_type)) {
        assert!(!user.accounts[&account_type].contains(&account.addr()), EAccountAlreadyRegistered);
        user.accounts.get_mut(&account_type).push_back(account.addr());
    } else {
        user.accounts.insert(account_type, vector<address>[account.addr()]);
    }
}

public fun remove_account<Config, CW: drop>(
    user: &mut User, 
    account: &Account<Config>, 
    config_witness: CW,
) {
    account.assert_is_config_module(config_witness);
    let account_type = type_name::get<Config>().into_string().to_string();

    assert!(user.accounts.contains(&account_type), EAccountTypeDoesntExist);
    let (exists, idx) = user.accounts[&account_type].index_of(&account.addr());
    
    assert!(exists, EAccountNotFound);
    user.accounts.get_mut(&account_type).swap_remove(idx);

    if (user.accounts[&account_type].is_empty())
        (_, _) = user.accounts.remove(&account_type);
}

/// Invites can be sent by an Account member (upon Account creation for instance)
public fun send_invite<Config, CW: drop>(
    account: &Account<Config>, 
    recipient: address, 
    config_witness: CW,
    ctx: &mut TxContext,
) {
    account.assert_is_config_module(config_witness);
    let account_type = type_name::get<Config>().into_string().to_string();

    transfer::transfer(Invite { 
        id: object::new(ctx), 
        account_addr: account.addr(),
        account_type,
    }, recipient);
}

// === View functions ===    

public fun users(registry: &Registry): &Table<address, ID> {
    &registry.users
}

public fun ids_for_type<Config>(user: &User): vector<address> {
    let account_type = type_name::get<Config>().into_string().to_string();
    user.accounts[&account_type]
}

public fun all_ids(user: &User): vector<address> {
    let mut map = user.accounts;
    let mut ids = vector<address>[];

    while (!map.is_empty()) {
        let (_, vec) = map.pop();
        ids.append(vec);
    };

    ids
}

//**************************************************************************************************//
// Tests                                                                                            //
//**************************************************************************************************//

// === Test Helpers ===

#[test_only]
public fun init_for_testing(ctx: &mut TxContext) {
    init(ctx);
}

#[test_only]
public fun registry_for_testing(ctx: &mut TxContext): Registry {
    Registry {
        id: object::new(ctx),
        users: table::new(ctx),
    }
}

#[test_only]
public fun add_account_for_testing<Config>(
    user: &mut User,
    account_addr: address,
) {
    let account_type = type_name::get<Config>().into_string().to_string();
    if (user.accounts.contains(&account_type)) {
        assert!(!user.accounts[&account_type].contains(&account_addr), EAccountAlreadyRegistered);
        user.accounts.get_mut(&account_type).push_back(account_addr);
    } else {
        user.accounts.insert(account_type, vector[account_addr]);
    };
}

// === Unit Tests ===

#[test_only]
use sui::test_scenario as ts;
#[test_only]
use sui::test_utils as tu;

#[test_only]
public struct DummyConfig has copy, drop, store {}
#[test_only]
public struct DummyConfig2 has copy, drop, store {}

#[test]
fun test_init() {
    let mut scenario = ts::begin(@0xCAFE);
    init(scenario.ctx());
    scenario.next_tx(@0xCAFE);

    let registry = scenario.take_shared<Registry>();
    assert!(registry.users.is_empty());
    ts::return_shared(registry);

    scenario.end();
}

#[test]
fun test_transfer_user_recipient() {
    let mut scenario = ts::begin(@0xCAFE);
    let mut registry = registry_for_testing(scenario.ctx());
    let user = new(scenario.ctx());

    transfer(&mut registry, user, @0xA11CE, scenario.ctx());
    scenario.next_tx(@0xA11CE);

    let user = scenario.take_from_sender<User>();
    let user_id = object::id(&user);

    assert!(registry.users.contains(@0xA11CE));
    assert!(registry.users.borrow(@0xA11CE) == user_id);

    tu::destroy(user);
    tu::destroy(registry);
    scenario.end();
}

#[test]
fun test_destroy_user() {
    let mut scenario = ts::begin(@0xCAFE);
    let mut registry = registry_for_testing(scenario.ctx());
    let user = new(scenario.ctx());

    transfer(&mut registry, user, @0xA11CE, scenario.ctx());
    scenario.next_tx(@0xA11CE);

    let user = scenario.take_from_sender<User>();
    destroy(&mut registry, user, scenario.ctx());

    assert!(!registry.users.contains(@0xA11CE));
    tu::destroy(registry);
    scenario.end();
}

#[test]
fun test_accept_invite() {
    let mut scenario = ts::begin(@0xCAFE);
    let mut user = new(scenario.ctx());

    let invite = Invite {
        id: object::new(scenario.ctx()),
        account_addr: @0xACC,
        account_type: b"0x0::config::Config".to_string(),
    };

    accept_invite(&mut user, invite);
    assert!(user.accounts.contains(&b"0x0::config::Config".to_string()));
    assert!(user.accounts[&b"0x0::config::Config".to_string()].contains(&@0xACC));

    tu::destroy(user);
    scenario.end();
}

#[test, expected_failure(abort_code = EAccountAlreadyRegistered)]
fun test_accept_invite_already_registered() {
    let mut scenario = ts::begin(@0xCAFE);
    let mut user = new(scenario.ctx());

    let invite = Invite {
        id: object::new(scenario.ctx()),
        account_addr: @0xACC,
        account_type: type_name::get<DummyConfig>().into_string().to_string(),
    };

    user.add_account_for_testing<DummyConfig>(@0xACC);
    assert!(user.accounts.contains(&type_name::get<DummyConfig>().into_string().to_string()));
    assert!(user.accounts[&type_name::get<DummyConfig>().into_string().to_string()].contains(&@0xACC));
    
    accept_invite(&mut user, invite);

    tu::destroy(user);
    scenario.end();
}

#[test]
fun test_refuse_invite() {
    let mut scenario = ts::begin(@0xCAFE);
    let user = new(scenario.ctx());

    let invite = Invite {
        id: object::new(scenario.ctx()),
        account_addr: @0xACC,
        account_type: b"0x0::config::Config".to_string(),
    };

    refuse_invite(invite);
    assert!(!user.accounts.contains(&b"0x0::config::Config".to_string()));

    tu::destroy(user);
    scenario.end();
}

#[test]
fun test_reorder_accounts() {
    let mut scenario = ts::begin(@0xCAFE);
    let mut user = new(scenario.ctx());
    
    user.add_account_for_testing<DummyConfig>(@0x1);
    user.add_account_for_testing<DummyConfig>(@0x2);
    user.add_account_for_testing<DummyConfig>(@0x3);
    let key = type_name::get<DummyConfig>().into_string().to_string();
    assert!(user.accounts.get(&key) == vector[@0x1, @0x2, @0x3]);

    user.reorder_accounts<DummyConfig>(vector[@0x2, @0x3, @0x1]);
    assert!(user.accounts.get(&key) == vector[@0x2, @0x3, @0x1]);

    tu::destroy(user);
    scenario.end();
}

#[test, expected_failure(abort_code = EAlreadyHasUser)]
fun test_error_transfer_to_existing_user() {
    let mut scenario = ts::begin(@0xCAFE);
    let mut registry = registry_for_testing(scenario.ctx());

    registry.transfer(new(scenario.ctx()), @0xCAFE, scenario.ctx());
    registry.transfer(new(scenario.ctx()), @0xCAFE, scenario.ctx());

    tu::destroy(registry);
    scenario.end();
}

#[test, expected_failure(abort_code = EWrongUserId)]
fun test_error_transfer_wrong_user_object() {
    let mut scenario = ts::begin(@0xCAFE);
    let mut registry = registry_for_testing(scenario.ctx());

    registry.transfer(new(scenario.ctx()), @0xCAFE, scenario.ctx());
    // OWNER transfers wrong user object to ALICE
    registry.transfer(new(scenario.ctx()), @0xA11CE, scenario.ctx());

    tu::destroy(registry);
    scenario.end();
}

#[test, expected_failure(abort_code = ENotEmpty)]
fun test_error_destroy_non_empty_user() {
    let mut scenario = ts::begin(@0xCAFE);
    let mut registry = registry_for_testing(scenario.ctx());
    let mut user = new(scenario.ctx());

    user.add_account_for_testing<DummyConfig>(@0xACC);
    destroy(&mut registry, user, scenario.ctx());

    tu::destroy(registry);
    scenario.end();
}

#[test, expected_failure(abort_code = EAccountAlreadyRegistered)]
fun test_error_add_already_existing_account() {
    let mut scenario = ts::begin(@0xCAFE);
    let mut user = new(scenario.ctx());

    user.add_account_for_testing<DummyConfig>(@0xACC);
    user.add_account_for_testing<DummyConfig>(@0xACC);
    
    tu::destroy(user);
    scenario.end();
}

#[test, expected_failure(abort_code = ENoAccountsToReorder)]
fun test_reorder_accounts_empty() {
    let mut scenario = ts::begin(@0xCAFE);
    let mut user = new(scenario.ctx());

    user.reorder_accounts<DummyConfig>(vector[]);

    tu::destroy(user);
    scenario.end();
}

#[test, expected_failure(abort_code = EWrongNumberOfAccounts)]
fun test_reorder_accounts_different_length() {
    let mut scenario = ts::begin(@0xCAFE);
    
    let mut user = new(scenario.ctx());
    user.add_account_for_testing<DummyConfig>(@0xACC);
    user.add_account_for_testing<DummyConfig>(@0xACC2);

    user.reorder_accounts<DummyConfig>(vector[@0xACC]);

    tu::destroy(user);
    scenario.end();
}

#[test, expected_failure(abort_code = EAccountNotFound)]
fun test_reorder_accounts_wrong_account() {
    let mut scenario = ts::begin(@0xCAFE);
    let mut user = new(scenario.ctx());
    
    user.add_account_for_testing<DummyConfig>(@0x1);
    user.add_account_for_testing<DummyConfig>(@0x2);

    user.reorder_accounts<DummyConfig>(vector[@0x1, @0x3]);

    tu::destroy(user);
    scenario.end();
}/// This is the core module managing the account Account<Config>.
/// It provides the apis to create, approve and execute intents with actions.
/// 
/// Fork modifications for DAO proposal platform:
/// - Added cancel_intent function for config-authorized intent cancellation with version witness
///   for proper dependency checking and security
/// 
/// The flow is as follows:
///   1. An intent is created by stacking actions into it. 
///      Actions are pushed from first to last, they must be executed then destroyed in the same order.
///   2. When the intent is resolved (threshold reached, quorum reached, etc), it can be executed. 
///      This returns an Executable hot potato constructed from certain fields of the validated Intent. 
///      It is directly passed into action functions to enforce account approval for an action to be executed.
///   3. The module that created the intent must destroy all of the actions and the Executable after execution 
///      by passing the same witness that was used for instantiation. 
///      This prevents the actions or the intent to be stored instead of executed.
/// 
/// Dependencies can create and manage dynamic fields for an account.
/// They should use custom types as keys to enable access only via the accessors defined.
/// 
/// Functions related to authentication, intent resolution, state of intents and config for an account type 
/// must be called from the module that defines the config of the account.
/// They necessitate a config_witness to ensure the caller is a dependency of the account.
/// 
/// The rest of the functions manipulating the common state of accounts are only called within this package.

module account_protocol::account;

// === Imports ===

use std::{
    string::String,
    type_name,
};
use sui::{
    transfer::Receiving,
    clock::Clock, 
    dynamic_field as df,
    dynamic_object_field as dof,
    package,
};
use account_protocol::{
    metadata::{Self, Metadata},
    deps::{Self, Deps},
    version_witness::{Self, VersionWitness},
    intents::{Self, Intents, Intent, Expired, Params},
    executable::{Self, Executable},
    version,
};

// === Errors ===

const ECantBeRemovedYet: u64 = 1;
const EHasntExpired: u64 = 2;
const ECantBeExecutedYet: u64 = 3;
const EWrongAccount: u64 = 4;
const ENotCalledFromConfigModule: u64 = 5;
const EActionsRemaining: u64 = 6;
const EManagedDataAlreadyExists: u64 = 7;
const EManagedDataDoesntExist: u64 = 8;
const EManagedAssetAlreadyExists: u64 = 9;
const EManagedAssetDoesntExist: u64 = 10;

// === Structs ===

public struct ACCOUNT has drop {}

/// Shared multisig Account object.
public struct Account<Config> has key, store {
    id: UID,
    // arbitrary data that can be proposed and added by members
    // first field is a human readable name to differentiate the multisig accounts
    metadata: Metadata,
    // ids and versions of the packages this account is using
    // idx 0: account_protocol, idx 1: account_actions optionally
    deps: Deps,
    // open intents, key should be a unique descriptive name
    intents: Intents,
    // config can be anything (e.g. Multisig, coin-based DAO, etc.)
    config: Config,
}

/// Protected type ensuring provenance, authenticate an address to an account.
public struct Auth {
    // address of the account that created the auth
    account_addr: address,
}

//**************************************************************************************************//
// Public functions                                                                                //
//**************************************************************************************************//

fun init(otw: ACCOUNT, ctx: &mut TxContext) {
    package::claim_and_keep(otw, ctx); // to create Display objects in the future
}

/// Verifies all actions have been processed and destroys the executable.
/// Called to complete the intent execution.
public fun confirm_execution<Config, Outcome: drop + store>(
    account: &mut Account<Config>, 
    executable: Executable<Outcome>,
) {
    let actions_length = executable.intent().actions().length();
    assert!(executable.action_idx() == actions_length, EActionsRemaining);
    
    let intent = executable.destroy();
    intent.assert_is_account(account.addr());
    
    account.intents.add_intent(intent);
}

/// Destroys an intent if it has no remaining execution.
/// Expired needs to be emptied by deleting each action in the bag within their own module.
public fun destroy_empty_intent<Config, Outcome: store + drop>(
    account: &mut Account<Config>, 
    key: String, 
): Expired {
    assert!(account.intents.get<Outcome>(key).execution_times().is_empty(), ECantBeRemovedYet);
    account.intents.destroy_intent<Outcome>(key)
}

/// Destroys an intent if it has expired.
/// Expired needs to be emptied by deleting each action in the bag within their own module.
public fun delete_expired_intent<Config, Outcome: store + drop>(
    account: &mut Account<Config>, 
    key: String, 
    clock: &Clock,
): Expired {
    assert!(clock.timestamp_ms() >= account.intents.get<Outcome>(key).expiration_time(), EHasntExpired);
    account.intents.destroy_intent<Outcome>(key)
}

/// Cancel an active intent and return its Expired bag for GC draining.
///
/// Security:
/// - `config_witness` gates **authority**: only the Config module may cancel.
/// - `deps_witness` gates **compatibility**: caller must be compiled against the
///   same `account_protocol` package identity/version the Account expects.
///   This prevents mismatched callers from older/newer packages.
public fun cancel_intent<Config, Outcome: store + drop, CW: drop>(
    account: &mut Account<Config>,
    key: String,
    deps_witness: VersionWitness,
    config_witness: CW,
): Expired {
    // Ensure the protocol dependency matches what this account expects
    account.deps().check(deps_witness);
    // Only the config module may cancel
    account.assert_is_config_module(config_witness);
    // Convert to Expired - deleters will handle unlocking during drain
    account.intents.destroy_intent<Outcome>(key)
}

/// Helper function to transfer an object to the account.
public fun keep<Config, T: key + store>(account: &Account<Config>, obj: T) {
    transfer::public_transfer(obj, account.addr());
}

/// Unpacks and verifies the Auth matches the account.
public fun verify<Config>(
    account: &Account<Config>,
    auth: Auth,
) {
    let Auth { account_addr } = auth;

    assert!(account.addr() == account_addr, EWrongAccount);
}

//**************************************************************************************************//
// Deps-only functions                                                                              //
//**************************************************************************************************//

/// The following functions are used to compose intents in external modules and packages.
/// 
/// The proper instantiation and execution of an intent is ensured by an intent witness.
/// This is a drop only type defined in the intent module preventing other modules to misuse the intent.
/// 
/// Additionally, these functions require a version witness which is a protected type for the protocol. 
/// It is checked against the dependencies of the account to ensure the package being called is authorized.
/// VersionWitness is a wrapper around a type defined in the version of the package being called.
/// It behaves like a witness but it is usable in the entire package instead of in a single module.

/// Creates a new intent. Can only be called from a dependency of the account.
public fun create_intent<Config, Outcome: store, IW: drop>(
    account: &Account<Config>,
    params: Params,
    outcome: Outcome, // resolution settings
    managed_name: String, // managed struct/object name for the role
    version_witness: VersionWitness, // proof of the package address that creates the intent
    intent_witness: IW, // intent witness
    ctx: &mut TxContext
): Intent<Outcome> {
    // ensures the package address is a dependency for this account
    account.deps().check(version_witness); 

    params.new_intent(
        outcome,
        managed_name,
        account.addr(),
        intent_witness,
        ctx
    )
}

/// Adds an intent to the account. Can only be called from a dependency of the account.
public fun insert_intent<Config, Outcome: store, IW: drop>(
    account: &mut Account<Config>, 
    intent: Intent<Outcome>, 
    version_witness: VersionWitness,
    intent_witness: IW,
) {
    // ensures the package address is a dependency for this account
    account.deps().check(version_witness);
    // ensures the right account is passed
    intent.assert_is_account(account.addr());
    // ensures the intent is created by the same package that creates the action
    intent.assert_is_witness(intent_witness);

    account.intents.add_intent(intent);
}

/// Managed data and assets:
/// Data structs and Assets objects attached as dynamic fields to the account object.
/// They are separated to improve objects discoverability on frontends and indexers.
/// Keys must be custom types defined in the same module where the function is implemented.

/// Adds a managed data struct to the account.
public fun add_managed_data<Config, Key: copy + drop + store, Data: store>(
    account: &mut Account<Config>, 
    key: Key, 
    data: Data,
    version_witness: VersionWitness,
) {
    assert!(!has_managed_data(account, key), EManagedDataAlreadyExists);
    account.deps().check(version_witness);
    df::add(&mut account.id, key, data);
}

/// Checks if a managed data struct exists in the account.
public fun has_managed_data<Config, Key: copy + drop + store>(
    account: &Account<Config>, 
    key: Key, 
): bool {
    df::exists_(&account.id, key)
}

/// Borrows a managed data struct from the account.
public fun borrow_managed_data<Config, Key: copy + drop + store, Data: store>(
    account: &Account<Config>,
    key: Key, 
    version_witness: VersionWitness,
): &Data {
    assert!(has_managed_data(account, key), EManagedDataDoesntExist);
    account.deps().check(version_witness);
    df::borrow(&account.id, key)
}

/// Borrows a managed data struct mutably from the account.
public fun borrow_managed_data_mut<Config, Key: copy + drop + store, Data: store>(
    account: &mut Account<Config>, 
    key: Key, 
    version_witness: VersionWitness,
): &mut Data {
    assert!(has_managed_data(account, key), EManagedDataDoesntExist);
    account.deps().check(version_witness);
    df::borrow_mut(&mut account.id, key)
}

/// Removes a managed data struct from the account.
public fun remove_managed_data<Config, Key: copy + drop + store, A: store>(
    account: &mut Account<Config>, 
    key: Key, 
    version_witness: VersionWitness,
): A {
    assert!(has_managed_data(account, key), EManagedDataDoesntExist);
    account.deps().check(version_witness);
    df::remove(&mut account.id, key)
}

/// Adds a managed object to the account.
public fun add_managed_asset<Config, Key: copy + drop + store, Asset: key + store>(
    account: &mut Account<Config>, 
    key: Key, 
    asset: Asset,
    version_witness: VersionWitness,
) {
    assert!(!has_managed_asset(account, key), EManagedAssetAlreadyExists);
    account.deps().check(version_witness);
    dof::add(&mut account.id, key, asset);
}

/// Checks if a managed object exists in the account.
public fun has_managed_asset<Config, Key: copy + drop + store>(
    account: &Account<Config>, 
    key: Key, 
): bool {
    dof::exists_(&account.id, key)
}

/// Borrows a managed object from the account.
public fun borrow_managed_asset<Config, Key: copy + drop + store, Asset: key + store>(
    account: &Account<Config>,
    key: Key, 
    version_witness: VersionWitness,
): &Asset {
    assert!(has_managed_asset(account, key), EManagedAssetDoesntExist);
    account.deps().check(version_witness);
    dof::borrow(&account.id, key)
}

/// Borrows a managed object mutably from the account.
public fun borrow_managed_asset_mut<Config, Key: copy + drop + store, Asset: key + store>(
    account: &mut Account<Config>, 
    key: Key, 
    version_witness: VersionWitness,
): &mut Asset {
    assert!(has_managed_asset(account, key), EManagedAssetDoesntExist);
    account.deps().check(version_witness);
    dof::borrow_mut(&mut account.id, key)
}

/// Removes a managed object from the account.
public fun remove_managed_asset<Config, Key: copy + drop + store, Asset: key + store>(
    account: &mut Account<Config>, 
    key: Key, 
    version_witness: VersionWitness,
): Asset {
    assert!(has_managed_asset(account, key), EManagedAssetDoesntExist);
    account.deps().check(version_witness);
    dof::remove(&mut account.id, key)
}

//**************************************************************************************************//
// Config-only functions                                                                            //
//**************************************************************************************************//

/// The following functions are used to define account and intent behavior for a specific account type/config.
/// 
/// They must be implemented in the module that defines the config of the account, which must be a dependency of the account.
/// We provide higher level macros to facilitate the implementation of these functions.

/// Creates a new account with default dependencies. Can only be called from the config module.
public fun new<Config, CW: drop>(
    config: Config, 
    deps: Deps,
    version_witness: VersionWitness,
    config_witness: CW,
    ctx: &mut TxContext
): Account<Config> {
    let account = Account<Config> { 
        id: object::new(ctx),
        metadata: metadata::empty(),
        deps,
        intents: intents::empty(ctx),
        config,
    };

    account.deps().check(version_witness);
    account.assert_is_config_module(config_witness);

    account 
}

/// Returns an Auth object that can be used to call gated functions. Can only be called from the config module.
public fun new_auth<Config, CW: drop>(
    account: &Account<Config>,
    version_witness: VersionWitness,
    config_witness: CW,
): Auth {
    account.deps().check(version_witness);
    account.assert_is_config_module(config_witness);

    Auth { account_addr: account.addr() }
}

/// Returns a tuple of the outcome that must be validated and the executable. Can only be called from the config module.
public fun create_executable<Config, Outcome: store + copy, CW: drop>(
    account: &mut Account<Config>,
    key: String, 
    clock: &Clock,
    version_witness: VersionWitness,
    config_witness: CW,
): (Outcome, Executable<Outcome>) {
    account.deps().check(version_witness);
    account.assert_is_config_module(config_witness);

    let mut intent = account.intents.remove_intent<Outcome>(key);
    let time = intent.pop_front_execution_time();
    assert!(clock.timestamp_ms() >= time, ECantBeExecutedYet);

    (
        *intent.outcome(),
        executable::new(intent) 
    )
}

/// Returns a mutable reference to the intents of the account. Can only be called from the config module.
public fun intents_mut<Config, CW: drop>(
    account: &mut Account<Config>, 
    version_witness: VersionWitness,
    config_witness: CW,
): &mut Intents {
    account.deps().check(version_witness);
    account.assert_is_config_module(config_witness);

    &mut account.intents
}

/// Returns a mutable reference to the config of the account. Can only be called from the config module.
public fun config_mut<Config, CW: drop>(
    account: &mut Account<Config>, 
    version_witness: VersionWitness,
    config_witness: CW,
): &mut Config {
    account.deps().check(version_witness);
    account.assert_is_config_module(config_witness);

    &mut account.config
}

//**************************************************************************************************//
// View functions                                                                                   //
//**************************************************************************************************//

/// Returns the address of the account.
public fun addr<Config>(account: &Account<Config>): address {
    account.id.uid_to_inner().id_to_address()
}

/// Returns the metadata of the account.
public fun metadata<Config>(account: &Account<Config>): &Metadata {
    &account.metadata
}

/// Returns the dependencies of the account.
public fun deps<Config>(account: &Account<Config>): &Deps {
    &account.deps
}

/// Returns the intents of the account.
public fun intents<Config>(account: &Account<Config>): &Intents {
    &account.intents
}

/// Returns the config of the account.
public fun config<Config>(account: &Account<Config>): &Config {
    &account.config
}

//**************************************************************************************************//
// Package functions                                                                                //
//**************************************************************************************************//

/// Returns a mutable reference to the metadata of the account.
public(package) fun metadata_mut<Config>(
    account: &mut Account<Config>, 
    version_witness: VersionWitness,
): &mut Metadata {
    // ensures the package address is a dependency for this account
    account.deps().check(version_witness);
    &mut account.metadata
}

/// Returns a mutable reference to the dependencies of the account.
public(package) fun deps_mut<Config>(
    account: &mut Account<Config>, 
    version_witness: VersionWitness,
): &mut Deps {
    // ensures the package address is a dependency for this account
    account.deps().check(version_witness);
    &mut account.deps
}

/// Receives an object from an account, only used in owned action lib module.
public(package) fun receive<Config, T: key + store>(
    account: &mut Account<Config>, 
    receiving: Receiving<T>,
): T {
    transfer::public_receive(&mut account.id, receiving)
}

/// Locks an object in the account, preventing it to be used in another intent.
public(package) fun lock_object<Config>(
    account: &mut Account<Config>, 
    id: ID,
) {
    account.intents.lock(id);
}

/// Unlocks an object in the account, allowing it to be used in another intent.
public(package) fun unlock_object<Config>(
    account: &mut Account<Config>, 
    id: ID,
) {
    account.intents.unlock(id);
}

/// Asserts that the function is called from the module defining the config of the account.
public(package) fun assert_is_config_module<Config, CW: drop>(
    _account: &Account<Config>, 
    _config_witness: CW
) {
    let account_type = type_name::get<Config>();
    let witness_type = type_name::get<CW>();
    assert!(
        account_type.get_address() == witness_type.get_address() &&
        account_type.get_module() == witness_type.get_module(),
        ENotCalledFromConfigModule
    );
}

//**************************************************************************************************//
// Tests                                                                                            //
//**************************************************************************************************//

// === Test Helpers ===

#[test_only]
public fun init_for_testing(ctx: &mut TxContext) {
    init(ACCOUNT {}, ctx);
}

#[test_only]
public struct Witness() has drop;

#[test_only]
public fun not_config_witness(): Witness {
    Witness()
}

// === Unit Tests ===

#[test_only]
use sui::test_utils::{assert_eq, destroy};
use account_extensions::extensions;

#[test_only]
public struct TestConfig has copy, drop, store {}
#[test_only]
public struct TestWitness() has drop;
#[test_only]
public struct WrongWitness() has drop;
#[test_only]
public struct TestKey has copy, drop, store {}
#[test_only]
public struct TestData has copy, drop, store {
    value: u64
}
#[test_only]
public struct TestAsset has key, store {
    id: UID
}

#[test]
fun test_addr() {
    let ctx = &mut tx_context::dummy();
    let deps = deps::new_for_testing();
    
    let account = new(TestConfig {}, deps, version::current(), TestWitness(), ctx);
    let account_addr = addr(&account);
    
    assert_eq(account_addr, object::id(&account).to_address());
    destroy(account);
}

#[test]
fun test_verify_auth() {
    let ctx = &mut tx_context::dummy();
    let deps = deps::new_for_testing();
    
    let account = new(TestConfig {}, deps, version::current(), TestWitness(), ctx);
    let auth = Auth { account_addr: account.addr() };
    
    // Should not abort
    verify(&account, auth);
    destroy(account);
}

#[test, expected_failure(abort_code = EWrongAccount)]
fun test_verify_auth_wrong_account() {
    let ctx = &mut tx_context::dummy();
    let deps = deps::new_for_testing();
    
    let account = new(TestConfig {}, deps, version::current(), TestWitness(), ctx);
    let auth = Auth { account_addr: @0xBAD };
    
    verify(&account, auth);
    destroy(account);
}

#[test]
fun test_managed_data_flow() {
    let ctx = &mut tx_context::dummy();
    let deps = deps::new_for_testing();
    
    let mut account = new(TestConfig {}, deps, version::current(), TestWitness(), ctx);
    let key = TestKey {};
    let data = TestData { value: 42 };
    
    // Test add
    add_managed_data(&mut account, key, data, version::current());
    assert!(has_managed_data(&account, key));
    
    // Test borrow
    let borrowed_data = borrow_managed_data(&account, key, version::current());
    assert_eq(*borrowed_data, data);
    
    // Test borrow_mut
    let borrowed_mut_data = borrow_managed_data_mut(&mut account, key, version::current());
    assert_eq(*borrowed_mut_data, data);
    
    // Test remove
    let removed_data = remove_managed_data(&mut account, key, version::current());
    assert_eq(removed_data, data);
    assert!(!has_managed_data(&account, key));
    destroy(account);
}

#[test, expected_failure(abort_code = EManagedDataAlreadyExists)]
fun test_add_managed_data_already_exists() {
    let ctx = &mut tx_context::dummy();
    let deps = deps::new_for_testing();
    
    let mut account = new(TestConfig {}, deps, version::current(), TestWitness(), ctx);
    let key = TestKey {};
    let data1 = TestData { value: 42 };
    let data2 = TestData { value: 100 };
    
    add_managed_data(&mut account, key, data1, version::current());
    add_managed_data(&mut account, key, data2, version::current());
    destroy(account);
}

#[test, expected_failure(abort_code = EManagedDataDoesntExist)]
fun test_borrow_managed_data_doesnt_exist() {
    let ctx = &mut tx_context::dummy();
    let deps = deps::new_for_testing();
    
    let account = new(TestConfig {}, deps, version::current(), TestWitness(), ctx);
    let key = TestKey {};
    
    borrow_managed_data<_, TestKey, TestData>(&account, key, version::current());
    destroy(account);
}

#[test, expected_failure(abort_code = EManagedDataDoesntExist)]
fun test_borrow_managed_data_mut_doesnt_exist() {
    let ctx = &mut tx_context::dummy();
    let deps = deps::new_for_testing();
    
    let mut account = new(TestConfig {}, deps, version::current(), TestWitness(), ctx);
    let key = TestKey {};
    
    borrow_managed_data_mut<_, TestKey, TestData>(&mut account, key, version::current());
    destroy(account);
}

#[test, expected_failure(abort_code = EManagedDataDoesntExist)]
fun test_remove_managed_data_doesnt_exist() {
    let ctx = &mut tx_context::dummy();
    let deps = deps::new_for_testing();
    
    let mut account = new(TestConfig {}, deps, version::current(), TestWitness(), ctx);
    let key = TestKey {};
    
    remove_managed_data<_, TestKey, TestData>(&mut account, key, version::current());
    destroy(account);
}

#[test]
fun test_managed_asset_flow() {
    let ctx = &mut tx_context::dummy();
    let deps = deps::new_for_testing();
    
    let mut account = new(TestConfig {}, deps, version::current(), TestWitness(), ctx);
    let key = TestKey {};
    let asset = TestAsset { id: object::new(ctx) };
    let asset_id = object::id(&asset);
    
    // Test add
    add_managed_asset(&mut account, key, asset, version::current());
    assert!(has_managed_asset(&account, key), 0);
    
    // Test borrow
    let borrowed_asset = borrow_managed_asset<_, TestKey, TestAsset>(&account, key, version::current());
    assert_eq(object::id(borrowed_asset), asset_id);
    
    // Test remove
    let removed_asset = remove_managed_asset<_, TestKey, TestAsset>(&mut account, key, version::current());
    assert_eq(object::id(&removed_asset), asset_id);
    assert!(!has_managed_asset(&account, key));
    destroy(account);
    destroy(removed_asset);
}

#[test]
fun test_has_managed_data_false() {
    let ctx = &mut tx_context::dummy();
    let deps = deps::new_for_testing();
    
    let account = new(TestConfig {}, deps, version::current(), TestWitness(), ctx);
    let key = TestKey {};
    
    assert!(!has_managed_data(&account, key));
    destroy(account);
}

#[test]
fun test_has_managed_asset_false() {
    let ctx = &mut tx_context::dummy();
    let deps = deps::new_for_testing();
    
    let account = new(TestConfig {}, deps, version::current(), TestWitness(), ctx);
    let key = TestKey {};
    
    assert!(!has_managed_asset(&account, key));
    destroy(account);
}

#[test, expected_failure(abort_code = EManagedAssetAlreadyExists)]
fun test_add_managed_asset_already_exists() {
    let ctx = &mut tx_context::dummy();
    let deps = deps::new_for_testing();
    
    let mut account = new(TestConfig {}, deps, version::current(), TestWitness(), ctx);
    let key = TestKey {};
    let asset1 = TestAsset { id: object::new(ctx) };
    let asset2 = TestAsset { id: object::new(ctx) };
    
    add_managed_asset(&mut account, key, asset1, version::current());
    add_managed_asset(&mut account, key, asset2, version::current());
    destroy(account);
}

#[test, expected_failure(abort_code = EManagedAssetDoesntExist)]
fun test_borrow_managed_asset_doesnt_exist() {
    let ctx = &mut tx_context::dummy();
    let deps = deps::new_for_testing();
    
    let account = new(TestConfig {}, deps, version::current(), TestWitness(), ctx);
    let key = TestKey {};
    
    borrow_managed_asset<_, TestKey, TestAsset>(&account, key, version::current());
    destroy(account);
}

#[test, expected_failure(abort_code = EManagedAssetDoesntExist)]
fun test_borrow_managed_asset_mut_doesnt_exist() {
    let ctx = &mut tx_context::dummy();
    let deps = deps::new_for_testing();
    
    let mut account = new(TestConfig {}, deps, version::current(), TestWitness(), ctx);
    let key = TestKey {};
    
    borrow_managed_asset_mut<_, TestKey, TestAsset>(&mut account, key, version::current());
    destroy(account);
}

#[test, expected_failure(abort_code = EManagedAssetDoesntExist)]
fun test_remove_managed_asset_doesnt_exist() {
    let ctx = &mut tx_context::dummy();
    let deps = deps::new_for_testing();
    
    let mut account = new(TestConfig {}, deps, version::current(), TestWitness(), ctx);
    let key = TestKey {};
    
    let removed_asset = remove_managed_asset<_, TestKey, TestAsset>(&mut account, key, version::current());
    destroy(removed_asset);
    destroy(account);
}

#[test]
fun test_new_auth() {
    let ctx = &mut tx_context::dummy();
    let deps = deps::new_for_testing();
    
    let account = new(TestConfig {}, deps, version::current(), TestWitness(), ctx);
    let auth = new_auth(&account, version::current(), TestWitness());
    
    assert_eq(auth.account_addr, account.addr());
    destroy(account);
    destroy(auth);
}

#[test]
fun test_metadata_access() {
    let ctx = &mut tx_context::dummy();
    let deps = deps::new_for_testing();
    
    let account = new(TestConfig {}, deps, version::current(), TestWitness(), ctx);
    
    // Should not abort - just testing access
    assert_eq(metadata(&account).size(), 0);
    destroy(account);
}

#[test]
fun test_config_access() {
    let ctx = &mut tx_context::dummy();
    let deps = deps::new_for_testing();
    
    let account = new(TestConfig {}, deps, version::current(), TestWitness(), ctx);
    
    // Should not abort - just testing access
    config(&account);
    destroy(account);
}

#[test]
fun test_assert_is_config_module_correct_witness() {
    let ctx = &mut tx_context::dummy();
    let deps = deps::new_for_testing();
    
    let account = new(TestConfig {}, deps, version::current(), TestWitness(), ctx);
    
    // Should not abort
    assert_is_config_module(&account, TestWitness());
    destroy(account);
}

#[test, expected_failure(abort_code = ENotCalledFromConfigModule)]
fun test_assert_config_module_wrong_witness_package_address() {
    let ctx = &mut tx_context::dummy();
    let deps = deps::new_for_testing();
    
    let account = new(TestConfig {}, deps, version::current(), TestWitness(), ctx);
    assert_is_config_module(&account, extensions::witness());
    destroy(account);
}

#[test, expected_failure(abort_code = ENotCalledFromConfigModule)]
fun test_assert_config_module_wrong_witness_module() {
    let ctx = &mut tx_context::dummy();
    let deps = deps::new_for_testing();
    
    let account = new(TestConfig {}, deps, version::current(), TestWitness(), ctx);
    assert_is_config_module(&account, version::witness());
    destroy(account);
}/// Dependencies are the packages that an Account object can call.
/// They are stored in a vector and can be modified through an intent.
/// AccountProtocol is the only mandatory dependency, found at index 0.
/// 
/// For improved security, we provide a whitelist of allowed packages in Extensions.
/// If unverified_allowed is false, then only these packages can be added.

module account_protocol::deps;

// === Imports ===

use std::string::String;
use account_extensions::extensions::Extensions;
use account_protocol::version_witness::{Self, VersionWitness};

// === Errors ===

const EDepNotFound: u64 = 0;
const EDepAlreadyExists: u64 = 1;
const ENotDep: u64 = 2;
const ENotExtension: u64 = 3;
const EAccountProtocolMissing: u64 = 4;
const EDepsNotSameLength: u64 = 5;
const EAccountConfigMissing: u64 = 6;

// === Structs ===

/// Parent struct protecting the deps
public struct Deps has copy, drop, store {
    inner: vector<Dep>,
    // can community extensions be added
    unverified_allowed: bool,
}

/// Child struct storing the name, package and version of a dependency
public struct Dep has copy, drop, store {
    // name of the package
    name: String,
    // id of the package
    addr: address,
    // version of the package
    version: u64,
}

// === Public functions ===

/// Creates a new Deps struct, AccountProtocol must be the first dependency.
public fun new(
    extensions: &Extensions,
    unverified_allowed: bool,
    names: vector<String>,
    addresses: vector<address>,
    mut versions: vector<u64>,
): Deps {
    assert!(names.length() == addresses.length() && addresses.length() == versions.length(), EDepsNotSameLength);
    assert!(
        names[0] == b"AccountProtocol".to_string() &&
        extensions.is_extension(names[0], addresses[0], versions[0]), 
        EAccountProtocolMissing
    );
    // second dependency must be AccountConfig (we don't know the name)
    assert!(names[1] != b"AccountActions".to_string(), EAccountConfigMissing);

    let mut inner = vector<Dep>[];

    names.zip_do!(addresses, |name, addr| {
        let version = versions.remove(0);
        
        assert!(!inner.any!(|dep| dep.name == name), EDepAlreadyExists);
        assert!(!inner.any!(|dep| dep.addr == addr), EDepAlreadyExists);
        if (!unverified_allowed) 
            assert!(extensions.is_extension(name, addr, version), ENotExtension);

        inner.push_back(Dep { name, addr, version });
    });

    Deps { inner, unverified_allowed }
}

/// Creates a new Deps struct from latest packages for names.
/// Unverified packages are not allowed after this operation.
public fun new_latest_extensions(
    extensions: &Extensions,
    names: vector<String>,
): Deps {
    assert!(names[0] == b"AccountProtocol".to_string(), EAccountProtocolMissing);

    let mut inner = vector<Dep>[];

    names.do!(|name| {
        assert!(!inner.any!(|dep| dep.name == name), EDepAlreadyExists);
        let (addr, version) = extensions.get_latest_for_name(name);
        
        inner.push_back(Dep { name, addr, version });
    });

    Deps { inner, unverified_allowed: false }
}

public fun new_inner(
    extensions: &Extensions,
    deps: &Deps,
    names: vector<String>,
    addresses: vector<address>,
    mut versions: vector<u64>,
): vector<Dep> {
    assert!(names.length() == addresses.length() && addresses.length() == versions.length(), EDepsNotSameLength);
    // AccountProtocol is mandatory and cannot be removed
    assert!(
        names[0] == b"AccountProtocol".to_string() &&
        extensions.is_extension(names[0], addresses[0], versions[0]), 
        EAccountProtocolMissing
    );
    // AccountConfig is mandatory and cannot be removed
    assert!(names[1] == deps.get_by_idx(1).name, EAccountConfigMissing);

    let mut inner = vector<Dep>[];
    names.zip_do!(addresses, |name, addr| {
        let version = versions.remove(0);
        
        assert!(!inner.any!(|dep| dep.name == name), EDepAlreadyExists);
        assert!(!inner.any!(|dep| dep.addr == addr), EDepAlreadyExists);
        if (!deps.unverified_allowed) 
            assert!(extensions.is_extension(name, addr, version), ENotExtension);

        inner.push_back(Dep { name, addr, version });
    });

    inner
}

/// Safe because deps_mut is only accessible in this package.
public fun inner_mut(deps: &mut Deps): &mut vector<Dep> {
    &mut deps.inner
}

// === View functions ===

/// Checks if a package is a dependency.
public fun check(deps: &Deps, version_witness: VersionWitness) {
    assert!(deps.contains_addr(version_witness.package_addr()), ENotDep);
}

/// Returns true if unverified packages are allowed.
public fun unverified_allowed(deps: &Deps): bool {
    deps.unverified_allowed
}

/// Returns a dependency by index.
public fun get_by_idx(deps: &Deps, idx: u64): &Dep {
    &deps.inner[idx]
}

/// Returns a dependency by name.
public fun get_by_name(deps: &Deps, name: String): &Dep {
    let opt = deps.inner.find_index!(|dep| dep.name == name);
    assert!(opt.is_some(), EDepNotFound);
    let idx = opt.destroy_some();

    &deps.inner[idx]
}

/// Returns a dependency by address.
public fun get_by_addr(deps: &Deps, addr: address): &Dep {
    let opt = deps.inner.find_index!(|dep| dep.addr == addr);
    assert!(opt.is_some(), EDepNotFound);
    let idx = opt.destroy_some();
    
    &deps.inner[idx]
}

/// Returns the number of dependencies.
public fun length(deps: &Deps): u64 {
    deps.inner.length()
}

/// Returns the name of a dependency.
public fun name(dep: &Dep): String {
    dep.name
}

/// Returns the address of a dependency.
public fun addr(dep: &Dep): address {
    dep.addr
}

/// Returns the version of a dependency.
public fun version(dep: &Dep): u64 {
    dep.version
}

/// Returns true if a dependency exists by name.
public fun contains_name(deps: &Deps, name: String): bool {
    deps.inner.any!(|dep| dep.name == name)
}

/// Returns true if a dependency exists by address.
public fun contains_addr(deps: &Deps, addr: address): bool {
    deps.inner.any!(|dep| dep.addr == addr)
}

// === Package functions ===

/// Toggles the unverified_allowed flag.
public(package) fun toggle_unverified_allowed(deps: &mut Deps) {
    deps.unverified_allowed = !deps.unverified_allowed;
}

//**************************************************************************************************//
// Test functions                                                                                   //
//**************************************************************************************************//

// === Test Helpers ===

#[test_only]
public fun new_for_testing(): Deps {
    Deps {
        inner: vector[
            Dep { name: b"AccountProtocol".to_string(), addr: @account_protocol, version: 1 },
            Dep { name: b"AccountConfig".to_string(), addr: @0x1, version: 1 },
            Dep { name: b"AccountActions".to_string(), addr: @0x2, version: 1 }
        ],
        unverified_allowed: false
    }
}

#[test_only]
public fun toggle_unverified_allowed_for_testing(deps: &mut Deps) {
    deps.unverified_allowed = !deps.unverified_allowed;
}

// === Unit Tests ===

#[test_only]
use sui::test_utils::{assert_eq, destroy};

#[test]
fun test_inner_mut() {
    let mut deps = Deps {
        inner: vector[
            Dep { name: b"AccountProtocol".to_string(), addr: @account_protocol, version: 1 },
            Dep { name: b"AccountConfig".to_string(), addr: @0x1, version: 1 },
            Dep { name: b"AccountActions".to_string(), addr: @0x2, version: 1 }
        ],
        unverified_allowed: false
    };
    let inner = inner_mut(&mut deps);
    
    assert_eq(inner.length(), 3);
    inner.push_back(Dep { name: b"NewDep".to_string(), addr: @0x3, version: 1 });
    assert_eq(inner.length(), 4);
    
    destroy(deps);
}

#[test]
fun test_check_success() {
    let deps = Deps {
        inner: vector[
            Dep { name: b"AccountProtocol".to_string(), addr: @account_protocol, version: 1 },
            Dep { name: b"AccountConfig".to_string(), addr: @0x1, version: 1 },
            Dep { name: b"AccountActions".to_string(), addr: @0x2, version: 1 }
        ],
        unverified_allowed: false
    };
    let witness = version_witness::new_for_testing(@account_protocol);
    
    check(&deps, witness);
}

#[test, expected_failure(abort_code = ENotDep)]
fun test_check_failure() {
    let deps = Deps {
        inner: vector[
            Dep { name: b"AccountProtocol".to_string(), addr: @account_protocol, version: 1 },
            Dep { name: b"AccountConfig".to_string(), addr: @0x1, version: 1 },
            Dep { name: b"AccountActions".to_string(), addr: @0x2, version: 1 }
        ],
        unverified_allowed: false
    };
    let witness = version_witness::new_for_testing(@0xDEAD);
    
    check(&deps, witness);
}

#[test]
fun test_get_by_idx() {
    let deps = new_for_testing();
    let dep = get_by_idx(&deps, 0);
    
    assert_eq(dep.name, b"AccountProtocol".to_string());
    assert_eq(dep.addr, @account_protocol);
    assert_eq(dep.version, 1);
}

#[test]
fun test_get_by_name_success() {
    let deps = new_for_testing();
    let dep = get_by_name(&deps, b"AccountProtocol".to_string());
    
    assert_eq(dep.name, b"AccountProtocol".to_string());
    assert_eq(dep.addr, @account_protocol);
    assert_eq(dep.version, 1);
}

#[test, expected_failure(abort_code = EDepNotFound)]
fun test_get_by_name_not_found() {
    let deps = new_for_testing();
    let _dep = get_by_name(&deps, b"Nonexistent".to_string());
}

#[test, expected_failure(abort_code = EDepNotFound)]
fun test_get_by_name_empty_string() {
    let deps = new_for_testing();
    let _dep = get_by_name(&deps, b"".to_string());
}

#[test]
fun test_get_by_addr_success() {
    let deps = new_for_testing();
    let dep = get_by_addr(&deps, @account_protocol);
    
    assert_eq(dep.name, b"AccountProtocol".to_string());
    assert_eq(dep.addr, @account_protocol);
    assert_eq(dep.version, 1);
}

#[test, expected_failure(abort_code = EDepNotFound)]
fun test_get_by_addr_not_found() {
    let deps = new_for_testing();
    let _dep = get_by_addr(&deps, @0xDEAD);
}

#[test, expected_failure(abort_code = EDepNotFound)]
fun test_get_by_addr_zero_address() {
    let deps = new_for_testing();
    let _dep = get_by_addr(&deps, @0x0);
}

#[test]
fun test_length() {
    let deps = new_for_testing();
    assert_eq(length(&deps), 3);
}

#[test]
fun test_name_addr_version() {
    let deps = new_for_testing();
    let dep = get_by_idx(&deps, 0);
    
    assert_eq(name(dep), b"AccountProtocol".to_string());
    assert_eq(addr(dep), @account_protocol);
    assert_eq(version(dep), 1);
}

#[test]
fun test_contains_name_true() {
    let deps = new_for_testing();
    assert!(contains_name(&deps, b"AccountProtocol".to_string()));
    assert!(contains_name(&deps, b"AccountConfig".to_string()));
    assert!(contains_name(&deps, b"AccountActions".to_string()));
}

#[test]
fun test_contains_name_false() {
    let deps = new_for_testing();
    assert!(!contains_name(&deps, b"Nonexistent".to_string()));
    assert!(!contains_name(&deps, b"".to_string()));
}

#[test]
fun test_contains_name_empty_deps() {
    let deps = Deps { inner: vector[], unverified_allowed: false };
    assert!(!contains_name(&deps, b"AnyName".to_string()));
}

#[test]
fun test_contains_addr_true() {
    let deps = new_for_testing();
    assert!(contains_addr(&deps, @account_protocol));
    assert!(contains_addr(&deps, @0x1));
    assert!(contains_addr(&deps, @0x2));
}

#[test]
fun test_contains_addr_false() {
    let deps = new_for_testing();
    assert!(!contains_addr(&deps, @0xDEAD));
    assert!(!contains_addr(&deps, @0x0));
    assert!(!contains_addr(&deps, @0x3));
}

#[test]
fun test_contains_addr_empty_deps() {
    let deps = Deps { inner: vector[], unverified_allowed: false };
    assert!(!contains_addr(&deps, @0x1));
}

#[test]
fun test_toggle_unverified_allowed() {
    let mut deps = new_for_testing();
    
    // Start with false
    assert!(!unverified_allowed(&deps));
    
    // Toggle to true
    toggle_unverified_allowed(&mut deps);
    assert!(unverified_allowed(&deps));
    
    // Toggle back to false
    toggle_unverified_allowed(&mut deps);
    assert!(!unverified_allowed(&deps));
    
    // Toggle to true again
    toggle_unverified_allowed(&mut deps);
    assert!(unverified_allowed(&deps));
}

#[test]
fun test_toggle_unverified_allowed_from_true() {
    let mut deps = new_for_testing();
    deps.unverified_allowed = true;
    
    // Start with true
    assert!(unverified_allowed(&deps));
    
    // Toggle to false
    toggle_unverified_allowed(&mut deps);
    assert!(!unverified_allowed(&deps));
    
    // Toggle back to true
    toggle_unverified_allowed(&mut deps);
    assert!(unverified_allowed(&deps));
}

/// This module defines the VersionWitness type used to track the version of the protocol.
/// This type is used as a regular witness, but for an entire package instead of a single module.

module account_protocol::version_witness;

// === Imports ===

use std::type_name;
use sui::{
    address, 
    hex,
};

// === Structs ===

/// Witness to check the version of a package.
public struct VersionWitness has copy, drop {
    // package id where the witness has been created
    package_addr: address,
}

/// Creates a new VersionWitness for the package where the Witness is instianted.
public fun new<PW: drop>(_package_witness: PW): VersionWitness {
    let package_type = type_name::get<PW>();
    let package_addr = address::from_bytes(hex::decode(package_type.get_address().into_bytes()));

    VersionWitness { package_addr }
}

// === Public Functions ===

/// Returns the address of the package where the witness has been created.
public fun package_addr(witness: &VersionWitness): address {
    witness.package_addr
}

//**************************************************************************************************//
// Tests                                                                                            //
//**************************************************************************************************//

// === Test Helpers ===

#[test_only]
public fun new_for_testing(package_addr: address): VersionWitness {
    VersionWitness { package_addr }
}

// === Unit Tests ===

#[test_only]
public struct TestPackageWitness() has drop;

#[test]
fun test_new_version_witness() {
    let witness = new(TestPackageWitness());
    // Should not abort - just testing creation and access
    assert!(package_addr(&witness) == @account_protocol, 0);
}/// This is the core module managing Intents.
/// It provides the interface to create and execute intents which is used in the `account` module.
/// The `locked` field tracks the owned objects used in an intent, to prevent state changes.
/// e.g. withdraw coinA (value=10sui), coinA must not be split before intent is executed.

module account_protocol::intents;

// === Imports ===

use std::{
    string::String,
    type_name::{Self, TypeName},
};
use sui::{
    bag::{Self, Bag},
    dynamic_field,
    vec_set::{Self, VecSet},
    clock::Clock,
};

// === Aliases ===

use fun dynamic_field::add as UID.df_add;
use fun dynamic_field::borrow as UID.df_borrow;
use fun dynamic_field::remove as UID.df_remove;

// === Errors ===

const EIntentNotFound: u64 = 0;
const EObjectAlreadyLocked: u64 = 1;
const EObjectNotLocked: u64 = 2;
const ENoExecutionTime: u64 = 3;
const EExecutionTimesNotAscending: u64 = 4;
const EActionsNotEmpty: u64 = 5;
const EKeyAlreadyExists: u64 = 6;
const EWrongAccount: u64 = 7;
const EWrongWitness: u64 = 8;
const ESingleExecution: u64 = 9;

// === Structs ===

/// Parent struct protecting the intents
public struct Intents has store {
    // map of intents: key -> Intent<Outcome>
    inner: Bag,
    // ids of the objects that are being requested in intents, to avoid state changes
    locked: VecSet<ID>,
}

/// Child struct, intent owning a sequence of actions requested to be executed
/// Outcome is a custom struct depending on the config
public struct Intent<Outcome> has store {
    // type of the intent, checked against the witness to ensure correct execution
    type_: TypeName,
    // name of the intent, serves as a key, should be unique
    key: String,
    // what this intent aims to do, for informational purpose
    description: String,
    // address of the account that created the intent
    account: address,
    // address of the user that created the intent
    creator: address,
    // timestamp of the intent creation
    creation_time: u64,
    // proposer can add a timestamp_ms before which the intent can't be executed
    // can be used to schedule actions via a backend
    // recurring intents can be executed at these times
    execution_times: vector<u64>,
    // the intent can be deleted from this timestamp
    expiration_time: u64,
    // role for the intent 
    role: String,
    // heterogenous array of actions to be executed in order
    actions: Bag,
    // Generic struct storing vote related data, depends on the config
    outcome: Outcome,
}

/// Hot potato wrapping actions from an intent that expired or has been executed
public struct Expired {
    // address of the account that created the intent
    account: address,
    // index of the first action in the bag
    start_index: u64,
    // actions that expired
    actions: Bag
}

/// Params of an intent to reduce boilerplate.
public struct Params has key, store {
    id: UID,
}
/// Fields are a df so it intents can be improved in the future
public struct ParamsFieldsV1 has copy, drop, store {
    key: String,
    description: String,
    creation_time: u64,
    execution_times: vector<u64>,
    expiration_time: u64,
}

// === Public functions ===

public fun new_params(
    key: String,
    description: String,
    execution_times: vector<u64>,
    expiration_time: u64,
    clock: &Clock,
    ctx: &mut TxContext,
): Params {
    assert!(!execution_times.is_empty(), ENoExecutionTime);
    let mut i = 0;
    while (i < vector::length(&execution_times) - 1) {
        assert!(execution_times[i] <= execution_times[i + 1], EExecutionTimesNotAscending);
        i = i + 1;
    };
    
    let fields = ParamsFieldsV1 { 
        key, 
        description, 
        creation_time: clock.timestamp_ms(), 
        execution_times, 
        expiration_time 
    };
    let mut id = object::new(ctx);
    id.df_add(true, fields);

    Params { id }
}

public fun new_params_with_rand_key(
    description: String,
    execution_times: vector<u64>,
    expiration_time: u64,
    clock: &Clock,
    ctx: &mut TxContext,
): (Params, String) {
    let key = ctx.fresh_object_address().to_string();
    let params = new_params(key, description, execution_times, expiration_time, clock, ctx);

    (params, key)
}

public fun add_action<Outcome, Action: store, IW: drop>(
    intent: &mut Intent<Outcome>,
    action: Action,
    intent_witness: IW,
) {
    intent.assert_is_witness(intent_witness);

    let idx = intent.actions().length();
    intent.actions_mut().add(idx, action);
}

public fun remove_action<Action: store>(
    expired: &mut Expired, 
): Action {
    let idx = expired.start_index;
    expired.start_index = idx + 1;

    expired.actions.remove(idx)
}

public use fun destroy_empty_expired as Expired.destroy_empty;
public fun destroy_empty_expired(expired: Expired) {
    let Expired { actions, .. } = expired;
    assert!(actions.is_empty(), EActionsNotEmpty);
    actions.destroy_empty();
}

// === View functions ===

public use fun params_key as Params.key;
public fun params_key(params: &Params): String {
    params.id.df_borrow<_, ParamsFieldsV1>(true).key
}

public use fun params_description as Params.description;
public fun params_description(params: &Params): String {
    params.id.df_borrow<_, ParamsFieldsV1>(true).description
}

public use fun params_creation_time as Params.creation_time;
public fun params_creation_time(params: &Params): u64 {
    params.id.df_borrow<_, ParamsFieldsV1>(true).creation_time
}

public use fun params_execution_times as Params.execution_times;
public fun params_execution_times(params: &Params): vector<u64> {
    params.id.df_borrow<_, ParamsFieldsV1>(true).execution_times
}

public use fun params_expiration_time as Params.expiration_time;
public fun params_expiration_time(params: &Params): u64 {
    params.id.df_borrow<_, ParamsFieldsV1>(true).expiration_time
}

public fun length(intents: &Intents): u64 {
    intents.inner.length()
}

public fun locked(intents: &Intents): &VecSet<ID> {
    &intents.locked
}

public fun contains(intents: &Intents, key: String): bool {
    intents.inner.contains(key)
}

public fun get<Outcome: store>(intents: &Intents, key: String): &Intent<Outcome> {
    assert!(intents.inner.contains(key), EIntentNotFound);
    intents.inner.borrow(key)
}

public fun get_mut<Outcome: store>(intents: &mut Intents, key: String): &mut Intent<Outcome> {
    assert!(intents.inner.contains(key), EIntentNotFound);
    intents.inner.borrow_mut(key)
}

public fun type_<Outcome>(intent: &Intent<Outcome>): TypeName {
    intent.type_
}

public fun key<Outcome>(intent: &Intent<Outcome>): String {
    intent.key
}

public fun description<Outcome>(intent: &Intent<Outcome>): String {
    intent.description
}

public fun account<Outcome>(intent: &Intent<Outcome>): address {
    intent.account
}

public fun creator<Outcome>(intent: &Intent<Outcome>): address {
    intent.creator
}

public fun creation_time<Outcome>(intent: &Intent<Outcome>): u64 {
    intent.creation_time
}

public fun execution_times<Outcome>(intent: &Intent<Outcome>): vector<u64> {
    intent.execution_times
}

public fun expiration_time<Outcome>(intent: &Intent<Outcome>): u64 {
    intent.expiration_time
}

public fun role<Outcome>(intent: &Intent<Outcome>): String {
    intent.role
}

public fun actions<Outcome>(intent: &Intent<Outcome>): &Bag {
    &intent.actions
}

public fun actions_mut<Outcome>(intent: &mut Intent<Outcome>): &mut Bag {
    &mut intent.actions
}

public fun outcome<Outcome>(intent: &Intent<Outcome>): &Outcome {
    &intent.outcome
}

public fun outcome_mut<Outcome>(intent: &mut Intent<Outcome>): &mut Outcome {
    &mut intent.outcome
}

public use fun expired_account as Expired.account;
public fun expired_account(expired: &Expired): address {
    expired.account
}

public use fun expired_start_index as Expired.start_index;
public fun expired_start_index(expired: &Expired): u64 {
    expired.start_index
}

public use fun expired_actions as Expired.actions;
public fun expired_actions(expired: &Expired): &Bag {
    &expired.actions
}

public fun assert_is_account<Outcome>(
    intent: &Intent<Outcome>,
    account_addr: address,
) {
    assert!(intent.account == account_addr, EWrongAccount);
}

public fun assert_is_witness<Outcome, IW: drop>(
    intent: &Intent<Outcome>,
    _: IW,
) {
    assert!(intent.type_ == type_name::get<IW>(), EWrongWitness);
}

public use fun assert_expired_is_account as Expired.assert_is_account;
public fun assert_expired_is_account(expired: &Expired, account_addr: address) {
    assert!(expired.account == account_addr, EWrongAccount);
}

public fun assert_single_execution(params: &Params) {
    assert!(
        params.id.df_borrow<_, ParamsFieldsV1>(true).execution_times.length() == 1, 
        ESingleExecution
    );
}

// === Package functions ===

/// The following functions are only used in the `account` module

public(package) fun empty(ctx: &mut TxContext): Intents {
    Intents { inner: bag::new(ctx), locked: vec_set::empty() }
}

public(package) fun new_intent<Outcome, IW: drop>(
    params: Params,
    outcome: Outcome,
    managed_name: String,
    account_addr: address,
    _intent_witness: IW,
    ctx: &mut TxContext
): Intent<Outcome> {
    let Params { mut id } = params;
    
    let ParamsFieldsV1 { 
        key, 
        description, 
        creation_time, 
        execution_times, 
        expiration_time 
    } = id.df_remove(true);
    id.delete();

    Intent<Outcome> { 
        type_: type_name::get<IW>(),
        key,
        description,
        account: account_addr,
        creator: ctx.sender(),
        creation_time,
        execution_times,
        expiration_time,
        role: new_role<IW>(managed_name),
        actions: bag::new(ctx),
        outcome,
    }
}

public(package) fun add_intent<Outcome: store>(
    intents: &mut Intents,
    intent: Intent<Outcome>,
) {
    assert!(!intents.contains(intent.key), EKeyAlreadyExists);
    intents.inner.add(intent.key, intent);
}

public(package) fun remove_intent<Outcome: store>(
    intents: &mut Intents,
    key: String,
): Intent<Outcome> {
    assert!(intents.contains(key), EIntentNotFound);
    intents.inner.remove(key)
}

public(package) fun pop_front_execution_time<Outcome>(
    intent: &mut Intent<Outcome>,
): u64 {
    intent.execution_times.remove(0)
}

public(package) fun lock(intents: &mut Intents, id: ID) {
    assert!(!intents.locked.contains(&id), EObjectAlreadyLocked);
    intents.locked.insert(id);
}

public(package) fun unlock(intents: &mut Intents, id: ID) {
    assert!(intents.locked.contains(&id), EObjectNotLocked);
    intents.locked.remove(&id);
}

/// Removes an intent being executed if the execution_time is reached
/// Outcome must be validated in AccountMultisig to be destroyed
public(package) fun destroy_intent<Outcome: store + drop>(
    intents: &mut Intents,
    key: String,
): Expired {
    let Intent<Outcome> { account, actions, .. } = intents.inner.remove(key);
    
    Expired { account, start_index: 0, actions }
}

// === Private functions ===

fun new_role<IW: drop>(managed_name: String): String {
    let intent_type = type_name::get<IW>();
    let mut role = intent_type.get_address().to_string();
    role.append_utf8(b"::");
    role.append(intent_type.get_module().to_string());

    if (!managed_name.is_empty()) {
        role.append_utf8(b"::");
        role.append(managed_name);
    };

    role
}

//**************************************************************************************************//
// Tests                                                                                            //
//**************************************************************************************************//

#[test_only]
use sui::test_utils::{assert_eq, destroy};
#[test_only]
use sui::clock;

#[test_only]
public struct TestOutcome has copy, drop, store {}
#[test_only]
public struct TestAction has store {}
#[test_only]
public struct TestIntentWitness() has drop;
#[test_only]
public struct WrongWitness() has drop;

#[test]
fun test_new_params() {
    let ctx = &mut tx_context::dummy();
    let clock = clock::create_for_testing(ctx);
    
    let params = new_params(
        b"test_key".to_string(),
        b"test_description".to_string(),
        vector[1000],
        2000,
        &clock,
        ctx
    );
    
    assert_eq(params.key(), b"test_key".to_string());
    assert_eq(params.description(), b"test_description".to_string());
    assert_eq(params.execution_times(), vector[1000]);
    assert_eq(params.expiration_time(), 2000);
    assert_eq(params.creation_time(), 0);
    
    destroy(params);
    destroy(clock);
}

#[test]
fun test_new_params_with_rand_key() {
    let ctx = &mut tx_context::dummy();
    let clock = clock::create_for_testing(ctx);
    
    let (params, key) = new_params_with_rand_key(
        b"test_description".to_string(),
        vector[1000],
        2000,
        &clock,
        ctx
    );
    
    assert_eq(params.key(), key);
    assert_eq(params.description(), b"test_description".to_string());
    assert_eq(params.execution_times(), vector[1000]);
    assert_eq(params.expiration_time(), 2000);
    
    destroy(params);
    destroy(clock);
}

#[test, expected_failure(abort_code = ENoExecutionTime)]
fun test_new_params_empty_execution_times() {
    let ctx = &mut tx_context::dummy();
    let clock = clock::create_for_testing(ctx);
    
    let params = new_params(
        b"test_key".to_string(),
        b"test_description".to_string(),
        vector[],
        2000,
        &clock,
        ctx
    );
    destroy(params);
    destroy(clock);
}

#[test, expected_failure(abort_code = EExecutionTimesNotAscending)]
fun test_new_params_not_ascending_execution_times() {
    let ctx = &mut tx_context::dummy();
    let clock = clock::create_for_testing(ctx);
    
    let params = new_params(
        b"test_key".to_string(),
        b"test_description".to_string(),
        vector[2000, 1000],
        3000,
        &clock,
        ctx
    );
    destroy(params);
    destroy(clock);
}

#[test]
fun test_new_intent() {
    let ctx = &mut tx_context::dummy();
    let clock = clock::create_for_testing(ctx);
    
    let params = new_params(
        b"test_key".to_string(),
        b"test_description".to_string(),
        vector[1000],
        2000,
        &clock,
        ctx
    );
    
    let intent = new_intent(
        params,
        TestOutcome {},
        b"test_role".to_string(),
        @0xCAFE,
        TestIntentWitness(),
        ctx
    );
    
    assert_eq(intent.key(), b"test_key".to_string());
    assert_eq(intent.description(), b"test_description".to_string());
    assert_eq(intent.account(), @0xCAFE);
    assert_eq(intent.creation_time(), clock.timestamp_ms());
    assert_eq(intent.execution_times(), vector[1000]);
    assert_eq(intent.expiration_time(), 2000);
    assert_eq(intent.actions().length(), 0);
    
    destroy(intent);
    destroy(clock);
}

#[test]
fun test_add_action() {
    let ctx = &mut tx_context::dummy();
    let clock = clock::create_for_testing(ctx);
    
    let params = new_params(
        b"test_key".to_string(),
        b"test_description".to_string(),
        vector[1000],
        2000,
        &clock,
        ctx
    );
    
    let mut intent = new_intent(
        params,
        TestOutcome {},
        b"test_role".to_string(),
        @0xCAFE,
        TestIntentWitness(),
        ctx
    );
    
    add_action(&mut intent, TestAction {}, TestIntentWitness());
    assert_eq(intent.actions().length(), 1);
    
    add_action(&mut intent, TestAction {}, TestIntentWitness());
    assert_eq(intent.actions().length(), 2);
    
    destroy(intent);
    destroy(clock);
}

#[test]
fun test_remove_action() {
    let ctx = &mut tx_context::dummy();
    let clock = clock::create_for_testing(ctx);
    let mut intents = empty(ctx);
    
    let params = new_params(
        b"test_key".to_string(),
        b"test_description".to_string(),
        vector[1000],
        2000,
        &clock,
        ctx
    );
    
    let mut intent = new_intent(
        params,
        TestOutcome {},
        b"test_role".to_string(),
        @0xCAFE,
        TestIntentWitness(),
        ctx
    );
    
    add_action(&mut intent, TestAction {}, TestIntentWitness());
    add_action(&mut intent, TestAction {}, TestIntentWitness());
    add_intent(&mut intents, intent);
    
    let mut expired = intents.destroy_intent<TestOutcome>(b"test_key".to_string());
    
    let action1: TestAction = remove_action(&mut expired);
    let action2: TestAction = remove_action(&mut expired);
    
    assert_eq(expired.start_index, 2);
    assert_eq(expired.actions().length(), 0);
    
    expired.destroy_empty();
    destroy(intents);
    destroy(clock);
    destroy(action1);
    destroy(action2);
}

#[test]
fun test_empty_intents() {
    let ctx = &mut tx_context::dummy();
    let intents = empty(ctx);
    
    assert_eq(length(&intents), 0);
    assert_eq(locked(&intents).size(), 0);
    assert!(!contains(&intents, b"test_key".to_string()));
    
    destroy(intents);
}

#[test]
fun test_add_and_remove_intent() {
    let ctx = &mut tx_context::dummy();
    let clock = clock::create_for_testing(ctx);
    let mut intents = empty(ctx);
    
    let params = new_params(
        b"test_key".to_string(),
        b"test_description".to_string(),
        vector[1000],
        2000,
        &clock,
        ctx
    );
    
    let intent = new_intent(
        params,
        TestOutcome {},
        b"test_role".to_string(),
        @0xCAFE,
        TestIntentWitness(),
        ctx
    );
    
    add_intent(&mut intents, intent);
    assert_eq(length(&intents), 1);
    assert!(contains(&intents, b"test_key".to_string()));
    
    let removed_intent = remove_intent<TestOutcome>(&mut intents, b"test_key".to_string());
    assert_eq(length(&intents), 0);
    assert!(!contains(&intents, b"test_key".to_string()));
    
    destroy(removed_intent);
    destroy(intents);
    destroy(clock);
}

#[test, expected_failure(abort_code = EKeyAlreadyExists)]
fun test_add_duplicate_intent() {
    let ctx = &mut tx_context::dummy();
    let clock = clock::create_for_testing(ctx);
    let mut intents = empty(ctx);
    
    let params1 = new_params(
        b"test_key".to_string(),
        b"test_description".to_string(),
        vector[1000],
        2000,
        &clock,
        ctx
    );
    
    let params2 = new_params(
        b"test_key".to_string(),
        b"test_description2".to_string(),
        vector[1000],
        2000,
        &clock,
        ctx
    );
    
    let intent1 = new_intent(
        params1,
        TestOutcome {},
        b"test_role".to_string(),
        @0xCAFE,
        TestIntentWitness(),
        ctx
    );
    
    let intent2 = new_intent(
        params2,
        TestOutcome {},
        b"test_role".to_string(),
        @0xCAFE,
        TestIntentWitness(),
        ctx
    );
    
    add_intent(&mut intents, intent1);
    add_intent(&mut intents, intent2);
    
    destroy(intents);
    destroy(clock);
}

#[test, expected_failure(abort_code = EIntentNotFound)]
fun test_remove_nonexistent_intent() {
    let ctx = &mut tx_context::dummy();
    let mut intents = empty(ctx);
    
    let removed_intent = remove_intent<TestOutcome>(&mut intents, b"nonexistent_key".to_string());
    
    destroy(removed_intent);
    destroy(intents);
}

#[test]
fun test_lock_and_unlock_object() {
    let ctx = &mut tx_context::dummy();
    let mut intents = empty(ctx);
    let object_id = tx_context::fresh_object_address(ctx).to_id();
    
    assert!(!locked(&intents).contains(&object_id));
    
    lock(&mut intents, object_id);
    assert!(locked(&intents).contains(&object_id));
    
    unlock(&mut intents, object_id);
    assert!(!locked(&intents).contains(&object_id));
    
    destroy(intents);
}

#[test, expected_failure(abort_code = EObjectAlreadyLocked)]
fun test_lock_already_locked_object() {
    let ctx = &mut tx_context::dummy();
    let mut intents = empty(ctx);
    let object_id = tx_context::fresh_object_address(ctx).to_id();
    
    lock(&mut intents, object_id);
    lock(&mut intents, object_id);
    
    destroy(intents);
}

#[test, expected_failure(abort_code = EObjectNotLocked)]
fun test_unlock_not_locked_object() {
    let ctx = &mut tx_context::dummy();
    let mut intents = empty(ctx);
    let object_id = tx_context::fresh_object_address(ctx).to_id();
    
    unlock(&mut intents, object_id);
    
    destroy(intents);
}

#[test]
fun test_pop_front_execution_time() {
    let ctx = &mut tx_context::dummy();
    let clock = clock::create_for_testing(ctx);
    
    let params = new_params(
        b"test_key".to_string(),
        b"test_description".to_string(),
        vector[1000, 2000, 3000],
        4000,
        &clock,
        ctx
    );
    
    let mut intent = new_intent(
        params,
        TestOutcome {},
        b"test_role".to_string(),
        @0xCAFE,
        TestIntentWitness(),
        ctx
    );
    
    assert_eq(intent.execution_times(), vector[1000, 2000, 3000]);
    
    let time1 = pop_front_execution_time(&mut intent);
    assert_eq(time1, 1000);
    assert_eq(intent.execution_times(), vector[2000, 3000]);
    
    let time2 = pop_front_execution_time(&mut intent);
    assert_eq(time2, 2000);
    assert_eq(intent.execution_times(), vector[3000]);
    
    destroy(intent);
    destroy(clock);
}

#[test]
fun test_assert_is_account() {
    let ctx = &mut tx_context::dummy();
    let clock = clock::create_for_testing(ctx);
    
    let params = new_params(
        b"test_key".to_string(),
        b"test_description".to_string(),
        vector[1000],
        2000,
        &clock,
        ctx
    );
    
    let intent = new_intent(
        params,
        TestOutcome {},
        b"test_role".to_string(),
        @0xCAFE,
        TestIntentWitness(),
        ctx
    );
    
    // Should not abort
    assert_is_account(&intent, @0xCAFE);
    
    destroy(intent);
    destroy(clock);
}

#[test, expected_failure(abort_code = EWrongAccount)]
fun test_assert_is_account_wrong() {
    let ctx = &mut tx_context::dummy();
    let clock = clock::create_for_testing(ctx);
    
    let params = new_params(
        b"test_key".to_string(),
        b"test_description".to_string(),
        vector[1000],
        2000,
        &clock,
        ctx
    );
    
    let intent = new_intent(
        params,
        TestOutcome {},
        b"test_role".to_string(),
        @0xCAFE,
        TestIntentWitness(),
        ctx
    );
    
    assert_is_account(&intent, @0xBAD);
    
    destroy(intent);
    destroy(clock);
}

#[test]
fun test_assert_is_witness() {
    let ctx = &mut tx_context::dummy();
    let clock = clock::create_for_testing(ctx);
    
    let params = new_params(
        b"test_key".to_string(),
        b"test_description".to_string(),
        vector[1000],
        2000,
        &clock,
        ctx
    );
    
    let intent = new_intent(
        params,
        TestOutcome {},
        b"test_role".to_string(),
        @0xCAFE,
        TestIntentWitness(),
        ctx
    );
    
    // Should not abort
    assert_is_witness(&intent, TestIntentWitness());
    
    destroy(intent);
    destroy(clock);
}

#[test, expected_failure(abort_code = EWrongWitness)]
fun test_assert_is_witness_wrong() {
    let ctx = &mut tx_context::dummy();
    let clock = clock::create_for_testing(ctx);
    
    let params = new_params(
        b"test_key".to_string(),
        b"test_description".to_string(),
        vector[1000],
        2000,
        &clock,
        ctx
    );
    
    let intent = new_intent(
        params,
        TestOutcome {},
        b"test_role".to_string(),
        @0xCAFE,
        TestIntentWitness(),
        ctx
    );
    
    assert_is_witness(&intent, WrongWitness());
    
    destroy(intent);
    destroy(clock);
}

#[test]
fun test_assert_single_execution() {
    let ctx = &mut tx_context::dummy();
    let clock = clock::create_for_testing(ctx);
    
    let params = new_params(
        b"test_key".to_string(),
        b"test_description".to_string(),
        vector[1000],
        2000,
        &clock,
        ctx
    );
    
    // Should not abort
    assert_single_execution(&params);
    
    destroy(params);
    destroy(clock);
}

#[test, expected_failure(abort_code = ESingleExecution)]
fun test_assert_single_execution_multiple() {
    let ctx = &mut tx_context::dummy();
    let clock = clock::create_for_testing(ctx);
    
    let params = new_params(
        b"test_key".to_string(),
        b"test_description".to_string(),
        vector[1000, 2000],
        3000,
        &clock,
        ctx
    );
    
    assert_single_execution(&params);
    
    destroy(params);
    destroy(clock);
}/// The Executable struct is hot potato constructed from an Intent that has been resolved.
/// It ensures that the actions are executed as intended as it can't be stored.
/// Action index is tracked to ensure each action is executed exactly once.

module account_protocol::executable;

// === Imports ===

use account_protocol::intents::Intent;

// === Structs ===

/// Hot potato ensuring the actions in the intent are executed as intended.
public struct Executable<Outcome: store> {
    // intent to return or destroy (if execution_times empty) after execution
    intent: Intent<Outcome>,
    // current action index
    action_idx: u64,
}

// === View functions ===

/// Returns the issuer of the corresponding intent
public fun intent<Outcome: store>(executable: &Executable<Outcome>): &Intent<Outcome> {
    &executable.intent
}

/// Returns the current action index
public fun action_idx<Outcome: store>(executable: &Executable<Outcome>): u64 {
    executable.action_idx
}

public fun contains_action<Outcome: store, Action: store>(
    executable: &mut Executable<Outcome>,
): bool {
    let actions_length = executable.intent().actions().length();
    let mut contains = false;
    
    actions_length.do!(|i| {
        if (executable.intent.actions().contains_with_type<u64, Action>(i)) contains = true;
    });

    contains
}

public fun next_action<Outcome: store, Action: store, IW: drop>(
    executable: &mut Executable<Outcome>,
    intent_witness: IW,
): &Action {
    executable.intent.assert_is_witness(intent_witness);

    let action_idx = executable.action_idx;
    executable.action_idx = executable.action_idx + 1;
    
    executable.intent().actions().borrow(action_idx)
}

// === Package functions ===

public(package) fun new<Outcome: store>(intent: Intent<Outcome>): Executable<Outcome> {
    Executable { intent, action_idx: 0 }
}

public(package) fun destroy<Outcome: store>(executable: Executable<Outcome>): Intent<Outcome> {
    let Executable { intent, .. } = executable;
    intent
}

//**************************************************************************************************//
// Tests                                                                                            //
//**************************************************************************************************//

#[test_only]
use sui::test_utils::{assert_eq, destroy as test_destroy};
#[test_only]
use sui::clock;
#[test_only]
use account_protocol::intents;

#[test_only]
public struct TestOutcome has copy, drop, store {}
#[test_only]
public struct TestAction has store {}
#[test_only]
public struct TestIntentWitness() has drop;

#[test]
fun test_new_executable() {
    let ctx = &mut tx_context::dummy();
    let clock = clock::create_for_testing(ctx);
    
    let params = intents::new_params(
        b"test_key".to_string(),
        b"test_description".to_string(),
        vector[1000],
        2000,
        &clock,
        ctx
    );
    
    let intent = intents::new_intent(
        params,
        TestOutcome {},
        b"test_role".to_string(),
        @0xCAFE,
        TestIntentWitness(),
        ctx
    );
    
    let executable = new(intent);
    
    assert_eq(action_idx(&executable), 0);
    assert_eq(intent(&executable).key(), b"test_key".to_string());
    
    test_destroy(executable);
    test_destroy(clock);
}

#[test]
fun test_next_action() {
    let ctx = &mut tx_context::dummy();
    let clock = clock::create_for_testing(ctx);
    
    let params = intents::new_params(
        b"test_key".to_string(),
        b"test_description".to_string(),
        vector[1000],
        2000,
        &clock,
        ctx
    );
    
    let mut intent = intents::new_intent(
        params,
        TestOutcome {},
        b"test_role".to_string(),
        @0xCAFE,
        TestIntentWitness(),
        ctx
    );
    
    intents::add_action(&mut intent, TestAction {}, TestIntentWitness());
    intents::add_action(&mut intent, TestAction {}, TestIntentWitness());
    
    let mut executable = new(intent);
    
    assert_eq(action_idx(&executable), 0);
    
    let _action1: &TestAction = next_action(&mut executable, TestIntentWitness());
    assert_eq(action_idx(&executable), 1);
    
    let _action2: &TestAction = next_action(&mut executable, TestIntentWitness());
    assert_eq(action_idx(&executable), 2);
    
    test_destroy(executable);
    test_destroy(clock);
}

#[test]
fun test_contains_action() {
    let ctx = &mut tx_context::dummy();
    let clock = clock::create_for_testing(ctx);
    
    let params = intents::new_params(
        b"test_key".to_string(),
        b"test_description".to_string(),
        vector[1000],
        2000,
        &clock,
        ctx
    );
    
    let mut intent = intents::new_intent(
        params,
        TestOutcome {},
        b"test_role".to_string(),
        @0xCAFE,
        TestIntentWitness(),
        ctx
    );
    
    intents::add_action(&mut intent, TestAction {}, TestIntentWitness());
    
    let mut executable = new(intent);
    
    assert!(contains_action<_, TestAction>(&mut executable));
    
    test_destroy(executable);
    test_destroy(clock);
}

#[test]
fun test_contains_action_empty() {
    let ctx = &mut tx_context::dummy();
    let clock = clock::create_for_testing(ctx);
    
    let params = intents::new_params(
        b"test_key".to_string(),
        b"test_description".to_string(),
        vector[1000],
        2000,
        &clock,
        ctx
    );
    
    let intent = intents::new_intent(
        params,
        TestOutcome {},
        b"test_role".to_string(),
        @0xCAFE,
        TestIntentWitness(),
        ctx
    );
    
    let mut executable = new(intent);
    
    assert!(!contains_action<_, TestAction>(&mut executable));
    
    test_destroy(executable);
    test_destroy(clock);
}

#[test]
fun test_destroy_executable() {
    let ctx = &mut tx_context::dummy();
    let clock = clock::create_for_testing(ctx);
    
    let params = intents::new_params(
        b"test_key".to_string(),
        b"test_description".to_string(),
        vector[1000],
        2000,
        &clock,
        ctx
    );
    
    let intent = intents::new_intent(
        params,
        TestOutcome {},
        b"test_role".to_string(),
        @0xCAFE,
        TestIntentWitness(),
        ctx
    );
    
    let executable = new(intent);
    let recovered_intent = destroy(executable);
    
    assert_eq(recovered_intent.key(), b"test_key".to_string());
    assert_eq(recovered_intent.description(), b"test_description".to_string());
    
    test_destroy(recovered_intent);
    test_destroy(clock);
}

#[test]
fun test_executable_with_multiple_actions() {
    let ctx = &mut tx_context::dummy();
    let clock = clock::create_for_testing(ctx);
    
    let params = intents::new_params(
        b"test_key".to_string(),
        b"test_description".to_string(),
        vector[1000],
        2000,
        &clock,
        ctx
    );
    
    let mut intent = intents::new_intent(
        params,
        TestOutcome {},
        b"test_role".to_string(),
        @0xCAFE,
        TestIntentWitness(),
        ctx
    );
    
    // Add multiple actions
    intents::add_action(&mut intent, TestAction {}, TestIntentWitness());
    intents::add_action(&mut intent, TestAction {}, TestIntentWitness());
    intents::add_action(&mut intent, TestAction {}, TestIntentWitness());
    
    let mut executable = new(intent);
    
    assert_eq(action_idx(&executable), 0);
    assert_eq(intent(&executable).actions().length(), 3);
    
    // Execute all actions
    let _action1: &TestAction = next_action(&mut executable, TestIntentWitness());
    let _action2: &TestAction = next_action(&mut executable, TestIntentWitness());
    let _action3: &TestAction = next_action(&mut executable, TestIntentWitness());
    
    assert_eq(action_idx(&executable), 3);
    
    test_destroy(executable);
    test_destroy(clock);
}

#[test]
fun test_intent_access() {
    let ctx = &mut tx_context::dummy();
    let clock = clock::create_for_testing(ctx);
    
    let params = intents::new_params(
        b"test_key".to_string(),
        b"test_description".to_string(),
        vector[1000],
        2000,
        &clock,
        ctx
    );
    
    let intent = intents::new_intent(
        params,
        TestOutcome {},
        b"test_role".to_string(),
        @0xCAFE,
        TestIntentWitness(),
        ctx
    );
    
    let executable = new(intent);
    let intent_ref = intent(&executable);
    
    assert_eq(intent_ref.key(), b"test_key".to_string());
    assert_eq(intent_ref.description(), b"test_description".to_string());
    assert_eq(intent_ref.account(), @0xCAFE);
    let mut role = @account_protocol.to_string();
    role.append_utf8(b"::executable");
    role.append_utf8(b"::test_role");
    assert_eq(intent_ref.role(), role);
    
    test_destroy(executable);
    test_destroy(clock);
}

/// This module manages the metadata field of Account.
/// It provides the interface to create and get the fields of a Metadata struct.

module account_protocol::metadata;

// === Imports ===

use std::string::String;
use sui::vec_map::{Self, VecMap};

// === Errors ===

const EMetadataNotSameLength: u64 = 0;

// === Structs ===

/// Parent struct protecting the metadata
public struct Metadata has copy, drop, store {
    inner: VecMap<String, String>
}

// === Public functions ===

/// Creates an empty Metadata struct
public fun empty(): Metadata {
    Metadata { inner: vec_map::empty() }
}

/// Creates a new Metadata struct from keys and values.
public fun from_keys_values(keys: vector<String>, values: vector<String>): Metadata {
    assert!(keys.length() == values.length(), EMetadataNotSameLength);
    Metadata {
        inner: vec_map::from_keys_values(keys, values)
    }
}

/// Gets the value for the key.
public fun get(metadata: &Metadata, key: String): String {
    *metadata.inner.get(&key)
}

/// Gets the entry at the index.
public fun get_entry_by_idx(metadata: &Metadata, idx: u64): (String, String) {
    let (key, value) = metadata.inner.get_entry_by_idx(idx);
    (*key, *value)
}

/// Returns the number of entries.
public fun size(metadata: &Metadata): u64 {
    metadata.inner.size()
}

//**************************************************************************************************//
// Tests                                                                                            //
//**************************************************************************************************//

// === Test Helpers ===

#[test_only]
use sui::test_utils::{assert_eq, destroy};

// === Unit Tests ===

#[test]
fun test_empty() {
    let metadata = empty();
    assert_eq(size(&metadata), 0);
    destroy(metadata);
}

#[test]
fun test_from_keys_values() {
    let keys = vector[b"key1".to_string(), b"key2".to_string()];
    let values = vector[b"value1".to_string(), b"value2".to_string()];
    
    let metadata = from_keys_values(keys, values);
    assert_eq(size(&metadata), 2);
    assert_eq(get(&metadata, b"key1".to_string()), b"value1".to_string());
    assert_eq(get(&metadata, b"key2".to_string()), b"value2".to_string());
    
    destroy(metadata);
}

#[test, expected_failure(abort_code = EMetadataNotSameLength)]
fun test_from_keys_values_different_lengths() {
    let keys = vector[b"key1".to_string(), b"key2".to_string()];
    let values = vector[b"value1".to_string()];
    
    let metadata = from_keys_values(keys, values);
    destroy(metadata);
}

#[test]
fun test_get() {
    let keys = vector[b"test_key".to_string()];
    let values = vector[b"test_value".to_string()];
    
    let metadata = from_keys_values(keys, values);
    let value = get(&metadata, b"test_key".to_string());
    assert_eq(value, b"test_value".to_string());
    
    destroy(metadata);
}

#[test]
fun test_get_entry_by_idx() {
    let keys = vector[b"key1".to_string(), b"key2".to_string()];
    let values = vector[b"value1".to_string(), b"value2".to_string()];
    
    let metadata = from_keys_values(keys, values);
    
    let (key1, value1) = get_entry_by_idx(&metadata, 0);
    let (key2, value2) = get_entry_by_idx(&metadata, 1);
    
    assert_eq(key1, b"key1".to_string());
    assert_eq(value1, b"value1".to_string());
    assert_eq(key2, b"key2".to_string());
    assert_eq(value2, b"value2".to_string());
    
    destroy(metadata);
}

#[test]
fun test_size() {
    let metadata = empty();
    assert_eq(size(&metadata), 0);
    
    let keys = vector[b"key1".to_string()];
    let values = vector[b"value1".to_string()];
    let metadata2 = from_keys_values(keys, values);
    assert_eq(size(&metadata2), 1);
    
    destroy(metadata);
    destroy(metadata2);
}

#[test]
fun test_multiple_entries() {
    let keys = vector[b"name".to_string(), b"description".to_string(), b"version".to_string()];
    let values = vector[b"Test Account".to_string(), b"A test account".to_string(), b"1.0".to_string()];
    
    let metadata = from_keys_values(keys, values);
    assert_eq(size(&metadata), 3);
    assert_eq(get(&metadata, b"name".to_string()), b"Test Account".to_string());
    assert_eq(get(&metadata, b"description".to_string()), b"A test account".to_string());
    assert_eq(get(&metadata, b"version".to_string()), b"1.0".to_string());
    
    destroy(metadata);
}/// This module tracks the version of the package by implementing the version_witness type.
/// A new version type should be defined for each new version of the package.

module account_protocol::version;

// === Imports ===

use account_protocol::version_witness::{Self, VersionWitness};

// === Constants ===

const VERSION: u64 = 1; // bump this when the package is upgraded

// === Structs ===

// define a new version struct for each new version of the package
public struct V1() has drop;

public(package) fun current(): VersionWitness {
    version_witness::new(V1()) // modify with the new version struct
}

// === Public functions ===

public fun get(): u64 {
    VERSION
}

// === Test functions ===

#[test_only]
public struct Witness() has drop;

#[test_only]
public fun witness(): Witness {
    Witness()
}

#[test]
public fun test_get() {
    assert!(get() == 1, 1);
}/// This module allows objects owned by the account to be accessed through intents in a secure way.
/// The objects can be taken only via an WithdrawAction action which uses Transfer to Object (TTO).
/// This action can't be proposed directly since it wouldn't make sense to withdraw an object without using it.

module account_protocol::owned;

// === Imports ===

use sui::{
    coin::{Self, Coin},
    transfer::Receiving
};
use account_protocol::{
    account::{Account, Auth},
    intents::{Expired, Intent},
    executable::Executable,
};

// === Errors ===

const EWrongObject: u64 = 0;
const EObjectLocked: u64 = 1;

// === Structs ===

/// Action guarding access to account owned objects which can only be received via this action
public struct WithdrawAction has store {
    // the owned object we want to access
    object_id: ID,
}

// === Public functions ===

/// Creates a new WithdrawAction and add it to an intent
public fun new_withdraw<Config, Outcome, IW: drop>(
    intent: &mut Intent<Outcome>, 
    account: &mut Account<Config>,
    object_id: ID,
    intent_witness: IW,
) {
    intent.assert_is_account(account.addr());
    
    account.lock_object(object_id);
    intent.add_action(WithdrawAction { object_id }, intent_witness);
}

/// Executes a WithdrawAction and returns the object
public fun do_withdraw<Config, Outcome: store, T: key + store, IW: drop>(
    executable: &mut Executable<Outcome>,
    account: &mut Account<Config>,  
    receiving: Receiving<T>,
    intent_witness: IW,
): T {    
    executable.intent().assert_is_account(account.addr());

    let action: &WithdrawAction = executable.next_action(intent_witness);
    assert!(receiving.receiving_object_id() == action.object_id, EWrongObject);

    account.receive(receiving)
}

/// Deletes a WithdrawAction from an expired intent
public fun delete_withdraw<Config>(expired: &mut Expired, account: &mut Account<Config>) {
    expired.assert_is_account(account.addr());

    let WithdrawAction { object_id } = expired.remove_action();
    account.unlock_object(object_id);
}

// Coin operations

/// Authorized addresses can merge and split coins.
/// Returns the IDs to use in a following intent, conserves the order.
public fun merge_and_split<Config, CoinType>(
    auth: Auth, 
    account: &mut Account<Config>, 
    to_merge: vector<Receiving<Coin<CoinType>>>, // there can be only one coin if we just want to split
    to_split: vector<u64>, // there can be no amount if we just want to merge
    ctx: &mut TxContext
): vector<ID> { 
    account.verify(auth);
    // receive all coins
    let mut coins = vector::empty();
    to_merge.do!(|item| {
        let coin = account.receive(item);
        coins.push_back(coin);
    });

    let coin = merge(account, coins, ctx);
    let ids = split(account, coin, to_split, ctx);

    ids
}

fun merge<Config, CoinType>(
    account: &Account<Config>,
    coins: vector<Coin<CoinType>>, 
    ctx: &mut TxContext
): Coin<CoinType> {
    let mut merged = coin::zero<CoinType>(ctx);
    coins.do!(|coin| {
        assert!(!account.intents().locked().contains(&object::id(&coin)), EObjectLocked);
        merged.join(coin);
    });

    merged
}

fun split<Config, CoinType>(
    account: &Account<Config>, 
    mut coin: Coin<CoinType>,
    amounts: vector<u64>, 
    ctx: &mut TxContext
): vector<ID> {
    // never throws as long as the function is called from merge_and_split only
    assert!(!account.intents().locked().contains(&object::id(&coin)), EObjectLocked);

    let ids = amounts.map!(|amount| {
        let split = coin.split(amount, ctx);
        let id = object::id(&split);
        account.keep(split);
        id
    });
    account.keep(coin);

    ids
}
/// This module allows to manage Account settings.
/// The actions are related to the modifications of all the fields of the Account (except Intents and Config).
/// All these fields are encapsulated in the `Account` struct and each managed in their own module.
/// They are only accessible mutably via package functions defined in account.move which are used here only.
/// 
/// Dependencies are all the packages and their versions that the account can call (including this one).
/// The allowed dependencies are defined in the `Extensions` struct and are maintained by account.tech team.
/// Optionally, any package can be added to the account if unverified_allowed is true.
/// 
/// Accounts can choose to use any version of any package and must explicitly migrate to the new version.
/// This is closer to a trustless model preventing anyone with the UpgradeCap from updating the dependencies maliciously.

module account_protocol::config;

// === Imports ===

use std::string::String;
use account_protocol::{
    account::{Account, Auth},
    intents::{Expired, Params},
    executable::Executable,
    deps::{Self, Dep},
    metadata,
    version,
    intent_interface,
};
use account_extensions::extensions::Extensions;

// === Aliases ===

use fun intent_interface::build_intent as Account.build_intent;
use fun intent_interface::process_intent as Account.process_intent;

// === Structs ===

/// Intent Witness
public struct ConfigDepsIntent() has drop;
/// Intent Witness
public struct ToggleUnverifiedAllowedIntent() has drop;

/// Action struct wrapping the deps account field into an action
public struct ConfigDepsAction has store {
    deps: vector<Dep>,
}
/// Action struct wrapping the unverified_allowed account field into an action
public struct ToggleUnverifiedAllowedAction has store {}

// === Public functions ===

/// Authorized addresses can edit the metadata of the account
public fun edit_metadata<Config>(
    auth: Auth,
    account: &mut Account<Config>,
    keys: vector<String>,
    values: vector<String>,
) {
    account.verify(auth);
    *account.metadata_mut(version::current()) = metadata::from_keys_values(keys, values);
}

/// Authorized addresses can update the existing dependencies of the account to the latest versions
public fun update_extensions_to_latest<Config>(
    auth: Auth,
    account: &mut Account<Config>,
    extensions: &Extensions,
) {
    account.verify(auth);

    let mut i = 0;
    let mut new_names = vector<String>[];
    let mut new_addrs = vector<address>[];
    let mut new_versions = vector<u64>[];

    while (i < account.deps().length()) {
        let dep = account.deps().get_by_idx(i);
        if (extensions.is_extension(dep.name(), dep.addr(), dep.version())) {
            let (addr, version) = extensions.get_latest_for_name(dep.name());
            new_names.push_back(dep.name());
            new_addrs.push_back(addr);
            new_versions.push_back(version);
        } else {
            // else cannot automatically update to latest version so add as is
            new_names.push_back(dep.name());
            new_addrs.push_back(dep.addr());
            new_versions.push_back(dep.version());
        };
        i = i + 1;
    };

    *account.deps_mut(version::current()).inner_mut() = 
        deps::new_inner(extensions, account.deps(), new_names, new_addrs, new_versions);
}

/// Creates an intent to update the dependencies of the account
public fun request_config_deps<Config, Outcome: store>(
    auth: Auth,
    account: &mut Account<Config>, 
    params: Params,
    outcome: Outcome,
    extensions: &Extensions,
    names: vector<String>,
    addresses: vector<address>,
    versions: vector<u64>,
    ctx: &mut TxContext
) {
    account.verify(auth);
    params.assert_single_execution();
    
    let deps = deps::new_inner(extensions, account.deps(), names, addresses, versions);

    account.build_intent!(
        params,
        outcome, 
        b"".to_string(),
        version::current(),
        ConfigDepsIntent(),   
        ctx,
        |intent, iw| intent.add_action(ConfigDepsAction { deps }, iw),
    );
}

/// Executes an intent updating the dependencies of the account
public fun execute_config_deps<Config, Outcome: store>(
    executable: &mut Executable<Outcome>,
    account: &mut Account<Config>,  
) {
    account.process_intent!(
        executable, 
        version::current(),   
        ConfigDepsIntent(), 
        |executable, iw| {
            let ConfigDepsAction { deps } = executable.next_action<_, ConfigDepsAction, _>(iw);
            *account.deps_mut(version::current()).inner_mut() = *deps;
        }
    ); 
} 

/// Deletes the ConfigDepsAction from an expired intent
public fun delete_config_deps(expired: &mut Expired) {
    let ConfigDepsAction { .. } = expired.remove_action();
}

/// Creates an intent to toggle the unverified_allowed flag of the account
public fun request_toggle_unverified_allowed<Config, Outcome: store>(
    auth: Auth,
    account: &mut Account<Config>, 
    params: Params,
    outcome: Outcome,
    ctx: &mut TxContext
) {
    account.verify(auth);
    params.assert_single_execution();
    
    account.build_intent!(
        params,
        outcome,
        b"".to_string(),
        version::current(),
        ToggleUnverifiedAllowedIntent(),
        ctx,
        |intent, iw| intent.add_action(ToggleUnverifiedAllowedAction {}, iw),
    );
}

/// Executes an intent toggling the unverified_allowed flag of the account
public fun execute_toggle_unverified_allowed<Config, Outcome: store>(
    executable: &mut Executable<Outcome>,
    account: &mut Account<Config>, 
) {
    account.process_intent!(
        executable, 
        version::current(),
        ToggleUnverifiedAllowedIntent(),
        |executable, iw| {
            let _action: &ToggleUnverifiedAllowedAction = executable.next_action(iw);
            account.deps_mut(version::current()).toggle_unverified_allowed()
        },
    );    
}

/// Deletes the ToggleUnverifiedAllowedAction from an expired intent
public fun delete_toggle_unverified_allowed(expired: &mut Expired) {
    let ToggleUnverifiedAllowedAction {} = expired.remove_action();
}

/// [Intent Interface] - Functions to create intents and add actions to them.
///
/// 1. Build an intent by stacking actions into it.
/// 2. Process an intent by executing the actions sequentially.

module account_protocol::intent_interface;

// === Imports ===

use std::string::String;
use account_protocol::{
    account::{Self, Account},
    intents::{Intent, Params},
    version_witness::VersionWitness,
    executable::Executable,
};

// === Public functions ===

/// Example implementation:
/// 
/// ```move
/// 
/// public fun request_intent_name<Config, Outcome: store>(
///     auth: Auth,
///     account: &mut Account<Config>, 
///     params: Params,
///     outcome: Outcome,
///     action1: Action1,
///     action2: Action2,
///     ctx: &mut TxContext
/// ) {
///     account.verify(auth);
///     params.assert_single_execution(); // if not a recurring intent
/// 
///     account.build_intent!(
///         params,
///         outcome, 
///         b"".to_string(),
///         version::current(),
///         IntentWitness(),   
///         ctx,
///         |intent, iw| {
///             intent.add_action(action1, iw);
///             intent.add_action(action2, iw);
///         }
///     );
/// }
/// 
/// ```

/// Creates an intent with actions and adds it to the account.
public macro fun build_intent<$Config, $Outcome, $IW: drop>(
    $account: &mut Account<$Config>,
    $params: Params,
    $outcome: $Outcome,
    $managed_name: String,
    $version_witness: VersionWitness,
    $intent_witness: $IW,
    $ctx: &mut TxContext,
    $new_actions: |&mut Intent<$Outcome>, $IW|,
) {
    let mut intent = account::create_intent(
        $account,
        $params,
        $outcome,
        $managed_name,
        $version_witness, 
        $intent_witness,
        $ctx 
    );

    $new_actions(&mut intent, $intent_witness);

    account::insert_intent($account, intent, $version_witness, $intent_witness);
}

/// Example implementation:
/// 
/// ```move
/// 
/// public fun execute_intent_name<Config, Outcome: store>(
///     executable: &mut Executable<Outcome>,
///     account: &mut Account<Config>,  
/// ) {
///     account.process_intent!(
///         executable, 
///         version::current(),   
///         ConfigDepsIntent(), 
///         |executable, iw| {
///             do_action(executable, iw, <ADDITIONAL_ARG>)
///             do_other_action(executable, iw)
///         }
///     ); 
/// } 
/// 
/// ```

/// Executes the actions from the executable intent.
public macro fun process_intent<$Config, $Outcome: store, $IW: drop>(
    $account: &Account<$Config>, 
    $executable: &mut Executable<$Outcome>,
    $version_witness: VersionWitness,
    $intent_witness: $IW,
    $do_actions: |&mut Executable<$Outcome>, $IW| -> _
): _ {
    let account = $account;
    let executable = $executable;
    // let version_witness = $version_witness;
    // let intent_witness = $intent_witness;
    // ensures the package address is a dependency for this account
    account.deps().check($version_witness);
    // ensures the right account is passed
    executable.intent().assert_is_account(account.addr());
    // ensures the intent is created by the same package that creates the action
    executable.intent().assert_is_witness($intent_witness);

    $do_actions(executable, $intent_witness)
}/// [Account Interface] - High level functions to create required "methods" for the account.
///
/// 1. Define a new Account type with a specific config and default dependencies.
/// 2. Define a mechanism to authenticate an address to grant permission to call certain functions.
/// 3. Define a way to modify the outcome of an intent.
/// 4. Define an `Outcome.validate()` that will be called upon intent execution.

module account_protocol::account_interface;

// === Imports ===

use std::string::String;
use sui::clock::Clock;
use account_protocol::{
    account::{Self, Account, Auth},
    deps::Deps,
    version_witness::VersionWitness,
    executable::Executable,
};

// === Public functions ===

/// Example implementation:
/// 
/// ```move
/// 
/// public struct Witness() has drop;
///
/// public fun new_account(
///     extensions: &Extensions,
///     ctx: &mut TxContext,
/// ): Account<Config> {
///     fees.process(coin);
/// 
///     let config = Config {
///        .. <FIELDS>
///     };
/// 
///     create_account!(
///        config, 
///        version::current(), 
///        Witness(), 
///        ctx, 
///        || deps::new_latest_extensions(extensions, vector[b"AccountProtocol".to_string(), b"MyConfig".to_string()])
///     )
/// }
/// 
/// ```

/// Returns a new Account object with a specific config and initialize dependencies.
public macro fun create_account<$Config, $CW: drop>(
    $config: $Config,
    $version_witness: VersionWitness,
    $config_witness: $CW,
    $ctx: &mut TxContext,
    $init_deps: || -> Deps,
): Account<$Config> {
    let deps = $init_deps();
    account::new<$Config, $CW>($config, deps, $version_witness, $config_witness, $ctx)
}

/// Example implementation:
/// 
/// ```move
/// 
/// public fun authenticate(
///     account: &Account<Multisig, Approvals>,
///     ctx: &TxContext
/// ): Auth {
///     authenticate!(
///        account, 
///        version::current(), 
///        Witness(), 
///        || account.config().assert_is_member(ctx)
///     )
/// }
/// 
/// ```

/// Returns an Auth if the conditions passed are met (used to create intents and more).
public macro fun create_auth<$Config, $CW: drop>(
    $account: &Account<$Config>,
    $version_witness: VersionWitness,
    $config_witness: $CW,
    $grant_permission: ||, // condition to grant permission, must throw if not met
): Auth {
    let account = $account;

    $grant_permission();
    
    account.new_auth($version_witness, $config_witness)
}

/// Example implementation:
/// 
/// ```move
/// 
/// public fun approve_intent<Config>(
///     account: &mut Account<Config>, 
///     key: String,
///     ctx: &TxContext
/// ) {
///     <PREPARE_DATA>
///     
///     resolve_intent!(
///         account, 
///         key, 
///         version::current(), 
///         Witness(), 
///         |outcome_mut| {
///             <DO_SOMETHING>
///         }
///     );
/// }
/// 
/// ```

/// Modifies the outcome of an intent.
public macro fun resolve_intent<$Config, $Outcome, $CW: drop>(
    $account: &mut Account<$Config>,
    $key: String,
    $version_witness: VersionWitness,
    $config_witness: $CW,
    $modify_outcome: |&mut $Outcome|,
) {
    let account = $account;

    let outcome_mut = account
        .intents_mut($version_witness, $config_witness)
        .get_mut($key)
        .outcome_mut<$Outcome>();

    $modify_outcome(outcome_mut);
}

/// Example implementation:
/// 
/// IMPORTANT: You must provide an Outcome.validate() function that will be called automatically.
/// It must take the outcome by value, a reference to the Config and the role of the intent even if not used.
/// 
/// ```move
/// 
/// public fun execute_intent(
///     account: &mut Account<Config>, 
///     key: String, 
///     clock: &Clock,
/// ): Executable<Outcome> {
///     execute_intent!<_, Outcome, _>(account, key, clock, version::current(), Witness())
/// }
/// 
/// fun validate_outcome(
///     outcome: Outcome, 
///     config: &Config,
///     role: String,
/// ) {
///     let Outcome { fields, .. } = outcome;
/// 
///     assert!(<CHECK_CONDITIONS>);
/// }
/// 
/// ``` 

/// Validates the outcome of an intent and returns an executable.
public macro fun execute_intent<$Config, $Outcome, $CW: drop>(
    $account: &mut Account<$Config>,
    $key: String,
    $clock: &Clock,
    $version_witness: VersionWitness,
    $config_witness: $CW,
    $validate_outcome: |$Outcome|,
): Executable<$Outcome> {
    let (outcome, executable) = account::create_executable<_, $Outcome, _>(
        $account, $key, $clock, $version_witness, $config_witness
    );

    $validate_outcome(outcome);

    executable
}