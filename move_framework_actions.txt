/// Init actions for Move framework - mirrors Futarchy pattern
/// These work on unshared Accounts during initialization
///
/// ## FORK NOTE
/// **Added**: Complete init_actions module for atomic DAO initialization
/// **Reason**: Allow intents (vault deposits, minting, vesting, etc.) to be called
/// during the init process of unshared Accounts before they are publicly shared.
/// This enables atomic DAO bootstrapping via PTBs without requiring proposal approval.
/// **Pattern**: Entry functions call `do_*_unshared()` functions in action modules
/// **Safety**: Functions use `public(package)` visibility to prevent misuse on shared Accounts
module account_actions::init_actions;

use account_actions::access_control;
use account_actions::currency;
use account_actions::kiosk;
use account_actions::package_upgrade;
use account_actions::transfer;
use account_actions::vault;
use account_actions::version;
use account_actions::vesting;
use account_protocol::account::{Self, Account};
use std::option::{Self, Option};
use std::string::{Self, String};
use sui::clock::{Self, Clock};
use sui::coin::{Self, Coin, TreasuryCap};
use sui::object;
use sui::package::UpgradeCap;
use sui::tx_context::TxContext;

// === Error Codes ===

/// Error when vectors have mismatched lengths
const ELengthMismatch: u64 = 1000;

/// Error when trying to init on a shared account (if we could detect it)
const EInitOnSharedAccount: u64 = 1001;

/// Error when initialization is called after finalization
const EInitAfterFinalization: u64 = 1002;

/// Error when vault name already exists
const EVaultAlreadyExists: u64 = 1003;

/// Error when kiosk name already exists
const EKioskAlreadyExists: u64 = 1004;

/// Error when capability already locked
const ECapabilityAlreadyLocked: u64 = 1005;

/// Error when treasury cap already locked
const ETreasuryCapAlreadyLocked: u64 = 1006;

/// Error when upgrade cap already locked
const EUpgradeCapAlreadyLocked: u64 = 1007;

/// Error when object key already exists
const EObjectKeyAlreadyExists: u64 = 1008;

// === Init Vault Actions ===

/// Deposit initial funds during account creation
public fun init_vault_deposit<Config, CoinType: drop>(
    account: &mut Account<Config>,
    coin: Coin<CoinType>,
    vault_name: vector<u8>,
    ctx: &mut TxContext,
) {
    vault::do_deposit_unshared(
        account,
        string::utf8(vault_name),
        coin,
        ctx,
    );
}

/// Deposit with default vault name
public fun init_vault_deposit_default<Config, CoinType: drop>(
    account: &mut Account<Config>,
    coin: Coin<CoinType>,
    ctx: &mut TxContext,
) {
    vault::do_deposit_unshared(
        account,
        vault::default_vault_name(),
        coin,
        ctx,
    );
}

// === Init Currency Actions ===

/// Lock treasury cap during initialization
public fun init_lock_treasury_cap<Config, CoinType>(
    account: &mut Account<Config>,
    cap: TreasuryCap<CoinType>,
) {
    currency::do_lock_cap_unshared(account, cap);
}

/// Mint coins during initialization
public fun init_mint<Config, CoinType>(
    account: &mut Account<Config>,
    amount: u64,
    recipient: address,
    ctx: &mut TxContext,
) {
    currency::do_mint_unshared<Config, CoinType>(account, amount, recipient, ctx);
}

/// Mint and deposit during initialization
public fun init_mint_and_deposit<Config, CoinType: drop>(
    account: &mut Account<Config>,
    amount: u64,
    vault_name: vector<u8>,
    ctx: &mut TxContext,
) {
    let coin = currency::do_mint_to_coin_unshared<Config, CoinType>(
        account,
        amount,
        ctx,
    );
    vault::do_deposit_unshared(
        account,
        string::utf8(vault_name),
        coin,
        ctx,
    );
}

// === Init Vesting Actions ===

/// Create vesting during initialization
/// Creates a vesting schedule with coins and transfers ClaimCap to recipient
/// Returns the vesting ID for reference
public fun init_create_vesting<Config, CoinType>(
    _account: &mut Account<Config>, // For consistency, though not used
    coin: Coin<CoinType>,
    recipient: address,
    start_timestamp: u64,
    duration_ms: u64,
    cliff_ms: u64,
    clock: &Clock,
    ctx: &mut TxContext,
): object::ID {
    vesting::do_create_vesting_unshared(
        coin,
        recipient,
        start_timestamp,
        duration_ms,
        cliff_ms,
        clock,
        ctx,
    )
}

/// Create founder vesting with standard parameters
/// Convenience function with preset duration for founder vesting
/// Returns the vesting ID for reference
public fun init_create_founder_vesting<Config, CoinType>(
    _account: &mut Account<Config>,
    coin: Coin<CoinType>,
    founder: address,
    cliff_ms: u64,
    clock: &Clock,
    ctx: &mut TxContext,
): object::ID {
    // Standard 4-year vesting for founders
    let duration_ms = 4 * 365 * 24 * 60 * 60 * 1000; // 4 years in milliseconds
    let start_timestamp = clock.timestamp_ms();

    vesting::do_create_vesting_unshared(
        coin,
        founder,
        start_timestamp,
        duration_ms,
        cliff_ms,
        clock,
        ctx,
    )
}

/// Create team vesting with custom duration
/// Returns the vesting ID for reference
public fun init_create_team_vesting<Config, CoinType>(
    _account: &mut Account<Config>,
    coin: Coin<CoinType>,
    team_member: address,
    duration_ms: u64,
    cliff_ms: u64,
    clock: &Clock,
    ctx: &mut TxContext,
): object::ID {
    let start_timestamp = clock.timestamp_ms();

    vesting::do_create_vesting_unshared(
        coin,
        team_member,
        start_timestamp,
        duration_ms,
        cliff_ms,
        clock,
        ctx,
    )
}

// === Init Package Upgrade Actions ===

/// Lock upgrade cap during initialization
/// Stores UpgradeCap in the Account for controlled package upgrades
public fun init_lock_upgrade_cap<Config>(
    account: &mut Account<Config>,
    cap: UpgradeCap,
    package_name: vector<u8>,
    delay_ms: u64,
) {
    package_upgrade::do_lock_cap_unshared(
        account,
        cap,
        string::utf8(package_name),
        delay_ms,
    );
}

// === Init Kiosk Actions ===

/// Open kiosk during initialization
/// Creates a kiosk for NFT management
/// Returns the kiosk ID for subsequent operations
public fun init_open_kiosk<Config>(account: &mut Account<Config>, ctx: &mut TxContext): object::ID {
    kiosk::do_open_unshared(account, ctx)
}

// Note: init_place_in_kiosk removed - PTBs should use the returned
// kiosk ID directly with standard kiosk functions

// === Init Access Control Actions ===

/// Lock generic capability during initialization
/// Stores any capability object in the Account
public fun init_lock_capability<Config, Cap: key + store>(account: &mut Account<Config>, cap: Cap) {
    access_control::do_lock_cap_unshared(account, cap);
}

// === Init Owned Actions ===

/// Store owned object during initialization
/// Directly stores an object in the Account's owned storage
public fun init_store_object<Config, Key: copy + drop + store, T: key + store>(
    account: &mut Account<Config>,
    key: Key,
    object: T,
    _ctx: &mut TxContext,
) {
    // Store the object in the Account's owned storage using add_managed_asset
    account.add_managed_asset(key, object, version::current());
}

// === Init Transfer Actions ===

/// Transfer object during initialization
/// Useful for transferring objects created during DAO setup
public fun init_transfer_object<T: key + store>(object: T, recipient: address) {
    transfer::do_transfer_unshared(object, recipient);
}

/// Transfer multiple objects during initialization
public fun init_transfer_objects<T: key + store>(
    mut objects: vector<T>,
    mut recipients: vector<address>,
) {
    assert!(vector::length(&objects) == vector::length(&recipients), ELengthMismatch);

    while (!vector::is_empty(&objects)) {
        let object = vector::pop_back(&mut objects);
        let recipient = vector::pop_back(&mut recipients);
        transfer::do_transfer_unshared(object, recipient);
    };

    vector::destroy_empty(objects);
    vector::destroy_empty(recipients);
}

// === Init Stream Actions ===

/// Create a vault stream during initialization
/// Creates a time-based payment stream for salaries, grants, etc.
/// Returns the stream ID for reference
public fun init_create_vault_stream<Config, CoinType: drop>(
    account: &mut Account<Config>,
    vault_name: vector<u8>,
    beneficiary: address,
    total_amount: u64,
    start_time: u64,
    end_time: u64,
    cliff_time: Option<u64>,
    max_per_withdrawal: u64,
    min_interval_ms: u64,
    clock: &Clock,
    ctx: &mut TxContext,
): object::ID {
    vault::create_stream_unshared<Config, CoinType>(
        account,
        string::utf8(vault_name),
        beneficiary,
        total_amount,
        start_time,
        end_time,
        cliff_time,
        max_per_withdrawal,
        min_interval_ms,
        100, // Default max beneficiaries
        clock,
        ctx,
    )
}

/// Create a simple salary stream with monthly payments
/// Convenience function for common use case
/// Returns the stream ID for reference
public fun init_create_salary_stream<Config, CoinType: drop>(
    account: &mut Account<Config>,
    employee: address,
    monthly_amount: u64,
    num_months: u64,
    clock: &Clock,
    ctx: &mut TxContext,
): object::ID {
    let current_time = clock.timestamp_ms();
    let month_ms = 30 * 24 * 60 * 60 * 1000; // Approximately 30 days
    let total_amount = monthly_amount * num_months;
    let start_time = current_time;
    let end_time = current_time + (month_ms * num_months);

    vault::create_stream_unshared<Config, CoinType>(
        account,
        vault::default_vault_name(),
        employee,
        total_amount,
        start_time,
        end_time,
        option::none(), // No cliff
        monthly_amount, // Max per withdrawal = monthly amount
        month_ms, // Min interval = 1 month
        1, // Single beneficiary
        clock,
        ctx,
    )
}
/// This module tracks the version of the package by implementing the version_witness type.
/// A new version type should be defined for each new version of the package.

module account_actions::version;

use account_protocol::version_witness::{Self, VersionWitness};

// === Imports ===

// === Constants ===

const VERSION: u64 = 1; // bump this when the package is upgraded

// === Structs ===

// define a new version struct for each new version of the package
public struct V1() has drop;

public fun current(): VersionWitness {
    version_witness::new(V1()) // modify with the new version struct
}

// === Public functions ===

public fun get(): u64 {
    VERSION
}
// ============================================================================
// FORK ADDITION - Currency Action Decoder
// ============================================================================
// NEW FILE added to the fork for on-chain action decoding.
//
// PURPOSE:
// Provides human-readable decoding of currency actions (minting, burning,
// metadata updates) for transparency. Part of the mandatory decoder system
// that ensures all actions can be decoded and displayed to users.
//
// IMPLEMENTATION:
// - Handles MintAction, BurnAction, UpdateAction, DisableAction
// - Complex Option<T> handling for metadata fields
// - Uses BCS deserialization with peel_* functions and macros
// - Security validation via validate_all_bytes_consumed()
// ============================================================================

/// Decoder for currency actions - tightly coupled with currency action definitions
module account_actions::currency_decoder;

use account_actions::currency::{MintAction, BurnAction, DisableAction, UpdateAction};
use account_protocol::bcs_validation;
use account_protocol::schema::{Self, ActionDecoderRegistry, HumanReadableField};
use std::ascii;
use std::string::String;
use std::type_name;
use sui::bcs;
use sui::dynamic_object_field;
use sui::object::{Self, UID};

// === Imports ===

// === Decoder Objects ===

/// Decoder for MintAction<CoinType>
public struct MintActionDecoder has key, store {
    id: UID,
}

/// Decoder for BurnAction<CoinType>
public struct BurnActionDecoder has key, store {
    id: UID,
}

/// Decoder for DisableAction<CoinType>
public struct DisableActionDecoder has key, store {
    id: UID,
}

/// Decoder for UpdateAction<CoinType>
public struct UpdateActionDecoder has key, store {
    id: UID,
}

/// Placeholder for generic registration
public struct CoinPlaceholder has drop, store {}

// === Decoder Functions ===

/// Decode a MintAction
public fun decode_mint_action<CoinType>(
    _decoder: &MintActionDecoder,
    action_data: vector<u8>,
): vector<HumanReadableField> {
    let mut bcs_data = bcs::new(action_data);
    let amount = bcs::peel_u64(&mut bcs_data);

    // Security: ensure all bytes are consumed to prevent trailing data attacks
    bcs_validation::validate_all_bytes_consumed(bcs_data);

    vector[
        schema::new_field(
            b"amount".to_string(),
            amount.to_string(),
            b"u64".to_string(),
        ),
    ]
}

/// Decode a BurnAction
public fun decode_burn_action<CoinType>(
    _decoder: &BurnActionDecoder,
    action_data: vector<u8>,
): vector<HumanReadableField> {
    let mut bcs_data = bcs::new(action_data);
    let amount = bcs::peel_u64(&mut bcs_data);

    // Security: ensure all bytes are consumed to prevent trailing data attacks
    bcs_validation::validate_all_bytes_consumed(bcs_data);

    vector[
        schema::new_field(
            b"amount".to_string(),
            amount.to_string(),
            b"u64".to_string(),
        ),
    ]
}

/// Decode a DisableAction
public fun decode_disable_action<CoinType>(
    _decoder: &DisableActionDecoder,
    action_data: vector<u8>,
): vector<HumanReadableField> {
    let mut bcs_data = bcs::new(action_data);
    let mint = bcs::peel_bool(&mut bcs_data);
    let burn = bcs::peel_bool(&mut bcs_data);
    let update_symbol = bcs::peel_bool(&mut bcs_data);
    let update_name = bcs::peel_bool(&mut bcs_data);
    let update_description = bcs::peel_bool(&mut bcs_data);
    let update_icon = bcs::peel_bool(&mut bcs_data);

    // Security: ensure all bytes are consumed to prevent trailing data attacks
    bcs_validation::validate_all_bytes_consumed(bcs_data);

    let mut fields = vector::empty();

    fields.push_back(
        schema::new_field(
            b"mint".to_string(),
            if (mint) { b"true" } else { b"false" }.to_string(),
            b"bool".to_string(),
        ),
    );

    fields.push_back(
        schema::new_field(
            b"burn".to_string(),
            if (burn) { b"true" } else { b"false" }.to_string(),
            b"bool".to_string(),
        ),
    );

    fields.push_back(
        schema::new_field(
            b"update_symbol".to_string(),
            if (update_symbol) { b"true" } else { b"false" }.to_string(),
            b"bool".to_string(),
        ),
    );

    fields.push_back(
        schema::new_field(
            b"update_name".to_string(),
            if (update_name) { b"true" } else { b"false" }.to_string(),
            b"bool".to_string(),
        ),
    );

    fields.push_back(
        schema::new_field(
            b"update_description".to_string(),
            if (update_description) { b"true" } else { b"false" }.to_string(),
            b"bool".to_string(),
        ),
    );

    fields
}

/// Decode an UpdateAction
public fun decode_update_action<CoinType>(
    _decoder: &UpdateActionDecoder,
    action_data: vector<u8>,
): vector<HumanReadableField> {
    let mut bcs_data = bcs::new(action_data);
    let mut symbol = bcs_data.peel_option!(|bcs| bcs.peel_vec_u8());
    let mut name = bcs_data.peel_option!(|bcs| bcs.peel_vec_u8());
    let mut description = bcs_data.peel_option!(|bcs| bcs.peel_vec_u8());
    let mut icon_url = bcs_data.peel_option!(|bcs| bcs.peel_vec_u8());

    // Security: ensure all bytes are consumed to prevent trailing data attacks
    bcs_validation::validate_all_bytes_consumed(bcs_data);

    let mut fields = vector::empty();

    // Symbol (optional)
    fields.push_back(
        schema::new_field(
            b"symbol".to_string(),
            if (symbol.is_some()) {
                symbol.destroy_some().to_string()
            } else {
                symbol.destroy_none();
                b"None".to_string()
            },
            b"Option<String>".to_string(),
        ),
    );

    // Name (optional)
    fields.push_back(
        schema::new_field(
            b"name".to_string(),
            if (name.is_some()) {
                name.destroy_some().to_string()
            } else {
                name.destroy_none();
                b"None".to_string()
            },
            b"Option<String>".to_string(),
        ),
    );

    // Description (optional)
    fields.push_back(
        schema::new_field(
            b"description".to_string(),
            if (description.is_some()) {
                description.destroy_some().to_string()
            } else {
                description.destroy_none();
                b"None".to_string()
            },
            b"Option<String>".to_string(),
        ),
    );

    // Icon URL (optional)
    fields.push_back(
        schema::new_field(
            b"icon_url".to_string(),
            if (icon_url.is_some()) {
                icon_url.destroy_some().to_string()
            } else {
                icon_url.destroy_none();
                b"None".to_string()
            },
            b"Option<String>".to_string(),
        ),
    );

    fields
}

// === Registration Functions ===

/// Register all currency decoders
public fun register_decoders(registry: &mut ActionDecoderRegistry, ctx: &mut TxContext) {
    register_mint_decoder(registry, ctx);
    register_burn_decoder(registry, ctx);
    register_disable_decoder(registry, ctx);
    register_update_decoder(registry, ctx);
}

fun register_mint_decoder(registry: &mut ActionDecoderRegistry, ctx: &mut TxContext) {
    let decoder = MintActionDecoder { id: object::new(ctx) };
    let type_key = type_name::with_defining_ids<MintAction<CoinPlaceholder>>();
    dynamic_object_field::add(schema::registry_id_mut(registry), type_key, decoder);
}

fun register_burn_decoder(registry: &mut ActionDecoderRegistry, ctx: &mut TxContext) {
    let decoder = BurnActionDecoder { id: object::new(ctx) };
    let type_key = type_name::with_defining_ids<BurnAction<CoinPlaceholder>>();
    dynamic_object_field::add(schema::registry_id_mut(registry), type_key, decoder);
}

fun register_disable_decoder(registry: &mut ActionDecoderRegistry, ctx: &mut TxContext) {
    let decoder = DisableActionDecoder { id: object::new(ctx) };
    let type_key = type_name::with_defining_ids<DisableAction<CoinPlaceholder>>();
    dynamic_object_field::add(schema::registry_id_mut(registry), type_key, decoder);
}

fun register_update_decoder(registry: &mut ActionDecoderRegistry, ctx: &mut TxContext) {
    let decoder = UpdateActionDecoder { id: object::new(ctx) };
    let type_key = type_name::with_defining_ids<UpdateAction<CoinPlaceholder>>();
    dynamic_object_field::add(schema::registry_id_mut(registry), type_key, decoder);
}
// ============================================================================
// FORK ADDITION - Vault Action Decoder
// ============================================================================
// NEW FILE added to the fork for on-chain action decoding.
//
// PURPOSE:
// Provides human-readable decoding of vault actions (treasury operations)
// for transparency. Part of the mandatory decoder system that ensures all
// actions can be decoded and displayed to users before execution.
//
// IMPLEMENTATION:
// - Handles SpendAction and DepositAction for treasury management
// - Uses BCS deserialization with peel_* functions
// - Security validation via validate_all_bytes_consumed()
// - Returns vector<HumanReadableField> for universal display
// ============================================================================

/// Decoder for vault actions - tightly coupled with vault action definitions
/// This module knows exactly how to decode SpendAction and DepositAction
module account_actions::vault_decoder;

use account_actions::vault::{
    SpendAction,
    DepositAction,
    ToggleStreamPauseAction,
    ToggleStreamFreezeAction
};
use account_protocol::bcs_validation;
use account_protocol::schema::{Self, ActionDecoderRegistry, HumanReadableField};
use std::string::String;
use std::type_name;
use sui::bcs;
use sui::dynamic_object_field;
use sui::object::{Self, UID};

// === Imports ===

// === Decoder Objects ===

/// Decoder that knows how to decode SpendAction<CoinType>
public struct SpendActionDecoder has key, store {
    id: UID,
}

/// Decoder that knows how to decode DepositAction<CoinType>
public struct DepositActionDecoder has key, store {
    id: UID,
}

/// Decoder for ToggleStreamPauseAction
public struct ToggleStreamPauseActionDecoder has key, store {
    id: UID,
}

/// Decoder for ToggleStreamFreezeAction
public struct ToggleStreamFreezeActionDecoder has key, store {
    id: UID,
}

// === Placeholder for Generic Registration ===

/// Placeholder type for registering generic decoders
public struct CoinPlaceholder has drop, store {}

// === Decoder Functions ===

/// Decode a SpendAction from BCS bytes to human-readable fields
public fun decode_spend_action<CoinType>(
    _decoder: &SpendActionDecoder,
    action_data: vector<u8>,
): vector<HumanReadableField> {
    // Deserialize the fields directly - DO NOT reconstruct the Action struct
    let mut bcs_data = bcs::new(action_data);
    let name = bcs::peel_vec_u8(&mut bcs_data).to_string();
    let amount = bcs::peel_u64(&mut bcs_data);

    // Security: ensure all bytes are consumed to prevent trailing data attacks
    bcs_validation::validate_all_bytes_consumed(bcs_data);

    let mut fields = vector::empty();

    // Extract and convert each field
    fields.push_back(
        schema::new_field(
            b"name".to_string(),
            name,
            b"String".to_string(),
        ),
    );

    fields.push_back(
        schema::new_field(
            b"amount".to_string(),
            amount.to_string(),
            b"u64".to_string(),
        ),
    );

    fields
}

/// Decode a DepositAction from BCS bytes to human-readable fields
public fun decode_deposit_action<CoinType>(
    _decoder: &DepositActionDecoder,
    action_data: vector<u8>,
): vector<HumanReadableField> {
    // Deserialize the fields directly - DO NOT reconstruct the Action struct
    let mut bcs_data = bcs::new(action_data);
    let name = bcs::peel_vec_u8(&mut bcs_data).to_string();
    let amount = bcs::peel_u64(&mut bcs_data);

    // Security: ensure all bytes are consumed to prevent trailing data attacks
    bcs_validation::validate_all_bytes_consumed(bcs_data);

    let mut fields = vector::empty();

    fields.push_back(
        schema::new_field(
            b"name".to_string(),
            name,
            b"String".to_string(),
        ),
    );

    fields.push_back(
        schema::new_field(
            b"amount".to_string(),
            amount.to_string(),
            b"u64".to_string(),
        ),
    );

    fields
}

/// Decode a ToggleStreamPauseAction
public fun decode_toggle_stream_pause_action(
    _decoder: &ToggleStreamPauseActionDecoder,
    action_data: vector<u8>,
): vector<HumanReadableField> {
    let mut bcs_data = bcs::new(action_data);
    let vault_name = bcs::peel_vec_u8(&mut bcs_data).to_string();
    let stream_id = object::id_from_bytes(bcs::peel_vec_u8(&mut bcs_data));
    let pause_duration_ms = bcs::peel_u64(&mut bcs_data);

    bcs_validation::validate_all_bytes_consumed(bcs_data);

    vector[
        schema::new_field(
            b"vault_name".to_string(),
            vault_name,
            b"String".to_string(),
        ),
        schema::new_field(
            b"stream_id".to_string(),
            stream_id.id_to_address().to_string(),
            b"ID".to_string(),
        ),
        schema::new_field(
            b"pause_duration_ms".to_string(),
            pause_duration_ms.to_string(),
            b"u64".to_string(),
        ),
        schema::new_field(
            b"action".to_string(),
            if (pause_duration_ms == 0) { b"unpause" } else { b"pause" }.to_string(),
            b"string".to_string(),
        ),
    ]
}

/// Decode a ToggleStreamFreezeAction
public fun decode_toggle_stream_freeze_action(
    _decoder: &ToggleStreamFreezeActionDecoder,
    action_data: vector<u8>,
): vector<HumanReadableField> {
    let mut bcs_data = bcs::new(action_data);
    let vault_name = bcs::peel_vec_u8(&mut bcs_data).to_string();
    let stream_id = object::id_from_bytes(bcs::peel_vec_u8(&mut bcs_data));
    let freeze = bcs::peel_bool(&mut bcs_data);

    bcs_validation::validate_all_bytes_consumed(bcs_data);

    vector[
        schema::new_field(
            b"vault_name".to_string(),
            vault_name,
            b"String".to_string(),
        ),
        schema::new_field(
            b"stream_id".to_string(),
            stream_id.id_to_address().to_string(),
            b"ID".to_string(),
        ),
        schema::new_field(
            b"freeze".to_string(),
            if (freeze) { b"true" } else { b"false" }.to_string(),
            b"bool".to_string(),
        ),
        schema::new_field(
            b"action".to_string(),
            if (freeze) { b"emergency_freeze" } else { b"unfreeze" }.to_string(),
            b"string".to_string(),
        ),
    ]
}

// === Registration Functions ===

/// Register all vault decoders in the registry
/// Called once during protocol initialization
public fun register_decoders(registry: &mut ActionDecoderRegistry, ctx: &mut TxContext) {
    register_spend_decoder(registry, ctx);
    register_deposit_decoder(registry, ctx);
    register_toggle_stream_pause_decoder(registry, ctx);
    register_toggle_stream_freeze_decoder(registry, ctx);
}

/// Register the SpendAction decoder
fun register_spend_decoder(registry: &mut ActionDecoderRegistry, ctx: &mut TxContext) {
    let decoder = SpendActionDecoder {
        id: object::new(ctx),
    };

    // Use placeholder for generic registration
    let type_key = type_name::with_defining_ids<SpendAction<CoinPlaceholder>>();

    // Attach decoder as dynamic object field
    dynamic_object_field::add(
        schema::registry_id_mut(registry),
        type_key,
        decoder,
    );
}

/// Register the DepositAction decoder
fun register_deposit_decoder(registry: &mut ActionDecoderRegistry, ctx: &mut TxContext) {
    let decoder = DepositActionDecoder {
        id: object::new(ctx),
    };

    let type_key = type_name::with_defining_ids<DepositAction<CoinPlaceholder>>();

    dynamic_object_field::add(
        schema::registry_id_mut(registry),
        type_key,
        decoder,
    );
}

/// Register the ToggleStreamPauseAction decoder
fun register_toggle_stream_pause_decoder(
    registry: &mut ActionDecoderRegistry,
    ctx: &mut TxContext,
) {
    let decoder = ToggleStreamPauseActionDecoder {
        id: object::new(ctx),
    };

    let type_key = type_name::with_defining_ids<ToggleStreamPauseAction>();

    dynamic_object_field::add(
        schema::registry_id_mut(registry),
        type_key,
        decoder,
    );
}

/// Register the ToggleStreamFreezeAction decoder
fun register_toggle_stream_freeze_decoder(
    registry: &mut ActionDecoderRegistry,
    ctx: &mut TxContext,
) {
    let decoder = ToggleStreamFreezeActionDecoder {
        id: object::new(ctx),
    };

    let type_key = type_name::with_defining_ids<ToggleStreamFreezeAction>();

    dynamic_object_field::add(
        schema::registry_id_mut(registry),
        type_key,
        decoder,
    );
}

// === Verification Functions ===

/// Check if a SpendAction decoder is registered
public fun has_spend_decoder(registry: &ActionDecoderRegistry): bool {
    let type_key = type_name::with_defining_ids<SpendAction<CoinPlaceholder>>();
    dynamic_object_field::exists_(schema::registry_id(registry), type_key)
}

/// Check if a DepositAction decoder is registered
public fun has_deposit_decoder(registry: &ActionDecoderRegistry): bool {
    let type_key = type_name::with_defining_ids<DepositAction<CoinPlaceholder>>();
    dynamic_object_field::exists_(schema::registry_id(registry), type_key)
}
// ============================================================================
// FORK ADDITION - Kiosk Action Decoder
// ============================================================================
// NEW FILE added to the fork for on-chain action decoding.
//
// PURPOSE:
// Provides human-readable decoding of kiosk (NFT) actions for transparency.
// Part of the mandatory decoder system that ensures all actions can be
// decoded and displayed to users before execution.
//
// IMPLEMENTATION:
// - Handles TakeAction and ListAction for NFT operations
// - Uses object::id_from_bytes() for ID deserialization
// - Converts IDs to addresses for string representation
// - Returns vector<HumanReadableField> for universal display
// ============================================================================

/// Decoder for kiosk actions - tightly coupled with kiosk action definitions
module account_actions::kiosk_decoder;

use account_actions::kiosk::{TakeAction, ListAction};
use account_protocol::bcs_validation;
use account_protocol::schema::{Self, ActionDecoderRegistry, HumanReadableField};
use std::string::String;
use std::type_name;
use sui::bcs;
use sui::dynamic_object_field;
use sui::object::{Self, UID, ID};

// === Imports ===

// === Decoder Objects ===

/// Decoder for TakeAction
public struct TakeActionDecoder has key, store {
    id: UID,
}

/// Decoder for ListAction
public struct ListActionDecoder has key, store {
    id: UID,
}

// === Decoder Functions ===

/// Decode a TakeAction
public fun decode_take_action(
    _decoder: &TakeActionDecoder,
    action_data: vector<u8>,
): vector<HumanReadableField> {
    // Deserialize the fields directly - DO NOT reconstruct the Action struct
    let mut bcs_data = bcs::new(action_data);
    let name = bcs::peel_vec_u8(&mut bcs_data).to_string();
    let nft_id = object::id_from_bytes(bcs::peel_vec_u8(&mut bcs_data));
    let recipient = bcs::peel_address(&mut bcs_data);

    // Security: ensure all bytes are consumed to prevent trailing data attacks
    bcs_validation::validate_all_bytes_consumed(bcs_data);

    let mut fields = vector::empty();

    fields.push_back(
        schema::new_field(
            b"name".to_string(),
            name,
            b"String".to_string(),
        ),
    );

    fields.push_back(
        schema::new_field(
            b"nft_id".to_string(),
            nft_id.id_to_address().to_string(),
            b"ID".to_string(),
        ),
    );

    fields.push_back(
        schema::new_field(
            b"recipient".to_string(),
            recipient.to_string(),
            b"address".to_string(),
        ),
    );

    fields
}

/// Decode a ListAction
public fun decode_list_action(
    _decoder: &ListActionDecoder,
    action_data: vector<u8>,
): vector<HumanReadableField> {
    // Deserialize the fields directly - DO NOT reconstruct the Action struct
    let mut bcs_data = bcs::new(action_data);
    let name = bcs::peel_vec_u8(&mut bcs_data).to_string();
    let nft_id = object::id_from_bytes(bcs::peel_vec_u8(&mut bcs_data));
    let price = bcs::peel_u64(&mut bcs_data);

    // Security: ensure all bytes are consumed to prevent trailing data attacks
    bcs_validation::validate_all_bytes_consumed(bcs_data);

    let mut fields = vector::empty();

    fields.push_back(
        schema::new_field(
            b"name".to_string(),
            name,
            b"String".to_string(),
        ),
    );

    fields.push_back(
        schema::new_field(
            b"nft_id".to_string(),
            nft_id.id_to_address().to_string(),
            b"ID".to_string(),
        ),
    );

    fields.push_back(
        schema::new_field(
            b"price".to_string(),
            price.to_string(),
            b"u64".to_string(),
        ),
    );

    fields
}

// === Registration Functions ===

/// Register all kiosk decoders
public fun register_decoders(registry: &mut ActionDecoderRegistry, ctx: &mut TxContext) {
    register_take_decoder(registry, ctx);
    register_list_decoder(registry, ctx);
}

fun register_take_decoder(registry: &mut ActionDecoderRegistry, ctx: &mut TxContext) {
    let decoder = TakeActionDecoder { id: object::new(ctx) };
    let type_key = type_name::with_defining_ids<TakeAction>();
    dynamic_object_field::add(schema::registry_id_mut(registry), type_key, decoder);
}

fun register_list_decoder(registry: &mut ActionDecoderRegistry, ctx: &mut TxContext) {
    let decoder = ListActionDecoder { id: object::new(ctx) };
    let type_key = type_name::with_defining_ids<ListAction>();
    dynamic_object_field::add(schema::registry_id_mut(registry), type_key, decoder);
}
// ============================================================================
// FORK MODIFICATION NOTICE - Decoder Registry Initialization
// ============================================================================
// NEW FILE added to the fork for decoder system initialization.
//
// CHANGES IN THIS FORK (2025-01-14):
// - Added RegistryInfo shared object to store registry ID dynamically
// - Added RegistryCreated event emission for off-chain indexing
// - Added DECODER_REGISTRY_INIT one-time witness pattern
// - Removed hardcoded REGISTRY_ID constant - now discoverable at runtime
// - Single transaction deployment - no manual ID updates needed
//
// PURPOSE:
// Central initialization point for all action decoders. Creates and shares
// the global ActionDecoderRegistry during protocol deployment.
//
// BENEFITS:
// - Deploy once, fully configured
// - No constants to update post-deployment
// - Registry ID discoverable through multiple methods
// - Clean, professional deployment process
// ============================================================================

/// Main decoder registry initialization module
/// Registers all decoders during protocol deployment
module account_actions::decoder_registry_init;

use account_actions::access_control_decoder;
use account_actions::currency_decoder;
use account_actions::kiosk_decoder;
use account_actions::package_upgrade_decoder;
use account_actions::transfer_decoder;
use account_actions::vault_decoder;
use account_actions::vesting_decoder;
use account_protocol::schema::{Self, ActionDecoderRegistry};
use sui::event;
use sui::object::{Self, ID, UID};
use sui::transfer;

// === Imports ===

// === Events ===

/// Emitted when the registry is created, containing its ID
public struct RegistryCreated has copy, drop {
    registry_id: ID,
}

// === Structs ===

/// One-time witness for initialization
public struct DECODER_REGISTRY_INIT has drop {}

/// Registry info object that stores the registry ID
/// This is a shared object that anyone can read to get the registry ID
public struct RegistryInfo has key, store {
    id: UID,
    registry_id: ID,
}

/// Admin capability for decoder management
public struct DecoderAdminCap has key, store {
    id: UID,
}

// === Init Function ===

/// Initialize the decoder registry with all action decoders
/// This is called once during protocol deployment
fun init(witness: DECODER_REGISTRY_INIT, ctx: &mut TxContext) {
    // Create the decoder registry
    let mut registry = schema::init_registry(ctx);

    // Get the registry ID before sharing
    let registry_id = object::id(&registry);

    // Register all decoders
    register_all_decoders(&mut registry, ctx);

    // Share the registry for public access
    transfer::public_share_object(registry);

    // Create and share a RegistryInfo object that stores the registry ID
    let info = RegistryInfo {
        id: object::new(ctx),
        registry_id,
    };
    transfer::public_share_object(info);

    // Create admin capability
    let admin_cap = DecoderAdminCap {
        id: object::new(ctx),
    };
    transfer::transfer(admin_cap, ctx.sender());

    // Emit event with the registry ID for off-chain indexing
    event::emit(RegistryCreated { registry_id });
}

// === Public Functions ===

/// Get the registry ID from the shared RegistryInfo object
public fun get_registry_id(info: &RegistryInfo): ID {
    info.registry_id
}

/// Register all decoders from all action modules
public fun register_all_decoders(registry: &mut ActionDecoderRegistry, ctx: &mut TxContext) {
    // Register vault action decoders
    vault_decoder::register_decoders(registry, ctx);

    // Register currency action decoders
    currency_decoder::register_decoders(registry, ctx);

    // Register package upgrade decoders
    package_upgrade_decoder::register_decoders(registry, ctx);

    // Register vesting action decoders
    vesting_decoder::register_decoders(registry, ctx);

    // Register transfer action decoders
    transfer_decoder::register_decoders(registry, ctx);

    // Register kiosk action decoders
    kiosk_decoder::register_decoders(registry, ctx);

    // Register access control action decoders
    access_control_decoder::register_decoders(registry, ctx);
}

/// Update decoders (requires admin capability)
public fun update_decoders(
    registry: &mut ActionDecoderRegistry,
    _admin_cap: &DecoderAdminCap,
    ctx: &mut TxContext,
) {
    // This allows re-registration of decoders after updates
    register_all_decoders(registry, ctx);
}
// ============================================================================
// FORK ADDITION - Package Upgrade Action Decoder
// ============================================================================
// NEW FILE added to the fork for on-chain action decoding.
//
// PURPOSE:
// Provides human-readable decoding of package upgrade actions for transparency.
// Critical for DAO governance to understand contract upgrade proposals.
//
// IMPLEMENTATION:
// - Handles UpgradeAction and RestrictAction for package management
// - Decodes digest (32 bytes) and policy fields
// - Uses BCS deserialization with security validation
// - Returns vector<HumanReadableField> for universal display
// ============================================================================

/// Decoder for package upgrade actions
module account_actions::package_upgrade_decoder;

use account_actions::package_upgrade::{UpgradeAction, CommitAction, RestrictAction};
use account_protocol::bcs_validation;
use account_protocol::schema::{Self, ActionDecoderRegistry, HumanReadableField};
use std::string::String;
use std::type_name;
use std::vector;
use sui::bcs;
use sui::dynamic_object_field;
use sui::object::{Self, UID};

// === Imports ===

// === Decoder Objects ===

/// Decoder for UpgradeAction
public struct UpgradeActionDecoder has key, store {
    id: UID,
}

/// Decoder for CommitAction
public struct CommitActionDecoder has key, store {
    id: UID,
}

/// Decoder for RestrictAction
public struct RestrictActionDecoder has key, store {
    id: UID,
}

// === Decoder Functions ===

/// Decode an UpgradeAction
public fun decode_upgrade_action(
    _decoder: &UpgradeActionDecoder,
    action_data: vector<u8>,
): vector<HumanReadableField> {
    let mut bcs_data = bcs::new(action_data);
    let name = bcs::peel_vec_u8(&mut bcs_data).to_string();
    let digest = bcs::peel_vec_u8(&mut bcs_data);

    // Security: ensure all bytes are consumed to prevent trailing data attacks
    bcs_validation::validate_all_bytes_consumed(bcs_data);

    let mut fields = vector::empty();

    fields.push_back(
        schema::new_field(
            b"name".to_string(),
            name,
            b"String".to_string(),
        ),
    );

    // Convert digest bytes to hex string for readability
    fields.push_back(
        schema::new_field(
            b"digest".to_string(),
            bytes_to_hex_string(digest),
            b"vector<u8>".to_string(),
        ),
    );

    fields
}

/// Decode a CommitAction
public fun decode_commit_action(
    _decoder: &CommitActionDecoder,
    action_data: vector<u8>,
): vector<HumanReadableField> {
    let mut bcs_data = bcs::new(action_data);
    let name = bcs::peel_vec_u8(&mut bcs_data).to_string();

    // Security: ensure all bytes are consumed to prevent trailing data attacks
    bcs_validation::validate_all_bytes_consumed(bcs_data);

    vector[
        schema::new_field(
            b"name".to_string(),
            name,
            b"String".to_string(),
        ),
    ]
}

/// Decode a RestrictAction
public fun decode_restrict_action(
    _decoder: &RestrictActionDecoder,
    action_data: vector<u8>,
): vector<HumanReadableField> {
    let mut bcs_data = bcs::new(action_data);
    let name = bcs::peel_vec_u8(&mut bcs_data).to_string();
    let policy = bcs::peel_u8(&mut bcs_data);

    // Security: ensure all bytes are consumed to prevent trailing data attacks
    bcs_validation::validate_all_bytes_consumed(bcs_data);

    let mut fields = vector::empty();

    fields.push_back(
        schema::new_field(
            b"name".to_string(),
            name,
            b"String".to_string(),
        ),
    );

    // Convert policy u8 to human-readable string
    let policy_str = if (policy == 0) {
        b"compatible"
    } else if (policy == 128) {
        b"additive"
    } else if (policy == 192) {
        b"dependency-only"
    } else if (policy == 255) {
        b"immutable"
    } else {
        b"unknown"
    };

    fields.push_back(
        schema::new_field(
            b"policy".to_string(),
            policy_str.to_string(),
            b"u8".to_string(),
        ),
    );

    fields
}

// === Helper Functions ===

/// Convert bytes to hex string for display
fun bytes_to_hex_string(bytes: vector<u8>): String {
    let hex_chars = b"0123456789abcdef";
    let mut result = vector::empty<u8>();

    let mut i = 0;
    let len = bytes.length();
    while (i < len && i < 8) {
        // Show first 8 bytes for brevity
        let byte = bytes[i];
        result.push_back(hex_chars[(byte >> 4) as u64]);
        result.push_back(hex_chars[(byte & 0x0f) as u64]);
        i = i + 1;
    };

    if (len > 8) {
        result.append(b"...");
    };

    result.to_string()
}

// === Registration Functions ===

/// Register all package upgrade decoders
public fun register_decoders(registry: &mut ActionDecoderRegistry, ctx: &mut TxContext) {
    register_upgrade_decoder(registry, ctx);
    register_commit_decoder(registry, ctx);
    register_restrict_decoder(registry, ctx);
}

fun register_upgrade_decoder(registry: &mut ActionDecoderRegistry, ctx: &mut TxContext) {
    let decoder = UpgradeActionDecoder { id: object::new(ctx) };
    let type_key = type_name::with_defining_ids<UpgradeAction>();
    dynamic_object_field::add(schema::registry_id_mut(registry), type_key, decoder);
}

fun register_commit_decoder(registry: &mut ActionDecoderRegistry, ctx: &mut TxContext) {
    let decoder = CommitActionDecoder { id: object::new(ctx) };
    let type_key = type_name::with_defining_ids<CommitAction>();
    dynamic_object_field::add(schema::registry_id_mut(registry), type_key, decoder);
}

fun register_restrict_decoder(registry: &mut ActionDecoderRegistry, ctx: &mut TxContext) {
    let decoder = RestrictActionDecoder { id: object::new(ctx) };
    let type_key = type_name::with_defining_ids<RestrictAction>();
    dynamic_object_field::add(schema::registry_id_mut(registry), type_key, decoder);
}
// ============================================================================
// FORK ADDITION - Vesting Action Decoder
// ============================================================================
// NEW FILE added to the fork for on-chain action decoding.
//
// PURPOSE:
// Provides human-readable decoding of vesting actions for transparency.
// Part of the mandatory decoder system that ensures all actions can be
// decoded and displayed to users before execution.
//
// IMPLEMENTATION:
// - Uses BCS deserialization with peel_* functions
// - Security validation via validate_all_bytes_consumed()
// - Returns vector<HumanReadableField> for universal display
// - Handles CreateVestingAction and CancelVestingAction
// ============================================================================

/// Decoder for vesting actions - tightly coupled with vesting action definitions
module account_actions::vesting_decoder;

use account_actions::vesting::{
    CreateVestingAction,
    CancelVestingAction,
    ToggleVestingPauseAction,
    ToggleVestingFreezeAction
};
use account_protocol::bcs_validation;
use account_protocol::schema::{Self, ActionDecoderRegistry, HumanReadableField};
use std::string::String;
use std::type_name;
use sui::bcs;
use sui::dynamic_object_field;
use sui::object::{Self, UID, ID};

// === Imports ===

// === Decoder Objects ===

/// Decoder for CreateVestingAction<CoinType>
public struct CreateVestingActionDecoder has key, store {
    id: UID,
}

/// Decoder for CancelVestingAction
public struct CancelVestingActionDecoder has key, store {
    id: UID,
}

/// Decoder for ToggleVestingPauseAction
public struct ToggleVestingPauseActionDecoder has key, store {
    id: UID,
}

/// Decoder for ToggleVestingFreezeAction
public struct ToggleVestingFreezeActionDecoder has key, store {
    id: UID,
}

// === Placeholder for Generic Registration ===

/// Placeholder type for registering generic decoders
public struct CoinPlaceholder has drop, store {}

// === Decoder Functions ===

/// Decode a CreateVestingAction
public fun decode_create_vesting_action<CoinType>(
    _decoder: &CreateVestingActionDecoder,
    action_data: vector<u8>,
): vector<HumanReadableField> {
    // Deserialize the fields directly - DO NOT reconstruct the Action struct
    let mut bcs_data = bcs::new(action_data);
    let amount = bcs::peel_u64(&mut bcs_data);
    let start_timestamp = bcs::peel_u64(&mut bcs_data);
    let end_timestamp = bcs::peel_u64(&mut bcs_data);
    let mut cliff_time = bcs_data.peel_option!(|bcs| bcs.peel_u64());
    let recipient = bcs::peel_address(&mut bcs_data);
    let max_beneficiaries = bcs::peel_u64(&mut bcs_data);
    let max_per_withdrawal = bcs::peel_u64(&mut bcs_data);
    let min_interval_ms = bcs::peel_u64(&mut bcs_data);
    let is_transferable = bcs::peel_bool(&mut bcs_data);
    let is_cancelable = bcs::peel_bool(&mut bcs_data);
    let mut metadata = bcs_data.peel_option!(|bcs| bcs.peel_vec_u8());

    // Security: ensure all bytes are consumed to prevent trailing data attacks
    bcs_validation::validate_all_bytes_consumed(bcs_data);

    let mut fields = vector::empty();

    fields.push_back(
        schema::new_field(
            b"amount".to_string(),
            amount.to_string(),
            b"u64".to_string(),
        ),
    );

    fields.push_back(
        schema::new_field(
            b"start_timestamp".to_string(),
            start_timestamp.to_string(),
            b"u64".to_string(),
        ),
    );

    fields.push_back(
        schema::new_field(
            b"end_timestamp".to_string(),
            end_timestamp.to_string(),
            b"u64".to_string(),
        ),
    );

    fields.push_back(
        schema::new_field(
            b"cliff_time".to_string(),
            if (cliff_time.is_some()) {
                cliff_time.destroy_some().to_string()
            } else {
                cliff_time.destroy_none();
                b"None".to_string()
            },
            b"Option<u64>".to_string(),
        ),
    );

    fields.push_back(
        schema::new_field(
            b"recipient".to_string(),
            recipient.to_string(),
            b"address".to_string(),
        ),
    );

    fields.push_back(
        schema::new_field(
            b"max_beneficiaries".to_string(),
            max_beneficiaries.to_string(),
            b"u64".to_string(),
        ),
    );

    fields.push_back(
        schema::new_field(
            b"max_per_withdrawal".to_string(),
            max_per_withdrawal.to_string(),
            b"u64".to_string(),
        ),
    );

    fields.push_back(
        schema::new_field(
            b"min_interval_ms".to_string(),
            min_interval_ms.to_string(),
            b"u64".to_string(),
        ),
    );

    fields.push_back(
        schema::new_field(
            b"is_transferable".to_string(),
            if (is_transferable) { b"true" } else { b"false" }.to_string(),
            b"bool".to_string(),
        ),
    );

    fields.push_back(
        schema::new_field(
            b"is_cancelable".to_string(),
            if (is_cancelable) { b"true" } else { b"false" }.to_string(),
            b"bool".to_string(),
        ),
    );

    fields.push_back(
        schema::new_field(
            b"metadata".to_string(),
            if (metadata.is_some()) {
                metadata.destroy_some().to_string()
            } else {
                metadata.destroy_none();
                b"None".to_string()
            },
            b"Option<String>".to_string(),
        ),
    );

    fields
}

/// Decode a CancelVestingAction
public fun decode_cancel_vesting_action(
    _decoder: &CancelVestingActionDecoder,
    action_data: vector<u8>,
): vector<HumanReadableField> {
    // Deserialize the fields directly - DO NOT reconstruct the Action struct
    let mut bcs_data = bcs::new(action_data);
    let vesting_id = object::id_from_bytes(bcs::peel_vec_u8(&mut bcs_data));

    // Security: ensure all bytes are consumed to prevent trailing data attacks
    bcs_validation::validate_all_bytes_consumed(bcs_data);

    vector[
        schema::new_field(
            b"vesting_id".to_string(),
            vesting_id.id_to_address().to_string(),
            b"ID".to_string(),
        ),
    ]
}

/// Decode a ToggleVestingPauseAction
public fun decode_toggle_vesting_pause_action(
    _decoder: &ToggleVestingPauseActionDecoder,
    action_data: vector<u8>,
): vector<HumanReadableField> {
    let mut bcs_data = bcs::new(action_data);
    let vesting_id = object::id_from_bytes(bcs::peel_vec_u8(&mut bcs_data));
    let pause_duration_ms = bcs::peel_u64(&mut bcs_data);

    bcs_validation::validate_all_bytes_consumed(bcs_data);

    vector[
        schema::new_field(
            b"vesting_id".to_string(),
            vesting_id.id_to_address().to_string(),
            b"ID".to_string(),
        ),
        schema::new_field(
            b"pause_duration_ms".to_string(),
            pause_duration_ms.to_string(),
            b"u64".to_string(),
        ),
        schema::new_field(
            b"action".to_string(),
            if (pause_duration_ms == 0) { b"unpause" } else { b"pause" }.to_string(),
            b"string".to_string(),
        ),
    ]
}

/// Decode a ToggleVestingFreezeAction
public fun decode_toggle_vesting_freeze_action(
    _decoder: &ToggleVestingFreezeActionDecoder,
    action_data: vector<u8>,
): vector<HumanReadableField> {
    let mut bcs_data = bcs::new(action_data);
    let vesting_id = object::id_from_bytes(bcs::peel_vec_u8(&mut bcs_data));
    let freeze = bcs::peel_bool(&mut bcs_data);

    bcs_validation::validate_all_bytes_consumed(bcs_data);

    vector[
        schema::new_field(
            b"vesting_id".to_string(),
            vesting_id.id_to_address().to_string(),
            b"ID".to_string(),
        ),
        schema::new_field(
            b"freeze".to_string(),
            if (freeze) { b"true" } else { b"false" }.to_string(),
            b"bool".to_string(),
        ),
        schema::new_field(
            b"action".to_string(),
            if (freeze) { b"emergency_freeze" } else { b"unfreeze" }.to_string(),
            b"string".to_string(),
        ),
    ]
}

// === Registration Functions ===

/// Register all vesting decoders
public fun register_decoders(registry: &mut ActionDecoderRegistry, ctx: &mut TxContext) {
    register_create_vesting_decoder(registry, ctx);
    register_cancel_vesting_decoder(registry, ctx);
    register_toggle_vesting_pause_decoder(registry, ctx);
    register_toggle_vesting_freeze_decoder(registry, ctx);
}

fun register_create_vesting_decoder(registry: &mut ActionDecoderRegistry, ctx: &mut TxContext) {
    let decoder = CreateVestingActionDecoder { id: object::new(ctx) };
    let type_key = type_name::with_defining_ids<CreateVestingAction<CoinPlaceholder>>();
    dynamic_object_field::add(schema::registry_id_mut(registry), type_key, decoder);
}

fun register_cancel_vesting_decoder(registry: &mut ActionDecoderRegistry, ctx: &mut TxContext) {
    let decoder = CancelVestingActionDecoder { id: object::new(ctx) };
    let type_key = type_name::with_defining_ids<CancelVestingAction>();
    dynamic_object_field::add(schema::registry_id_mut(registry), type_key, decoder);
}

fun register_toggle_vesting_pause_decoder(
    registry: &mut ActionDecoderRegistry,
    ctx: &mut TxContext,
) {
    let decoder = ToggleVestingPauseActionDecoder { id: object::new(ctx) };
    let type_key = type_name::with_defining_ids<ToggleVestingPauseAction>();
    dynamic_object_field::add(schema::registry_id_mut(registry), type_key, decoder);
}

fun register_toggle_vesting_freeze_decoder(
    registry: &mut ActionDecoderRegistry,
    ctx: &mut TxContext,
) {
    let decoder = ToggleVestingFreezeActionDecoder { id: object::new(ctx) };
    let type_key = type_name::with_defining_ids<ToggleVestingFreezeAction>();
    dynamic_object_field::add(schema::registry_id_mut(registry), type_key, decoder);
}
// ============================================================================
// FORK ADDITION - Transfer Action Decoder
// ============================================================================
// NEW FILE added to the fork for on-chain action decoding.
//
// PURPOSE:
// Provides human-readable decoding of transfer actions for transparency.
// Part of the mandatory decoder system that ensures all actions can be
// decoded and displayed to users before execution.
//
// IMPLEMENTATION:
// - Simple single-field decoder for TransferAction
// - Uses BCS deserialization with security validation
// - Returns vector<HumanReadableField> for universal display
// ============================================================================

/// Decoder for transfer actions - tightly coupled with transfer action definitions
module account_actions::transfer_decoder;

use account_actions::transfer::{TransferAction, TransferToSenderAction};
use account_protocol::bcs_validation;
use account_protocol::schema::{Self, ActionDecoderRegistry, HumanReadableField};
use std::string::String;
use std::type_name;
use sui::bcs;
use sui::dynamic_object_field;
use sui::object::{Self, UID};

// === Imports ===

// === Decoder Objects ===

/// Decoder for TransferAction
public struct TransferActionDecoder has key, store {
    id: UID,
}

/// Decoder for TransferToSenderAction
public struct TransferToSenderActionDecoder has key, store {
    id: UID,
}

// === Decoder Functions ===

/// Decode a TransferAction
public fun decode_transfer_action(
    _decoder: &TransferActionDecoder,
    action_data: vector<u8>,
): vector<HumanReadableField> {
    // Deserialize the fields directly - DO NOT reconstruct the Action struct
    let mut bcs_data = bcs::new(action_data);
    let recipient = bcs::peel_address(&mut bcs_data);

    // Security: ensure all bytes are consumed to prevent trailing data attacks
    bcs_validation::validate_all_bytes_consumed(bcs_data);

    vector[
        schema::new_field(
            b"recipient".to_string(),
            recipient.to_string(),
            b"address".to_string(),
        ),
    ]
}

/// Decode a TransferToSenderAction
public fun decode_transfer_to_sender_action(
    _decoder: &TransferToSenderActionDecoder,
    _action_data: vector<u8>,
): vector<HumanReadableField> {
    // TransferToSenderAction is an empty struct with no fields to decode
    // We acknowledge the action_data exists but don't deserialize it

    // Return action type information
    vector[
        schema::new_field(
            b"action_type".to_string(),
            b"TransferToSenderAction".to_string(),
            b"String".to_string(),
        ),
    ]
}

// === Registration Functions ===

/// Register all transfer decoders
public fun register_decoders(registry: &mut ActionDecoderRegistry, ctx: &mut TxContext) {
    register_transfer_decoder(registry, ctx);
    register_transfer_to_sender_decoder(registry, ctx);
}

fun register_transfer_decoder(registry: &mut ActionDecoderRegistry, ctx: &mut TxContext) {
    let decoder = TransferActionDecoder { id: object::new(ctx) };
    let type_key = type_name::with_defining_ids<TransferAction>();
    dynamic_object_field::add(schema::registry_id_mut(registry), type_key, decoder);
}

fun register_transfer_to_sender_decoder(registry: &mut ActionDecoderRegistry, ctx: &mut TxContext) {
    let decoder = TransferToSenderActionDecoder { id: object::new(ctx) };
    let type_key = type_name::with_defining_ids<TransferToSenderAction>();
    dynamic_object_field::add(schema::registry_id_mut(registry), type_key, decoder);
}
// ============================================================================
// FORK ADDITION - Access Control Action Decoder
// ============================================================================
// NEW FILE added to the fork for on-chain action decoding.
//
// PURPOSE:
// Provides human-readable decoding of access control actions for transparency.
// Part of the mandatory decoder system that ensures all actions can be
// decoded and displayed to users before execution.
//
// IMPLEMENTATION:
// - Handles BorrowAction and ReturnAction (empty structs)
// - Minimal decoder as these actions have no fields
// - Still validates BCS consumption for security
// - Returns action type information for display
// ============================================================================

/// Decoder for access control actions - tightly coupled with access control action definitions
module account_actions::access_control_decoder;

use account_actions::access_control::{BorrowAction, ReturnAction};
use account_protocol::bcs_validation;
use account_protocol::schema::{Self, ActionDecoderRegistry, HumanReadableField};
use std::string::String;
use std::type_name;
use sui::bcs;
use sui::dynamic_object_field;
use sui::object::{Self, UID};

// === Imports ===

// === Decoder Objects ===

/// Decoder for BorrowAction<Cap>
public struct BorrowActionDecoder has key, store {
    id: UID,
}

/// Decoder for ReturnAction<Cap>
public struct ReturnActionDecoder has key, store {
    id: UID,
}

// === Placeholder for Generic Registration ===

/// Placeholder type for registering generic decoders
public struct CapPlaceholder has drop, store {}

// === Decoder Functions ===

/// Decode a BorrowAction
public fun decode_borrow_action<Cap>(
    _decoder: &BorrowActionDecoder,
    _action_data: vector<u8>,
): vector<HumanReadableField> {
    // BorrowAction is an empty struct with no fields to decode
    // We acknowledge the action_data exists but don't deserialize it

    // Return action type information
    vector[
        schema::new_field(
            b"action_type".to_string(),
            b"BorrowAction".to_string(),
            b"String".to_string(),
        ),
    ]
}

/// Decode a ReturnAction
public fun decode_return_action<Cap>(
    _decoder: &ReturnActionDecoder,
    _action_data: vector<u8>,
): vector<HumanReadableField> {
    // ReturnAction is an empty struct with no fields to decode
    // We acknowledge the action_data exists but don't deserialize it

    // Return action type information
    vector[
        schema::new_field(
            b"action_type".to_string(),
            b"ReturnAction".to_string(),
            b"String".to_string(),
        ),
    ]
}

// === Registration Functions ===

/// Register all access control decoders
public fun register_decoders(registry: &mut ActionDecoderRegistry, ctx: &mut TxContext) {
    register_borrow_decoder(registry, ctx);
    register_return_decoder(registry, ctx);
}

fun register_borrow_decoder(registry: &mut ActionDecoderRegistry, ctx: &mut TxContext) {
    let decoder = BorrowActionDecoder { id: object::new(ctx) };
    let type_key = type_name::with_defining_ids<BorrowAction<CapPlaceholder>>();
    dynamic_object_field::add(schema::registry_id_mut(registry), type_key, decoder);
}

fun register_return_decoder(registry: &mut ActionDecoderRegistry, ctx: &mut TxContext) {
    let decoder = ReturnActionDecoder { id: object::new(ctx) };
    let type_key = type_name::with_defining_ids<ReturnAction<CapPlaceholder>>();
    dynamic_object_field::add(schema::registry_id_mut(registry), type_key, decoder);
}
// ============================================================================
// FORK MODIFICATION NOTICE - Kiosk Management with Serialize-Then-Destroy Pattern
// ============================================================================
// This module manages NFT operations in Kiosks for Account.
//
// CHANGES IN THIS FORK:
// - Actions use type markers: KioskTake, KioskList
// - Implemented serialize-then-destroy pattern for both action types
// - Added destruction functions: destroy_take_action, destroy_list_action
// - Actions serialize to bytes before adding to intent via add_typed_action()
// - Returns TransferRequest hot potato for completing NFT transfers
// - Type-safe action validation through compile-time TypeName comparison
// ============================================================================
/// Authenticated users can place nfts from their kiosk into the account's without passing through the intent process.
/// Nfts can be transferred into any other Kiosk. Upon resolution, the recipient must execute the transfer.
/// The functions take the caller's kiosk and the account's kiosk to execute.
/// Nfts can be listed for sale in the kiosk, and then purchased by anyone.
/// Authorized addresses can withdraw the profits from the kiosk to the Account.

module account_actions::kiosk;

// === Imports ===

use std::string::{Self, String};
use sui::{
    coin,
    sui::SUI,
    kiosk::{Self, Kiosk, KioskOwnerCap},
    transfer_policy::{TransferPolicy, TransferRequest},
    bcs::{Self, BCS},
};
// NOTE: Kiosk rules commented out as the kiosk dependency was removed
// use kiosk::{kiosk_lock_rule, royalty_rule, personal_kiosk_rule};
use account_protocol::{
    action_validation,
    account::{Account, Auth},
    intents::{Self, Expired, Intent},
    executable::{Self, Executable},
    version_witness::VersionWitness,
};
use account_actions::version;
use account_extensions::framework_action_types::{Self, KioskTake, KioskList};

// === Use Fun Aliases ===
// Removed - add_typed_action is now called directly

// === Errors ===

const EWrongReceiver: u64 = 0;

// === Structs ===    

/// Dynamic Object Field key for the KioskOwnerCap
public struct KioskOwnerKey(String) has copy, drop, store;

/// Action transferring nfts from the account's kiosk to another one
public struct TakeAction has drop, store {
    // name of the Kiosk
    name: String,
    // id of the nfts to transfer
    nft_id: ID,
    // owner of the receiver kiosk
    recipient: address,
}
/// Action listing nfts for purchase
public struct ListAction has drop, store {
    // name of the Kiosk
    name: String,
    // id of the nft to list
    nft_id: ID,
    // listing price of the nft
    price: u64
}

// === Public functions ===

/// Creates a new Kiosk and locks the KioskOwnerCap in the Account
#[allow(lint(share_owned))]
public fun open<Config>(
    auth: Auth,
    account: &mut Account<Config>, 
    name: String, 
    ctx: &mut TxContext
) {
    account.verify(auth);

    let (mut kiosk, kiosk_owner_cap) = kiosk::new(ctx);
    kiosk.set_owner_custom(&kiosk_owner_cap, account.addr());

    account.add_managed_asset(KioskOwnerKey(name), kiosk_owner_cap, version::current());
    transfer::public_share_object(kiosk);
}

/// Open kiosk during initialization - works on unshared Accounts
/// Creates a kiosk for NFT management during DAO creation
/// Returns the kiosk ID for subsequent operations
///
/// ## FORK NOTE
/// **Added**: `do_open_unshared()` for init-time kiosk creation
/// **Reason**: Allow DAOs to create NFT kiosks during atomic initialization.
/// Shares the Kiosk publicly while storing KioskOwnerCap in Account.
/// **Safety**: `public(package)` visibility ensures only callable during init
#[allow(lint(share_owned))]
public(package) fun do_open_unshared<Config>(
    account: &mut Account<Config>,
    ctx: &mut TxContext
): ID {
    let (mut kiosk, kiosk_owner_cap) = kiosk::new(ctx);
    kiosk.set_owner_custom(&kiosk_owner_cap, account.addr());

    let kiosk_id = object::id(&kiosk);

    // Use default name for init kiosk
    let name = string::utf8(b"Main Kiosk");
    account.add_managed_asset(KioskOwnerKey(name), kiosk_owner_cap, version::current());
    transfer::public_share_object(kiosk);

    kiosk_id
}

/// Checks if a Kiosk exists for a given name.
public fun has_lock<Config>(
    account: &Account<Config>,
    name: String
): bool {
    account.has_managed_asset(KioskOwnerKey(name))
}

/// Deposits from another Kiosk, no need for intent.
/// Optional royalty, lock and personal kiosk rules are automatically resolved for the type.
/// Additional rules may be confirmed after in the PTB.
public fun place<Config, Nft: key + store>(
    auth: Auth,
    account: &mut Account<Config>, 
    account_kiosk: &mut Kiosk, 
    sender_kiosk: &mut Kiosk, 
    sender_cap: &KioskOwnerCap, 
    policy: &mut TransferPolicy<Nft>,
    name: String,
    nft_id: ID,
    ctx: &mut TxContext
): TransferRequest<Nft> {
    account.verify(auth);

    let cap: &KioskOwnerCap = account.borrow_managed_asset(KioskOwnerKey(name), version::current());

    sender_kiosk.list<Nft>(sender_cap, nft_id, 0);
    let (nft, mut request) = sender_kiosk.purchase<Nft>(nft_id, coin::zero<SUI>(ctx));

    // NOTE: Kiosk rule handling commented out as the kiosk dependency was removed
    // This just places the NFT in the kiosk without handling specific rules
    account_kiosk.place(cap, nft);

    // if (policy.has_rule<Nft, kiosk_lock_rule::Rule>()) {
    //     account_kiosk.lock(cap, policy, nft);
    //     kiosk_lock_rule::prove(&mut request, account_kiosk);
    // } else {
    //     account_kiosk.place(cap, nft);
    // };
    //
    // if (policy.has_rule<Nft, royalty_rule::Rule>()) {
    //     // can't read royalty rule on-chain because transfer_policy::get_rule not implemented
    //     // so we can't throw an error if there is a minimum floor price set
    //     royalty_rule::pay(policy, &mut request, coin::zero<SUI>(ctx));
    // };
    //
    // if (policy.has_rule<Nft, personal_kiosk_rule::Rule>()) {
    //     personal_kiosk_rule::prove(account_kiosk, &mut request);
    // };
    // the request can be filled with arbitrary rules and must be confirmed afterwards
    request
}

/// Authenticated users can delist nfts
public fun delist<Config, Nft: key + store>(
    auth: Auth,
    account: &mut Account<Config>, 
    kiosk: &mut Kiosk, 
    name: String,
    nft_id: ID,
) {
    account.verify(auth);

    let cap: &KioskOwnerCap = account.borrow_managed_asset(KioskOwnerKey(name), version::current());
    kiosk.delist<Nft>(cap, nft_id);
}

/// Authenticated users can withdraw the profits to the account
public fun withdraw_profits<Config>(
    auth: Auth,
    account: &mut Account<Config>,
    kiosk: &mut Kiosk,
    name: String,
    ctx: &mut TxContext
) {
    account.verify(auth);

    let cap: &KioskOwnerCap = account.borrow_managed_asset(KioskOwnerKey(name), version::current());

    let profits_mut = kiosk.profits_mut(cap);
    let profits_value = profits_mut.value();
    let profits = profits_mut.split(profits_value);

    account.keep(coin::from_balance<SUI>(profits, ctx), ctx);
}

/// Closes the kiosk if empty
public fun close<Config>(
    auth: Auth,
    account: &mut Account<Config>,
    name: String,
    kiosk: Kiosk,
    ctx: &mut TxContext
) {
    account.verify(auth);

    let cap: KioskOwnerCap = account.remove_managed_asset(KioskOwnerKey(name), version::current());
    let profits = kiosk.close_and_withdraw(cap, ctx);
    
    account.keep(profits, ctx);
}

// === Destruction Functions ===

/// Destroy a TakeAction after serialization
public fun destroy_take_action(action: TakeAction) {
    let TakeAction { name: _, nft_id: _, recipient: _ } = action;
}

/// Destroy a ListAction after serialization
public fun destroy_list_action(action: ListAction) {
    let ListAction { name: _, nft_id: _, price: _ } = action;
}

// Intent functions

/// Creates a new TakeAction and adds it to an intent.
public fun new_take<Outcome, IW: drop>(
    intent: &mut Intent<Outcome>,
    name: String,
    nft_id: ID,
    recipient: address,
    intent_witness: IW,
) {
    // Create the action struct
    let action = TakeAction { name, nft_id, recipient };

    // Serialize it
    let action_data = bcs::to_bytes(&action);

    // Add to intent with pre-serialized bytes
    intent.add_typed_action(
        framework_action_types::kiosk_take(),
        action_data,
        intent_witness
    );

    // Explicitly destroy the action struct
    destroy_take_action(action);
}

/// Processes a TakeAction, resolves the rules and places the nft into the recipient's kiosk.
public fun do_take<Config, Outcome: store, Nft: key + store, IW: drop>(
    executable: &mut Executable<Outcome>,
    account: &mut Account<Config>,
    account_kiosk: &mut Kiosk,
    recipient_kiosk: &mut Kiosk,
    recipient_cap: &KioskOwnerCap,
    policy: &mut TransferPolicy<Nft>,
    version_witness: VersionWitness,
    _intent_witness: IW,
    ctx: &mut TxContext
): TransferRequest<Nft> {
    executable.intent().assert_is_account(account.addr());

    // Get BCS bytes from ActionSpec
    let specs = executable.intent().action_specs();
    let spec = specs.borrow(executable.action_idx());

    // CRITICAL: Assert that the action type is what we expect
    action_validation::assert_action_type<KioskTake>(spec);

    let action_data = intents::action_spec_data(spec);

    // Create BCS reader and deserialize
    let mut reader = bcs::new(*action_data);
    let name = bcs::peel_vec_u8(&mut reader).to_string();
    let nft_id = bcs::peel_address(&mut reader).to_id();
    let recipient = bcs::peel_address(&mut reader);

    assert!(recipient == ctx.sender(), EWrongReceiver);

    let cap: &KioskOwnerCap = account.borrow_managed_asset(KioskOwnerKey(name), version_witness);

    account_kiosk.list<Nft>(cap, nft_id, 0);
    let (nft, mut request) = account_kiosk.purchase<Nft>(nft_id, coin::zero<SUI>(ctx));

    // NOTE: Kiosk rule handling commented out as the kiosk dependency was removed
    // This just places the NFT in the recipient kiosk without handling specific rules
    recipient_kiosk.place(recipient_cap, nft);

    // if (policy.has_rule<Nft, kiosk_lock_rule::Rule>()) {
    //     recipient_kiosk.lock(recipient_cap, policy, nft);
    //     kiosk_lock_rule::prove(&mut request, recipient_kiosk);
    // } else {
    //     recipient_kiosk.place(recipient_cap, nft);
    // };
    //
    // if (policy.has_rule<Nft, royalty_rule::Rule>()) {
    //     royalty_rule::pay(policy, &mut request, coin::zero<SUI>(ctx));
    // };
    //
    // if (policy.has_rule<Nft, personal_kiosk_rule::Rule>()) {
    //     personal_kiosk_rule::prove(account_kiosk, &mut request);
    // };

    // Increment action index
    executable::increment_action_idx(executable);

    // the request can be filled with arbitrary rules and must be confirmed afterwards
    request
}

/// Deletes a TakeAction from an expired intent.
public fun delete_take(expired: &mut Expired) {
    let _spec = intents::remove_action_spec(expired);
    // ActionSpec has drop, automatically cleaned up
}

/// Creates a new ListAction and adds it to an intent.
public fun new_list<Outcome, IW: drop>(
    intent: &mut Intent<Outcome>,
    name: String,
    nft_id: ID,
    price: u64,
    intent_witness: IW,
) {
    // Create the action struct
    let action = ListAction { name, nft_id, price };

    // Serialize it
    let action_data = bcs::to_bytes(&action);

    // Add to intent with pre-serialized bytes
    intent.add_typed_action(
        framework_action_types::kiosk_list(),
        action_data,
        intent_witness
    );

    // Explicitly destroy the action struct
    destroy_list_action(action);
}

/// Processes a ListAction and lists the nft for purchase.
public fun do_list<Config, Outcome: store, Nft: key + store, IW: drop>(
    executable: &mut Executable<Outcome>,
    account: &mut Account<Config>,
    kiosk: &mut Kiosk,
    version_witness: VersionWitness,
    _intent_witness: IW,
) {
    executable.intent().assert_is_account(account.addr());

    // Get BCS bytes from ActionSpec
    let specs = executable.intent().action_specs();
    let spec = specs.borrow(executable.action_idx());

    // CRITICAL: Assert that the action type is what we expect
    action_validation::assert_action_type<KioskList>(spec);

    let action_data = intents::action_spec_data(spec);

    // Create BCS reader and deserialize
    let mut reader = bcs::new(*action_data);
    let name = bcs::peel_vec_u8(&mut reader).to_string();
    let nft_id = bcs::peel_address(&mut reader).to_id();
    let price = bcs::peel_u64(&mut reader);

    let cap: &KioskOwnerCap = account.borrow_managed_asset(KioskOwnerKey(name), version_witness);

    kiosk.list<Nft>(cap, nft_id, price);

    // Increment action index
    executable::increment_action_idx(executable);
}

/// Deletes a ListAction from an expired intent.
public fun delete_list(expired: &mut Expired) {
    let _spec = intents::remove_action_spec(expired);
    // ActionSpec has drop, automatically cleaned up
}

// ============================================================================
// FORK MODIFICATION NOTICE - Package Upgrade with Serialize-Then-Destroy Pattern
// ============================================================================
// This module manages UpgradeCap operations with timelock for Account.
//
// CHANGES IN THIS FORK:
// - Actions use type markers: PackageUpgrade, PackageCommit, PackageRestrict
// - Implemented serialize-then-destroy pattern for all 3 action types
// - Added destruction functions: destroy_upgrade_action, destroy_commit_action, destroy_restrict_action
// - Actions serialize to bytes before adding to intent via add_typed_action()
// - Enhanced BCS validation: version checks + validate_all_bytes_consumed
// - Type-safe action validation through compile-time TypeName comparison
// ============================================================================
/// Package managers can lock UpgradeCaps in the account. Caps can't be unlocked, this is to enforce the policies.
/// Any rule can be defined for the upgrade lock. The module provide a timelock rule by default, based on execution time.
/// Upon locking, the user can define an optional timelock corresponding to the minimum delay between an upgrade proposal and its execution.
/// The account can decide to make the policy more restrictive or destroy the Cap, to make the package immutable.

module account_actions::package_upgrade;

// === Imports ===

use std::string::String;
use sui::{
    package::{Self, UpgradeCap, UpgradeTicket, UpgradeReceipt},
    clock::Clock,
    vec_map::{Self, VecMap},
    bcs::{Self, BCS},
};
use account_protocol::{
    action_validation,
    account::{Account, Auth},
    intents::{Self, Expired, Intent},
    executable::{Self, Executable},
    version_witness::VersionWitness,
    bcs_validation,
};
use account_actions::{
    version,
};
use account_extensions::framework_action_types::{Self, PackageUpgrade, PackageCommit, PackageRestrict};

// === Use Fun Aliases ===
// Removed - add_typed_action is now called directly

// === Error ===

const ELockAlreadyExists: u64 = 0;
const EUpgradeTooEarly: u64 = 1;
const EPackageDoesntExist: u64 = 2;
const EUnsupportedActionVersion: u64 = 3;

// === Structs ===

/// Dynamic Object Field key for the UpgradeCap.
public struct UpgradeCapKey(String) has copy, drop, store;
/// Dynamic field key for the UpgradeRules.
public struct UpgradeRulesKey(String) has copy, drop, store;
/// Dynamic field key for the UpgradeIndex.
public struct UpgradeIndexKey() has copy, drop, store;

/// Dynamic field wrapper defining an optional timelock.
public struct UpgradeRules has store {
    // minimum delay between proposal and execution
    delay_ms: u64,
} 

/// Map tracking the latest upgraded package address for a package name.
public struct UpgradeIndex has store {
    // map of package name to address
    packages_info: VecMap<String, address>,
}

/// Action to upgrade a package using a locked UpgradeCap.
public struct UpgradeAction has drop, store {
    // name of the package
    name: String,
    // digest of the package build we want to publish
    digest: vector<u8>,
}
/// Action to commit an upgrade.
public struct CommitAction has drop, store {
    // name of the package
    name: String,
}
/// Action to restrict the policy of a locked UpgradeCap.
public struct RestrictAction has drop, store {
    // name of the package
    name: String,
    // downgrades to this policy
    policy: u8,
}

// === Public Functions ===

/// Attaches the UpgradeCap as a Dynamic Object Field to the account.
public fun lock_cap<Config>(
    auth: Auth,
    account: &mut Account<Config>,
    cap: UpgradeCap,
    name: String, // name of the package
    delay_ms: u64, // minimum delay between proposal and execution
) {
    account.verify(auth);
    assert!(!has_cap(account, name), ELockAlreadyExists);

    if (!account.has_managed_data(UpgradeIndexKey()))
        account.add_managed_data(UpgradeIndexKey(), UpgradeIndex { packages_info: vec_map::empty() }, version::current());

    let upgrade_index_mut: &mut UpgradeIndex = account.borrow_managed_data_mut(UpgradeIndexKey(), version::current());
    upgrade_index_mut.packages_info.insert(name, cap.package().to_address());
    
    account.add_managed_asset(UpgradeCapKey(name), cap, version::current());
    account.add_managed_data(UpgradeRulesKey(name), UpgradeRules { delay_ms }, version::current());
}

/// Lock upgrade cap during initialization - works on unshared Accounts
/// This function is for use during account creation, before the account is shared.
///
/// ## FORK NOTE
/// **Added**: `do_lock_cap_unshared()` for init-time UpgradeCap management
/// **Reason**: Allow DAOs to lock package UpgradeCaps during atomic initialization,
/// establishing controlled upgrade governance from creation. Sets upgrade delay rules.
/// **Safety**: `public(package)` visibility ensures only callable during init
public(package) fun do_lock_cap_unshared<Config>(
    account: &mut Account<Config>,
    cap: UpgradeCap,
    name: String,
    delay_ms: u64,
) {
    assert!(!has_cap(account, name), ELockAlreadyExists);

    if (!account.has_managed_data(UpgradeIndexKey()))
        account.add_managed_data(UpgradeIndexKey(), UpgradeIndex { packages_info: vec_map::empty() }, version::current());

    let upgrade_index_mut: &mut UpgradeIndex = account.borrow_managed_data_mut(UpgradeIndexKey(), version::current());
    upgrade_index_mut.packages_info.insert(name, cap.package().to_address());

    account.add_managed_asset(UpgradeCapKey(name), cap, version::current());
    account.add_managed_data(UpgradeRulesKey(name), UpgradeRules { delay_ms }, version::current());
}

/// Returns true if the account has an UpgradeCap for a given package name.
public fun has_cap<Config>(
    account: &Account<Config>, 
    name: String
): bool {
    account.has_managed_asset(UpgradeCapKey(name))
}

/// Returns the address of the package for a given package name.
public fun get_cap_package<Config>(
    account: &Account<Config>, 
    name: String
): address {
    account.borrow_managed_asset<_, _, UpgradeCap>(UpgradeCapKey(name), version::current()).package().to_address()
} 

/// Returns the version of the UpgradeCap for a given package name.
public fun get_cap_version<Config>(
    account: &Account<Config>, 
    name: String
): u64 {
    account.borrow_managed_asset<_, _, UpgradeCap>(UpgradeCapKey(name), version::current()).version()
} 

/// Returns the policy of the UpgradeCap for a given package name.
public fun get_cap_policy<Config>(
    account: &Account<Config>, 
    name: String
): u8 {
    account.borrow_managed_asset<_, _, UpgradeCap>(UpgradeCapKey(name), version::current()).policy()
} 

/// Returns the timelock of the UpgradeRules for a given package name.
public fun get_time_delay<Config>(
    account: &Account<Config>, 
    name: String
): u64 {
    account.borrow_managed_data<_, _, UpgradeRules>(UpgradeRulesKey(name), version::current()).delay_ms
}

/// Returns the map of package names to package addresses.
public fun get_packages_info<Config>(
    account: &Account<Config>
): &VecMap<String, address> {
    &account.borrow_managed_data<_, _, UpgradeIndex>(UpgradeIndexKey(), version::current()).packages_info
}

/// Returns true if the package is managed by the account.
public fun is_package_managed<Config>(
    account: &Account<Config>,
    package_addr: address
): bool {
    if (!account.has_managed_data(UpgradeIndexKey())) return false;
    let index: &UpgradeIndex = account.borrow_managed_data(UpgradeIndexKey(), version::current());
    
    let mut i = 0;
    while (i < index.packages_info.length()) {
        let (_, value) = index.packages_info.get_entry_by_idx(i);
        if (value == package_addr) return true;
        i = i + 1;
    };

    false
}

/// Returns the address of the package for a given package name.
public fun get_package_addr<Config>(
    account: &Account<Config>,
    package_name: String
): address {
    let index: &UpgradeIndex = account.borrow_managed_data(UpgradeIndexKey(), version::current());
    *index.packages_info.get(&package_name)
}

/// Returns the package name for a given package address.
#[allow(unused_assignment)] // false positive
public fun get_package_name<Config>(
    account: &Account<Config>,
    package_addr: address
): String {
    let index: &UpgradeIndex = account.borrow_managed_data(UpgradeIndexKey(), version::current());
    let (mut i, mut package_name) = (0, b"".to_string());
    loop {
        let (name, addr) = index.packages_info.get_entry_by_idx(i);
        package_name = *name;
        if (addr == package_addr) break package_name;
        
        i = i + 1;
        if (i == index.packages_info.length()) abort EPackageDoesntExist;
    };
    
    package_name
}

// === Destruction Functions ===

/// Destroy an UpgradeAction after serialization
public fun destroy_upgrade_action(action: UpgradeAction) {
    let UpgradeAction { name: _, digest: _ } = action;
}

/// Destroy a CommitAction after serialization
public fun destroy_commit_action(action: CommitAction) {
    let CommitAction { name: _ } = action;
}

/// Destroy a RestrictAction after serialization
public fun destroy_restrict_action(action: RestrictAction) {
    let RestrictAction { name: _, policy: _ } = action;
}

// Intent functions

/// Creates a new UpgradeAction and adds it to an intent.
public fun new_upgrade<Outcome, IW: drop>(
    intent: &mut Intent<Outcome>,
    name: String,
    digest: vector<u8>,
    intent_witness: IW,
) {
    // Create the action struct
    let action = UpgradeAction { name, digest };

    // Serialize it
    let action_data = bcs::to_bytes(&action);

    // Add to intent with pre-serialized bytes
    intent.add_typed_action(
        framework_action_types::package_upgrade(),
        action_data,
        intent_witness
    );

    // Explicitly destroy the action struct
    destroy_upgrade_action(action);
}    

/// Processes an UpgradeAction and returns a UpgradeTicket.
public fun do_upgrade<Config, Outcome: store, IW: drop>(
    executable: &mut Executable<Outcome>,
    account: &mut Account<Config>,
    clock: &Clock,
    version_witness: VersionWitness,
    _intent_witness: IW,
): UpgradeTicket {
    executable.intent().assert_is_account(account.addr());

    // Get BCS bytes from ActionSpec
    let specs = executable.intent().action_specs();
    let spec = specs.borrow(executable.action_idx());

    // CRITICAL: Assert that the action type is what we expect
    action_validation::assert_action_type<PackageUpgrade>(spec);

    let action_data = intents::action_spec_data(spec);

    // Check version before deserialization
    let spec_version = intents::action_spec_version(spec);
    assert!(spec_version == 1, EUnsupportedActionVersion);

    // Create BCS reader and deserialize
    let mut reader = bcs::new(*action_data);
    let name = bcs::peel_vec_u8(&mut reader).to_string();
    let digest = bcs::peel_vec_u8(&mut reader);

    // Validate all bytes consumed
    bcs_validation::validate_all_bytes_consumed(reader);

    assert!(
        clock.timestamp_ms() >= executable.intent().creation_time() + get_time_delay(account, name),
        EUpgradeTooEarly
    );

    let cap: &mut UpgradeCap = account.borrow_managed_asset_mut(UpgradeCapKey(name), version_witness);
    let policy = cap.policy();

    // Increment action index
    executable::increment_action_idx(executable);

    cap.authorize_upgrade(policy, digest) // return ticket
}    

/// Deletes an UpgradeAction from an expired intent.
public fun delete_upgrade(expired: &mut Expired) {
    let _spec = intents::remove_action_spec(expired);
    // ActionSpec has drop, automatically cleaned up
}

/// Creates a new CommitAction and adds it to an intent.
public fun new_commit<Outcome, IW: drop>(
    intent: &mut Intent<Outcome>,
    name: String,
    intent_witness: IW,
) {
    // Create the action struct
    let action = CommitAction { name };

    // Serialize it
    let action_data = bcs::to_bytes(&action);

    // Add to intent with pre-serialized bytes
    intent.add_typed_action(
        framework_action_types::package_commit(),
        action_data,
        intent_witness
    );

    // Explicitly destroy the action struct
    destroy_commit_action(action);
}    

// must be called after UpgradeAction is processed, there cannot be any other action processed before
/// Commits an upgrade and updates the index with the new package address.
public fun do_commit<Config, Outcome: store, IW: drop>(
    executable: &mut Executable<Outcome>,
    account: &mut Account<Config>,
    receipt: UpgradeReceipt,
    version_witness: VersionWitness,
    _intent_witness: IW,
) {
    executable.intent().assert_is_account(account.addr());

    // Get BCS bytes from ActionSpec
    let specs = executable.intent().action_specs();
    let spec = specs.borrow(executable.action_idx());

    // CRITICAL: Assert that the action type is what we expect
    action_validation::assert_action_type<PackageCommit>(spec);

    let action_data = intents::action_spec_data(spec);

    // Check version before deserialization
    let spec_version = intents::action_spec_version(spec);
    assert!(spec_version == 1, EUnsupportedActionVersion);

    // Create BCS reader and deserialize
    let mut reader = bcs::new(*action_data);
    let name = bcs::peel_vec_u8(&mut reader).to_string();

    // Validate all bytes consumed
    bcs_validation::validate_all_bytes_consumed(reader);

    let cap_mut: &mut UpgradeCap = account.borrow_managed_asset_mut(UpgradeCapKey(name), version_witness);
    cap_mut.commit_upgrade(receipt);
    let new_package_addr = cap_mut.package().to_address();

    // update the index with the new package address
    let index_mut: &mut UpgradeIndex = account.borrow_managed_data_mut(UpgradeIndexKey(), version_witness);
    *index_mut.packages_info.get_mut(&name) = new_package_addr;

    // Increment action index
    executable::increment_action_idx(executable);
}

public fun delete_commit(expired: &mut Expired) {
    let _spec = intents::remove_action_spec(expired);
    // ActionSpec has drop, automatically cleaned up
}

/// Creates a new RestrictAction and adds it to an intent.
public fun new_restrict<Outcome, IW: drop>(
    intent: &mut Intent<Outcome>,
    name: String,
    policy: u8,
    intent_witness: IW,
) {
    // Create the action struct
    let action = RestrictAction { name, policy };

    // Serialize it
    let action_data = bcs::to_bytes(&action);

    // Add to intent with pre-serialized bytes
    intent.add_typed_action(
        framework_action_types::package_restrict(),
        action_data,
        intent_witness
    );

    // Explicitly destroy the action struct
    destroy_restrict_action(action);
}    

/// Processes a RestrictAction and updates the UpgradeCap policy.
public fun do_restrict<Config, Outcome: store, IW: drop>(
    executable: &mut Executable<Outcome>,
    account: &mut Account<Config>,
    version_witness: VersionWitness,
    _intent_witness: IW,
) {
    executable.intent().assert_is_account(account.addr());

    // Get BCS bytes from ActionSpec
    let specs = executable.intent().action_specs();
    let spec = specs.borrow(executable.action_idx());

    // CRITICAL: Assert that the action type is what we expect
    action_validation::assert_action_type<PackageRestrict>(spec);

    let action_data = intents::action_spec_data(spec);

    // Check version before deserialization
    let spec_version = intents::action_spec_version(spec);
    assert!(spec_version == 1, EUnsupportedActionVersion);

    // Create BCS reader and deserialize
    let mut reader = bcs::new(*action_data);
    let name = bcs::peel_vec_u8(&mut reader).to_string();
    let policy = bcs::peel_u8(&mut reader);

    // Validate all bytes consumed
    bcs_validation::validate_all_bytes_consumed(reader);

    if (policy == package::additive_policy()) {
        let cap_mut: &mut UpgradeCap = account.borrow_managed_asset_mut(UpgradeCapKey(name), version_witness);
        cap_mut.only_additive_upgrades();
    } else if (policy == package::dep_only_policy()) {
        let cap_mut: &mut UpgradeCap = account.borrow_managed_asset_mut(UpgradeCapKey(name), version_witness);
        cap_mut.only_dep_upgrades();
    } else {
        let cap: UpgradeCap = account.remove_managed_asset(UpgradeCapKey(name), version_witness);
        package::make_immutable(cap);
    };

    // Increment action index
    executable::increment_action_idx(executable);
}

/// Deletes a RestrictAction from an expired intent.
public fun delete_restrict(expired: &mut Expired) {
    let _spec = intents::remove_action_spec(expired);
    // ActionSpec has drop, automatically cleaned up
}

// === Package Funtions ===

/// Borrows the UpgradeCap for a given package address.
public(package) fun borrow_cap<Config>(
    account: &Account<Config>, 
    package_addr: address
): &UpgradeCap {
    let name = get_package_name(account, package_addr);
    account.borrow_managed_asset(UpgradeCapKey(name), version::current())
}
/// Common utilities for time-based streaming/vesting functionality.
/// Shared between vault streams and vesting modules to avoid duplication.
///
/// === Fork Addition (BSL 1.1 Licensed) ===
/// Created to consolidate common logic for streaming/vesting calculations.
/// This module was added to the original Move framework to:
/// 1. Eliminate code duplication between vault.move and vesting.move
/// 2. Provide consistent vesting math across all time-based payment features
/// 3. Enable future modules to leverage tested streaming calculations
/// 4. Support advanced features like cliff periods, pausing, and rate limiting
///
/// Key shared functionality:
/// - Linear vesting calculations with overflow protection
/// - Cliff period support for delayed vesting starts
/// - Pause duration tracking for accurate vesting adjustments
/// - Rate limiting checks for withdrawal protection
/// - Effective time calculations accounting for pauses
/// - Vested/unvested split calculations for cancellations
///
/// This enables both vault streams and standalone vestings to have:
/// - Consistent mathematical accuracy
/// - Shared security validations
/// - Unified approach to time-based fund releases

module account_actions::stream_utils;

use std::u128;

// === Imports ===

// === Constants ===
//
// UPGRADABLE CONSTANT PATTERN:
// These constants are defined here in the framework for backwards compatibility,
// but the canonical source is futarchy_one_shot_utils::constants.
//
// To upgrade these values:
// 1. Update futarchy_one_shot_utils::constants::max_beneficiaries()
// 2. Deploy new version of futarchy_one_shot_utils
// 3. All dependent packages inherit new limits on next deployment
//
// This pattern allows system-wide configuration updates without modifying
// the framework package, enabling DAOs to adjust limits via governance.

public fun max_beneficiaries(): u64 { 100 }

// === Vesting Calculation Functions ===

/// Calculates linearly vested amount based on time elapsed
public fun calculate_linear_vested(
    total_amount: u64,
    start_time: u64,
    end_time: u64,
    current_time: u64,
): u64 {
    if (current_time < start_time) return 0;
    if (current_time >= end_time) return total_amount;

    let duration = end_time - start_time;
    let elapsed = current_time - start_time;

    // Use u128 to prevent overflow in multiplication
    let vested = (total_amount as u128) * (elapsed as u128) / (duration as u128);
    (vested as u64)
}

/// Calculates vested amount with cliff period
public fun calculate_vested_with_cliff(
    total_amount: u64,
    start_time: u64,
    end_time: u64,
    cliff_time: u64,
    current_time: u64,
): u64 {
    // Nothing vests before cliff
    if (current_time < cliff_time) return 0;

    // After cliff, calculate linear vesting
    calculate_linear_vested(total_amount, start_time, end_time, current_time)
}

/// Calculates effective time accounting for pause duration
public fun calculate_effective_time(current_time: u64, end_time: u64, paused_duration: u64): u64 {
    let effective_end = end_time + paused_duration;
    if (current_time > effective_end) {
        effective_end
    } else {
        current_time
    }
}

/// Validates stream/vesting parameters
public fun validate_time_parameters(
    start_time: u64,
    end_time: u64,
    cliff_time_opt: &Option<u64>,
    current_time: u64,
): bool {
    // End must be after start
    if (end_time <= start_time) return false;

    // Start must be in future or present
    if (start_time < current_time) return false;

    // If cliff exists, must be between start and end
    if (cliff_time_opt.is_some()) {
        let cliff = *cliff_time_opt.borrow();
        if (cliff < start_time || cliff > end_time) return false;
    };

    true
}

/// Calculates pause duration between two timestamps
public fun calculate_pause_duration(paused_at: u64, resumed_at: u64): u64 {
    if (resumed_at > paused_at) {
        resumed_at - paused_at
    } else {
        0
    }
}

/// Checks if withdrawal respects rate limiting
public fun check_rate_limit(
    last_withdrawal_time: u64,
    min_interval_ms: u64,
    current_time: u64,
): bool {
    if (min_interval_ms == 0 || last_withdrawal_time == 0) {
        true
    } else {
        current_time >= last_withdrawal_time + min_interval_ms
    }
}

/// Checks if withdrawal amount respects maximum limit
public fun check_withdrawal_limit(amount: u64, max_per_withdrawal: u64): bool {
    if (max_per_withdrawal == 0) {
        true
    } else {
        amount <= max_per_withdrawal
    }
}

/// Calculates available amount to claim
public fun calculate_claimable(
    total_amount: u64,
    claimed_amount: u64,
    start_time: u64,
    end_time: u64,
    current_time: u64,
    paused_duration: u64,
    cliff_time_opt: &Option<u64>,
): u64 {
    let effective_time = calculate_effective_time(
        current_time,
        end_time,
        paused_duration,
    );

    let vested = if (cliff_time_opt.is_some()) {
        calculate_vested_with_cliff(
            total_amount,
            start_time,
            end_time + paused_duration,
            *cliff_time_opt.borrow(),
            effective_time,
        )
    } else {
        calculate_linear_vested(
            total_amount,
            start_time,
            end_time + paused_duration,
            effective_time,
        )
    };

    if (vested > claimed_amount) {
        vested - claimed_amount
    } else {
        0
    }
}

/// Splits vested and unvested amounts for cancellation
public fun split_vested_unvested(
    total_amount: u64,
    claimed_amount: u64,
    balance_remaining: u64,
    start_time: u64,
    end_time: u64,
    current_time: u64,
    paused_duration: u64,
    cliff_time_opt: &Option<u64>,
): (u64, u64, u64) {
    let effective_time = calculate_effective_time(
        current_time,
        end_time,
        paused_duration,
    );

    let vested = if (cliff_time_opt.is_some()) {
        calculate_vested_with_cliff(
            total_amount,
            start_time,
            end_time + paused_duration,
            *cliff_time_opt.borrow(),
            effective_time,
        )
    } else {
        calculate_linear_vested(
            total_amount,
            start_time,
            end_time + paused_duration,
            effective_time,
        )
    };

    // Calculate amounts
    let unvested_claimed = if (claimed_amount > vested) {
        claimed_amount - vested
    } else {
        0
    };

    let to_pay_beneficiary = if (vested > claimed_amount) {
        let owed = vested - claimed_amount;
        if (owed > balance_remaining) {
            balance_remaining
        } else {
            owed
        }
    } else {
        0
    };

    let to_refund = if (balance_remaining > to_pay_beneficiary) {
        balance_remaining - to_pay_beneficiary
    } else {
        0
    };

    (to_pay_beneficiary, to_refund, unvested_claimed)
}

// === Pause Control Helpers ===

/// Calculate pause_until timestamp for timed pause
/// Returns None for indefinite pause (pause_duration_ms == 0)
public fun calculate_pause_until(current_time: u64, pause_duration_ms: u64): Option<u64> {
    if (pause_duration_ms == 0) {
        std::option::none() // Indefinite pause
    } else {
        // Safe addition - caller should validate overflow
        std::option::some(current_time + pause_duration_ms)
    }
}

/// Check if timed pause has expired
public fun is_pause_expired(paused_until_opt: &Option<u64>, current_time: u64): bool {
    if (paused_until_opt.is_none()) {
        false // Indefinite pause - never expires
    } else {
        current_time >= *paused_until_opt.borrow()
    }
}

/// Validate pause duration doesn't overflow
public fun validate_pause_duration(current_time: u64, pause_duration_ms: u64): bool {
    if (pause_duration_ms == 0) {
        true // Indefinite pause is valid
    } else {
        let pause_until = current_time + pause_duration_ms;
        pause_until > current_time // Check for overflow
    }
}

// === Expiry Helpers ===

/// Check if stream/vesting has expired
public fun is_expired(expiry_opt: &Option<u64>, current_time: u64): bool {
    if (expiry_opt.is_none()) {
        false // No expiry
    } else {
        current_time >= *expiry_opt.borrow()
    }
}

/// Validate expiry is in the future
public fun validate_expiry(current_time: u64, expiry_timestamp: u64): bool {
    expiry_timestamp > current_time
}

// === State Check Helpers ===

/// Check if claiming is allowed (not paused, not frozen, not expired)
public fun can_claim(
    is_paused: bool,
    is_frozen: bool,
    expiry_opt: &Option<u64>,
    current_time: u64,
): bool {
    if (is_paused || is_frozen) {
        return false
    };
    !is_expired(expiry_opt, current_time)
}

/// Calculate next vesting timestamp
public fun next_vesting_time(
    start_time: u64,
    end_time: u64,
    cliff_time_opt: &Option<u64>,
    expiry_opt: &Option<u64>,
    current_time: u64,
): Option<u64> {
    // Check expiry first
    if (is_expired(expiry_opt, current_time)) {
        return std::option::none()
    };

    // If before cliff, next vest is cliff time
    if (cliff_time_opt.is_some()) {
        let cliff = *cliff_time_opt.borrow();
        if (current_time < cliff) {
            return std::option::some(cliff)
        };
    };

    // If after end, no more vesting
    if (current_time >= end_time) {
        return std::option::none()
    };

    // Linear vesting - always vesting now
    std::option::some(current_time)
}

// === Test Helpers ===

#[test_only]
public fun test_linear_vesting() {
    // Test before start
    assert!(calculate_linear_vested(1000, 100, 200, 50) == 0);

    // Test at start
    assert!(calculate_linear_vested(1000, 100, 200, 100) == 0);

    // Test halfway
    assert!(calculate_linear_vested(1000, 100, 200, 150) == 500);

    // Test at end
    assert!(calculate_linear_vested(1000, 100, 200, 200) == 1000);

    // Test after end
    assert!(calculate_linear_vested(1000, 100, 200, 250) == 1000);
}

#[test_only]
public fun test_cliff_vesting() {
    // Test before cliff
    assert!(calculate_vested_with_cliff(1000, 100, 200, 130, 120) == 0);

    // Test at cliff
    assert!(calculate_vested_with_cliff(1000, 100, 200, 130, 130) == 300);

    // Test after cliff
    assert!(calculate_vested_with_cliff(1000, 100, 200, 130, 150) == 500);
}

#[test_only]
public fun test_effective_time() {
    // Test no pause
    assert!(calculate_effective_time(150, 200, 0) == 150);

    // Test with pause, before adjusted end
    assert!(calculate_effective_time(150, 200, 50) == 150);

    // Test with pause, after adjusted end
    assert!(calculate_effective_time(300, 200, 50) == 250);
}
// ============================================================================
// FORK MODIFICATION NOTICE - Vault Management with Serialize-Then-Destroy Pattern
// ============================================================================
// This module manages multi-vault treasury operations with streaming support.
//
// CHANGES IN THIS FORK:
// - Actions use type markers: VaultDeposit, VaultSpend
// - Implemented serialize-then-destroy pattern for resource safety
// - Added destruction functions for all action structs
// - Actions serialize to bytes before adding to intent via add_typed_action()
// - Enhanced BCS validation: version checks + validate_all_bytes_consumed
// - Type-safe action validation through compile-time TypeName comparison
// - REMOVED ExecutionContext - PTBs handle object flow naturally
// ============================================================================
/// Members can create multiple vaults with different balances and managers (using roles).
/// This allows for a more flexible and granular way to manage funds.
///
/// === Fork Modifications (BSL 1.1 Licensed) ===
/// Enhanced vault module with comprehensive streaming functionality:
/// - Added generic stream management capabilities:
///   * Multiple beneficiaries support (primary + additional)
///   * Pause/resume functionality with duration tracking
///   * Stream metadata for extensibility
///   * Transferability and cancellability settings
///   * Beneficiary management (add/remove/transfer)
///   * Amount reduction capability
/// - Maintains backward compatibility with existing vault operations
/// - Enables other modules to build on top without duplicating stream state
/// - VaultStream: Time-based streaming with rate limiting for controlled treasury withdrawals
/// - Permissionless deposits: Anyone can add to existing coin types (enables revenue/donations)
/// - Stream management: Create, withdraw from, and cancel streams with proper vesting math
/// - All funds remain in vault until withdrawn (no separate vesting objects)
///
/// === Integration with Shared Utilities ===
/// As of the latest refactor, vault streams now use the shared stream_utils module
/// for all vesting calculations. This ensures:
/// - Consistent math with standalone vesting module
/// - Reduced code duplication and maintenance burden
/// - Unified approach to time-based fund releases
/// - Shared security validations and overflow protection
///
/// Note: The vesting.move module has been restored and enhanced to provide
/// standalone vesting functionality. Vault streams are for treasury-managed
/// streaming payments, while vestings are for independent token locks.
///
/// These changes enable DAOs to:
/// 1. Grant time-limited treasury access without full custody
/// 2. Implement salary/grant payments that vest over time
/// 3. Accept permissionless revenue deposits from protocols
/// 4. Enforce withdrawal limits and cooling periods for security
/// 5. Choose between vault-managed streams or standalone vestings

module account_actions::vault;

// === Imports ===

use std::{
    string::String,
    type_name::{Self, TypeName},
    option::Option,
    u128,
    u64,
};
use sui::{
    bag::{Self, Bag},
    balance::Balance,
    coin::{Self, Coin},
    table::{Self, Table},
    clock::Clock,
    event,
    object::{Self, ID},
    transfer,
    tx_context,
    vec_map::{Self, VecMap},
    vec_set::{Self, VecSet},
    bcs,
};
use account_protocol::{
    account::{Self, Account, Auth},
    intents::{Self, Expired, Intent},
    executable::{Self, Executable},
    version_witness::VersionWitness,
    bcs_validation,
    action_validation,
};
use account_actions::{version, stream_utils};
use account_extensions::framework_action_types::{Self, VaultDeposit, VaultSpend};

// === Use Fun Aliases ===
// Removed - add_typed_action is now called directly

// === Errors ===

const EVaultNotEmpty: u64 = 0;
const EStreamNotFound: u64 = 1;
const EStreamNotStarted: u64 = 2;
const EStreamCliffNotReached: u64 = 3;
const EUnauthorizedBeneficiary: u64 = 4;
const EWrongCoinType: u64 = 5;
const EWithdrawalLimitExceeded: u64 = 6;
const EWithdrawalTooSoon: u64 = 7;
const EInsufficientVestedAmount: u64 = 8;
const EInvalidStreamParameters: u64 = 9;
const EIntentAmountMismatch: u64 = 10;
// === Fork additions ===
const EStreamPaused: u64 = 11;
const EAmountMustBeGreaterThanZero: u64 = 20;
const EVaultDoesNotExist: u64 = 21;
const ECoinTypeDoesNotExist: u64 = 22;
const EInsufficientBalance: u64 = 23;
const EStreamNotPaused: u64 = 12;
const ENotTransferable: u64 = 13;
const ENotCancellable: u64 = 14;
const EBeneficiaryAlreadyExists: u64 = 15;
const EBeneficiaryNotFound: u64 = 16;
const EUnsupportedActionVersion: u64 = 17;
const ECannotReduceBelowClaimed: u64 = 18;
const ETooManyBeneficiaries: u64 = 19;
const ETimeCalculationOverflow: u64 = 24;
const EVestingPaused: u64 = 25;  // Reusing vesting error code for stream pause
const EEmergencyFrozen: u64 = 26;
const EVestingNotPaused: u64 = 27;

// === Structs ===

/// Dynamic Field key for the Vault.
public struct VaultKey(String) has copy, drop, store;
/// Dynamic field holding a budget with different coin types, key is name
public struct Vault has store {
    // heterogeneous array of Balances, TypeName -> Balance<CoinType>
    bag: Bag,
    // streams for time-based vesting withdrawals
    streams: Table<ID, VaultStream>,
}

/// Stream for time-based vesting from vault
/// === Fork Enhancement ===
/// Added generic stream management features:
/// - Multiple beneficiaries support
/// - Stream pausing/resuming
/// - Metadata for extensibility
/// - Transfer and reduction capabilities
public struct VaultStream has store, drop {
    id: ID,
    coin_type: TypeName,
    beneficiary: address,  // Primary beneficiary
    // Core vesting parameters
    total_amount: u64,
    claimed_amount: u64,
    start_time: u64,
    end_time: u64,
    cliff_time: Option<u64>,
    // Rate limiting
    max_per_withdrawal: u64,
    min_interval_ms: u64,
    last_withdrawal_time: u64,
    // === Fork additions for generic stream management ===
    // Multiple beneficiaries support
    additional_beneficiaries: vector<address>,
    max_beneficiaries: u64,  // Configurable per stream
    // Pause functionality
    is_paused: bool,
    paused_at: Option<u64>,
    paused_until: Option<u64>,  // None = indefinite, Some(ts) = pause until timestamp
    paused_duration: u64,  // Total time paused (affects vesting calculation)
    emergency_frozen: bool,  // If true, even unpause won't work
    // Expiry
    expiry_timestamp: Option<u64>,  // Stream becomes invalid after this time
    // Metadata for extensibility
    metadata: Option<String>,
    // Transfer settings
    is_transferable: bool,
    is_cancellable: bool,
}

// === Fork: Event Structs for Stream Operations ===

/// Emitted when a stream is created
public struct StreamCreated has copy, drop {
    stream_id: ID,
    beneficiary: address,
    total_amount: u64,
    coin_type: TypeName,
    start_time: u64,
    end_time: u64,
}

/// Emitted when funds are withdrawn from a stream
public struct StreamWithdrawal has copy, drop {
    stream_id: ID,
    beneficiary: address,
    amount: u64,
    remaining_vested: u64,
}

/// Emitted when a stream is cancelled
public struct StreamCancelled has copy, drop {
    stream_id: ID,
    refunded_amount: u64,
    final_payment: u64,
}

/// Emitted when a stream is paused
public struct StreamPaused has copy, drop {
    stream_id: ID,
    paused_at: u64,
}

/// Emitted when a stream is resumed
public struct StreamResumed has copy, drop {
    stream_id: ID,
    resumed_at: u64,
    pause_duration: u64,
}

/// Emitted when a beneficiary is added
public struct BeneficiaryAdded has copy, drop {
    stream_id: ID,
    new_beneficiary: address,
}

/// Emitted when a beneficiary is removed
public struct BeneficiaryRemoved has copy, drop {
    stream_id: ID,
    removed_beneficiary: address,
}

/// Emitted when a stream is transferred
public struct StreamTransferred has copy, drop {
    stream_id: ID,
    old_beneficiary: address,
    new_beneficiary: address,
}

/// Emitted when stream metadata is updated
public struct StreamMetadataUpdated has copy, drop {
    stream_id: ID,
}

/// Emitted when stream amount is reduced
public struct StreamAmountReduced has copy, drop {
    stream_id: ID,
    old_amount: u64,
    new_amount: u64,
}

/// Emitted when a stream is emergency frozen
public struct StreamFrozen has copy, drop {
    stream_id: ID,
    timestamp: u64,
}

/// Emitted when emergency freeze is removed
public struct StreamUnfrozen has copy, drop {
    stream_id: ID,
    timestamp: u64,
}

/// Action to deposit an amount of this coin to the targeted Vault.
public struct DepositAction<phantom CoinType> has store, drop {
    // vault name
    name: String,
    // exact amount to be deposited
    amount: u64,
}
/// Action to be used within intent making good use of the returned coin, similar to owned::withdraw.
public struct SpendAction<phantom CoinType> has store, drop {
    // vault name
    name: String,
    // amount to withdraw
    amount: u64,
}

/// Action for toggling stream pause (combines pause/resume)
public struct ToggleStreamPauseAction has store {
    vault_name: String,
    stream_id: ID,
    pause_duration_ms: u64, // 0 = unpause, >0 = pause for duration
}

/// Action for toggling emergency freeze (combines freeze/unfreeze)
public struct ToggleStreamFreezeAction has store {
    vault_name: String,
    stream_id: ID,
    freeze: bool, // true = freeze, false = unfreeze
}

// === Public Functions ===

/// Authorized address can open a vault.
public fun open<Config>(
    auth: Auth,
    account: &mut Account<Config>,
    name: String,
    ctx: &mut TxContext
) {
    account.verify(auth);

    account.add_managed_data(VaultKey(name), Vault {
        bag: bag::new(ctx),
        streams: table::new(ctx),
    }, version::current());
}

/// Deposits coins owned by a an authorized address into a vault.
public fun deposit<Config, CoinType: drop>(
    auth: Auth,
    account: &mut Account<Config>,
    name: String, 
    coin: Coin<CoinType>, 
) {
    account.verify(auth);

    let vault: &mut Vault = 
        account.borrow_managed_data_mut(VaultKey(name), version::current());

    if (vault.coin_type_exists<CoinType>()) {
        let balance_mut = vault.bag.borrow_mut<_, Balance<_>>(type_name::with_defining_ids<CoinType>());
        balance_mut.join(coin.into_balance());
    } else {
        vault.bag.add(type_name::with_defining_ids<CoinType>(), coin.into_balance());
    };
}

/// Permissionless deposit - anyone can add to existing coin types
/// Safe because it only increases DAO assets, never decreases
public fun deposit_permissionless<Config, CoinType: drop>(
    account: &mut Account<Config>,
    name: String,
    coin: Coin<CoinType>,
) {
    let vault: &mut Vault =
        account.borrow_managed_data_mut(VaultKey(name), version::current());

    // Only allow deposits to existing coin types
    assert!(coin_type_exists<CoinType>(vault), EWrongCoinType);

    let balance_mut = vault.bag.borrow_mut<_, Balance<_>>(type_name::with_defining_ids<CoinType>());
    balance_mut.join(coin.into_balance());
}

/// Withdraws coins from a vault with authorization.
/// This is the Auth-based counterpart to `deposit`, used for direct withdrawals
/// outside of intent execution (e.g., for liquidity subsidy escrow funding).
///
/// ## FORK NOTE
/// **Added**: `spend()` for Auth-based vault withdrawals
/// **Reason**: Enable direct coin withdrawal from vault for subsidy integration and other
/// use cases that need vault access outside intent execution flow.
/// **Complements**: Existing `deposit()` function for symmetric Auth-based vault API
public fun spend<Config, CoinType: drop>(
    auth: Auth,
    account: &mut Account<Config>,
    name: String,
    amount: u64,
    ctx: &mut TxContext,
): Coin<CoinType> {
    account.verify(auth);

    let vault: &mut Vault =
        account.borrow_managed_data_mut(VaultKey(name), version::current());

    // Ensure coin type exists in vault
    assert!(vault.coin_type_exists<CoinType>(), EWrongCoinType);

    // Withdraw from balance
    let balance_mut = vault.bag.borrow_mut<_, Balance<_>>(type_name::with_defining_ids<CoinType>());
    assert!(balance_mut.value() >= amount, EInsufficientBalance);

    let coin = coin::take(balance_mut, amount, ctx);

    // Clean up empty balance if needed
    if (balance_mut.value() == 0) {
        vault.bag.remove<_, Balance<CoinType>>(type_name::with_defining_ids<CoinType>()).destroy_zero();
    };

    coin
}

/// Returns the balance of a specific coin type in a vault.
/// Convenience function that combines vault existence check with balance lookup.
///
/// ## FORK NOTE
/// **Added**: `balance()` for checking vault coin balances
/// **Reason**: Simplify balance checks before withdrawing (e.g., for subsidy funding)
/// **Returns**: Balance amount, or 0 if vault doesn't exist or doesn't have the coin type
public fun balance<Config, CoinType: drop>(
    account: &Account<Config>,
    name: String,
): u64 {
    if (!has_vault(account, name)) {
        return 0
    };

    let vault: &Vault = account.borrow_managed_data(VaultKey(name), version::current());

    if (!coin_type_exists<CoinType>(vault)) {
        return 0
    };

    coin_type_value<CoinType>(vault)
}

/// Default vault name for standard operations
///
/// ## FORK NOTE
/// **Added**: Helper function for consistent vault naming
/// **Reason**: Standardize default vault name across init and runtime operations
public fun default_vault_name(): String {
    std::string::utf8(b"Main Vault")
}

/// Deposit during initialization - works on unshared Accounts
/// This function is for use during account creation, before the account is shared.
/// It follows the same pattern as Futarchy init actions.
///
/// ## FORK NOTE
/// **Added**: `do_deposit_unshared()` for init-time vault deposits
/// **Reason**: Enable initial treasury funding during DAO creation without Auth checks.
/// Creates vault on-demand if it doesn't exist, then deposits coins.
/// **Safety**: `public(package)` visibility ensures only callable during init
///
/// SAFETY: This function MUST only be called on unshared Accounts.
/// Calling this on a shared Account bypasses Auth checks.
/// The package(package) visibility helps enforce this constraint.
public(package) fun do_deposit_unshared<Config, CoinType: drop>(
    account: &mut Account<Config>,
    name: String,
    coin: Coin<CoinType>,
    ctx: &mut tx_context::TxContext,
) {
    // SAFETY REQUIREMENT: Account must be unshared
    // Move doesn't allow runtime is_shared checks, so this is enforced by:
    // 1. package(package) visibility - only callable from this package
    // 2. Only exposed through init_actions module
    // 3. Documentation and naming convention (_unshared suffix)

    // Ensure vault exists
    if (!account.has_managed_data(VaultKey(name))) {
        let vault = Vault {
            bag: bag::new(ctx),
            streams: table::new(ctx),
        };
        account.add_managed_data(VaultKey(name), vault, version::current());
    };

    let vault: &mut Vault =
        account.borrow_managed_data_mut(VaultKey(name), version::current());

    // Add coin to vault
    let coin_type_name = type_name::with_defining_ids<CoinType>();
    if (vault.bag.contains(coin_type_name)) {
        let balance_mut = vault.bag.borrow_mut<TypeName, Balance<CoinType>>(coin_type_name);
        balance_mut.join(coin.into_balance());
    } else {
        vault.bag.add(coin_type_name, coin.into_balance());
    };
}

/// Closes the vault if empty.
public fun close<Config>(
    auth: Auth,
    account: &mut Account<Config>,
    name: String,
) {
    account.verify(auth);

    let Vault { bag, streams } =
        account.remove_managed_data(VaultKey(name), version::current());
    assert!(bag.is_empty(), EVaultNotEmpty);
    assert!(streams.is_empty(), EVaultNotEmpty);
    bag.destroy_empty();
    streams.destroy_empty();
}

/// Returns true if the vault exists.
public fun has_vault<Config>(
    account: &Account<Config>, 
    name: String
): bool {
    account.has_managed_data(VaultKey(name))
}

/// Returns a reference to the vault.
public fun borrow_vault<Config>(
    account: &Account<Config>, 
    name: String
): &Vault {
    account.borrow_managed_data(VaultKey(name), version::current())
}

/// Returns the number of coin types in the vault.
public fun size(vault: &Vault): u64 {
    vault.bag.length()
}

/// Returns true if the coin type exists in the vault.
public fun coin_type_exists<CoinType: drop>(vault: &Vault): bool {
    vault.bag.contains(type_name::with_defining_ids<CoinType>())
}

/// Returns the value of the coin type in the vault.
public fun coin_type_value<CoinType: drop>(vault: &Vault): u64 {
    vault.bag.borrow<TypeName, Balance<CoinType>>(type_name::with_defining_ids<CoinType>()).value()
}

// === Destruction Functions ===

/// Destroy a DepositAction after serialization
public fun destroy_deposit_action<CoinType>(action: DepositAction<CoinType>) {
    let DepositAction { name: _, amount: _ } = action;
}

/// Destroy a SpendAction after serialization
public fun destroy_spend_action<CoinType>(action: SpendAction<CoinType>) {
    let SpendAction { name: _, amount: _ } = action;
}

/// Destroy a ToggleStreamPauseAction after serialization
public fun destroy_toggle_stream_pause_action(action: ToggleStreamPauseAction) {
    let ToggleStreamPauseAction { vault_name: _, stream_id: _, pause_duration_ms: _ } = action;
}

/// Destroy a ToggleStreamFreezeAction after serialization
public fun destroy_toggle_stream_freeze_action(action: ToggleStreamFreezeAction) {
    let ToggleStreamFreezeAction { vault_name: _, stream_id: _, freeze: _ } = action;
}

// Intent functions

/// Creates a DepositAction and adds it to an intent with descriptor.
public fun new_deposit<Outcome, CoinType, IW: drop>(
    intent: &mut Intent<Outcome>,
    name: String,
    amount: u64,
    intent_witness: IW,
) {
    // Create action struct
    let action = DepositAction<CoinType> {
        name,
        amount,
    };

    // Serialize the entire struct directly
    let action_data = bcs::to_bytes(&action);

    // Add to intent with parameterized type witness
    // The action struct itself serves as the type witness, preserving CoinType parameter
    intent.add_typed_action(
        action,  // Action moved here, TypeName becomes DepositAction<CoinType>
        action_data,
        intent_witness
    );

    // Action already consumed by add_typed_action - no need to destroy
}

/// Processes a DepositAction and deposits a coin to the vault.
public fun do_deposit<Config, Outcome: store, CoinType: drop, IW: drop>(
    executable: &mut Executable<Outcome>,
    account: &mut Account<Config>,
    coin: Coin<CoinType>,
    version_witness: VersionWitness,
    _intent_witness: IW,
) {
    executable.intent().assert_is_account(account.addr());

    // Get BCS bytes from ActionSpec
    let specs = executable.intent().action_specs();
    let spec = specs.borrow(executable.action_idx());

    // CRITICAL: Assert that the action type is what we expect
    action_validation::assert_action_type<VaultDeposit>(spec);

    let action_data = intents::action_spec_data(spec);

    // Check version before deserialization
    let spec_version = intents::action_spec_version(spec);
    assert!(spec_version == 1, EUnsupportedActionVersion);

    // Deserialize the entire action struct directly
    let mut reader = bcs::new(*action_data);
    let name = std::string::utf8(bcs::peel_vec_u8(&mut reader));
    let amount = bcs::peel_u64(&mut reader);

    // Validate all bytes consumed
    bcs_validation::validate_all_bytes_consumed(reader);

    assert!(amount == coin.value(), EIntentAmountMismatch);

    let vault: &mut Vault = account.borrow_managed_data_mut(VaultKey(name), version_witness);
    if (!vault.coin_type_exists<CoinType>()) {
        vault.bag.add(type_name::with_defining_ids<CoinType>(), coin.into_balance());
    } else {
        let balance_mut = vault.bag.borrow_mut<_, Balance<_>>(type_name::with_defining_ids<CoinType>());
        balance_mut.join(coin.into_balance());
    };

    // Increment action index
    executable::increment_action_idx(executable);
}

/// Deletes a DepositAction from an expired intent.
public fun delete_deposit<CoinType>(expired: &mut Expired) {
    let _spec = intents::remove_action_spec(expired);
    // ActionSpec has drop, so it's automatically cleaned up
    // No need to deserialize the data
}

/// Creates a SpendAction and adds it to an intent with descriptor.
public fun new_spend<Outcome, CoinType, IW: drop>(
    intent: &mut Intent<Outcome>,
    name: String,
    amount: u64,
    intent_witness: IW,
) {
    // Create action struct
    let action = SpendAction<CoinType> {
        name,
        amount,
    };

    // Serialize the entire struct directly
    let action_data = bcs::to_bytes(&action);

    // Add to intent with parameterized type witness
    // The action struct itself serves as the type witness, preserving CoinType parameter
    intent.add_typed_action(
        action,  // Action moved here, TypeName becomes SpendAction<CoinType>
        action_data,
        intent_witness
    );

    // Action already consumed by add_typed_action - no need to destroy
}

/// Creates a ToggleStreamPauseAction and adds it to an intent
public fun new_toggle_stream_pause<Outcome, IW: drop>(
    intent: &mut Intent<Outcome>,
    vault_name: String,
    stream_id: ID,
    pause_duration_ms: u64, // 0 = unpause, >0 = pause for duration
    intent_witness: IW,
) {
    let action = ToggleStreamPauseAction { vault_name, stream_id, pause_duration_ms };
    let action_data = bcs::to_bytes(&action);
    intent.add_typed_action(
        framework_action_types::toggle_stream_pause(),
        action_data,
        intent_witness
    );
    destroy_toggle_stream_pause_action(action);
}

/// Creates a ToggleStreamFreezeAction and adds it to an intent
public fun new_toggle_stream_freeze<Outcome, IW: drop>(
    intent: &mut Intent<Outcome>,
    vault_name: String,
    stream_id: ID,
    freeze: bool, // true = freeze, false = unfreeze
    intent_witness: IW,
) {
    let action = ToggleStreamFreezeAction { vault_name, stream_id, freeze };
    let action_data = bcs::to_bytes(&action);
    intent.add_typed_action(
        framework_action_types::toggle_stream_freeze(),
        action_data,
        intent_witness
    );
    destroy_toggle_stream_freeze_action(action);
}

// === Execution Functions ===

/// Execute toggle stream pause action
public fun do_toggle_stream_pause<Config, Outcome: store, CoinType, IW: drop>(
    executable: &mut Executable<Outcome>,
    account: &mut Account<Config>,
    vault_name: String,
    clock: &Clock,
    version_witness: VersionWitness,
    witness: IW,
    ctx: &mut TxContext,
) {
    executable.intent().assert_is_account(account.addr());

    let specs = executable.intent().action_specs();
    let spec = specs.borrow(executable.action_idx());

    // CRITICAL: Assert that the action type is what we expect
    action_validation::assert_action_type<framework_action_types::ToggleStreamPause>(spec);

    let action_data = intents::action_spec_data(spec);

    // Create BCS reader and deserialize
    let mut reader = bcs::new(*action_data);
    let deserialized_vault_name = std::string::utf8(bcs::peel_vec_u8(&mut reader));
    let stream_id = object::id_from_bytes(bcs::peel_vec_u8(&mut reader));
    let pause_duration_ms = bcs::peel_u64(&mut reader);

    // Validate vault name matches
    assert!(vault_name == deserialized_vault_name, EVaultDoesNotExist);

    // Get vault
    let vault: &mut Vault = account.borrow_managed_data_mut(VaultKey(vault_name), version_witness);
    assert!(vault.streams.contains(stream_id), EStreamNotFound);

    // Execute pause/unpause logic
    if (pause_duration_ms == 0) {
        // Unpause
        check_and_unpause_stream(vault, stream_id, clock);
    } else {
        // Pause
        pause_stream<CoinType>(vault, stream_id, pause_duration_ms, clock, ctx);
    };

    // Increment action index
    executable::increment_action_idx(executable);
}

/// Execute toggle stream freeze action
public fun do_toggle_stream_freeze<Config, Outcome: store, CoinType, IW: drop>(
    executable: &mut Executable<Outcome>,
    account: &mut Account<Config>,
    vault_name: String,
    clock: &Clock,
    version_witness: VersionWitness,
    witness: IW,
) {
    executable.intent().assert_is_account(account.addr());

    let specs = executable.intent().action_specs();
    let spec = specs.borrow(executable.action_idx());

    // CRITICAL: Assert that the action type is what we expect
    action_validation::assert_action_type<framework_action_types::ToggleStreamFreeze>(spec);

    let action_data = intents::action_spec_data(spec);

    // Create BCS reader and deserialize
    let mut reader = bcs::new(*action_data);
    let deserialized_vault_name = std::string::utf8(bcs::peel_vec_u8(&mut reader));
    let stream_id = object::id_from_bytes(bcs::peel_vec_u8(&mut reader));
    let freeze = bcs::peel_bool(&mut reader);

    // Validate vault name matches
    assert!(vault_name == deserialized_vault_name, EVaultDoesNotExist);

    // Get vault
    let vault: &mut Vault = account.borrow_managed_data_mut(VaultKey(vault_name), version_witness);
    assert!(vault.streams.contains(stream_id), EStreamNotFound);

    // Execute freeze/unfreeze logic
    if (freeze) {
        emergency_freeze_stream(vault, stream_id, clock);
    } else {
        emergency_unfreeze_stream(vault, stream_id, clock);
    };

    // Increment action index
    executable::increment_action_idx(executable);
}

/// Processes a SpendAction and takes a coin from the vault.
public fun do_spend<Config, Outcome: store, CoinType: drop, IW: drop>(
    executable: &mut Executable<Outcome>,
    account: &mut Account<Config>,
    version_witness: VersionWitness,
    _intent_witness: IW,
    ctx: &mut TxContext
): Coin<CoinType> {
    executable.intent().assert_is_account(account.addr());

    // Get BCS bytes from ActionSpec
    let specs = executable.intent().action_specs();
    let spec = specs.borrow(executable.action_idx());

    // CRITICAL: Assert that the action type is what we expect
    action_validation::assert_action_type<VaultSpend>(spec);

    let action_data = intents::action_spec_data(spec);

    // Check version before deserialization
    let spec_version = intents::action_spec_version(spec);
    assert!(spec_version == 1, EUnsupportedActionVersion);

    // Deserialize the entire action struct directly
    let mut reader = bcs::new(*action_data);
    let name = std::string::utf8(bcs::peel_vec_u8(&mut reader));
    let amount = bcs::peel_u64(&mut reader);

    // Validate all bytes consumed
    bcs_validation::validate_all_bytes_consumed(reader);

    let vault: &mut Vault = account.borrow_managed_data_mut(VaultKey(name), version_witness);
    let balance_mut = vault.bag.borrow_mut<_, Balance<_>>(type_name::with_defining_ids<CoinType>());
    let coin = coin::take(balance_mut, amount, ctx);

    if (balance_mut.value() == 0)
        vault.bag.remove<_, Balance<CoinType>>(type_name::with_defining_ids<CoinType>()).destroy_zero();

    // Store coin info in context for potential use by later actions
    // PTBs handle object flow naturally - no context storage needed

    // Increment action index
    executable::increment_action_idx(executable);
    coin
}

/// Deletes a SpendAction from an expired intent.
public fun delete_spend<CoinType>(expired: &mut Expired) {
    let _spec = intents::remove_action_spec(expired);
    // ActionSpec has drop, so it's automatically cleaned up
    // No need to deserialize the data
}

// === Stream Management Functions ===

/// Creates a new stream in the vault
public fun create_stream<Config, CoinType: drop>(
    auth: Auth,
    account: &mut Account<Config>,
    vault_name: String,
    beneficiary: address,
    total_amount: u64,
    start_time: u64,
    end_time: u64,
    cliff_time: Option<u64>,
    max_per_withdrawal: u64,
    min_interval_ms: u64,
    max_beneficiaries: u64,
    clock: &Clock,
    ctx: &mut TxContext,
): ID {
    account.verify(auth);

    // Validate stream parameters
    let current_time = clock.timestamp_ms();
    assert!(
        account_actions::stream_utils::validate_time_parameters(
            start_time,
            end_time,
            &cliff_time,
            current_time
        ),
        EInvalidStreamParameters
    );

    let vault: &mut Vault = account.borrow_managed_data_mut(VaultKey(vault_name), version::current());

    // Check that vault has sufficient balance
    assert!(vault.coin_type_exists<CoinType>(), EWrongCoinType);
    let balance = vault.bag.borrow<TypeName, Balance<CoinType>>(type_name::with_defining_ids<CoinType>());
    assert!(balance.value() >= total_amount, EInsufficientVestedAmount);

    // Create stream
    let stream_id = object::new(ctx);
    let stream = VaultStream {
        id: object::uid_to_inner(&stream_id),
        coin_type: type_name::with_defining_ids<CoinType>(),
        beneficiary,
        total_amount,
        claimed_amount: 0,
        start_time,
        end_time,
        cliff_time,
        max_per_withdrawal,
        min_interval_ms,
        last_withdrawal_time: 0,
        // Fork additions
        additional_beneficiaries: vector::empty(),
        max_beneficiaries,
        is_paused: false,
        paused_at: option::none(),
        paused_until: option::none(),
        paused_duration: 0,
        emergency_frozen: false,
        expiry_timestamp: option::none(),
        metadata: option::none(),
        is_transferable: true,
        is_cancellable: true,
    };

    let id = object::uid_to_inner(&stream_id);
    object::delete(stream_id);

    // Store stream in vault
    table::add(&mut vault.streams, id, stream);

    // Emit event
    event::emit(StreamCreated {
        stream_id: id,
        beneficiary,
        total_amount,
        coin_type: type_name::with_defining_ids<CoinType>(),
        start_time,
        end_time,
    });

    id
}

/// Cancel a stream and return unused funds
public fun cancel_stream<Config, CoinType: drop>(
    auth: Auth,
    account: &mut Account<Config>,
    vault_name: String,
    stream_id: ID,
    clock: &Clock,
    ctx: &mut TxContext,
): (Coin<CoinType>, u64) {
    account.verify(auth);

    let vault: &mut Vault = account.borrow_managed_data_mut(VaultKey(vault_name), version::current());
    assert!(table::contains(&vault.streams, stream_id), EStreamNotFound);

    let stream = table::remove(&mut vault.streams, stream_id);
    assert!(stream.is_cancellable, ENotCancellable);

    let current_time = clock.timestamp_ms();
    let balance_remaining = stream.total_amount - stream.claimed_amount;

    // Calculate what should be paid to beneficiary vs refunded
    let (to_pay_beneficiary, to_refund, _unvested_claimed) =
        account_actions::stream_utils::split_vested_unvested(
            stream.total_amount,
            stream.claimed_amount,
            balance_remaining,
            stream.start_time,
            stream.end_time,
            current_time,
            stream.paused_duration,
            &stream.cliff_time,
        );

    let balance_mut = vault.bag.borrow_mut<TypeName, Balance<CoinType>>(stream.coin_type);

    // Create coins for refund and final payment
    let mut refund_coin = coin::zero<CoinType>(ctx);
    if (to_refund > 0) {
        refund_coin.join(coin::take(balance_mut, to_refund, ctx));
    };

    // Transfer final payment to beneficiary if any
    if (to_pay_beneficiary > 0) {
        let final_payment = coin::take(balance_mut, to_pay_beneficiary, ctx);
        transfer::public_transfer(final_payment, stream.beneficiary);
    };

    // Emit event
    event::emit(StreamCancelled {
        stream_id,
        refunded_amount: to_refund,
        final_payment: to_pay_beneficiary,
    });

    // Clean up empty balance if needed
    if (balance_mut.value() == 0) {
        vault.bag.remove<TypeName, Balance<CoinType>>(stream.coin_type).destroy_zero();
    };

    (refund_coin, to_refund)
}

/// Withdraw from a stream
public fun withdraw_from_stream<Config, CoinType: drop>(
    account: &mut Account<Config>,
    vault_name: String,
    stream_id: ID,
    amount: u64,
    clock: &Clock,
    ctx: &mut TxContext,
): Coin<CoinType> {
    let vault: &mut Vault = account.borrow_managed_data_mut(VaultKey(vault_name), version::current());
    assert!(table::contains(&vault.streams, stream_id), EStreamNotFound);

    let stream = table::borrow_mut(&mut vault.streams, stream_id);
    assert!(!stream.is_paused, EStreamPaused);

    let current_time = clock.timestamp_ms();

    // Check if stream has started
    assert!(current_time >= stream.start_time, EStreamNotStarted);

    // Check cliff period
    if (stream.cliff_time.is_some()) {
        assert!(current_time >= *stream.cliff_time.borrow(), EStreamCliffNotReached);
    };

    // Check rate limiting
    assert!(
        account_actions::stream_utils::check_rate_limit(
            stream.last_withdrawal_time,
            stream.min_interval_ms,
            current_time
        ),
        EWithdrawalTooSoon
    );

    // Check withdrawal limits
    assert!(
        account_actions::stream_utils::check_withdrawal_limit(
            amount,
            stream.max_per_withdrawal
        ),
        EWithdrawalLimitExceeded
    );

    // Calculate available amount
    let available = account_actions::stream_utils::calculate_claimable(
        stream.total_amount,
        stream.claimed_amount,
        stream.start_time,
        stream.end_time,
        current_time,
        stream.paused_duration,
        &stream.cliff_time,
    );

    assert!(available >= amount, EInsufficientVestedAmount);

    // Update stream state
    stream.claimed_amount = stream.claimed_amount + amount;
    stream.last_withdrawal_time = current_time;

    // Withdraw from vault balance
    let balance_mut = vault.bag.borrow_mut<TypeName, Balance<CoinType>>(stream.coin_type);
    let coin = coin::take(balance_mut, amount, ctx);

    // Emit event
    event::emit(StreamWithdrawal {
        stream_id,
        beneficiary: tx_context::sender(ctx),
        amount,
        remaining_vested: available - amount,
    });

    // Clean up empty balance if needed
    if (balance_mut.value() == 0) {
        vault.bag.remove<TypeName, Balance<CoinType>>(stream.coin_type).destroy_zero();
    };

    coin
}

/// Calculate how much can be claimed from a stream
public fun calculate_claimable<Config>(
    account: &Account<Config>,
    vault_name: String,
    stream_id: ID,
    clock: &Clock,
): u64 {
    let vault: &Vault = account.borrow_managed_data(VaultKey(vault_name), version::current());
    assert!(table::contains(&vault.streams, stream_id), EStreamNotFound);

    let stream = table::borrow(&vault.streams, stream_id);
    let current_time = clock.timestamp_ms();

    account_actions::stream_utils::calculate_claimable(
        stream.total_amount,
        stream.claimed_amount,
        stream.start_time,
        stream.end_time,
        current_time,
        stream.paused_duration,
        &stream.cliff_time,
    )
}

/// Get stream information
public fun stream_info<Config>(
    account: &Account<Config>,
    vault_name: String,
    stream_id: ID,
): (address, u64, u64, u64, u64, bool, bool) {
    let vault: &Vault = account.borrow_managed_data(VaultKey(vault_name), version::current());
    assert!(table::contains(&vault.streams, stream_id), EStreamNotFound);

    let stream = table::borrow(&vault.streams, stream_id);
    (
        stream.beneficiary,
        stream.total_amount,
        stream.claimed_amount,
        stream.start_time,
        stream.end_time,
        stream.is_paused,
        stream.is_cancellable
    )
}

/// Check if a stream exists
public fun has_stream<Config>(
    account: &Account<Config>,
    vault_name: String,
    stream_id: ID,
): bool {
    if (!account.has_managed_data(VaultKey(vault_name))) {
        return false
    };

    let vault: &Vault = account.borrow_managed_data(VaultKey(vault_name), version::current());
    table::contains(&vault.streams, stream_id)
}

/// Create a stream during initialization - works on unshared Accounts.
/// Directly creates a stream without requiring Auth during DAO creation.
///
/// ## FORK NOTE
/// **Added**: `create_stream_unshared()` for init-time payment stream creation
/// **Reason**: Allow DAOs to set up recurring payment streams (salaries, grants)
/// during atomic initialization from vault funds. Validates parameters and balance.
/// **Safety**: `public(package)` visibility ensures only callable during init
///
/// SAFETY: This function MUST only be called on unshared Accounts
/// during the initialization phase before the Account is shared.
/// Once an Account is shared, this function will fail as it bypasses
/// the normal Auth checks that protect shared Accounts.
public(package) fun create_stream_unshared<Config, CoinType: drop>(
    account: &mut Account<Config>,
    vault_name: String,
    beneficiary: address,
    total_amount: u64,
    start_time: u64,
    end_time: u64,
    cliff_time: Option<u64>,
    max_per_withdrawal: u64,
    min_interval_ms: u64,
    max_beneficiaries: u64,
    clock: &Clock,
    ctx: &mut TxContext,
): ID {
    // Validate stream parameters
    let current_time = clock.timestamp_ms();
    assert!(
        account_actions::stream_utils::validate_time_parameters(
            start_time,
            end_time,
            &cliff_time,
            current_time
        ),
        EInvalidStreamParameters
    );
    assert!(total_amount > 0, EAmountMustBeGreaterThanZero);
    assert!(max_beneficiaries <= account_actions::stream_utils::max_beneficiaries(), ETooManyBeneficiaries);

    // Ensure vault exists and has sufficient balance
    let vault_exists = account.has_managed_data(VaultKey(vault_name));
    assert!(vault_exists, EVaultDoesNotExist);

    let vault: &mut Vault = account.borrow_managed_data_mut(VaultKey(vault_name), version::current());
    let coin_type_name = type_name::with_defining_ids<CoinType>();
    assert!(bag::contains(&vault.bag, coin_type_name), ECoinTypeDoesNotExist);

    let balance = vault.bag.borrow<TypeName, Balance<CoinType>>(coin_type_name);
    assert!(balance.value() >= total_amount, EInsufficientBalance);

    // Create stream ID
    let stream_uid = object::new(ctx);
    let stream_id = object::uid_to_inner(&stream_uid);
    object::delete(stream_uid);

    // Create stream
    let stream = VaultStream {
        id: stream_id,
        coin_type: coin_type_name,
        beneficiary,
        total_amount,
        claimed_amount: 0,
        start_time,
        end_time,
        cliff_time,
        max_per_withdrawal,
        min_interval_ms,
        last_withdrawal_time: 0,
        paused_duration: 0,
        paused_at: option::none(),
        paused_until: option::none(),
        is_paused: false,
        emergency_frozen: false,
        expiry_timestamp: option::none(),
        is_cancellable: true,
        is_transferable: true,
        additional_beneficiaries: vector::empty<address>(),
        max_beneficiaries,
        metadata: option::none(),
    };

    // Copy ID before moving stream
    let stream_id_copy = stream.id;

    // Add stream to vault
    table::add(&mut vault.streams, stream_id_copy, stream);

    // Emit event
    event::emit(StreamCreated {
        stream_id: stream_id_copy,
        beneficiary,
        total_amount,
        coin_type: coin_type_name,
        start_time,
        end_time,
    });

    stream_id_copy
}

// === Stream Pause Control ===

/// Pause a stream for a specific duration (in milliseconds)
/// Pass 0 for pause_duration_ms to pause indefinitely
public fun pause_stream<CoinType>(
    vault: &mut Vault,
    stream_id: ID,
    pause_duration_ms: u64,
    clock: &Clock,
    ctx: &mut TxContext,
) {
    let stream = table::borrow_mut(&mut vault.streams, stream_id);

    // Only beneficiary can pause
    let sender = tx_context::sender(ctx);
    assert!(stream.beneficiary == sender || stream.additional_beneficiaries.contains(&sender), EUnauthorizedBeneficiary);
    assert!(!stream.is_paused, EVestingPaused);
    assert!(!stream.emergency_frozen, EEmergencyFrozen);

    let current_time = clock.timestamp_ms();

    // Use stream_utils for validation and calculation
    assert!(stream_utils::validate_pause_duration(current_time, pause_duration_ms), ETimeCalculationOverflow);

    stream.is_paused = true;
    stream.paused_at = option::some(current_time);
    stream.paused_until = stream_utils::calculate_pause_until(current_time, pause_duration_ms);

    event::emit(StreamPaused {
        stream_id,
        paused_at: current_time,
    });
}

/// Resume a paused stream
public fun resume_stream<CoinType>(
    vault: &mut Vault,
    stream_id: ID,
    clock: &Clock,
    ctx: &mut TxContext,
) {
    let stream = table::borrow_mut(&mut vault.streams, stream_id);

    // Only beneficiary can resume
    let sender = tx_context::sender(ctx);
    assert!(stream.beneficiary == sender || stream.additional_beneficiaries.contains(&sender), EUnauthorizedBeneficiary);
    assert!(stream.is_paused, EVestingNotPaused);
    assert!(!stream.emergency_frozen, EEmergencyFrozen);

    let current_time = clock.timestamp_ms();

    // Calculate pause duration
    if (stream.paused_at.is_some()) {
        let pause_start = *stream.paused_at.borrow();
        let pause_duration = stream_utils::calculate_pause_duration(pause_start, current_time);
        stream.paused_duration = stream.paused_duration + pause_duration;
    };

    stream.is_paused = false;
    stream.paused_at = option::none();
    stream.paused_until = option::none();

    event::emit(StreamResumed {
        stream_id,
        resumed_at: current_time,
        pause_duration: stream.paused_duration,
    });
}

/// Check if pause has expired and auto-unpause if needed
/// Can be called by anyone
public fun check_and_unpause_stream(
    vault: &mut Vault,
    stream_id: ID,
    clock: &Clock,
) {
    let stream = table::borrow_mut(&mut vault.streams, stream_id);

    if (!stream.is_paused) {
        return
    };

    let current_time = clock.timestamp_ms();

    // Use stream_utils to check if pause expired
    if (stream_utils::is_pause_expired(&stream.paused_until, current_time)) {
        // Calculate pause duration
        if (stream.paused_at.is_some()) {
            let pause_start = *stream.paused_at.borrow();
            let pause_duration = stream_utils::calculate_pause_duration(pause_start, current_time);
            stream.paused_duration = stream.paused_duration + pause_duration;
        };

        stream.is_paused = false;
        stream.paused_at = option::none();
        stream.paused_until = option::none();

        event::emit(StreamResumed {
            stream_id,
            resumed_at: current_time,
            pause_duration: stream.paused_duration,
        });
    };
}

// === Emergency Controls ===

/// Emergency freeze a stream - prevents all claims and unpause
/// Only callable by governance/authority
public fun emergency_freeze_stream(
    vault: &mut Vault,
    stream_id: ID,
    clock: &Clock,
) {
    let stream = table::borrow_mut(&mut vault.streams, stream_id);
    assert!(!stream.emergency_frozen, EEmergencyFrozen);

    stream.emergency_frozen = true;
    if (!stream.is_paused) {
        stream.is_paused = true;
        stream.paused_at = option::some(clock.timestamp_ms());
        stream.paused_until = option::none(); // Indefinite
    };

    event::emit(StreamFrozen {
        stream_id,
        timestamp: clock.timestamp_ms(),
    });
}

/// Remove emergency freeze
/// Only callable by governance/authority
public fun emergency_unfreeze_stream(
    vault: &mut Vault,
    stream_id: ID,
    clock: &Clock,
) {
    let stream = table::borrow_mut(&mut vault.streams, stream_id);
    assert!(stream.emergency_frozen, EVestingNotPaused);

    stream.emergency_frozen = false;

    event::emit(StreamUnfrozen {
        stream_id,
        timestamp: clock.timestamp_ms(),
    });

    // Note: Does NOT auto-unpause - beneficiary must explicitly unpause after unfreezing
}

// === Preview Functions ===

/// Calculate currently claimable amount from a stream
public fun stream_claimable_now(
    vault: &Vault,
    stream_id: ID,
    clock: &Clock,
): u64 {
    let stream = table::borrow(&vault.streams, stream_id);
    let current_time = clock.timestamp_ms();

    // Use stream_utils to check if claiming is allowed
    if (!stream_utils::can_claim(
        stream.is_paused,
        stream.emergency_frozen,
        &stream.expiry_timestamp,
        current_time
    )) {
        return 0
    };

    // Check cliff
    if (stream.cliff_time.is_some()) {
        let cliff = *stream.cliff_time.borrow();
        if (current_time < cliff) {
            return 0
        };
    } else if (current_time < stream.start_time) {
        return 0
    };

    // Calculate claimable using stream_utils
    stream_utils::calculate_claimable(
        stream.total_amount,
        stream.claimed_amount,
        stream.start_time,
        stream.end_time,
        current_time,
        stream.paused_duration,
        &stream.cliff_time
    )
}

/// Get next vesting time for a stream
public fun stream_next_vest_time(
    vault: &Vault,
    stream_id: ID,
    clock: &Clock,
): Option<u64> {
    let stream = table::borrow(&vault.streams, stream_id);
    let current_time = clock.timestamp_ms();

    // Use stream_utils for calculation
    stream_utils::next_vesting_time(
        stream.start_time,
        stream.end_time,
        &stream.cliff_time,
        &stream.expiry_timestamp,
        current_time
    )
}

// NOTE: Expiry management removed - doesn't make sense for beneficiary to set their own expiry

// ============================================================================
// FORK MODIFICATION NOTICE - Currency Management with Serialize-Then-Destroy Pattern
// ============================================================================
// This module manages TreasuryCap and CoinMetadata operations for Account.
//
// CHANGES IN THIS FORK:
// - Actions use type markers: CurrencyMint, CurrencyBurn, CurrencyUpdate, CurrencyDisable
// - Implemented serialize-then-destroy pattern for all 4 action types
// - Added destruction functions: destroy_mint_action, destroy_burn_action, etc.
// - Actions serialize to bytes before adding to intent via add_typed_action()
// - Enhanced BCS validation: version checks + validate_all_bytes_consumed
// - Type-safe action validation through compile-time TypeName comparison
// - REMOVED ExecutionContext - PTBs handle object flow naturally
// ============================================================================
/// Authenticated users can lock a TreasuryCap in the Account to restrict minting and burning operations,
/// as well as modifying the CoinMetadata.

module account_actions::currency;

// === Imports ===

use std::{
    string::{Self, String},
    ascii,
    option,

};
use sui::{
    coin::{Self, Coin, TreasuryCap, CoinMetadata},
    url::{Self, Url},
    bcs,
    object,
};
use account_protocol::{
    action_validation,
    account::{Self, Account, Auth},
    intents::{Self, Expired, Intent},
    executable::{Self, Executable},
    version_witness::VersionWitness,
    bcs_validation,
};
use account_actions::{
    currency,
    version
};
use account_extensions::framework_action_types::{Self, CurrencyDisable, CurrencyMint, CurrencyBurn, CurrencyUpdate};
// === Use Fun Aliases ===
// Removed - add_typed_action is now called directly

// === Errors ===

const ENoChange: u64 = 0;
const EWrongValue: u64 = 1;
const EMintDisabled: u64 = 2;
const EBurnDisabled: u64 = 3;
const ECannotUpdateName: u64 = 4;
const ECannotUpdateSymbol: u64 = 5;
const ECannotUpdateDescription: u64 = 6;
const ECannotUpdateIcon: u64 = 7;
const EMaxSupply: u64 = 8;
const EUnsupportedActionVersion: u64 = 9;

// === Structs ===    

/// Dynamic Object Field key for the TreasuryCap.
public struct TreasuryCapKey<phantom CoinType>() has copy, drop, store;
/// Dynamic Field key for the CurrencyRules.
public struct CurrencyRulesKey<phantom CoinType>() has copy, drop, store;
/// Dynamic Field wrapper restricting access to a TreasuryCap, permissions are disabled forever if set.
public struct CurrencyRules<phantom CoinType> has store {
    // coin can have a fixed supply, can_mint must be true to be able to mint more
    max_supply: Option<u64>,
    // total amount minted
    total_minted: u64,
    // total amount burned
    total_burned: u64,
    // permissions
    can_mint: bool,
    can_burn: bool,
    can_update_symbol: bool,
    can_update_name: bool,
    can_update_description: bool,
    can_update_icon: bool,
}

/// Action disabling permissions marked as true, cannot be reenabled.
public struct DisableAction<phantom CoinType> has store, drop {
    mint: bool,
    burn: bool,
    update_symbol: bool,
    update_name: bool,
    update_description: bool,
    update_icon: bool,
}
/// Action minting new coins.
public struct MintAction<phantom CoinType> has store, drop {
    amount: u64,
}
/// Action burning coins.
public struct BurnAction<phantom CoinType> has store, drop {
    amount: u64,
}
/// Action updating a CoinMetadata object using a locked TreasuryCap.
public struct UpdateAction<phantom CoinType> has store, drop {
    symbol: Option<ascii::String>,
    name: Option<String>,
    description: Option<String>,
    icon_url: Option<ascii::String>,
}

// === Public functions ===

/// Authenticated users can lock a TreasuryCap.
public fun lock_cap<Config, CoinType>(
    auth: Auth,
    account: &mut Account<Config>,
    treasury_cap: TreasuryCap<CoinType>,
    max_supply: Option<u64>,
) {
    account.verify(auth);

    let rules = CurrencyRules<CoinType> { 
        max_supply,
        total_minted: 0,
        total_burned: 0,
        can_mint: true,
        can_burn: true,
        can_update_symbol: true,
        can_update_name: true,
        can_update_description: true,
        can_update_icon: true,
    };
    account.add_managed_data(CurrencyRulesKey<CoinType>(), rules, version::current());
    account.add_managed_asset(TreasuryCapKey<CoinType>(), treasury_cap, version::current());
}

/// Lock treasury cap during initialization - works on unshared Accounts
/// This function is for use during account creation, before the account is shared.
///
/// ## FORK NOTE
/// **Added**: `do_lock_cap_unshared()` for init-time TreasuryCap locking
/// **Reason**: Enable DAOs to lock their TreasuryCap during atomic initialization
/// without Auth checks. Sets default CurrencyRules permissively to allow minting.
/// **Safety**: `public(package)` visibility + naming convention enforces unshared-only usage
///
/// SAFETY: This function MUST only be called on unshared Accounts.
/// Calling this on a shared Account bypasses Auth checks.
public(package) fun do_lock_cap_unshared<Config, CoinType>(
    account: &mut Account<Config>,
    treasury_cap: TreasuryCap<CoinType>,
) {
    // SAFETY REQUIREMENT: Account must be unshared
    // Default rules with no max supply
    let rules = CurrencyRules<CoinType> {
        max_supply: option::none(),
        total_minted: 0,
        total_burned: 0,
        can_mint: true,
        can_burn: true,
        can_update_symbol: true,
        can_update_name: true,
        can_update_description: true,
        can_update_icon: true,
    };
    account.add_managed_data(CurrencyRulesKey<CoinType>(), rules, version::current());
    account.add_managed_asset(TreasuryCapKey<CoinType>(), treasury_cap, version::current());
}

/// Mint coins during initialization - works on unshared Accounts
/// Transfers minted coins directly to recipient
///
/// ## FORK NOTE
/// **Added**: `do_mint_unshared()` for init-time minting
/// **Reason**: Allow initial token distribution during DAO creation (founders, team, treasury)
/// without requiring Auth or proposal approval. Validates against CurrencyRules.
/// **Safety**: `public(package)` visibility ensures only callable during init
///
/// SAFETY: This function MUST only be called on unshared Accounts.
/// Calling this on a shared Account bypasses Auth checks.
public(package) fun do_mint_unshared<Config, CoinType>(
    account: &mut Account<Config>,
    amount: u64,
    recipient: address,
    ctx: &mut TxContext,
) {
    // SAFETY REQUIREMENT: Account must be unshared
    let rules: &mut CurrencyRules<CoinType> =
        account.borrow_managed_data_mut(CurrencyRulesKey<CoinType>(), version::current());

    assert!(rules.can_mint, EMintDisabled);
    if (rules.max_supply.is_some()) {
        let total_supply = rules.total_minted - rules.total_burned;
        assert!(amount + total_supply <= *rules.max_supply.borrow(), EMaxSupply);
    };

    rules.total_minted = rules.total_minted + amount;

    let cap: &mut TreasuryCap<CoinType> =
        account.borrow_managed_asset_mut(TreasuryCapKey<CoinType>(), version::current());

    let coin = cap.mint(amount, ctx);
    transfer::public_transfer(coin, recipient);
}

/// Mint coins to Coin object during initialization - works on unshared Accounts
/// Returns Coin for further use in the same transaction
///
/// ## FORK NOTE
/// **Added**: `do_mint_to_coin_unshared()` for composable init-time minting
/// **Reason**: Mint coins and return Coin object for immediate use in same PTB
/// (e.g., mint then deposit to vault, or mint then add to liquidity pool)
/// **Safety**: `public(package)` visibility ensures only callable during init
public(package) fun do_mint_to_coin_unshared<Config, CoinType>(
    account: &mut Account<Config>,
    amount: u64,
    ctx: &mut TxContext,
): Coin<CoinType> {
    let rules: &mut CurrencyRules<CoinType> =
        account.borrow_managed_data_mut(CurrencyRulesKey<CoinType>(), version::current());

    assert!(rules.can_mint, EMintDisabled);
    if (rules.max_supply.is_some()) {
        let total_supply = rules.total_minted - rules.total_burned;
        assert!(amount + total_supply <= *rules.max_supply.borrow(), EMaxSupply);
    };

    rules.total_minted = rules.total_minted + amount;

    let cap: &mut TreasuryCap<CoinType> =
        account.borrow_managed_asset_mut(TreasuryCapKey<CoinType>(), version::current());

    cap.mint(amount, ctx)
}

/// Checks if a TreasuryCap exists for a given coin type.
public fun has_cap<Config, CoinType>(
    account: &Account<Config>
): bool {
    account.has_managed_asset(TreasuryCapKey<CoinType>())
}

/// Borrows a mutable reference to the TreasuryCap for a given coin type.
/// This is used by oracle mints and other patterns that need direct cap access
/// to bypass object-level policies (only Account access matters).
public fun borrow_treasury_cap_mut<Config, CoinType>(
    account: &mut Account<Config>
): &mut TreasuryCap<CoinType> {
    account.borrow_managed_asset_mut(TreasuryCapKey<CoinType>(), version::current())
}

/// Borrows the CurrencyRules for a given coin type.
public fun borrow_rules<Config, CoinType>(
    account: &Account<Config>
): &CurrencyRules<CoinType> {
    account.borrow_managed_data(CurrencyRulesKey<CoinType>(), version::current())
}

/// Returns the total supply of a given coin type.
public fun coin_type_supply<Config, CoinType>(account: &Account<Config>): u64 {
    let cap: &TreasuryCap<CoinType> = 
        account.borrow_managed_asset(TreasuryCapKey<CoinType>(), version::current());
    cap.total_supply()
}

/// Returns the maximum supply of a given coin type.
public fun max_supply<CoinType>(lock: &CurrencyRules<CoinType>): Option<u64> {
    lock.max_supply
}

/// Returns the total amount minted of a given coin type.
public fun total_minted<CoinType>(lock: &CurrencyRules<CoinType>): u64 {
    lock.total_minted
}

/// Returns the total amount burned of a given coin type.
public fun total_burned<CoinType>(lock: &CurrencyRules<CoinType>): u64 {
    lock.total_burned
}

/// Returns true if the coin type can mint.
public fun can_mint<CoinType>(lock: &CurrencyRules<CoinType>): bool {
    lock.can_mint
}

/// Returns true if the coin type can burn.
public fun can_burn<CoinType>(lock: &CurrencyRules<CoinType>): bool {
    lock.can_burn
}

/// Returns true if the coin type can update the symbol.
public fun can_update_symbol<CoinType>(lock: &CurrencyRules<CoinType>): bool {
    lock.can_update_symbol
}

/// Returns true if the coin type can update the name.
public fun can_update_name<CoinType>(lock: &CurrencyRules<CoinType>): bool {
    lock.can_update_name
}

/// Returns true if the coin type can update the description.
public fun can_update_description<CoinType>(lock: &CurrencyRules<CoinType>): bool {
    lock.can_update_description
}

/// Returns true if the coin type can update the icon.
public fun can_update_icon<CoinType>(lock: &CurrencyRules<CoinType>): bool {
    lock.can_update_icon
}

/// Read metadata from a CoinMetadata object
/// Simple helper to extract all metadata fields in one call
/// Returns: (decimals, symbol, name, description, icon_url)
public fun read_coin_metadata<CoinType>(
    metadata: &CoinMetadata<CoinType>,
): (u8, ascii::String, String, String, ascii::String) {
    (
        metadata.get_decimals(),
        metadata.get_symbol(),
        metadata.get_name(),
        metadata.get_description(),
        metadata.get_icon_url().extract().inner_url()
    )
}

/// Anyone can burn coins they own if enabled.
public fun public_burn<Config, CoinType>(
    account: &mut Account<Config>,
    coin: Coin<CoinType>
) {
    let rules_mut: &mut CurrencyRules<CoinType> =
        account.borrow_managed_data_mut(CurrencyRulesKey<CoinType>(), version::current());
    assert!(rules_mut.can_burn, EBurnDisabled);
    rules_mut.total_burned = rules_mut.total_burned + coin.value();

    let cap_mut: &mut TreasuryCap<CoinType> =
        account.borrow_managed_asset_mut(TreasuryCapKey<CoinType>(), version::current());
    cap_mut.burn(coin);
}

// === Destruction Functions ===

/// Destroy a MintAction after serialization
public fun destroy_mint_action<CoinType>(action: MintAction<CoinType>) {
    let MintAction { amount: _ } = action;
}

/// Destroy a BurnAction after serialization
public fun destroy_burn_action<CoinType>(action: BurnAction<CoinType>) {
    let BurnAction { amount: _ } = action;
}

// Intent functions

/// Creates a DisableAction and adds it to an intent.
public fun new_disable<Outcome, CoinType, IW: drop>(
    intent: &mut Intent<Outcome>,
    mint: bool,
    burn: bool,
    update_symbol: bool,
    update_name: bool,
    update_description: bool,
    update_icon: bool,
    intent_witness: IW,
) {
    assert!(mint || burn || update_symbol || update_name || update_description || update_icon, ENoChange);

    // Create the action struct with drop ability
    let action = DisableAction<CoinType> { mint, burn, update_symbol, update_name, update_description, update_icon };

    // Serialize it
    let action_data = bcs::to_bytes(&action);

    // Add to intent - action used as witness preserves CoinType in TypeName
    intent.add_typed_action(
        action,  // ✅ Preserves CoinType parameter in TypeName
        action_data,
        intent_witness
    );

    // No destroy needed - action consumed by add_typed_action
}

/// Processes a DisableAction and disables the permissions marked as true.
public fun do_disable<Config, Outcome: store, CoinType, IW: drop>(
    executable: &mut Executable<Outcome>,
    account: &mut Account<Config>,
    version_witness: VersionWitness,
    _intent_witness: IW,
) {
    executable.intent().assert_is_account(account.addr());

    // Get BCS bytes from ActionSpec
    let specs = executable.intent().action_specs();
    let spec = specs.borrow(executable.action_idx());

    // CRITICAL: Assert that the action type is what we expect
    action_validation::assert_action_type<CurrencyDisable>(spec);


    let action_data = intents::action_spec_data(spec);

    // Check version before deserialization
    let spec_version = intents::action_spec_version(spec);
    assert!(spec_version == 1, EUnsupportedActionVersion);

    // Create BCS reader and deserialize
    let mut reader = bcs::new(*action_data);
    let mint = bcs::peel_bool(&mut reader);
    let burn = bcs::peel_bool(&mut reader);
    let update_symbol = bcs::peel_bool(&mut reader);
    let update_name = bcs::peel_bool(&mut reader);
    let update_description = bcs::peel_bool(&mut reader);
    let update_icon = bcs::peel_bool(&mut reader);

    // Validate all bytes consumed
    bcs_validation::validate_all_bytes_consumed(reader);

    let rules_mut: &mut CurrencyRules<CoinType> =
        account.borrow_managed_data_mut(CurrencyRulesKey<CoinType>(), version_witness);

    // if disabled, can be true or false, it has no effect
    if (mint) rules_mut.can_mint = false;
    if (burn) rules_mut.can_burn = false;
    if (update_symbol) rules_mut.can_update_symbol = false;
    if (update_name) rules_mut.can_update_name = false;
    if (update_description) rules_mut.can_update_description = false;
    if (update_icon) rules_mut.can_update_icon = false;

    // Increment action index
    executable::increment_action_idx(executable);
}

/// Deletes a DisableAction from an expired intent.
public fun delete_disable<CoinType>(expired: &mut Expired) {
    let _spec = intents::remove_action_spec(expired);
    // ActionSpec has drop, so it's automatically cleaned up
}

/// Creates an UpdateAction and adds it to an intent.
public fun new_update<Outcome, CoinType, IW: drop>(
    intent: &mut Intent<Outcome>,
    symbol: Option<ascii::String>,
    name: Option<String>,
    description: Option<String>,
    icon_url: Option<ascii::String>,
    intent_witness: IW,
) {
    assert!(symbol.is_some() || name.is_some() || description.is_some() || icon_url.is_some(), ENoChange);

    // Create the action struct with drop ability
    let action = UpdateAction<CoinType> { symbol, name, description, icon_url };

    // Serialize it
    let action_data = bcs::to_bytes(&action);

    // Add to intent - action used as witness preserves CoinType in TypeName
    intent.add_typed_action(
        action,  // ✅ Preserves CoinType parameter in TypeName
        action_data,
        intent_witness
    );

    // No destroy needed - action consumed by add_typed_action
}

/// Processes an UpdateAction, updates the CoinMetadata.
public fun do_update<Config, Outcome: store, CoinType, IW: drop>(
    executable: &mut Executable<Outcome>,
    account: &mut Account<Config>,
    metadata: &mut CoinMetadata<CoinType>,
    version_witness: VersionWitness,
    _intent_witness: IW,
) {
    executable.intent().assert_is_account(account.addr());

    // Get BCS bytes from ActionSpec
    let specs = executable.intent().action_specs();
    let spec = specs.borrow(executable.action_idx());

    // CRITICAL: Assert that the action type is what we expect
    action_validation::assert_action_type<CurrencyUpdate>(spec);


    let action_data = intents::action_spec_data(spec);

    // Check version before deserialization
    let spec_version = intents::action_spec_version(spec);
    assert!(spec_version == 1, EUnsupportedActionVersion);

    // Create BCS reader and deserialize
    let mut reader = bcs::new(*action_data);

    // Deserialize Option fields
    let symbol = if (bcs::peel_bool(&mut reader)) {
        option::some(bcs::peel_vec_u8(&mut reader).to_ascii_string())
    } else {
        option::none()
    };

    let name = if (bcs::peel_bool(&mut reader)) {
        option::some(bcs::peel_vec_u8(&mut reader).to_string())
    } else {
        option::none()
    };

    let description = if (bcs::peel_bool(&mut reader)) {
        option::some(bcs::peel_vec_u8(&mut reader).to_string())
    } else {
        option::none()
    };

    let icon_url = if (bcs::peel_bool(&mut reader)) {
        option::some(bcs::peel_vec_u8(&mut reader).to_ascii_string())
    } else {
        option::none()
    };

    // Validate all bytes consumed
    bcs_validation::validate_all_bytes_consumed(reader);

    let rules_mut: &mut CurrencyRules<CoinType> =
        account.borrow_managed_data_mut(CurrencyRulesKey<CoinType>(), version_witness);

    if (!rules_mut.can_update_symbol) assert!(symbol.is_none(), ECannotUpdateSymbol);
    if (!rules_mut.can_update_name) assert!(name.is_none(), ECannotUpdateName);
    if (!rules_mut.can_update_description) assert!(description.is_none(), ECannotUpdateDescription);
    if (!rules_mut.can_update_icon) assert!(icon_url.is_none(), ECannotUpdateIcon);

    let (default_symbol, default_name, default_description, default_icon_url) =
        (metadata.get_symbol(), metadata.get_name(), metadata.get_description(), metadata.get_icon_url().extract().inner_url());
    let cap: &TreasuryCap<CoinType> =
        account.borrow_managed_asset(TreasuryCapKey<CoinType>(), version_witness);

    cap.update_symbol(metadata, symbol.get_with_default(default_symbol));
    cap.update_name(metadata, name.get_with_default(default_name));
    cap.update_description(metadata, description.get_with_default(default_description));
    cap.update_icon_url(metadata, icon_url.get_with_default(default_icon_url));

    // Increment action index
    executable::increment_action_idx(executable);
}

/// Deletes an UpdateAction from an expired intent.
public fun delete_update<CoinType>(expired: &mut Expired) {
    let _spec = intents::remove_action_spec(expired);
    // ActionSpec has drop, so it's automatically cleaned up
}

/// Creates a MintAction and adds it to an intent with descriptor.
public fun new_mint<Outcome, CoinType, IW: drop>(
    intent: &mut Intent<Outcome>,
    amount: u64,
    intent_witness: IW,
) {
    // Create the action struct (no drop)
    let action = MintAction<CoinType> { amount };

    // Serialize it
    let action_data = bcs::to_bytes(&action);

    // Add to intent with parameterized type witness
    // The action struct itself serves as the type witness, preserving CoinType parameter
    intent.add_typed_action(
        action,  // Action moved here, TypeName becomes MintAction<CoinType>
        action_data,
        intent_witness
    );

    // Action already consumed by add_typed_action - no need to destroy
}

/// Processes a MintAction, mints and returns new coins.
public fun do_mint<Config, Outcome: store, CoinType, IW: drop>(
    executable: &mut Executable<Outcome>,
    account: &mut Account<Config>,
    version_witness: VersionWitness,
    _intent_witness: IW,
    ctx: &mut TxContext
): Coin<CoinType> {
    executable.intent().assert_is_account(account.addr());

    // Get BCS bytes from ActionSpec
    let specs = executable.intent().action_specs();
    let spec = specs.borrow(executable.action_idx());

    // CRITICAL: Assert that the action type is what we expect
    action_validation::assert_action_type<CurrencyMint>(spec);


    let action_data = intents::action_spec_data(spec);

    // Check version before deserialization
    let spec_version = intents::action_spec_version(spec);
    assert!(spec_version == 1, EUnsupportedActionVersion);

    // Create BCS reader and deserialize
    let mut reader = bcs::new(*action_data);
    let amount = bcs::peel_u64(&mut reader);

    // Validate all bytes consumed
    bcs_validation::validate_all_bytes_consumed(reader);

    let total_supply = currency::coin_type_supply<_, CoinType>(account);
    let rules_mut: &mut CurrencyRules<CoinType> =
        account.borrow_managed_data_mut(CurrencyRulesKey<CoinType>(), version_witness);

    assert!(rules_mut.can_mint, EMintDisabled);
    if (rules_mut.max_supply.is_some()) assert!(amount + total_supply <= *rules_mut.max_supply.borrow(), EMaxSupply);

    rules_mut.total_minted = rules_mut.total_minted + amount;

    let cap_mut: &mut TreasuryCap<CoinType> =
        account.borrow_managed_asset_mut(TreasuryCapKey<CoinType>(), version_witness);

    // Mint the coin
    let coin = cap_mut.mint(amount, ctx);

    // Store coin info in context for potential use by later actions
    // PTBs handle object flow naturally - no context storage needed

    // Increment action index
    executable::increment_action_idx(executable);

    coin
}

/// Deletes a MintAction from an expired intent.
public fun delete_mint<CoinType>(expired: &mut Expired) {
    let _spec = intents::remove_action_spec(expired);
    // ActionSpec has drop, so it's automatically cleaned up
}

/// Creates a BurnAction and adds it to an intent with descriptor.
public fun new_burn<Outcome, CoinType, IW: drop>(
    intent: &mut Intent<Outcome>,
    amount: u64,
    intent_witness: IW,
) {
    // Create the action struct
    let action = BurnAction<CoinType> { amount };

    // Serialize it
    let action_data = bcs::to_bytes(&action);

    // Add to intent with parameterized type witness
    // The action struct itself serves as the type witness, preserving CoinType parameter
    intent.add_typed_action(
        action,  // Action moved here, TypeName becomes BurnAction<CoinType>
        action_data,
        intent_witness
    );

    // Action already consumed by add_typed_action - no need to destroy
}

/// Processes a BurnAction, burns coins and returns the amount burned.
public fun do_burn<Config, Outcome: store, CoinType, IW: drop>(
    executable: &mut Executable<Outcome>,
    account: &mut Account<Config>,
    coin: Coin<CoinType>,
    version_witness: VersionWitness,
    _intent_witness: IW,
) {
    executable.intent().assert_is_account(account.addr());

    // Get BCS bytes from ActionSpec
    let specs = executable.intent().action_specs();
    let spec = specs.borrow(executable.action_idx());

    // CRITICAL: Assert that the action type is what we expect
    action_validation::assert_action_type<CurrencyBurn>(spec);


    let action_data = intents::action_spec_data(spec);

    // Check version before deserialization
    let spec_version = intents::action_spec_version(spec);
    assert!(spec_version == 1, EUnsupportedActionVersion);

    // Create BCS reader and deserialize
    let mut reader = bcs::new(*action_data);
    let amount = bcs::peel_u64(&mut reader);

    // Validate all bytes consumed
    bcs_validation::validate_all_bytes_consumed(reader);

    assert!(amount == coin.value(), EWrongValue);

    let rules_mut: &mut CurrencyRules<CoinType> =
        account.borrow_managed_data_mut(CurrencyRulesKey<CoinType>(), version_witness);
    assert!(rules_mut.can_burn, EBurnDisabled);

    rules_mut.total_burned = rules_mut.total_burned + amount;

    let cap_mut: &mut TreasuryCap<CoinType> =
        account.borrow_managed_asset_mut(TreasuryCapKey<CoinType>(), version_witness);

    // Increment action index
    executable::increment_action_idx(executable);

    cap_mut.burn(coin);
}

/// Deletes a BurnAction from an expired intent.
public fun delete_burn<CoinType>(expired: &mut Expired) {
    let _spec = intents::remove_action_spec(expired);
    // ActionSpec has drop, so it's automatically cleaned up
}

// ============================================================================
// FORK MODIFICATION NOTICE - Transfer with Serialize-Then-Destroy Pattern
// ============================================================================
// This module defines APIs to transfer assets owned or managed by Account.
//
// CHANGES IN THIS FORK:
// - TransferAction uses TransferObject type marker from framework_action_types
// - Implemented serialize-then-destroy pattern for resource safety
// - Added destroy_transfer_action function for explicit destruction
// - Actions serialize to bytes before adding to intent via add_typed_action()
// - Enhanced BCS validation: version checks + validate_all_bytes_consumed
// - Type-safe action validation through compile-time TypeName comparison
// ============================================================================
/// This module defines apis to transfer assets owned or managed by the account.
/// The intents can implement transfers for any action type (e.g. see owned or vault).

module account_actions::transfer;

// === Imports ===


use sui::bcs;
use account_protocol::{
    action_validation,
    intents::{Self, Expired, Intent},
    executable::{Self, Executable},
    bcs_validation,
};
use account_extensions::framework_action_types::{Self, TransferObject};

// === Use Fun Aliases ===
// Removed - add_typed_action is now called directly

// === Errors ===

const EUnsupportedActionVersion: u64 = 0;

// === Structs ===

/// Action used in combination with other actions (like WithdrawAction) to transfer objects to a recipient.
public struct TransferAction has store {
    // address to transfer to
    recipient: address,
}

/// Action to transfer to the transaction sender (perfect for crank fees)
public struct TransferToSenderAction has store {
    // No recipient field needed - uses tx_context::sender()
}

// === Destruction Functions ===

/// Destroy a TransferAction after serialization
public fun destroy_transfer_action(action: TransferAction) {
    let TransferAction { recipient: _ } = action;
}

/// Destroy a TransferToSenderAction after serialization
public fun destroy_transfer_to_sender_action(action: TransferToSenderAction) {
    let TransferToSenderAction {} = action;
}

// === Public functions ===

/// Creates a TransferAction and adds it to an intent with descriptor.
public fun new_transfer<Outcome, IW: drop>(
    intent: &mut Intent<Outcome>,
    recipient: address,
    intent_witness: IW,
) {
    // Create the action struct (no drop)
    let action = TransferAction { recipient };

    // Serialize it
    let action_data = bcs::to_bytes(&action);

    // Add to intent with pre-serialized bytes
    intent.add_typed_action(
        framework_action_types::transfer_object(),
        action_data,
        intent_witness
    );

    // Explicitly destroy the action struct
    destroy_transfer_action(action);
}

/// Processes a TransferAction and transfers an object to a recipient.
public fun do_transfer<Outcome: store, T: key + store, IW: drop>(
    executable: &mut Executable<Outcome>,
    object: T,
    _intent_witness: IW,
) {
    // Get BCS bytes from ActionSpec
    let specs = executable.intent().action_specs();
    let spec = specs.borrow(executable.action_idx());

    // CRITICAL: Assert that the action type is what we expect
    action_validation::assert_action_type<TransferObject>(spec);


    let action_data = intents::action_spec_data(spec);

    // Check version before deserialization
    let spec_version = intents::action_spec_version(spec);
    assert!(spec_version == 1, EUnsupportedActionVersion);

    // Create BCS reader and deserialize
    let mut reader = bcs::new(*action_data);
    let recipient = bcs::peel_address(&mut reader);

    // Validate all bytes consumed
    bcs_validation::validate_all_bytes_consumed(reader);

    transfer::public_transfer(object, recipient);
    executable::increment_action_idx(executable);
}

/// Transfer object during initialization - works on unshared Accounts
/// Directly transfers an object to a recipient during DAO creation.
///
/// ## FORK NOTE
/// **Added**: `do_transfer_unshared()` for init-time object transfers
/// **Reason**: Allow transferring objects created during DAO setup (e.g., ClaimCaps
/// from vesting, or other initialization artifacts) to intended recipients atomically.
/// **Safety**: Public visibility is safe - function doesn't access Account state
///
/// SAFETY: This function can be called during initialization to transfer
/// objects that were created as part of the DAO setup.
public fun do_transfer_unshared<T: key + store>(
    object: T,
    recipient: address,
) {
    transfer::public_transfer(object, recipient);
}

/// Deletes a TransferAction from an expired intent.
public fun delete_transfer(expired: &mut Expired) {
    let _spec = intents::remove_action_spec(expired);
    // ActionSpec has drop, automatically cleaned up
}

/// Creates a TransferToSenderAction and adds it to an intent
public fun new_transfer_to_sender<Outcome, IW: drop>(
    intent: &mut Intent<Outcome>,
    intent_witness: IW,
) {
    // Create the action struct with no fields
    let action = TransferToSenderAction {};

    // Serialize it
    let action_data = bcs::to_bytes(&action);

    // Add to intent with type marker for TransferObject (reusing existing type)
    intent.add_typed_action(
        framework_action_types::transfer_object(),
        action_data,
        intent_witness
    );

    // Explicitly destroy the action struct
    destroy_transfer_to_sender_action(action);
}

/// Processes a TransferToSenderAction and transfers an object to the transaction sender
public fun do_transfer_to_sender<Outcome: store, T: key + store, IW: drop>(
    executable: &mut Executable<Outcome>,
    object: T,
    _intent_witness: IW,
    ctx: &mut TxContext,
) {
    // Get BCS bytes from ActionSpec
    let specs = executable.intent().action_specs();
    let spec = specs.borrow(executable.action_idx());

    // CRITICAL: Assert that the action type is what we expect (using TransferObject)
    action_validation::assert_action_type<framework_action_types::TransferObject>(spec);

    let _action_data = intents::action_spec_data(spec);

    // Check version before deserialization
    let spec_version = intents::action_spec_version(spec);
    assert!(spec_version == 1, EUnsupportedActionVersion);

    // TransferToSenderAction is an empty struct with no fields to deserialize
    // We acknowledge the action_data exists but don't process it

    // Transfer to the transaction sender (the cranker!)
    transfer::public_transfer(object, tx_context::sender(ctx));
    executable::increment_action_idx(executable);
}

/// Deletes a TransferToSenderAction from an expired intent.
public fun delete_transfer_to_sender(expired: &mut Expired) {
    let _spec = intents::remove_action_spec(expired);
    // ActionSpec has drop, automatically cleaned up
}

// ============================================================================
// FORK MODIFICATION NOTICE - Access Control with Serialize-Then-Destroy Pattern
// ============================================================================
// This module manages capability-based access control for Account actions.
//
// CHANGES IN THIS FORK:
// - Actions use type markers: AccessControlBorrow, AccessControlReturn
// - Implemented serialize-then-destroy pattern for resource safety
// - Added destruction functions: destroy_borrow_action, destroy_return_action
// - Actions serialize to bytes before adding to intent via add_typed_action()
// - Enforces matching ReturnAction for every BorrowAction in intent
// - Type-safe action validation through compile-time TypeName comparison
// ============================================================================
/// Developers can restrict access to functions in their own package with a Cap that can be locked into an Account. 
/// The Cap can be borrowed upon approval and used in other move calls within the same ptb before being returned.
/// 
/// The Cap pattern uses the object type as a proof of access, the object ID is never checked.
/// Therefore, only one Cap of a given type can be locked into the Smart Account.
/// And any Cap of that type can be returned to the Smart Account after being borrowed.
/// 
/// A good practice to follow is to use a different Cap type for each function that needs to be restricted.
/// This way, the Cap borrowed can't be misused in another function, by the person executing the intent.
/// 
/// e.g.
/// 
/// public struct AdminCap has key, store {}
/// 
/// public fun foo(_: &AdminCap) { ... }

module account_actions::access_control;

// === Imports ===


use sui::bcs::{Self, BCS};
use account_protocol::{
    action_validation,
    account::{Account, Auth},
    intents::{Self, Expired, Intent},
    executable::{Self, Executable},
    version_witness::VersionWitness,
};
use account_actions::version;
use account_extensions::framework_action_types;

// === Use Fun Aliases ===
// Removed - add_typed_action is now called directly

// === Errors ===

/// BorrowAction requires a matching ReturnAction in the same intent to ensure capability is returned
const ENoReturn: u64 = 0;

// === Structs ===    

/// Dynamic Object Field key for the Cap.
public struct CapKey<phantom Cap>() has copy, drop, store;

/// Action giving access to the Cap.
public struct BorrowAction<phantom Cap> has drop, store {}
/// This hot potato is created upon approval to ensure the cap is returned.
public struct ReturnAction<phantom Cap> has drop, store {}

// === Public functions ===

/// Authenticated user can lock a Cap, the Cap must have at least store ability.
public fun lock_cap<Config, Cap: key + store>(
    auth: Auth,
    account: &mut Account<Config>,
    cap: Cap,
) {
    account.verify(auth);
    account.add_managed_asset(CapKey<Cap>(), cap, version::current());
}

/// Lock capability during initialization - works on unshared Accounts
/// Store any capability in the Account during creation
///
/// ## FORK NOTE
/// **Added**: `do_lock_cap_unshared()` function for init-time capability storage
/// **Reason**: Allow capabilities to be locked in unshared Accounts during initialization
/// without requiring Auth, enabling atomic DAO setup with PTBs. Bypasses Auth checks
/// which are unnecessary before Account is shared.
/// **Safety**: `public(package)` visibility ensures only init_actions can call
public(package) fun do_lock_cap_unshared<Config, Cap: key + store>(
    account: &mut Account<Config>,
    cap: Cap,
) {
    account.add_managed_asset(CapKey<Cap>(), cap, version::current());
}

/// Checks if there is a Cap locked for a given type.
public fun has_lock<Config, Cap>(
    account: &Account<Config>
): bool {
    account.has_managed_asset(CapKey<Cap>())
}

// === Destruction Functions ===

/// Destroy a BorrowAction after serialization
public fun destroy_borrow_action<Cap>(action: BorrowAction<Cap>) {
    let BorrowAction {} = action;
}

/// Destroy a ReturnAction after serialization
public fun destroy_return_action<Cap>(action: ReturnAction<Cap>) {
    let ReturnAction {} = action;
}

// Intent functions

/// Creates and returns a BorrowAction.
public fun new_borrow<Outcome, Cap, IW: drop>(
    intent: &mut Intent<Outcome>,
    intent_witness: IW,
) {
    // Create the action struct
    let action = BorrowAction<Cap> {};

    // Serialize it
    let action_data = bcs::to_bytes(&action);

    // Add to intent with pre-serialized bytes
    intent.add_typed_action(
        framework_action_types::access_control_borrow(),
        action_data,
        intent_witness
    );

    // Explicitly destroy the action struct
    destroy_borrow_action(action);
}

/// Processes a BorrowAction and returns a Borrowed hot potato and the Cap.
public fun do_borrow<Config, Outcome: store, Cap: key + store, IW: drop>(
    executable: &mut Executable<Outcome>,
    account: &mut Account<Config>,
    version_witness: VersionWitness,
    _intent_witness: IW,
): Cap {
    executable.intent().assert_is_account(account.addr());

    // Get BCS bytes from ActionSpec and verify it's a BorrowAction
    let specs = executable.intent().action_specs();
    let spec = specs.borrow(executable.action_idx());

    // CRITICAL: Assert that the action type is what we expect
    action_validation::assert_action_type<framework_action_types::AccessControlBorrow>(spec);

    let _action_data = intents::action_spec_data(spec);

    // BorrowAction is an empty struct with no fields to deserialize
    // We acknowledge the action_data exists but don't process it

    // CRITICAL: Verify that a matching ReturnAction exists in the intent
    // This ensures the borrowed capability will be returned
    let current_idx = executable.action_idx();
    let mut return_found = false;
    let return_action_type = action_validation::get_action_type_name<framework_action_types::AccessControlReturn>();

    // Search from the next action onwards
    let mut i = current_idx + 1;
    while (i < specs.length()) {
        let future_spec = specs.borrow(i);
        if (intents::action_spec_type(future_spec) == return_action_type) {
            return_found = true;
            break
        };
        i = i + 1;
    };

    assert!(return_found, ENoReturn);

    // For BorrowAction<Cap>, there's no data to deserialize (empty struct)
    // Just increment the action index
    executable::increment_action_idx(executable);

    account.remove_managed_asset(CapKey<Cap>(), version_witness)
}

/// Deletes a BorrowAction from an expired intent.
public fun delete_borrow<Cap>(expired: &mut Expired) {
    let _spec = intents::remove_action_spec(expired);
    // ActionSpec has drop, automatically cleaned up
}

/// Creates and returns a ReturnAction.
public fun new_return<Outcome, Cap, IW: drop>(
    intent: &mut Intent<Outcome>,
    intent_witness: IW,
) {
    // Create the action struct
    let action = ReturnAction<Cap> {};

    // Serialize it
    let action_data = bcs::to_bytes(&action);

    // Add to intent with pre-serialized bytes
    intent.add_typed_action(
        framework_action_types::access_control_return(),
        action_data,
        intent_witness
    );

    // Explicitly destroy the action struct
    destroy_return_action(action);
}

/// Returns a Cap to the Account and validates the ReturnAction.
public fun do_return<Config, Outcome: store, Cap: key + store, IW: drop>(
    executable: &mut Executable<Outcome>,
    account: &mut Account<Config>,
    cap: Cap,
    version_witness: VersionWitness,
    _intent_witness: IW,
) {
    executable.intent().assert_is_account(account.addr());

    // Get BCS bytes from ActionSpec and verify it's a ReturnAction
    let specs = executable.intent().action_specs();
    let spec = specs.borrow(executable.action_idx());

    // CRITICAL: Assert that the action type is what we expect
    action_validation::assert_action_type<framework_action_types::AccessControlReturn>(spec);

    let _action_data = intents::action_spec_data(spec);

    // ReturnAction is an empty struct with no fields to deserialize
    // We acknowledge the action_data exists but don't process it

    // Increment the action index
    executable::increment_action_idx(executable);

    account.add_managed_asset(CapKey<Cap>(), cap, version_witness);
}

/// Deletes a ReturnAction from an expired intent.
public fun delete_return<Cap>(expired: &mut Expired) {
    let _spec = intents::remove_action_spec(expired);
    // ActionSpec has drop, automatically cleaned up
}
// ============================================================================
// FORK MODIFICATION NOTICE - Vesting with Serialize-Then-Destroy Pattern
// ============================================================================
// This module provides comprehensive vesting functionality with streaming.
//
// CHANGES IN THIS FORK:
// - Actions use type markers: VestingCreate, VestingCancel
// - Implemented serialize-then-destroy pattern for both action types
// - Added destruction functions: destroy_create_vesting_action, destroy_cancel_vesting_action
// - Actions serialize to bytes before adding to intent via add_typed_action()
// - Comprehensive vesting features: cliff periods, multiple beneficiaries, pausable
// - Type-safe action validation through compile-time TypeName comparison
//
// COMPOSABILITY IMPROVEMENTS (2025-09-14):
// - claim_vesting() now returns Coin<CoinType> for PTB composability
// - Added claim_vesting_to() for direct transfers to recipients
// - Added claim_vesting_to_self() convenience function
// - Fixed design flaw: separated authorization from payment destination
// - Note: Batch claims removed - PTBs handle this natively
// ============================================================================
/// This module provides comprehensive vesting functionality similar to vault streams.
/// A vesting has configurable parameters for maximum flexibility:
/// - Multiple beneficiaries support
/// - Pause/resume functionality
/// - Metadata for extensibility
/// - Transfer and cancellation settings
/// - Cliff periods and rate limiting
///
/// === Fork Enhancement (BSL 1.1 Licensed) ===
/// Originally deleted from the Move framework, this module was restored and
/// significantly enhanced to provide feature parity with vault streams.
///
/// Major improvements from original:
/// 1. **Cancellability Control**: Added `is_cancelable` flag to create uncancelable vestings
/// 2. **Multiple Beneficiaries**: Support for primary + additional beneficiaries (up to 100)
/// 3. **Pause/Resume**: Vestings can be paused, extending the vesting period appropriately
/// 4. **Transfer Support**: Primary beneficiary role can be transferred if enabled
/// 5. **Rate Limiting**: Configurable withdrawal limits and minimum intervals
/// 6. **Cliff Periods**: Optional cliff before any vesting begins
/// 7. **Metadata**: Extensible metadata field for additional context
/// 8. **Shared Utilities**: Uses stream_utils module for consistent calculations
/// 9. **Action Descriptors**: Integrated with governance approval system
/// 10. **Comprehensive Events**: Full audit trail of all vesting operations
///
/// This refactor ensures DAOs can:
/// - Create employee vesting schedules that cannot be cancelled
/// - Implement investor token locks with cliff periods
/// - Pause vestings during disputes or investigations
/// - Support team vestings with multiple recipients
/// - Enforce withdrawal limits to prevent dumps
///
/// All calculations now use the shared stream_utils module to ensure
/// consistency with vault streams and prevent calculation divergence.

module account_actions::vesting;

// === Imports ===

use std::{
    string::{Self, String},
    option::{Self, Option},
    type_name::{Self, TypeName},
    u64,
};
use sui::{
    balance::Balance,
    coin::{Self, Coin},
    clock::Clock,
    event,
    object::{Self, ID, UID},
    transfer,
    tx_context,
    bcs::{Self, BCS},
};
use account_protocol::{
    action_validation,
    account::Account,
    intents::{Self, Expired, Intent},
    executable::{Self, Executable},
    version_witness::VersionWitness,
    bcs_validation,
};
use account_extensions::framework_action_types::{Self, VestingCreate, VestingCancel};
use account_actions::{stream_utils, version};

use fun account_protocol::intents::add_typed_action as Intent.add_typed_action;

// === Errors ===

const EBalanceNotEmpty: u64 = 0;
const ETooEarly: u64 = 1;
const EWrongVesting: u64 = 2;
const EVestingNotCancelable: u64 = 3;
const EVestingPaused: u64 = 4;
const EVestingNotPaused: u64 = 5;
const ENotTransferable: u64 = 6;
const EUnauthorizedBeneficiary: u64 = 7;
const EBeneficiaryAlreadyExists: u64 = 8;
const EBeneficiaryNotFound: u64 = 9;
const ECannotReduceBelowClaimed: u64 = 10;
const ETooManyBeneficiaries: u64 = 11;
const EInvalidVestingParameters: u64 = 12;
const ECliffNotReached: u64 = 13;
const EWithdrawalLimitExceeded: u64 = 14;
const EWithdrawalTooSoon: u64 = 15;
const EInvalidInput: u64 = 16;
const ETimeCalculationOverflow: u64 = 17;  // Keep for pause duration validation
const EEmergencyFrozen: u64 = 18;
const EVestingExpired: u64 = 19;

// === Structs ===

/// Enhanced vesting with comprehensive features matching vault streams
public struct Vesting<phantom CoinType> has key {
    id: UID,
    // Core vesting parameters
    balance: Balance<CoinType>,
    claimed_amount: u64,
    start_timestamp: u64,
    end_timestamp: u64,
    cliff_time: Option<u64>,
    // Beneficiaries
    primary_beneficiary: address,
    additional_beneficiaries: vector<address>,
    max_beneficiaries: u64,
    // Rate limiting
    max_per_withdrawal: u64,
    min_interval_ms: u64,
    last_withdrawal_time: u64,
    // Control flags
    is_paused: bool,
    paused_at: Option<u64>,
    paused_until: Option<u64>,  // None = indefinite, Some(ts) = pause until timestamp
    paused_duration: u64,
    emergency_frozen: bool,     // If true, even unpause won't work
    is_transferable: bool,
    is_cancelable: bool,
    // Expiry
    expiry_timestamp: Option<u64>,  // Vesting becomes invalid after this time
    // Metadata
    metadata: Option<String>,
}

/// Cap enabling bearer to claim the vesting
public struct ClaimCap has key {
    id: UID,
    vesting_id: ID,
}

/// Action for creating a comprehensive vesting
public struct CreateVestingAction<phantom CoinType> has drop, store {
    amount: u64,
    start_timestamp: u64,
    end_timestamp: u64,
    cliff_time: Option<u64>,
    recipient: address,
    max_beneficiaries: u64,
    max_per_withdrawal: u64,
    min_interval_ms: u64,
    is_transferable: bool,
    is_cancelable: bool,
    metadata: Option<String>,
}

/// Action for canceling a vesting
public struct CancelVestingAction has drop, store {
    vesting_id: ID,
}

/// Action for toggling vesting pause (combines pause/resume)
public struct ToggleVestingPauseAction has drop, store {
    vesting_id: ID,
    pause_duration_ms: u64, // 0 = unpause, >0 = pause for duration
}

/// Action for toggling emergency freeze (combines freeze/unfreeze)
public struct ToggleVestingFreezeAction has drop, store {
    vesting_id: ID,
    freeze: bool, // true = freeze, false = unfreeze
}

// === Events ===

/// Emitted when a vesting is created
public struct VestingCreated has copy, drop {
    vesting_id: ID,
    beneficiary: address,
    amount: u64,
    start_time: u64,
    end_time: u64,
}

/// Emitted when funds are claimed from vesting
public struct VestingClaimed has copy, drop {
    vesting_id: ID,
    beneficiary: address,
    amount: u64,
    remaining: u64,
}

/// Emitted when a vesting is cancelled
public struct VestingCancelled has copy, drop {
    vesting_id: ID,
    refunded_amount: u64,
    final_payment: u64,
}

/// Emitted when a vesting is paused
public struct VestingPaused has copy, drop {
    vesting_id: ID,
    paused_at: u64,
}

/// Emitted when a vesting is resumed
public struct VestingResumed has copy, drop {
    vesting_id: ID,
    resumed_at: u64,
    pause_duration: u64,
}

/// Emitted when a beneficiary is added
public struct BeneficiaryAdded has copy, drop {
    vesting_id: ID,
    new_beneficiary: address,
}

/// Emitted when a beneficiary is removed
public struct BeneficiaryRemoved has copy, drop {
    vesting_id: ID,
    removed_beneficiary: address,
}

/// Emitted when a vesting is transferred
public struct VestingTransferred has copy, drop {
    vesting_id: ID,
    old_beneficiary: address,
    new_beneficiary: address,
}

/// Emitted when a vesting is emergency frozen
public struct VestingFrozen has copy, drop {
    vesting_id: ID,
    timestamp: u64,
}

/// Emitted when emergency freeze is removed
public struct VestingUnfrozen has copy, drop {
    vesting_id: ID,
    timestamp: u64,
}

// === Destruction Functions ===

/// Destroy a CreateVestingAction after serialization
public fun destroy_create_vesting_action<CoinType>(action: CreateVestingAction<CoinType>) {
    let CreateVestingAction {
        amount: _,
        start_timestamp: _,
        end_timestamp: _,
        cliff_time: _,
        recipient: _,
        max_beneficiaries: _,
        max_per_withdrawal: _,
        min_interval_ms: _,
        is_transferable: _,
        is_cancelable: _,
        metadata: _,
    } = action;
}

/// Destroy a CancelVestingAction after serialization
public fun destroy_cancel_vesting_action(action: CancelVestingAction) {
    let CancelVestingAction { vesting_id: _ } = action;
}

/// Destroy a ToggleVestingPauseAction after serialization
public fun destroy_toggle_vesting_pause_action(action: ToggleVestingPauseAction) {
    let ToggleVestingPauseAction { vesting_id: _, pause_duration_ms: _ } = action;
}

/// Destroy a ToggleVestingFreezeAction after serialization
public fun destroy_toggle_vesting_freeze_action(action: ToggleVestingFreezeAction) {
    let ToggleVestingFreezeAction { vesting_id: _, freeze: _ } = action;
}

// === Public Functions ===

/// Proposes to create vestings for multiple recipients (supports 1 to N recipients)
/// Each recipient gets their own independent Vesting object
public fun new_vesting<Config, Outcome, CoinType, IW: copy + drop>(
    intent: &mut Intent<Outcome>,
    _account: &Account<Config>,
    recipients: vector<address>,
    amounts: vector<u64>,
    start_timestamp: u64,
    end_timestamp: u64,
    cliff_time: Option<u64>,
    max_beneficiaries: u64,
    max_per_withdrawal: u64,
    min_interval_ms: u64,
    is_transferable: bool,
    is_cancelable: bool,
    metadata: Option<String>,
    intent_witness: IW,
) {
    use std::vector;

    let len = vector::length(&recipients);
    assert!(len > 0 && len == vector::length(&amounts), 0); // ELengthMismatch

    let mut i = 0;
    while (i < len) {
        // Create action struct for this recipient
        let action = CreateVestingAction<CoinType> {
            amount: *vector::borrow(&amounts, i),
            start_timestamp,
            end_timestamp,
            cliff_time,
            recipient: *vector::borrow(&recipients, i),
            max_beneficiaries,
            max_per_withdrawal,
            min_interval_ms,
            is_transferable,
            is_cancelable,
            metadata,
        };

        // Serialize the entire struct directly
        let action_data = bcs::to_bytes(&action);

        // Add to intent
        intent.add_typed_action(
            framework_action_types::vesting_create(),
            action_data,
            intent_witness // Now copyable, so can be used in loop
        );

        // Destroy the action struct
        destroy_create_vesting_action(action);

        i = i + 1;
    }
}

/// Creates the Vesting and ClaimCap objects from a CreateVestingAction
public fun do_vesting<Config, Outcome: store, CoinType, IW: drop>(
    executable: &mut Executable<Outcome>,
    _account: &mut Account<Config>,
    coin: Coin<CoinType>,
    clock: &Clock,
    _intent_witness: IW,
    ctx: &mut TxContext,
) {
    // Get BCS bytes from ActionSpec
    let specs = executable.intent().action_specs();
    let spec = specs.borrow(executable.action_idx());

    // CRITICAL: Assert that the action type is what we expect
    action_validation::assert_action_type<VestingCreate>(spec);


    let action_data = intents::action_spec_data(spec);

    // Deserialize the entire action struct directly
    let mut reader = bcs::new(*action_data);
    let amount = bcs::peel_u64(&mut reader);
    let start_timestamp = bcs::peel_u64(&mut reader);
    let end_timestamp = bcs::peel_u64(&mut reader);
    let cliff_time = if (bcs::peel_bool(&mut reader)) {
        option::some(bcs::peel_u64(&mut reader))
    } else {
        option::none()
    };
    let recipient = bcs::peel_address(&mut reader);
    let max_beneficiaries = bcs::peel_u64(&mut reader);
    let max_per_withdrawal = bcs::peel_u64(&mut reader);
    let min_interval_ms = bcs::peel_u64(&mut reader);
    let is_transferable = bcs::peel_bool(&mut reader);
    let is_cancelable = bcs::peel_bool(&mut reader);
    let metadata = if (bcs::peel_bool(&mut reader)) {
        option::some(string::utf8(bcs::peel_vec_u8(&mut reader)))
    } else {
        option::none()
    };

    // Validate all bytes consumed
    bcs_validation::validate_all_bytes_consumed(reader);

    // Validate parameters
    assert!(amount > 0, EInvalidVestingParameters);
    assert!(end_timestamp > start_timestamp, EInvalidVestingParameters);
    assert!(start_timestamp >= clock.timestamp_ms(), EInvalidVestingParameters);

    if (cliff_time.is_some()) {
        let cliff = *cliff_time.borrow();
        assert!(cliff >= start_timestamp && cliff <= end_timestamp, EInvalidVestingParameters);
    };
    assert!(max_beneficiaries > 0 && max_beneficiaries <= stream_utils::max_beneficiaries(), EInvalidVestingParameters);

    let id = object::new(ctx);
    let vesting_id = id.to_inner();

    let vesting = Vesting<CoinType> {
        id,
        balance: coin.into_balance(),
        claimed_amount: 0,
        start_timestamp,
        end_timestamp,
        cliff_time,
        primary_beneficiary: recipient,
        additional_beneficiaries: vector::empty(),
        max_beneficiaries,
        max_per_withdrawal,
        min_interval_ms,
        last_withdrawal_time: 0,
        is_paused: false,
        paused_at: option::none(),
        paused_until: option::none(),
        paused_duration: 0,
        emergency_frozen: false,
        is_transferable,
        is_cancelable,
        expiry_timestamp: option::none(),  // No expiry by default
        metadata,
    };

    let claim_cap = ClaimCap {
        id: object::new(ctx),
        vesting_id,
    };

    // Emit creation event
    event::emit(VestingCreated {
        vesting_id,
        beneficiary: recipient,
        amount,
        start_time: start_timestamp,
        end_time: end_timestamp,
    });

    transfer::transfer(claim_cap, recipient);
    transfer::share_object(vesting);

    // Increment action index
    executable::increment_action_idx(executable);
}

/// Create vesting during initialization - works on unshared Accounts
/// This simplified version creates a vesting directly during DAO initialization.
/// The vesting is shared immediately, and ClaimCap is transferred to recipient.
/// Returns the vesting ID for reference.
///
/// ## FORK NOTE
/// **Added**: `do_create_vesting_unshared()` for init-time vesting creation (NEW pattern)
/// **Reason**: Enable DAOs to create token vesting schedules during initialization
/// (for founders, team, advisors) without requiring Account context or Auth.
/// Shares Vesting object and transfers ClaimCap to recipient. This is part of the
/// complete init actions pattern - original framework had no bootstrapping mechanism.
/// **Safety**: `public(package)` visibility ensures only callable during init
public(package) fun do_create_vesting_unshared<CoinType>(
    coin: Coin<CoinType>,
    recipient: address,
    start_timestamp: u64,
    duration_ms: u64,
    cliff_ms: u64,
    clock: &Clock,
    ctx: &mut TxContext,
): ID {
    // Calculate end timestamp
    let end_timestamp = start_timestamp + duration_ms;

    // Calculate cliff time if cliff period specified
    let cliff_time = if (cliff_ms > 0) {
        option::some(start_timestamp + cliff_ms)
    } else {
        option::none()
    };

    // Validate parameters
    let amount = coin.value();
    assert!(amount > 0, EInvalidVestingParameters);
    assert!(end_timestamp > start_timestamp, EInvalidVestingParameters);
    assert!(start_timestamp >= clock.timestamp_ms(), EInvalidVestingParameters);

    if (cliff_time.is_some()) {
        let cliff = *cliff_time.borrow();
        assert!(cliff >= start_timestamp && cliff <= end_timestamp, EInvalidVestingParameters);
    };

    let id = object::new(ctx);
    let vesting_id = id.to_inner();

    // Create vesting with default parameters suitable for initialization
    let vesting = Vesting<CoinType> {
        id,
        balance: coin.into_balance(),
        claimed_amount: 0,
        start_timestamp,
        end_timestamp,
        cliff_time,
        primary_beneficiary: recipient,
        additional_beneficiaries: vector::empty(),
        max_beneficiaries: 10,  // Reasonable default
        max_per_withdrawal: 0,  // No limit
        min_interval_ms: 0,     // No minimum interval
        last_withdrawal_time: 0,
        is_paused: false,
        paused_at: option::none(),
        paused_until: option::none(),
        paused_duration: 0,
        emergency_frozen: false,
        is_transferable: false,  // Not transferable by default
        is_cancelable: false,    // Not cancelable for security
        expiry_timestamp: option::none(),
        metadata: option::none(),
    };

    let claim_cap = ClaimCap {
        id: object::new(ctx),
        vesting_id,
    };

    // Emit creation event
    event::emit(VestingCreated {
        vesting_id,
        beneficiary: recipient,
        amount,
        start_time: start_timestamp,
        end_time: end_timestamp,
    });

    // Transfer cap and share vesting
    transfer::transfer(claim_cap, recipient);
    transfer::share_object(vesting);

    // Return the vesting ID for reference
    vesting_id
}

/// Claims vested funds and returns the coin for composability
/// Caller must be an authorized beneficiary
public fun claim_vesting<CoinType>(
    vesting: &mut Vesting<CoinType>,
    amount: u64,
    clock: &Clock,
    ctx: &mut TxContext,
): Coin<CoinType> {
    // Check if sender is authorized beneficiary
    let sender = tx_context::sender(ctx);
    let is_authorized = vesting.primary_beneficiary == sender ||
                       vesting.additional_beneficiaries.contains(&sender);
    assert!(is_authorized, EUnauthorizedBeneficiary);

    let current_time = clock.timestamp_ms();

    // Use stream_utils to check if claiming is allowed
    assert!(stream_utils::can_claim(
        vesting.is_paused,
        vesting.emergency_frozen,
        &vesting.expiry_timestamp,
        current_time
    ), EVestingPaused); // Use EVestingPaused as generic "can't claim" error

    // Check cliff if applicable
    if (vesting.cliff_time.is_some()) {
        let cliff = *vesting.cliff_time.borrow();
        assert!(current_time >= cliff, ECliffNotReached);
    } else {
        assert!(current_time >= vesting.start_timestamp, ETooEarly);
    };
    
    // Check rate limiting using shared utilities
    assert!(
        stream_utils::check_rate_limit(
            vesting.last_withdrawal_time,
            vesting.min_interval_ms,
            current_time
        ),
        EWithdrawalTooSoon
    );
    
    assert!(
        stream_utils::check_withdrawal_limit(
            amount,
            vesting.max_per_withdrawal
        ),
        EWithdrawalLimitExceeded
    );
    
    // Calculate claimable amount using shared utility
    let available = stream_utils::calculate_claimable(
        vesting.balance.value() + vesting.claimed_amount,
        vesting.claimed_amount,
        vesting.start_timestamp,
        vesting.end_timestamp,
        current_time,
        vesting.paused_duration,
        &vesting.cliff_time
    );
    assert!(amount <= available, EBalanceNotEmpty);
    
    // Update state
    vesting.claimed_amount = vesting.claimed_amount + amount;
    vesting.last_withdrawal_time = current_time;
    
    // Create payment coin
    let payment = coin::from_balance(vesting.balance.split(amount), ctx);
    
    // Emit event
    event::emit(VestingClaimed {
        vesting_id: object::id(vesting),
        beneficiary: sender,
        amount,
        remaining: vesting.balance.value(),
    });

    // Return the coin for composability
    payment
}

/// Convenience function: Claims vested funds and transfers to a specific recipient
/// This wraps the composable claim_vesting function for simple use cases
public fun claim_vesting_to<CoinType>(
    vesting: &mut Vesting<CoinType>,
    amount: u64,
    recipient: address,
    clock: &Clock,
    ctx: &mut TxContext,
) {
    let payment = claim_vesting(vesting, amount, clock, ctx);
    transfer::public_transfer(payment, recipient);
}

/// Convenience function: Claims vested funds and transfers to sender
/// This is the simplest way to claim for yourself
public fun claim_vesting_to_self<CoinType>(
    vesting: &mut Vesting<CoinType>,
    amount: u64,
    clock: &Clock,
    ctx: &mut TxContext,
) {
    claim_vesting_to(vesting, amount, tx_context::sender(ctx), clock, ctx);
}

/// Cancels a vesting, returning unvested funds to the account
public fun cancel_vesting<Config, Outcome: store, CoinType, IW: drop>(
    executable: &mut Executable<Outcome>,
    account: &mut Account<Config>,
    vesting: Vesting<CoinType>,
    clock: &Clock,
    _intent_witness: IW,
    ctx: &mut TxContext,
) {
    // Get BCS bytes from ActionSpec
    let specs = executable.intent().action_specs();
    let spec = specs.borrow(executable.action_idx());
    let action_data = intents::action_spec_data(spec);

    // Create BCS reader and deserialize
    let mut reader = bcs::new(*action_data);
    let vesting_id = bcs::peel_address(&mut reader).to_id();

    assert!(object::id(&vesting) == vesting_id, EWrongVesting);
    assert!(vesting.is_cancelable, EVestingNotCancelable);

    let Vesting { 
        id, 
        mut balance, 
        claimed_amount,
        start_timestamp,
        end_timestamp,
        primary_beneficiary,
        paused_duration,
        cliff_time,
        additional_beneficiaries: _,
        max_beneficiaries: _,
        max_per_withdrawal: _,
        min_interval_ms: _,
        last_withdrawal_time: _,
        is_paused: _,
        paused_at: _,
        paused_until: _,
        emergency_frozen: _,
        is_transferable: _,
        is_cancelable: _,
        expiry_timestamp: _,
        metadata: _,
    } = vesting;
    
    let vesting_id = id.to_inner();
    id.delete();

    // Calculate vested/unvested split using shared utility
    let current_time = clock.timestamp_ms();
    let total_amount = balance.value() + claimed_amount;
    
    let (to_pay, to_refund, unvested_claimed) = stream_utils::split_vested_unvested(
        total_amount,
        claimed_amount,
        balance.value(),
        start_timestamp,
        end_timestamp,
        current_time,
        paused_duration,
        &cliff_time
    );

    // Pay remaining vested amount to beneficiary
    let final_payment = if (to_pay > 0) {
        let payment = coin::from_balance(balance.split(to_pay), ctx);
        transfer::public_transfer(payment, primary_beneficiary);
        to_pay
    } else {
        0
    };

    // Return unvested balance to account
    if (to_refund > 0) {
        let refund = coin::from_balance(balance, ctx);
        account.keep(refund, ctx);
    } else if (balance.value() > 0) {
        // Should not happen with correct calculation, but handle gracefully
        let leftover = coin::from_balance(balance, ctx);
        account.keep(leftover, ctx);
    } else {
        balance.destroy_zero();
    };

    // Emit cancellation event
    event::emit(VestingCancelled {
        vesting_id,
        refunded_amount: to_refund + unvested_claimed,
        final_payment,
    });

    // Increment action index
    executable::increment_action_idx(executable);
}

/// Pauses a vesting for a specific duration (in milliseconds)
/// Pass 0 for pause_duration_ms to pause indefinitely
public fun pause_vesting<CoinType>(
    vesting: &mut Vesting<CoinType>,
    pause_duration_ms: u64,
    clock: &Clock,
    ctx: &mut TxContext,
) {
    assert!(tx_context::sender(ctx) == vesting.primary_beneficiary, EUnauthorizedBeneficiary);
    assert!(!vesting.is_paused, EVestingNotPaused);
    assert!(!vesting.emergency_frozen, EEmergencyFrozen);

    let current_time = clock.timestamp_ms();

    // Use stream_utils for pause calculation and validation
    assert!(stream_utils::validate_pause_duration(current_time, pause_duration_ms), ETimeCalculationOverflow);

    vesting.is_paused = true;
    vesting.paused_at = option::some(current_time);
    vesting.paused_until = stream_utils::calculate_pause_until(current_time, pause_duration_ms);

    event::emit(VestingPaused {
        vesting_id: object::id(vesting),
        paused_at: current_time,
    });
}

/// Resumes a paused vesting
public fun resume_vesting<CoinType>(
    vesting: &mut Vesting<CoinType>,
    clock: &Clock,
    ctx: &mut TxContext,
) {
    assert!(tx_context::sender(ctx) == vesting.primary_beneficiary, EUnauthorizedBeneficiary);
    assert!(vesting.is_paused, EVestingNotPaused);
    assert!(!vesting.emergency_frozen, EEmergencyFrozen);

    let current_time = clock.timestamp_ms();
    if (vesting.paused_at.is_some()) {
        let pause_start = *vesting.paused_at.borrow();
        let pause_duration = stream_utils::calculate_pause_duration(pause_start, current_time);
        vesting.paused_duration = vesting.paused_duration + pause_duration;
    };

    vesting.is_paused = false;
    vesting.paused_at = option::none();
    vesting.paused_until = option::none();

    event::emit(VestingResumed {
        vesting_id: object::id(vesting),
        resumed_at: current_time,
        pause_duration: vesting.paused_duration,
    });
}

/// Check if pause has expired and auto-unpause if needed
/// Can be called by anyone to help beneficiary
public fun check_and_unpause<CoinType>(
    vesting: &mut Vesting<CoinType>,
    clock: &Clock,
) {
    if (!vesting.is_paused) {
        return
    };

    let current_time = clock.timestamp_ms();

    // Use stream_utils to check if pause expired
    if (stream_utils::is_pause_expired(&vesting.paused_until, current_time)) {
        // Auto-unpause (doesn't require beneficiary permission)
        if (vesting.paused_at.is_some()) {
            let pause_start = *vesting.paused_at.borrow();
            let pause_duration = stream_utils::calculate_pause_duration(pause_start, current_time);
            vesting.paused_duration = vesting.paused_duration + pause_duration;
        };

        vesting.is_paused = false;
        vesting.paused_at = option::none();
        vesting.paused_until = option::none();

        event::emit(VestingResumed {
            vesting_id: object::id(vesting),
            resumed_at: current_time,
            pause_duration: vesting.paused_duration,
        });
    };
}

/// Adds a beneficiary to the vesting
public fun add_beneficiary<CoinType>(
    vesting: &mut Vesting<CoinType>,
    new_beneficiary: address,
    ctx: &mut TxContext,
) {
    assert!(tx_context::sender(ctx) == vesting.primary_beneficiary, EUnauthorizedBeneficiary);
    assert!(vesting.additional_beneficiaries.length() < vesting.max_beneficiaries - 1, ETooManyBeneficiaries);
    assert!(!vesting.additional_beneficiaries.contains(&new_beneficiary), EBeneficiaryAlreadyExists);
    assert!(new_beneficiary != vesting.primary_beneficiary, EBeneficiaryAlreadyExists);
    
    vesting.additional_beneficiaries.push_back(new_beneficiary);
    
    event::emit(BeneficiaryAdded {
        vesting_id: object::id(vesting),
        new_beneficiary,
    });
}

/// Removes a beneficiary from the vesting
public fun remove_beneficiary<CoinType>(
    vesting: &mut Vesting<CoinType>,
    beneficiary: address,
    ctx: &mut TxContext,
) {
    assert!(tx_context::sender(ctx) == vesting.primary_beneficiary, EUnauthorizedBeneficiary);
    
    let (found, index) = vesting.additional_beneficiaries.index_of(&beneficiary);
    assert!(found, EBeneficiaryNotFound);
    
    vesting.additional_beneficiaries.remove(index);
    
    event::emit(BeneficiaryRemoved {
        vesting_id: object::id(vesting),
        removed_beneficiary: beneficiary,
    });
}

/// Transfers the primary beneficiary role
public fun transfer_vesting<CoinType>(
    vesting: &mut Vesting<CoinType>,
    new_beneficiary: address,
    ctx: &mut TxContext,
) {
    assert!(tx_context::sender(ctx) == vesting.primary_beneficiary, EUnauthorizedBeneficiary);
    assert!(vesting.is_transferable, ENotTransferable);
    
    let old_beneficiary = vesting.primary_beneficiary;
    vesting.primary_beneficiary = new_beneficiary;
    
    // Remove new beneficiary from additional if present
    let (found, index) = vesting.additional_beneficiaries.index_of(&new_beneficiary);
    if (found) {
        vesting.additional_beneficiaries.remove(index);
    };
    
    event::emit(VestingTransferred {
        vesting_id: object::id(vesting),
        old_beneficiary,
        new_beneficiary,
    });
}

/// Updates vesting metadata
public fun update_metadata<CoinType>(
    vesting: &mut Vesting<CoinType>,
    metadata: Option<String>,
    ctx: &mut TxContext,
) {
    assert!(tx_context::sender(ctx) == vesting.primary_beneficiary, EUnauthorizedBeneficiary);
    vesting.metadata = metadata;
}

// === Emergency Controls ===

/// Emergency freeze - prevents all claims and unpause
/// Only callable by governance/authority (not beneficiary)
/// Note: This is public so DAO governance can call it
public fun emergency_freeze<CoinType>(
    vesting: &mut Vesting<CoinType>,
    clock: &Clock,
) {
    assert!(!vesting.emergency_frozen, EEmergencyFrozen);

    vesting.emergency_frozen = true;
    if (!vesting.is_paused) {
        vesting.is_paused = true;
        vesting.paused_at = option::some(clock.timestamp_ms());
        vesting.paused_until = option::none(); // Indefinite
    };

    event::emit(VestingFrozen {
        vesting_id: object::id(vesting),
        timestamp: clock.timestamp_ms(),
    });
}

/// Remove emergency freeze
/// Only callable by governance/authority
public fun emergency_unfreeze<CoinType>(
    vesting: &mut Vesting<CoinType>,
    clock: &Clock,
) {
    assert!(vesting.emergency_frozen, EVestingNotPaused);

    vesting.emergency_frozen = false;

    event::emit(VestingUnfrozen {
        vesting_id: object::id(vesting),
        timestamp: clock.timestamp_ms(),
    });

    // Note: Does NOT auto-unpause - beneficiary must explicitly unpause after unfreezing
}

// === Preview Functions ===

/// Calculate currently claimable amount (vested but not yet claimed)
public fun claimable_now<CoinType>(
    vesting: &Vesting<CoinType>,
    clock: &Clock,
): u64 {
    let current_time = clock.timestamp_ms();

    // Use stream_utils to check if claiming is allowed
    if (!stream_utils::can_claim(
        vesting.is_paused,
        vesting.emergency_frozen,
        &vesting.expiry_timestamp,
        current_time
    )) {
        return 0
    };

    // Check cliff
    if (vesting.cliff_time.is_some()) {
        let cliff = *vesting.cliff_time.borrow();
        if (current_time < cliff) {
            return 0
        };
    } else if (current_time < vesting.start_timestamp) {
        return 0
    };

    // Calculate claimable using stream_utils
    let total_amount = vesting.balance.value() + vesting.claimed_amount;
    stream_utils::calculate_claimable(
        total_amount,
        vesting.claimed_amount,
        vesting.start_timestamp,
        vesting.end_timestamp,
        current_time,
        vesting.paused_duration,
        &vesting.cliff_time
    )
}

/// Get next vesting time (when more tokens become available)
public fun next_vest_time<CoinType>(
    vesting: &Vesting<CoinType>,
    clock: &Clock,
): Option<u64> {
    let current_time = clock.timestamp_ms();

    // Use stream_utils for next vesting time calculation
    stream_utils::next_vesting_time(
        vesting.start_timestamp,
        vesting.end_timestamp,
        &vesting.cliff_time,
        &vesting.expiry_timestamp,
        current_time
    )
}

// NOTE: Expiry management removed - doesn't make sense for beneficiary to set their own expiry

/// Proposes to cancel a vesting
public fun new_cancel_vesting<Config, Outcome, IW: drop>(
    intent: &mut Intent<Outcome>,
    _account: &Account<Config>,
    vesting_id: ID,
    intent_witness: IW,
) {
    // Create the action struct
    let action = CancelVestingAction { vesting_id };

    // Serialize it
    let action_data = bcs::to_bytes(&action);

    // Add to intent with pre-serialized bytes
    intent.add_typed_action(
        framework_action_types::vesting_cancel(),
        action_data,
        intent_witness
    );

    // Explicitly destroy the action struct
    destroy_cancel_vesting_action(action);
}

/// Proposes to toggle vesting pause (pause or resume)
public fun new_toggle_vesting_pause<Outcome, IW: drop>(
    intent: &mut Intent<Outcome>,
    vesting_id: ID,
    pause_duration_ms: u64, // 0 = unpause, >0 = pause for duration
    intent_witness: IW,
) {
    let action = ToggleVestingPauseAction { vesting_id, pause_duration_ms };
    let action_data = bcs::to_bytes(&action);
    intent.add_typed_action(
        framework_action_types::toggle_vesting_pause(),
        action_data,
        intent_witness
    );
    destroy_toggle_vesting_pause_action(action);
}

/// Proposes to toggle vesting emergency freeze
public fun new_toggle_vesting_freeze<Outcome, IW: drop>(
    intent: &mut Intent<Outcome>,
    vesting_id: ID,
    freeze: bool, // true = freeze, false = unfreeze
    intent_witness: IW,
) {
    let action = ToggleVestingFreezeAction { vesting_id, freeze };
    let action_data = bcs::to_bytes(&action);
    intent.add_typed_action(
        framework_action_types::toggle_vesting_freeze(),
        action_data,
        intent_witness
    );
    destroy_toggle_vesting_freeze_action(action);
}

// === Execution Functions ===

/// Execute toggle vesting pause action
public fun do_toggle_vesting_pause<Config, Outcome: store, CoinType, IW: drop>(
    executable: &mut Executable<Outcome>,
    _account: &Account<Config>,
    vesting: &mut Vesting<CoinType>,
    clock: &Clock,
    version: VersionWitness,
    witness: IW,
    ctx: &mut TxContext,
) {
    let specs = executable.intent().action_specs();
    let spec = specs.borrow(executable.action_idx());

    // CRITICAL: Assert that the action type is what we expect
    action_validation::assert_action_type<framework_action_types::ToggleVestingPause>(spec);

    let action_data = intents::action_spec_data(spec);

    // Create BCS reader and deserialize
    let mut reader = bcs::new(*action_data);
    let vesting_id = object::id_from_bytes(bcs::peel_vec_u8(&mut reader));
    let pause_duration_ms = bcs::peel_u64(&mut reader);

    // Validate vesting ID matches
    assert!(object::id(vesting) == vesting_id, EWrongVesting);

    // Execute pause/unpause logic
    if (pause_duration_ms == 0) {
        // Unpause
        check_and_unpause(vesting, clock);
    } else {
        // Pause
        pause_vesting(vesting, pause_duration_ms, clock, ctx);
    };

    // Increment action index
    executable::increment_action_idx(executable);
}

/// Execute toggle vesting freeze action
public fun do_toggle_vesting_freeze<Config, Outcome: store, CoinType, IW: drop>(
    executable: &mut Executable<Outcome>,
    _account: &Account<Config>,
    vesting: &mut Vesting<CoinType>,
    clock: &Clock,
    version: VersionWitness,
    witness: IW,
) {
    let specs = executable.intent().action_specs();
    let spec = specs.borrow(executable.action_idx());

    // CRITICAL: Assert that the action type is what we expect
    action_validation::assert_action_type<framework_action_types::ToggleVestingFreeze>(spec);

    let action_data = intents::action_spec_data(spec);

    // Create BCS reader and deserialize
    let mut reader = bcs::new(*action_data);
    let vesting_id = object::id_from_bytes(bcs::peel_vec_u8(&mut reader));
    let freeze = bcs::peel_bool(&mut reader);

    // Validate vesting ID matches
    assert!(object::id(vesting) == vesting_id, EWrongVesting);

    // Execute freeze/unfreeze logic
    if (freeze) {
        emergency_freeze(vesting, clock);
    } else {
        emergency_unfreeze(vesting, clock);
    };

    // Increment action index
    executable::increment_action_idx(executable);
}

/// Deletes the CreateVestingAction
public fun delete_vesting_action<CoinType>(expired: &mut Expired) {
    use sui::bcs;
    use std::string;

    let spec = account_protocol::intents::remove_action_spec(expired);
    let action_data = account_protocol::intents::action_spec_data(&spec);
    let mut reader = bcs::new(*action_data);

    // We don't need the values, but we must peel them to consume the bytes
    let CreateVestingAction<CoinType> {
        amount: _,
        start_timestamp: _,
        end_timestamp: _,
        cliff_time: _,
        recipient: _,
        max_beneficiaries: _,
        max_per_withdrawal: _,
        min_interval_ms: _,
        is_transferable: _,
        is_cancelable: _,
        metadata: _,
    } = CreateVestingAction {
        amount: bcs::peel_u64(&mut reader),
        start_timestamp: bcs::peel_u64(&mut reader),
        end_timestamp: bcs::peel_u64(&mut reader),
        cliff_time: bcs::peel_option_u64(&mut reader),
        recipient: bcs::peel_address(&mut reader),
        max_beneficiaries: bcs::peel_u64(&mut reader),
        max_per_withdrawal: bcs::peel_u64(&mut reader),
        min_interval_ms: bcs::peel_u64(&mut reader),
        is_transferable: bcs::peel_bool(&mut reader),
        is_cancelable: bcs::peel_bool(&mut reader),
        metadata: (if (bcs::peel_bool(&mut reader)) {
            option::some(string::utf8(bcs::peel_vec_u8(&mut reader)))
        } else {
            option::none()
        }),
    };
}

/// Deletes the CancelVestingAction
public fun delete_cancel_vesting_action(expired: &mut Expired) {
    let _spec = intents::remove_action_spec(expired);
    // ActionSpec has drop, automatically cleaned up
}

// === Private Functions ===
// (Removed compute_vested - now using stream_utils::calculate_linear_vested)

// === Test Functions ===

#[test_only]
public fun balance<CoinType>(vesting: &Vesting<CoinType>): u64 {
    vesting.balance.value()
}

#[test_only]
public fun is_cancelable<CoinType>(vesting: &Vesting<CoinType>): bool {
    vesting.is_cancelable
}

#[test_only]
public fun is_transferable<CoinType>(vesting: &Vesting<CoinType>): bool {
    vesting.is_transferable
}

#[test_only]
public fun is_paused<CoinType>(vesting: &Vesting<CoinType>): bool {
    vesting.is_paused
}

#[test_only]
public fun beneficiaries_count<CoinType>(vesting: &Vesting<CoinType>): u64 {
    1 + vesting.additional_beneficiaries.length()
}
module account_actions::owned_intents;

use account_actions::transfer as acc_transfer;
use account_actions::vault;
use account_actions::version;
use account_actions::vesting;
use account_protocol::account::{Account, Auth};
use account_protocol::executable::Executable;
use account_protocol::intent_interface;
use account_protocol::intents::Params;
use account_protocol::owned;
use std::string::String;
use std::type_name;
use sui::clock::Clock;
use sui::coin::Coin;
use sui::transfer::Receiving;

// === Imports ===

// === Aliases ===

use fun intent_interface::process_intent as Account.process_intent;

// === Errors ===

const EObjectsRecipientsNotSameLength: u64 = 0;
const ECoinsRecipientsNotSameLength: u64 = 1;
const ENoVault: u64 = 2;

// === Structs ===

/// Intent Witness defining the intent to withdraw a coin and deposit it into a vault.
public struct WithdrawAndTransferToVaultIntent() has copy, drop;
/// Intent Witness defining the intent to withdraw and transfer multiple objects.
public struct WithdrawObjectsAndTransferIntent() has copy, drop;
/// Intent Witness defining the intent to withdraw and transfer multiple coins.
public struct WithdrawCoinsAndTransferIntent() has copy, drop;
/// Intent Witness defining the intent to withdraw a coin and create a vesting.
public struct WithdrawAndVestIntent() has copy, drop;

// === Public functions ===

/// Creates a WithdrawAndTransferToVaultIntent and adds it to an Account.
public fun request_withdraw_and_transfer_to_vault<Config, Outcome: store, CoinType>(
    auth: Auth,
    account: &mut Account<Config>,
    params: Params,
    outcome: Outcome,
    coin_amount: u64,
    vault_name: String,
    ctx: &mut TxContext,
) {
    account.verify(auth);
    params.assert_single_execution();
    assert!(vault::has_vault(account, vault_name), ENoVault);

    intent_interface::build_intent!(
        account,
        params,
        outcome,
        b"".to_string(),
        version::current(),
        WithdrawAndTransferToVaultIntent(),
        ctx,
        |intent, iw| {
            owned::new_withdraw_coin(
                intent,
                account,
                type_name_to_string<CoinType>(),
                coin_amount,
                iw,
            );
            vault::new_deposit<_, CoinType, _>(intent, vault_name, coin_amount, iw);
        },
    );
}

/// Executes a WithdrawAndTransferToVaultIntent, deposits a coin owned by the account into a vault.
public fun execute_withdraw_and_transfer_to_vault<Config, Outcome: store, CoinType: drop>(
    executable: &mut Executable<Outcome>,
    account: &mut Account<Config>,
    receiving: Receiving<Coin<CoinType>>,
) {
    account.process_intent!(
        executable,
        version::current(),
        WithdrawAndTransferToVaultIntent(),
        |executable, iw| {
            let object = owned::do_withdraw_coin(executable, account, receiving, iw);
            vault::do_deposit<_, _, CoinType, _>(
                executable,
                account,
                object,
                version::current(),
                iw,
            );
        },
    );
}

/// Creates a WithdrawObjectsAndTransferIntent and adds it to an Account.
public fun request_withdraw_objects_and_transfer<Config, Outcome: store>(
    auth: Auth,
    account: &mut Account<Config>,
    params: Params,
    outcome: Outcome,
    object_ids: vector<ID>,
    recipients: vector<address>,
    ctx: &mut TxContext,
) {
    account.verify(auth);
    params.assert_single_execution();
    assert!(object_ids.length() == recipients.length(), EObjectsRecipientsNotSameLength);

    intent_interface::build_intent!(
        account,
        params,
        outcome,
        b"".to_string(),
        version::current(),
        WithdrawObjectsAndTransferIntent(),
        ctx,
        |intent, iw| object_ids.zip_do!(recipients, |object_id, recipient| {
            owned::new_withdraw_object(intent, account, object_id, iw);
            acc_transfer::new_transfer(intent, recipient, iw);
        }),
    );
}

/// Executes a WithdrawObjectsAndTransferIntent, transfers an object owned by the account. Can be looped over.
public fun execute_withdraw_object_and_transfer<Config, Outcome: store, T: key + store>(
    executable: &mut Executable<Outcome>,
    account: &mut Account<Config>,
    receiving: Receiving<T>,
) {
    account.process_intent!(
        executable,
        version::current(),
        WithdrawObjectsAndTransferIntent(),
        |executable, iw| {
            let object = owned::do_withdraw_object(executable, account, receiving, iw);
            acc_transfer::do_transfer(executable, object, iw);
        },
    );
}

/// Creates a WithdrawCoinsAndTransferIntent and adds it to an Account.
public fun request_withdraw_coins_and_transfer<Config, Outcome: store>(
    auth: Auth,
    account: &mut Account<Config>,
    params: Params,
    outcome: Outcome,
    coin_types: vector<String>,
    coin_amounts: vector<u64>,
    mut recipients: vector<address>,
    ctx: &mut TxContext,
) {
    account.verify(auth);
    params.assert_single_execution();
    assert!(
        coin_types.length() == coin_amounts.length() && coin_types.length() == recipients.length(),
        ECoinsRecipientsNotSameLength,
    );

    intent_interface::build_intent!(
        account,
        params,
        outcome,
        b"".to_string(),
        version::current(),
        WithdrawCoinsAndTransferIntent(),
        ctx,
        |intent, iw| coin_types.zip_do!(coin_amounts, |coin_type, coin_amount| {
            let recipient = recipients.remove(0);
            owned::new_withdraw_coin(intent, account, coin_type, coin_amount, iw);
            acc_transfer::new_transfer(intent, recipient, iw);
        }),
    );
}

/// Executes a WithdrawCoinsAndTransferIntent, transfers a coin owned by the account. Can be looped over.
public fun execute_withdraw_coin_and_transfer<Config, Outcome: store, CoinType>(
    executable: &mut Executable<Outcome>,
    account: &mut Account<Config>,
    receiving: Receiving<Coin<CoinType>>,
) {
    account.process_intent!(
        executable,
        version::current(),
        WithdrawCoinsAndTransferIntent(),
        |executable, iw| {
            let object = owned::do_withdraw_coin(executable, account, receiving, iw);
            acc_transfer::do_transfer(executable, object, iw);
        },
    );
}

/// Creates a WithdrawAndVestIntent and adds it to an Account.
public fun request_withdraw_and_vest<Config, Outcome: store, CoinType>(
    auth: Auth,
    account: &mut Account<Config>,
    params: Params,
    outcome: Outcome,
    recipients: vector<address>,
    amounts: vector<u64>,
    start_timestamp: u64,
    end_timestamp: u64,
    ctx: &mut TxContext,
) {
    account.verify(auth);
    params.assert_single_execution();

    // Calculate total amount needed
    let mut total_amount = 0u64;
    let mut i = 0;
    let len = amounts.length();
    while (i < len) {
        total_amount = total_amount + *amounts.borrow(i);
        i = i + 1;
    };

    intent_interface::build_intent!(
        account,
        params,
        outcome,
        b"".to_string(),
        version::current(),
        WithdrawAndVestIntent(),
        ctx,
        |intent, iw| {
            owned::new_withdraw_coin<_, _, _>(
                intent,
                account,
                type_name_to_string<CoinType>(),
                total_amount,
                iw,
            );
            vesting::new_vesting<_, _, CoinType, _>(
                intent,
                account,
                recipients,
                amounts,
                start_timestamp,
                end_timestamp,
                option::none(),
                1,
                total_amount,
                0,
                false,
                false,
                option::none(),
                iw,
            );
        },
    );
}

/// Executes a WithdrawAndVestIntent, withdraws a coin and creates a vesting.
public fun execute_withdraw_and_vest<Config, Outcome: store, CoinType>(
    executable: &mut Executable<Outcome>,
    account: &mut Account<Config>,
    receiving: Receiving<Coin<CoinType>>,
    clock: &Clock,
    ctx: &mut TxContext,
) {
    account.process_intent!(
        executable,
        version::current(),
        WithdrawAndVestIntent(),
        |executable, iw| {
            let coin = owned::do_withdraw_coin<_, _, CoinType, _>(
                executable,
                account,
                receiving,
                iw,
            );
            vesting::do_vesting<_, _, CoinType, _>(executable, account, coin, clock, iw, ctx);
        },
    );
}

// === Private functions ===

fun type_name_to_string<T>(): String {
    type_name::with_defining_ids<T>().into_string().to_string()
}
module account_actions::kiosk_intents;

use account_actions::kiosk as acc_kiosk;
use account_actions::version;
use account_protocol::account::{Account, Auth};
use account_protocol::executable::Executable;
use account_protocol::intent_interface;
use account_protocol::intents::Params;
use std::string::String;
use sui::kiosk::{Kiosk, KioskOwnerCap};
use sui::transfer_policy::{TransferPolicy, TransferRequest};

// === Imports ===

// === Aliases ===

use fun intent_interface::build_intent as Account.build_intent;
use fun intent_interface::process_intent as Account.process_intent;

// === Errors ===

const ENoLock: u64 = 0;
const ENftsPricesNotSameLength: u64 = 1;

// === Structs ===

/// Intent Witness defining the intent to take nfts from a kiosk managed by a account to another kiosk.
public struct TakeNftsIntent() has copy, drop;
/// Intent Witness defining the intent to list nfts in a kiosk managed by a account.
public struct ListNftsIntent() has copy, drop;

// === Public functions ===

/// Creates a TakeNftsIntent and adds it to an Account.
public fun request_take_nfts<Config, Outcome: store>(
    auth: Auth,
    account: &mut Account<Config>,
    params: Params,
    outcome: Outcome,
    kiosk_name: String,
    nft_ids: vector<ID>,
    recipient: address,
    ctx: &mut TxContext,
) {
    account.verify(auth);
    params.assert_single_execution();
    assert!(acc_kiosk::has_lock(account, kiosk_name), ENoLock);

    account.build_intent!(
        params,
        outcome,
        kiosk_name,
        version::current(),
        TakeNftsIntent(),
        ctx,
        |intent, iw| nft_ids.do!(
            |nft_id| acc_kiosk::new_take(intent, kiosk_name, nft_id, recipient, iw),
        ),
    );
}

/// Executes a TakeNftsIntent, takes nfts from a kiosk managed by a account to another kiosk. Can be looped over.
public fun execute_take_nfts<Config, Outcome: store, Nft: key + store>(
    executable: &mut Executable<Outcome>,
    account: &mut Account<Config>,
    account_kiosk: &mut Kiosk,
    recipient_kiosk: &mut Kiosk,
    recipient_cap: &KioskOwnerCap,
    policy: &mut TransferPolicy<Nft>,
    ctx: &mut TxContext,
): TransferRequest<Nft> {
    account.process_intent!(
        executable,
        version::current(),
        TakeNftsIntent(),
        |executable, iw| acc_kiosk::do_take<_, _, Nft, _>(
            executable,
            account,
            account_kiosk,
            recipient_kiosk,
            recipient_cap,
            policy,
            version::current(),
            iw,
            ctx,
        ),
    )
}

/// Creates a ListNftsIntent and adds it to an Account.
public fun request_list_nfts<Config, Outcome: store>(
    auth: Auth,
    account: &mut Account<Config>,
    params: Params,
    outcome: Outcome,
    kiosk_name: String,
    nft_ids: vector<ID>,
    prices: vector<u64>,
    ctx: &mut TxContext,
) {
    account.verify(auth);
    assert!(acc_kiosk::has_lock(account, kiosk_name), ENoLock);
    assert!(nft_ids.length() == prices.length(), ENftsPricesNotSameLength);

    account.build_intent!(
        params,
        outcome,
        kiosk_name,
        version::current(),
        ListNftsIntent(),
        ctx,
        |intent, iw| nft_ids.zip_do!(
            prices,
            |nft_id, price| acc_kiosk::new_list(intent, kiosk_name, nft_id, price, iw),
        ),
    );
}

/// Executes a ListNftsIntent, lists nfts in a kiosk managed by a account. Can be looped over.
public fun execute_list_nfts<Config, Outcome: store, Nft: key + store>(
    executable: &mut Executable<Outcome>,
    account: &mut Account<Config>,
    kiosk: &mut Kiosk,
) {
    account.process_intent!(
        executable,
        version::current(),
        ListNftsIntent(),
        |executable, iw| acc_kiosk::do_list<_, _, Nft, _>(
            executable,
            account,
            kiosk,
            version::current(),
            iw,
        ),
    );
}
module account_actions::package_upgrade_intents;

use account_actions::package_upgrade;
use account_actions::version;
use account_protocol::account::{Account, Auth};
use account_protocol::executable::Executable;
use account_protocol::intent_interface;
use account_protocol::intents::Params;
use std::string::String;
use sui::clock::Clock;
use sui::package::{Self, UpgradeTicket, UpgradeReceipt};

// === Imports ===

// === Aliases ===

use fun intent_interface::build_intent as Account.build_intent;
use fun intent_interface::process_intent as Account.process_intent;

// === Errors ===

const EInvalidPolicy: u64 = 1;
const EPolicyShouldRestrict: u64 = 2;
const ENoLock: u64 = 3;
const ETimeDelay: u64 = 4;

// === Structs ===

/// Intent Witness defining the intent to upgrade a package.
public struct UpgradePackageIntent() has copy, drop;
/// Intent Witness defining the intent to restrict an UpgradeCap.
public struct RestrictPolicyIntent() has copy, drop;

// === Public Functions ===

/// Creates an UpgradePackageIntent and adds it to an Account.
public fun request_upgrade_package<Config, Outcome: store>(
    auth: Auth,
    account: &mut Account<Config>,
    params: Params,
    outcome: Outcome,
    package_name: String,
    digest: vector<u8>,
    ctx: &mut TxContext,
) {
    account.verify(auth);
    params.assert_single_execution();

    assert!(package_upgrade::has_cap(account, package_name), ENoLock);
    assert!(
        params.execution_times()[0] >= params.creation_time() + package_upgrade::get_time_delay(account, package_name),
        ETimeDelay,
    );

    account.build_intent!(
        params,
        outcome,
        package_name,
        version::current(),
        UpgradePackageIntent(),
        ctx,
        |intent, iw| {
            package_upgrade::new_upgrade(intent, package_name, digest, iw);
            package_upgrade::new_commit(intent, package_name, iw);
        },
    );
}

/// Executes an UpgradePackageIntent, returns the UpgradeTicket for upgrading.
public fun execute_upgrade_package<Config, Outcome: store>(
    executable: &mut Executable<Outcome>,
    account: &mut Account<Config>,
    clock: &Clock,
): UpgradeTicket {
    account.process_intent!(
        executable,
        version::current(),
        UpgradePackageIntent(),
        |executable, iw| package_upgrade::do_upgrade(
            executable,
            account,
            clock,
            version::current(),
            iw,
        ),
    )
}

/// Need to consume the ticket to upgrade the package before completing the intent.

public fun execute_commit_upgrade<Config, Outcome: store>(
    executable: &mut Executable<Outcome>,
    account: &mut Account<Config>,
    receipt: UpgradeReceipt,
) {
    account.process_intent!(
        executable,
        version::current(),
        UpgradePackageIntent(),
        |executable, iw| package_upgrade::do_commit(
            executable,
            account,
            receipt,
            version::current(),
            iw,
        ),
    )
}

/// Creates a RestrictPolicyIntent and adds it to an Account.
public fun request_restrict_policy<Config, Outcome: store>(
    auth: Auth,
    account: &mut Account<Config>,
    params: Params,
    outcome: Outcome,
    package_name: String,
    policy: u8,
    ctx: &mut TxContext,
) {
    account.verify(auth);
    params.assert_single_execution();

    let current_policy = package_upgrade::get_cap_policy(account, package_name);
    assert!(policy > current_policy, EPolicyShouldRestrict);
    assert!(
        policy == package::additive_policy() ||
        policy == package::dep_only_policy() ||
        policy == 255, // make immutable
        EInvalidPolicy,
    );

    account.build_intent!(
        params,
        outcome,
        package_name,
        version::current(),
        RestrictPolicyIntent(),
        ctx,
        |intent, iw| package_upgrade::new_restrict(intent, package_name, policy, iw),
    );
}

/// Restricts the upgrade policy.
public fun execute_restrict_policy<Config, Outcome: store>(
    executable: &mut Executable<Outcome>,
    account: &mut Account<Config>,
) {
    account.process_intent!(
        executable,
        version::current(),
        RestrictPolicyIntent(),
        |executable, iw| package_upgrade::do_restrict(executable, account, version::current(), iw),
    );
}
module account_actions::empty_intents;

use account_actions::version;
use account_protocol::account::{Account, Auth};
use account_protocol::executable::Executable;
use account_protocol::intent_interface;
use account_protocol::intents::Params;

// === Imports ===

// === Aliases ===

use fun intent_interface::build_intent as Account.build_intent;
use fun intent_interface::process_intent as Account.process_intent;

// === Structs ===

/// Intent Witness defining an intent with no action.
public struct EmptyIntent() has copy, drop;

// === Public functions ===

/// Creates an EmptyIntent and adds it to an Account.
public fun request_empty<Config, Outcome: store>(
    auth: Auth,
    account: &mut Account<Config>,
    params: Params,
    outcome: Outcome,
    ctx: &mut TxContext,
) {
    account.verify(auth);

    account.build_intent!(
        params,
        outcome,
        b"".to_string(),
        version::current(),
        EmptyIntent(),
        ctx,
        |_intent, _iw| {},
    );
}

/// Executes an EmptyIntent (to be able to delete it)
public fun execute_empty<Config, Outcome: store>(
    executable: &mut Executable<Outcome>,
    account: &mut Account<Config>,
) {
    account.process_intent!(executable, version::current(), EmptyIntent(), |_executable, _iw| {})
}
// ============================================================================
// FORK MODIFICATION NOTICE - Vault Intents
// ============================================================================
// Intent helper module for vault operations.
//
// CHANGES IN THIS FORK:
// - PTBs handle object flow naturally - no ExecutionContext needed
// - Removed ActionResult consumption - no longer needed
// ============================================================================

module account_actions::vault_intents;

use account_actions::transfer as acc_transfer;
use account_actions::vault;
use account_actions::version;
use account_protocol::account::{Account, Auth};
use account_protocol::executable::Executable;
use account_protocol::intent_interface;
use account_protocol::intents::Params;
use std::string::String;

// === Imports ===

// === Aliases ===

use fun intent_interface::build_intent as Account.build_intent;
use fun intent_interface::process_intent as Account.process_intent;

// === Errors ===

const ENotSameLength: u64 = 0;
const EInsufficientFunds: u64 = 1;
const ECoinTypeDoesntExist: u64 = 2;

// === Structs ===

/// Intent Witness defining the vault spend and transfer intent, and associated role.
public struct SpendAndTransferIntent() has copy, drop;

// === Public Functions ===

/// Creates a SpendAndTransferIntent and adds it to an Account.
public fun request_spend_and_transfer<Config, Outcome: store, CoinType: drop>(
    auth: Auth,
    account: &mut Account<Config>,
    params: Params,
    outcome: Outcome,
    vault_name: String,
    amounts: vector<u64>,
    recipients: vector<address>,
    ctx: &mut TxContext,
) {
    account.verify(auth);
    assert!(amounts.length() == recipients.length(), ENotSameLength);

    let vault = vault::borrow_vault(account, vault_name);
    assert!(vault.coin_type_exists<CoinType>(), ECoinTypeDoesntExist);
    assert!(
        amounts.fold!(0u64, |sum, amount| sum + amount) <= vault.coin_type_value<CoinType>(),
        EInsufficientFunds,
    );

    account.build_intent!(
        params,
        outcome,
        vault_name,
        version::current(),
        SpendAndTransferIntent(),
        ctx,
        |intent, iw| amounts.zip_do!(recipients, |amount, recipient| {
            vault::new_spend<_, CoinType, _>(intent, vault_name, amount, iw);
            acc_transfer::new_transfer(intent, recipient, iw);
        }),
    );
}

/// Executes a SpendAndTransferIntent, transfers coins from the vault to the recipients. Can be looped over.
public fun execute_spend_and_transfer<Config, Outcome: store, CoinType: drop>(
    executable: &mut Executable<Outcome>,
    account: &mut Account<Config>,
    ctx: &mut TxContext,
) {
    account.process_intent!(
        executable,
        version::current(),
        SpendAndTransferIntent(),
        |executable, iw| {
            let coin = vault::do_spend<_, _, CoinType, _>(
                executable,
                account,
                version::current(),
                iw,
                ctx,
            );
            acc_transfer::do_transfer(executable, coin, iw);
        },
    );
}

// === Stream Control Actions ===

/// Request to toggle stream pause (pause or resume)
public fun request_toggle_stream_pause<Config, Outcome: store>(
    auth: Auth,
    account: &mut Account<Config>,
    params: Params,
    outcome: Outcome,
    vault_name: String,
    stream_id: ID,
    pause_duration_ms: u64, // 0 = unpause, >0 = pause for duration
    ctx: &mut TxContext,
) {
    account.verify(auth);

    account.build_intent!(
        params,
        outcome,
        vault_name,
        version::current(),
        SpendAndTransferIntent(), // TODO: Should this be a different witness?
        ctx,
        |intent, iw| {
            vault::new_toggle_stream_pause(intent, vault_name, stream_id, pause_duration_ms, iw);
        },
    );
}

/// Request to toggle stream emergency freeze
public fun request_toggle_stream_freeze<Config, Outcome: store>(
    auth: Auth,
    account: &mut Account<Config>,
    params: Params,
    outcome: Outcome,
    vault_name: String,
    stream_id: ID,
    freeze: bool, // true = freeze, false = unfreeze
    ctx: &mut TxContext,
) {
    account.verify(auth);

    account.build_intent!(
        params,
        outcome,
        vault_name,
        version::current(),
        SpendAndTransferIntent(), // TODO: Should this be a different witness?
        ctx,
        |intent, iw| {
            vault::new_toggle_stream_freeze(intent, vault_name, stream_id, freeze, iw);
        },
    );
}

// === Execution Functions ===

/// Executes toggle stream pause action
public fun execute_toggle_stream_pause<Config, Outcome: store, CoinType>(
    executable: &mut Executable<Outcome>,
    account: &mut Account<Config>,
    vault_name: String,
    clock: &sui::clock::Clock,
    ctx: &mut TxContext,
) {
    account.process_intent!(
        executable,
        version::current(),
        SpendAndTransferIntent(),
        |executable, iw| {
            vault::do_toggle_stream_pause<_, _, CoinType, _>(
                executable,
                account,
                vault_name,
                clock,
                version::current(),
                iw,
                ctx,
            );
        },
    );
}

/// Executes toggle stream freeze action
public fun execute_toggle_stream_freeze<Config, Outcome: store, CoinType>(
    executable: &mut Executable<Outcome>,
    account: &mut Account<Config>,
    vault_name: String,
    clock: &sui::clock::Clock,
    ctx: &mut TxContext,
) {
    account.process_intent!(
        executable,
        version::current(),
        SpendAndTransferIntent(),
        |executable, iw| {
            vault::do_toggle_stream_freeze<_, _, CoinType, _>(
                executable,
                account,
                vault_name,
                clock,
                version::current(),
                iw,
            );
        },
    );
}
// ============================================================================
// FORK MODIFICATION NOTICE - Currency Intents
// ============================================================================
// Intent helper module for currency operations.
//
// CHANGES IN THIS FORK:
// - PTBs handle object flow naturally - no ExecutionContext needed
// - Removed ActionResult consumption - no longer needed
// ============================================================================

module account_actions::currency_intents;

use account_actions::currency;
use account_actions::transfer as acc_transfer;
use account_actions::version;
use account_protocol::account::{Account, Auth};
use account_protocol::executable::Executable;
use account_protocol::intent_interface;
use account_protocol::intents::Params;
use account_protocol::owned;
use std::ascii;
use std::string::String;
use std::type_name;
use sui::coin::{Coin, CoinMetadata};
use sui::transfer::Receiving;

// === Imports ===

// === Aliases ===

use fun intent_interface::build_intent as Account.build_intent;
use fun intent_interface::process_intent as Account.process_intent;

// === Errors ===

const EAmountsRecipentsNotSameLength: u64 = 0;
const EMaxSupply: u64 = 1;
const ENoLock: u64 = 2;
const ECannotUpdateSymbol: u64 = 3;
const ECannotUpdateName: u64 = 4;
const ECannotUpdateDescription: u64 = 5;
const ECannotUpdateIcon: u64 = 6;
const EMintDisabled: u64 = 7;
const EBurnDisabled: u64 = 8;

// === Structs ===

/// Intent Witness defining the intent to disable one or more permissions.
public struct DisableRulesIntent() has copy, drop;
/// Intent Witness defining the intent to update the CoinMetadata associated with a locked TreasuryCap.
public struct UpdateMetadataIntent() has copy, drop;
/// Intent Witness defining the intent to transfer a minted coin.
public struct MintAndTransferIntent() has copy, drop;
/// Intent Witness defining the intent to burn coins from the account using a locked TreasuryCap.
public struct WithdrawAndBurnIntent() has copy, drop;

// === Public functions ===

/// Creates a DisableRulesIntent and adds it to an Account.
public fun request_disable_rules<Config, Outcome: store, CoinType>(
    auth: Auth,
    account: &mut Account<Config>,
    params: Params,
    outcome: Outcome,
    mint: bool,
    burn: bool,
    update_symbol: bool,
    update_name: bool,
    update_description: bool,
    update_icon: bool,
    ctx: &mut TxContext,
) {
    account.verify(auth);
    params.assert_single_execution();
    assert!(currency::has_cap<_, CoinType>(account), ENoLock);

    account.build_intent!(
        params,
        outcome,
        type_name_to_string<CoinType>(),
        version::current(),
        DisableRulesIntent(),
        ctx,
        |intent, iw| currency::new_disable<_, CoinType, _>(
            intent,
            mint,
            burn,
            update_symbol,
            update_name,
            update_description,
            update_icon,
            iw,
        ),
    );
}

/// Executes a DisableRulesIntent, disables rules for the coin forever.
public fun execute_disable_rules<Config, Outcome: store, CoinType>(
    executable: &mut Executable<Outcome>,
    account: &mut Account<Config>,
) {
    account.process_intent!(
        executable,
        version::current(),
        DisableRulesIntent(),
        |executable, iw| currency::do_disable<_, _, CoinType, _>(
            executable,
            account,
            version::current(),
            iw,
        ),
    );
}

/// Creates an UpdateMetadataIntent and adds it to an Account.
public fun request_update_metadata<Config, Outcome: store, CoinType>(
    auth: Auth,
    account: &mut Account<Config>,
    params: Params,
    outcome: Outcome,
    md_symbol: Option<ascii::String>,
    md_name: Option<String>,
    md_description: Option<String>,
    md_icon_url: Option<ascii::String>,
    ctx: &mut TxContext,
) {
    account.verify(auth);
    params.assert_single_execution();

    let rules = currency::borrow_rules<_, CoinType>(account);
    if (!rules.can_update_symbol()) assert!(md_symbol.is_none(), ECannotUpdateSymbol);
    if (!rules.can_update_name()) assert!(md_name.is_none(), ECannotUpdateName);
    if (!rules.can_update_description())
        assert!(md_description.is_none(), ECannotUpdateDescription);
    if (!rules.can_update_icon()) assert!(md_icon_url.is_none(), ECannotUpdateIcon);

    account.build_intent!(
        params,
        outcome,
        type_name_to_string<CoinType>(),
        version::current(),
        UpdateMetadataIntent(),
        ctx,
        |intent, iw| currency::new_update<_, CoinType, _>(
            intent,
            md_symbol,
            md_name,
            md_description,
            md_icon_url,
            iw,
        ),
    );
}

/// Executes an UpdateMetadataIntent, updates the CoinMetadata.
public fun execute_update_metadata<Config, Outcome: store, CoinType>(
    executable: &mut Executable<Outcome>,
    account: &mut Account<Config>,
    metadata: &mut CoinMetadata<CoinType>,
) {
    account.process_intent!(
        executable,
        version::current(),
        UpdateMetadataIntent(),
        |executable, iw| currency::do_update<_, _, CoinType, _>(
            executable,
            account,
            metadata,
            version::current(),
            iw,
        ),
    );
}

/// Creates a MintAndTransferIntent and adds it to an Account.
public fun request_mint_and_transfer<Config, Outcome: store, CoinType>(
    auth: Auth,
    account: &mut Account<Config>,
    params: Params,
    outcome: Outcome,
    amounts: vector<u64>,
    recipients: vector<address>,
    ctx: &mut TxContext,
) {
    account.verify(auth);
    assert!(amounts.length() == recipients.length(), EAmountsRecipentsNotSameLength);

    let rules = currency::borrow_rules<_, CoinType>(account);
    assert!(rules.can_mint(), EMintDisabled);
    let sum = amounts.fold!(0, |sum, amount| sum + amount);
    if (rules.max_supply().is_some()) assert!(sum <= *rules.max_supply().borrow(), EMaxSupply);

    account.build_intent!(
        params,
        outcome,
        type_name_to_string<CoinType>(),
        version::current(),
        MintAndTransferIntent(),
        ctx,
        |intent, iw| amounts.zip_do!(recipients, |amount, recipient| {
            currency::new_mint<_, CoinType, _>(intent, amount, iw);
            acc_transfer::new_transfer(intent, recipient, iw);
        }),
    );
}

/// Executes a MintAndTransferIntent, sends managed coins. Can be looped over.
public fun execute_mint_and_transfer<Config, Outcome: store, CoinType>(
    executable: &mut Executable<Outcome>,
    account: &mut Account<Config>,
    ctx: &mut TxContext,
) {
    account.process_intent!(
        executable,
        version::current(),
        MintAndTransferIntent(),
        |executable, iw| {
            let coin = currency::do_mint<_, _, CoinType, _>(
                executable,
                account,
                version::current(),
                iw,
                ctx,
            );
            acc_transfer::do_transfer(executable, coin, iw);
        },
    );
}

/// Creates a WithdrawAndBurnIntent and adds it to an Account.
public fun request_withdraw_and_burn<Config, Outcome: store, CoinType>(
    auth: Auth,
    account: &mut Account<Config>,
    params: Params,
    outcome: Outcome,
    coin_id: ID,
    amount: u64,
    ctx: &mut TxContext,
) {
    account.verify(auth);
    params.assert_single_execution();

    let rules = currency::borrow_rules<_, CoinType>(account);
    assert!(rules.can_burn(), EBurnDisabled);

    intent_interface::build_intent!(
        account,
        params,
        outcome,
        type_name_to_string<CoinType>(),
        version::current(),
        WithdrawAndBurnIntent(),
        ctx,
        |intent, iw| {
            owned::new_withdraw_object<_, _, _>(intent, account, coin_id, iw);
            currency::new_burn<_, CoinType, _>(intent, amount, iw);
        },
    );
}

/// Executes a WithdrawAndBurnIntent, burns a coin owned by the account.
public fun execute_withdraw_and_burn<Config, Outcome: store, CoinType>(
    executable: &mut Executable<Outcome>,
    account: &mut Account<Config>,
    receiving: Receiving<Coin<CoinType>>,
) {
    account.process_intent!(
        executable,
        version::current(),
        WithdrawAndBurnIntent(),
        |executable, iw| {
            let coin = owned::do_withdraw_object<_, _, Coin<CoinType>, _>(
                executable,
                account,
                receiving,
                iw,
            );
            currency::do_burn<_, _, CoinType, _>(executable, account, coin, version::current(), iw);
        },
    );
}

// === Private functions ===

fun type_name_to_string<T>(): String {
    type_name::with_defining_ids<T>().into_string().to_string()
}
module account_actions::access_control_intents;

use account_actions::access_control as ac;
use account_actions::version;
use account_protocol::account::{Account, Auth};
use account_protocol::executable::Executable;
use account_protocol::intent_interface;
use account_protocol::intents::Params;
use std::string::String;
use std::type_name;

// === Imports ===

// === Aliases ===

use fun intent_interface::build_intent as Account.build_intent;
use fun intent_interface::process_intent as Account.process_intent;

// === Errors ===

const ENoLock: u64 = 0;

// === Structs ===

/// Intent Witness defining the intent to borrow an access cap.
public struct BorrowCapIntent() has copy, drop;

// === Public functions ===

/// Creates a BorrowCapIntent and adds it to an Account.
public fun request_borrow_cap<Config, Outcome: store, Cap>(
    auth: Auth,
    account: &mut Account<Config>,
    params: Params,
    outcome: Outcome,
    ctx: &mut TxContext,
) {
    account.verify(auth);
    assert!(ac::has_lock<_, Cap>(account), ENoLock);

    account.build_intent!(
        params,
        outcome,
        type_name_to_string<Cap>(),
        version::current(),
        BorrowCapIntent(),
        ctx,
        |intent, iw| {
            ac::new_borrow<_, Cap, _>(intent, iw);
            ac::new_return<_, Cap, _>(intent, iw);
        },
    );
}

/// Executes a BorrowCapIntent, returns a cap and a hot potato.
public fun execute_borrow_cap<Config, Outcome: store, Cap: key + store>(
    executable: &mut Executable<Outcome>,
    account: &mut Account<Config>,
): Cap {
    account.process_intent!(
        executable,
        version::current(),
        BorrowCapIntent(),
        |executable, iw| ac::do_borrow(executable, account, version::current(), iw),
    )
}

/// Completes a BorrowCapIntent, destroys the executable and returns the cap to the account if the matching hot potato is returned.
public fun execute_return_cap<Config, Outcome: store, Cap: key + store>(
    executable: &mut Executable<Outcome>,
    account: &mut Account<Config>,
    cap: Cap,
) {
    account.process_intent!(
        executable,
        version::current(),
        BorrowCapIntent(),
        |executable, iw| ac::do_return(executable, account, cap, version::current(), iw),
    )
}

// === Private functions ===

fun type_name_to_string<T>(): String {
    type_name::with_defining_ids<T>().into_string().to_string()
}
// ============================================================================
// FORK ADDITION - Vesting Intents
// ============================================================================
// Intent helper module for vesting operations.
//
// CHANGES IN THIS FORK:
// - PTBs handle object flow naturally - no ExecutionContext needed
// - Provides high-level request functions for vesting toggle actions
// ============================================================================

module account_actions::vesting_intents;

use account_actions::version;
use account_actions::vesting;
use account_protocol::account::{Account, Auth};
use account_protocol::executable::Executable;
use account_protocol::intent_interface;
use account_protocol::intents::Params;
use std::string::String;
use sui::object::ID;

// === Imports ===

// === Aliases ===

use fun intent_interface::build_intent as Account.build_intent;
use fun intent_interface::process_intent as Account.process_intent;

// === Structs ===

/// Intent Witness defining the vesting control intent
public struct VestingControlIntent() has copy, drop;

// === Public Functions ===

/// Request to toggle vesting pause (pause or resume)
public fun request_toggle_vesting_pause<Config, Outcome: store>(
    auth: Auth,
    account: &mut Account<Config>,
    params: Params,
    outcome: Outcome,
    vesting_id: ID,
    pause_duration_ms: u64, // 0 = unpause, >0 = pause for duration
    ctx: &mut TxContext,
) {
    account.verify(auth);

    account.build_intent!(
        params,
        outcome,
        b"".to_string(),
        version::current(),
        VestingControlIntent(),
        ctx,
        |intent, iw| {
            vesting::new_toggle_vesting_pause(intent, vesting_id, pause_duration_ms, iw);
        },
    );
}

/// Request to toggle vesting emergency freeze
public fun request_toggle_vesting_freeze<Config, Outcome: store>(
    auth: Auth,
    account: &mut Account<Config>,
    params: Params,
    outcome: Outcome,
    vesting_id: ID,
    freeze: bool, // true = freeze, false = unfreeze
    ctx: &mut TxContext,
) {
    account.verify(auth);

    account.build_intent!(
        params,
        outcome,
        b"".to_string(),
        version::current(),
        VestingControlIntent(),
        ctx,
        |intent, iw| {
            vesting::new_toggle_vesting_freeze(intent, vesting_id, freeze, iw);
        },
    );
}

/// Executes toggle vesting pause action
public fun execute_toggle_vesting_pause<Config, Outcome: store, CoinType>(
    executable: &mut Executable<Outcome>,
    account: &mut Account<Config>,
    vesting: &mut vesting::Vesting<CoinType>,
    clock: &sui::clock::Clock,
    ctx: &mut TxContext,
) {
    account.process_intent!(
        executable,
        version::current(),
        VestingControlIntent(),
        |executable, iw| {
            vesting::do_toggle_vesting_pause<_, _, CoinType, _>(
                executable,
                account,
                vesting,
                clock,
                version::current(),
                iw,
                ctx,
            );
        },
    );
}

/// Executes toggle vesting freeze action
public fun execute_toggle_vesting_freeze<Config, Outcome: store, CoinType>(
    executable: &mut Executable<Outcome>,
    account: &mut Account<Config>,
    vesting: &mut vesting::Vesting<CoinType>,
    clock: &sui::clock::Clock,
    ctx: &mut TxContext,
) {
    account.process_intent!(
        executable,
        version::current(),
        VestingControlIntent(),
        |executable, iw| {
            vesting::do_toggle_vesting_freeze<_, _, CoinType, _>(
                executable,
                account,
                vesting,
                clock,
                version::current(),
                iw,
            );
        },
    );
}
