module futarchy::execute;

use std::option::{Self, Option};
use sui::{
    clock::Clock, 
    tx_context::TxContext,
    coin::Coin,
    sui::SUI,
    object::ID,
};
use account_protocol::{
    account::{Self, Account},
    executable::Executable,
    intents,
};

use futarchy::{
    strategy,
    gc_janitor,
    futarchy_config::{Self, FutarchyConfig, FutarchyOutcome, ExecutePermit},
    action_dispatcher,
    version,
    priority_queue,
    proposal_fee_manager::ProposalFeeManager,
    governance_actions::ProposalReservationRegistry,
};

const EPolicyNotSatisfied: u64 = 777;
const EInvalidPermit: u64 = 778;
const EPermitMismatch: u64 = 779;

/// Your single futarchy witness type
public struct FutarchyIntent has copy, drop {}

/// Helper function to confirm execution and handle one-shot intent cleanup
public fun confirm_and_cleanup(
    executable: Executable<FutarchyOutcome>,
    account: &mut Account<FutarchyConfig>,
) {
    // Get the key before consuming the executable
    let key = executable.intent().key();
    
    // Confirm execution - re-adds the intent
    account::confirm_execution(account, executable);
    
    // Check if this was a one-shot intent (empty execution_times after popping one)
    if (account::intents(account).contains(key)) {
        let intent = account::intents(account).get<FutarchyOutcome>(key);
        if (intent.execution_times().is_empty()) {
            // One-shot intent - destroy it and clean up
            let mut expired = account::destroy_empty_intent<FutarchyConfig, FutarchyOutcome>(account, key);
            gc_janitor::drain_all_public(account, &mut expired);
            intents::destroy_empty_expired(expired);
        }
        // else: recurring intent, leave it in storage
    }
}

/// Generic "all actions" runner WITHOUT governance resources
/// For proposals that don't create second-order proposals
public fun run_all<IW: copy + drop>(
    executable: Executable<FutarchyOutcome>,
    account: &mut Account<FutarchyConfig>,
    gate: strategy::Strategy,
    ok_a: bool,
    ok_b: bool,
    intent_witness: IW,
    clock: &Clock,
    ctx: &mut TxContext
) {
    assert!(strategy::can_execute(ok_a, ok_b, gate), EPolicyNotSatisfied);

    let executable = action_dispatcher::execute_standard_actions(
        executable,
        account,
        intent_witness,
        clock,
        ctx
    );
    
    // Confirm and cleanup using helper function
    confirm_and_cleanup(executable, account);
}

/// Generic "all actions" runner WITH governance resources
/// For proposals that may create second-order proposals
/// 
/// NOTE: Creating second-order proposals requires specialized execution
/// The frontend should use specific entry points in action_dispatcher
/// This function is kept for backwards compatibility but delegates to standard execution
public fun run_all_with_governance<IW: copy + drop>(
    executable: Executable<FutarchyOutcome>,
    account: &mut Account<FutarchyConfig>,
    gate: strategy::Strategy,
    ok_a: bool,
    ok_b: bool,
    intent_witness: IW,
    _queue: &mut priority_queue::ProposalQueue<FutarchyConfig>,
    _fee_manager: &mut ProposalFeeManager,
    _registry: &mut ProposalReservationRegistry,
    _parent_proposal_id: ID,
    mut fee_coin_opt: Option<Coin<SUI>>,
    clock: &Clock,
    ctx: &mut TxContext
) {
    assert!(strategy::can_execute(ok_a, ok_b, gate), EPolicyNotSatisfied);

    // Return fee coin if provided (governance actions not supported in this path)
    if (fee_coin_opt.is_some()) {
        let fee_coin = fee_coin_opt.extract();
        transfer::public_transfer(fee_coin, ctx.sender());
    };
    fee_coin_opt.destroy_none();
    
    // Execute standard actions only
    let executable = action_dispatcher::execute_standard_actions(
        executable,
        account,
        intent_witness,
        clock,
        ctx
    );
    
    // Confirm and cleanup using helper function
    confirm_and_cleanup(executable, account);
}

/// Typed runner for proposals with typed actions
/// 
/// NOTE: Typed actions (liquidity, oracle mint) require specific resources
/// The frontend should use specialized entry points in action_dispatcher:
/// - execute_oracle_mint for oracle minting
/// - execute_vault_spend for vault operations
/// This function is kept for backwards compatibility but delegates to standard execution
public fun run_typed<AssetType: drop + store, StableType: drop + store, IW: copy + drop>(
    executable: Executable<FutarchyOutcome>,
    account: &mut Account<FutarchyConfig>,
    gate: strategy::Strategy,
    ok_a: bool,
    ok_b: bool,
    intent_witness: IW,
    clock: &Clock,
    ctx: &mut TxContext
) {
    assert!(strategy::can_execute(ok_a, ok_b, gate), EPolicyNotSatisfied);

    // Execute standard actions only
    // Typed actions should be executed via specialized entry points
    let executable = action_dispatcher::execute_standard_actions(
        executable,
        account,
        intent_witness,
        clock,
        ctx
    );
    
    // Confirm and cleanup using helper function
    confirm_and_cleanup(executable, account);
}

/// Simple execution without strategy gates (for backwards compatibility)
public fun run_simple<IW: copy + drop>(
    executable: Executable<FutarchyOutcome>,
    account: &mut Account<FutarchyConfig>,
    intent_witness: IW,
    clock: &Clock,
    ctx: &mut TxContext
) {
    run_all(
        executable,
        account,
        strategy::and(),
        true,
        true,
        intent_witness,
        clock,
        ctx
    )
}

/// Permit-based execution for cross-DAO bundles WITHOUT governance resources
/// The permit is minted by futarchy_config after re-checking all gates
public fun run_with_permit(
    executable: Executable<FutarchyOutcome>,
    account: &mut Account<FutarchyConfig>,
    permit: ExecutePermit,
    clock: &Clock,
    ctx: &mut TxContext
) {
    let intent_key = account_protocol::executable::intent(&executable).key();
    assert!(
        futarchy_config::verify_permit(&permit, account, &intent_key, clock),
        EInvalidPermit
    );
    
    let executable = action_dispatcher::execute_standard_actions(
        executable,
        account,
        FutarchyIntent {},
        clock,
        ctx
    );
    
    // Consume the council approval if there was one (single-use)
    let _ = futarchy_config::consume_council_approval(account, &intent_key, ctx);
    
    // Confirm and cleanup using helper function
    confirm_and_cleanup(executable, account);
}/// DAO configuration management module
/// Provides centralized configuration structs and validation for futarchy DAOs
module futarchy::dao_config;

use std::{
    string::String,
    ascii::String as AsciiString,
};
use sui::url::Url;

// === Errors ===
const EInvalidMinAmount: u64 = 0; // Minimum amount must be positive
const EInvalidPeriod: u64 = 1; // Period must be positive
const EInvalidFee: u64 = 2; // Fee exceeds maximum (10000 bps = 100%)
const EInvalidMaxOutcomes: u64 = 3; // Max outcomes must be at least 2
const EInvalidTwapThreshold: u64 = 4; // TWAP threshold must be positive
const EInvalidProposalFee: u64 = 5; // Proposal fee must be positive
const EInvalidBondAmount: u64 = 6; // Bond amount must be positive
const EInvalidTwapParams: u64 = 7; // Invalid TWAP parameters
const EInvalidGracePeriod: u64 = 8; // Grace period too short
const EInvalidMaxConcurrentProposals: u64 = 9; // Max concurrent proposals must be positive

// === Constants ===
const MAX_FEE_BPS: u64 = 10000; // 100% in basis points
const MIN_OUTCOMES: u64 = 2; // Minimum number of outcomes for a proposal
const MIN_REVIEW_PERIOD_MS: u64 = 1000; // 1 second minimum review period (lowered for testing)
const MIN_TRADING_PERIOD_MS: u64 = 1000; // 1 second minimum trading period (lowered for testing)

// === Structs ===

/// Trading parameters configuration
public struct TradingParams has store, drop, copy {
    min_asset_amount: u64,
    min_stable_amount: u64,
    review_period_ms: u64,
    trading_period_ms: u64,
    amm_total_fee_bps: u64,
}

/// TWAP (Time-Weighted Average Price) configuration
public struct TwapConfig has store, drop, copy {
    start_delay: u64,
    step_max: u64,
    initial_observation: u128,
    threshold: u64,
}

/// Governance parameters configuration
public struct GovernanceConfig has store, drop, copy {
    max_outcomes: u64,
    proposal_fee_per_outcome: u64,
    required_bond_amount: u64,
    max_concurrent_proposals: u64,
    proposal_recreation_window_ms: u64,
    max_proposal_chain_depth: u64,
    fee_escalation_basis_points: u64,
    proposal_creation_enabled: bool,
    accept_new_proposals: bool,
    max_intents_per_outcome: u64,
    optimistic_challenge_fee: u64, // Fee to challenge optimistic proposals
    optimistic_challenge_period_ms: u64, // Time period to challenge optimistic proposals (e.g., 10 days)
    eviction_grace_period_ms: u64,
    proposal_intent_expiry_ms: u64, // How long proposal intents remain valid
}

/// Metadata configuration
public struct MetadataConfig has store, drop, copy {
    dao_name: AsciiString,
    icon_url: Url,
    description: String,
}

/// Security configuration for dead-man switch
public struct SecurityConfig has store, drop, copy {
    deadman_enabled: bool,               // If true, dead-man switch recovery is enabled
    recovery_liveness_ms: u64,           // Inactivity threshold for dead-man switch (e.g., 30 days)
    require_deadman_council: bool,       // If true, all councils must support dead-man switch
}

/// Complete DAO configuration
public struct DaoConfig has store, drop, copy {
    trading_params: TradingParams,
    twap_config: TwapConfig,
    governance_config: GovernanceConfig,
    metadata_config: MetadataConfig,
    security_config: SecurityConfig,
}

// === Constructor Functions ===

/// Create a new trading parameters configuration
public fun new_trading_params(
    min_asset_amount: u64,
    min_stable_amount: u64,
    review_period_ms: u64,
    trading_period_ms: u64,
    amm_total_fee_bps: u64,
): TradingParams {
    // Validate inputs
    assert!(min_asset_amount > 0, EInvalidMinAmount);
    assert!(min_stable_amount > 0, EInvalidMinAmount);
    assert!(review_period_ms >= MIN_REVIEW_PERIOD_MS, EInvalidPeriod);
    assert!(trading_period_ms >= MIN_TRADING_PERIOD_MS, EInvalidPeriod);
    assert!(amm_total_fee_bps <= MAX_FEE_BPS, EInvalidFee);
    
    TradingParams {
        min_asset_amount,
        min_stable_amount,
        review_period_ms,
        trading_period_ms,
        amm_total_fee_bps,
    }
}

/// Create a new TWAP configuration
public fun new_twap_config(
    start_delay: u64,
    step_max: u64,
    initial_observation: u128,
    threshold: u64,
): TwapConfig {
    // Validate inputs (allow 0 for start_delay for testing)
    // assert!(start_delay > 0, EInvalidTwapParams); // Commented out to allow 0 for testing
    assert!(step_max > 0, EInvalidTwapParams);
    assert!(initial_observation > 0, EInvalidTwapParams);
    assert!(threshold > 0, EInvalidTwapThreshold);
    
    TwapConfig {
        start_delay,
        step_max,
        initial_observation,
        threshold,
    }
}

/// Create a new governance configuration
public fun new_governance_config(
    max_outcomes: u64,
    proposal_fee_per_outcome: u64,
    required_bond_amount: u64,
    max_concurrent_proposals: u64,
    proposal_recreation_window_ms: u64,
    max_proposal_chain_depth: u64,
    fee_escalation_basis_points: u64,
    proposal_creation_enabled: bool,
    accept_new_proposals: bool,
    max_intents_per_outcome: u64,
    optimistic_challenge_fee: u64,
    optimistic_challenge_period_ms: u64,
    eviction_grace_period_ms: u64,
    proposal_intent_expiry_ms: u64,
): GovernanceConfig {
    // Validate inputs
    assert!(max_outcomes >= MIN_OUTCOMES, EInvalidMaxOutcomes);
    assert!(proposal_fee_per_outcome > 0, EInvalidProposalFee);
    assert!(required_bond_amount > 0, EInvalidBondAmount);
    assert!(max_concurrent_proposals > 0, EInvalidMaxConcurrentProposals);
    assert!(fee_escalation_basis_points <= MAX_FEE_BPS, EInvalidFee);
    assert!(max_intents_per_outcome > 0, EInvalidMaxOutcomes);
    assert!(optimistic_challenge_fee > 0, EInvalidProposalFee);
    assert!(optimistic_challenge_period_ms > 0, EInvalidPeriod); // Must be non-zero
    assert!(eviction_grace_period_ms >= 300000, EInvalidGracePeriod); // Min 5 minutes
    
    GovernanceConfig {
        max_outcomes,
        proposal_fee_per_outcome,
        required_bond_amount,
        max_concurrent_proposals,
        proposal_recreation_window_ms,
        max_proposal_chain_depth,
        fee_escalation_basis_points,
        proposal_creation_enabled,
        accept_new_proposals,
        max_intents_per_outcome,
        optimistic_challenge_fee,
        optimistic_challenge_period_ms,
        eviction_grace_period_ms,
        proposal_intent_expiry_ms,
    }
}

/// Create a new metadata configuration
public fun new_metadata_config(
    dao_name: AsciiString,
    icon_url: Url,
    description: String,
): MetadataConfig {
    MetadataConfig {
        dao_name,
        icon_url,
        description,
    }
}

/// Create a new security configuration
public fun new_security_config(
    deadman_enabled: bool,
    recovery_liveness_ms: u64,
    require_deadman_council: bool,
): SecurityConfig {
    SecurityConfig {
        deadman_enabled,
        recovery_liveness_ms,
        require_deadman_council,
    }
}

/// Create a complete DAO configuration
public fun new_dao_config(
    trading_params: TradingParams,
    twap_config: TwapConfig,
    governance_config: GovernanceConfig,
    metadata_config: MetadataConfig,
    security_config: SecurityConfig,
): DaoConfig {
    DaoConfig {
        trading_params,
        twap_config,
        governance_config,
        metadata_config,
        security_config,
    }
}

// === Getter Functions ===

// Trading params getters
public fun trading_params(config: &DaoConfig): &TradingParams { &config.trading_params }
public(package) fun trading_params_mut(config: &mut DaoConfig): &mut TradingParams { &mut config.trading_params }
public fun min_asset_amount(params: &TradingParams): u64 { params.min_asset_amount }
public fun min_stable_amount(params: &TradingParams): u64 { params.min_stable_amount }
public fun review_period_ms(params: &TradingParams): u64 { params.review_period_ms }
public fun trading_period_ms(params: &TradingParams): u64 { params.trading_period_ms }
public fun amm_total_fee_bps(params: &TradingParams): u64 { params.amm_total_fee_bps }

// TWAP config getters
public fun twap_config(config: &DaoConfig): &TwapConfig { &config.twap_config }
public(package) fun twap_config_mut(config: &mut DaoConfig): &mut TwapConfig { &mut config.twap_config }
public fun start_delay(twap: &TwapConfig): u64 { twap.start_delay }
public fun step_max(twap: &TwapConfig): u64 { twap.step_max }
public fun initial_observation(twap: &TwapConfig): u128 { twap.initial_observation }
public fun threshold(twap: &TwapConfig): u64 { twap.threshold }

// Governance config getters
public fun governance_config(config: &DaoConfig): &GovernanceConfig { &config.governance_config }
public(package) fun governance_config_mut(config: &mut DaoConfig): &mut GovernanceConfig { &mut config.governance_config }
public fun max_outcomes(gov: &GovernanceConfig): u64 { gov.max_outcomes }
public fun proposal_fee_per_outcome(gov: &GovernanceConfig): u64 { gov.proposal_fee_per_outcome }
public fun optimistic_challenge_fee(gov: &GovernanceConfig): u64 { gov.optimistic_challenge_fee }
public fun optimistic_challenge_period_ms(gov: &GovernanceConfig): u64 { gov.optimistic_challenge_period_ms }
public fun required_bond_amount(gov: &GovernanceConfig): u64 { gov.required_bond_amount }
public fun max_concurrent_proposals(gov: &GovernanceConfig): u64 { gov.max_concurrent_proposals }
public fun proposal_recreation_window_ms(gov: &GovernanceConfig): u64 { gov.proposal_recreation_window_ms }
public fun max_proposal_chain_depth(gov: &GovernanceConfig): u64 { gov.max_proposal_chain_depth }
public fun fee_escalation_basis_points(gov: &GovernanceConfig): u64 { gov.fee_escalation_basis_points }
public fun proposal_creation_enabled(gov: &GovernanceConfig): bool { gov.proposal_creation_enabled }
public fun accept_new_proposals(gov: &GovernanceConfig): bool { gov.accept_new_proposals }
public fun max_intents_per_outcome(gov: &GovernanceConfig): u64 { gov.max_intents_per_outcome }
public fun eviction_grace_period_ms(gov: &GovernanceConfig): u64 { gov.eviction_grace_period_ms }
public fun proposal_intent_expiry_ms(gov: &GovernanceConfig): u64 { gov.proposal_intent_expiry_ms }

// Metadata config getters
public fun metadata_config(config: &DaoConfig): &MetadataConfig { &config.metadata_config }
public(package) fun metadata_config_mut(config: &mut DaoConfig): &mut MetadataConfig { &mut config.metadata_config }
public fun dao_name(meta: &MetadataConfig): &AsciiString { &meta.dao_name }
public fun icon_url(meta: &MetadataConfig): &Url { &meta.icon_url }
public fun description(meta: &MetadataConfig): &String { &meta.description }

// Security config getters
public fun security_config(config: &DaoConfig): &SecurityConfig { &config.security_config }
public(package) fun security_config_mut(config: &mut DaoConfig): &mut SecurityConfig { &mut config.security_config }
public fun deadman_enabled(sec: &SecurityConfig): bool { sec.deadman_enabled }
public fun recovery_liveness_ms(sec: &SecurityConfig): u64 { sec.recovery_liveness_ms }
public fun require_deadman_council(sec: &SecurityConfig): bool { sec.require_deadman_council }

// === Update Functions ===

// === Direct Field Setters (Package-level) ===
// These functions provide efficient in-place field updates without struct copying

// Trading params direct setters
public(package) fun set_min_asset_amount(params: &mut TradingParams, amount: u64) {
    assert!(amount > 0, EInvalidMinAmount);
    params.min_asset_amount = amount;
}

public(package) fun set_min_stable_amount(params: &mut TradingParams, amount: u64) {
    assert!(amount > 0, EInvalidMinAmount);
    params.min_stable_amount = amount;
}

public(package) fun set_review_period_ms(params: &mut TradingParams, period: u64) {
    assert!(period >= MIN_REVIEW_PERIOD_MS, EInvalidPeriod);
    params.review_period_ms = period;
}

public(package) fun set_trading_period_ms(params: &mut TradingParams, period: u64) {
    assert!(period >= MIN_TRADING_PERIOD_MS, EInvalidPeriod);
    params.trading_period_ms = period;
}

public(package) fun set_amm_total_fee_bps(params: &mut TradingParams, fee_bps: u64) {
    assert!(fee_bps <= MAX_FEE_BPS, EInvalidFee);
    params.amm_total_fee_bps = fee_bps;
}

// TWAP config direct setters
public(package) fun set_start_delay(twap: &mut TwapConfig, delay: u64) {
    // Allow 0 for testing
    twap.start_delay = delay;
}

public(package) fun set_step_max(twap: &mut TwapConfig, max: u64) {
    assert!(max > 0, EInvalidTwapParams);
    twap.step_max = max;
}

public(package) fun set_initial_observation(twap: &mut TwapConfig, obs: u128) {
    assert!(obs > 0, EInvalidTwapParams);
    twap.initial_observation = obs;
}

public(package) fun set_threshold(twap: &mut TwapConfig, threshold: u64) {
    assert!(threshold > 0, EInvalidTwapThreshold);
    twap.threshold = threshold;
}

// Governance config direct setters
public(package) fun set_max_outcomes(gov: &mut GovernanceConfig, max: u64) {
    assert!(max >= MIN_OUTCOMES, EInvalidMaxOutcomes);
    gov.max_outcomes = max;
}

public(package) fun set_proposal_fee_per_outcome(gov: &mut GovernanceConfig, fee: u64) {
    assert!(fee > 0, EInvalidProposalFee);
    gov.proposal_fee_per_outcome = fee;
}

public(package) fun set_required_bond_amount(gov: &mut GovernanceConfig, amount: u64) {
    assert!(amount > 0, EInvalidBondAmount);
    gov.required_bond_amount = amount;
}

public(package) fun set_optimistic_challenge_fee(gov: &mut GovernanceConfig, amount: u64) {
    assert!(amount > 0, EInvalidProposalFee);
    gov.optimistic_challenge_fee = amount;
}

public(package) fun set_optimistic_challenge_period_ms(gov: &mut GovernanceConfig, period: u64) {
    assert!(period > 0, EInvalidPeriod); // Must be non-zero
    gov.optimistic_challenge_period_ms = period;
}

public(package) fun set_max_concurrent_proposals(gov: &mut GovernanceConfig, max: u64) {
    assert!(max > 0, EInvalidMaxConcurrentProposals);
    gov.max_concurrent_proposals = max;
}

public(package) fun set_proposal_recreation_window_ms(gov: &mut GovernanceConfig, window: u64) {
    gov.proposal_recreation_window_ms = window;
}

public(package) fun set_max_proposal_chain_depth(gov: &mut GovernanceConfig, depth: u64) {
    gov.max_proposal_chain_depth = depth;
}

public(package) fun set_fee_escalation_basis_points(gov: &mut GovernanceConfig, points: u64) {
    assert!(points <= MAX_FEE_BPS, EInvalidFee);
    gov.fee_escalation_basis_points = points;
}

public(package) fun set_proposal_creation_enabled(gov: &mut GovernanceConfig, enabled: bool) {
    gov.proposal_creation_enabled = enabled;
}

public(package) fun set_accept_new_proposals(gov: &mut GovernanceConfig, accept: bool) {
    gov.accept_new_proposals = accept;
}

public(package) fun set_max_intents_per_outcome(gov: &mut GovernanceConfig, max: u64) {
    assert!(max > 0, EInvalidMaxOutcomes);
    gov.max_intents_per_outcome = max;
}

public(package) fun set_eviction_grace_period_ms(gov: &mut GovernanceConfig, period: u64) {
    assert!(period >= 300000, EInvalidGracePeriod); // Min 5 minutes
    gov.eviction_grace_period_ms = period;
}

public(package) fun set_proposal_intent_expiry_ms(gov: &mut GovernanceConfig, period: u64) {
    assert!(period >= 3600000, EInvalidGracePeriod); // Min 1 hour
    gov.proposal_intent_expiry_ms = period;
}

// Metadata config direct setters
public(package) fun set_dao_name(meta: &mut MetadataConfig, name: AsciiString) {
    meta.dao_name = name;
}

public(package) fun set_icon_url(meta: &mut MetadataConfig, url: Url) {
    meta.icon_url = url;
}

public(package) fun set_description(meta: &mut MetadataConfig, desc: String) {
    meta.description = desc;
}

// Security config direct setters

public(package) fun set_deadman_enabled(sec: &mut SecurityConfig, val: bool) {
    sec.deadman_enabled = val;
}

public(package) fun set_recovery_liveness_ms(sec: &mut SecurityConfig, ms: u64) {
    sec.recovery_liveness_ms = ms;
}

public(package) fun set_require_deadman_council(sec: &mut SecurityConfig, val: bool) {
    sec.require_deadman_council = val;
}

/// Update trading parameters (returns new config)
public fun update_trading_params(config: &DaoConfig, new_params: TradingParams): DaoConfig {
    DaoConfig {
        trading_params: new_params,
        twap_config: config.twap_config,
        governance_config: config.governance_config,
        metadata_config: config.metadata_config,
        security_config: config.security_config,
    }
}

/// Update TWAP configuration (returns new config)
public fun update_twap_config(config: &DaoConfig, new_twap: TwapConfig): DaoConfig {
    DaoConfig {
        trading_params: config.trading_params,
        twap_config: new_twap,
        governance_config: config.governance_config,
        metadata_config: config.metadata_config,
        security_config: config.security_config,
    }
}

/// Update governance configuration (returns new config)
public fun update_governance_config(config: &DaoConfig, new_gov: GovernanceConfig): DaoConfig {
    DaoConfig {
        trading_params: config.trading_params,
        twap_config: config.twap_config,
        governance_config: new_gov,
        metadata_config: config.metadata_config,
        security_config: config.security_config,
    }
}

/// Update metadata configuration (returns new config)
public fun update_metadata_config(config: &DaoConfig, new_meta: MetadataConfig): DaoConfig {
    DaoConfig {
        trading_params: config.trading_params,
        twap_config: config.twap_config,
        governance_config: config.governance_config,
        metadata_config: new_meta,
        security_config: config.security_config,
    }
}

/// Update security configuration (returns new config)
public fun update_security_config(config: &DaoConfig, new_sec: SecurityConfig): DaoConfig {
    DaoConfig {
        trading_params: config.trading_params,
        twap_config: config.twap_config,
        governance_config: config.governance_config,
        metadata_config: config.metadata_config,
        security_config: new_sec,
    }
}

// === Default Configuration ===

/// Get default trading parameters for testing
public fun default_trading_params(): TradingParams {
    TradingParams {
        min_asset_amount: 1000000, // 1 token with 6 decimals
        min_stable_amount: 1000000, // 1 stable with 6 decimals
        review_period_ms: 86400000, // 24 hours
        trading_period_ms: 604800000, // 7 days
        amm_total_fee_bps: 30, // 0.3%
    }
}

/// Get default TWAP configuration for testing
public fun default_twap_config(): TwapConfig {
    TwapConfig {
        start_delay: 300000, // 5 minutes
        step_max: 300000, // 5 minutes
        initial_observation: 1000000000000, // Initial price observation
        threshold: 10, // 10% threshold
    }
}

/// Get default governance configuration for testing
public fun default_governance_config(): GovernanceConfig {
    GovernanceConfig {
        max_outcomes: 10,
        proposal_fee_per_outcome: 1000000, // 1 token per outcome
        required_bond_amount: 10000000, // 10 tokens
        max_concurrent_proposals: 5,
        proposal_recreation_window_ms: 86400000, // 24 hours
        max_proposal_chain_depth: 3,
        fee_escalation_basis_points: 500, // 5%
        proposal_creation_enabled: true,
        accept_new_proposals: true,
        max_intents_per_outcome: 10, // Allow up to 10 intents per outcome
        optimistic_challenge_fee: 1000000000, // 1 billion MIST = 1 token
        optimistic_challenge_period_ms: 864000000, // 10 days default
        eviction_grace_period_ms: 7200000, // 2 hours default
        proposal_intent_expiry_ms: 2592000000, // 30 days default
    }
}

/// Get default security configuration
public fun default_security_config(): SecurityConfig {
    SecurityConfig {
        deadman_enabled: false,          // Opt-in feature
        recovery_liveness_ms: 2_592_000_000, // 30 days default
        require_deadman_council: false,  // Optional
    }
}module futarchy::strategy;

// === Constants for Strategy Types ===
const STRATEGY_AND: u8 = 0;
const STRATEGY_OR: u8 = 1;
const STRATEGY_EITHER: u8 = 2;  // XOR
const STRATEGY_THRESHOLD: u8 = 3;

/// Strategy for combining multiple approval conditions
/// Uses constants instead of magic numbers for clarity
public struct Strategy has copy, drop, store { 
    kind: u8, 
    m: u64,  // For threshold: minimum approvals required
    n: u64   // For threshold: total number of conditions
}

public fun and(): Strategy { 
    Strategy { kind: STRATEGY_AND, m: 0, n: 0 } 
}

public fun or(): Strategy { 
    Strategy { kind: STRATEGY_OR, m: 0, n: 0 } 
}

public fun either(): Strategy { 
    Strategy { kind: STRATEGY_EITHER, m: 0, n: 0 } 
}

public fun threshold(m: u64, n: u64): Strategy { 
    Strategy { kind: STRATEGY_THRESHOLD, m, n } 
}

/// Combine boolean gates. Extend by adding more sources as needed.
public fun can_execute(ok_a: bool, ok_b: bool, s: Strategy): bool {
    if (s.kind == STRATEGY_AND) {
        // Both conditions must be true
        ok_a && ok_b
    } else if (s.kind == STRATEGY_OR) {
        // At least one condition must be true
        ok_a || ok_b
    } else if (s.kind == STRATEGY_EITHER) {
        // Exactly one condition must be true (XOR)
        (ok_a && !ok_b) || (!ok_a && ok_b)
    } else if (s.kind == STRATEGY_THRESHOLD) {
        // M-of-N threshold over 2 booleans
        let satisfied_count = (if (ok_a) 1 else 0) + (if (ok_b) 1 else 0);
        satisfied_count >= s.m && s.n >= s.m
    } else {
        // Unknown strategy type - fail safe by requiring all conditions
        false
    }
}

#[test]
fun test_and_strategy() {
    let s = and();
    assert!(can_execute(true, true, s) == true);
    assert!(can_execute(true, false, s) == false);
    assert!(can_execute(false, true, s) == false);
    assert!(can_execute(false, false, s) == false);
}

#[test]
fun test_or_strategy() {
    let s = or();
    assert!(can_execute(true, true, s) == true);
    assert!(can_execute(true, false, s) == true);
    assert!(can_execute(false, true, s) == true);
    assert!(can_execute(false, false, s) == false);
}

#[test]
fun test_either_strategy() {
    let s = either();
    assert!(can_execute(true, true, s) == false);
    assert!(can_execute(true, false, s) == true);
    assert!(can_execute(false, true, s) == true);
    assert!(can_execute(false, false, s) == false);
}

#[test]
fun test_threshold_strategy() {
    // 2-of-2 threshold (same as AND)
    let s = threshold(2, 2);
    assert!(can_execute(true, true, s) == true);
    assert!(can_execute(true, false, s) == false);
    assert!(can_execute(false, true, s) == false);
    assert!(can_execute(false, false, s) == false);
    
    // 1-of-2 threshold (same as OR)
    let s2 = threshold(1, 2);
    assert!(can_execute(true, true, s2) == true);
    assert!(can_execute(true, false, s2) == true);
    assert!(can_execute(false, true, s2) == true);
    assert!(can_execute(false, false, s2) == false);
}/// Configuration struct for Futarchy governance systems
/// Replaces the old DAO god object pattern with a focused configuration struct
/// for use with Account<FutarchyConfig>
module futarchy::futarchy_config;

// === Imports ===
use std::{
    string::String,
    ascii::String as AsciiString,
    option::{Self, Option},
    type_name,
};
use sui::{
    clock::Clock,
    url::{Self, Url},
    coin::TreasuryCap,
    table::{Self, Table},
    object::{Self, ID},
};
use account_protocol::{
    account::{Self, Account, Auth},
    executable::{Self, Executable},
    deps::{Self, Deps},
    intents::{Self, Intents},
    version_witness::VersionWitness,
};
use account_extensions::extensions::Extensions;
use futarchy::{
    version,
    proposal::{Self, Proposal},
    market_state::{Self, MarketState},
    dao_config::{Self, DaoConfig, TradingParams, TwapConfig, GovernanceConfig, MetadataConfig},
    events,
};

// === Constants ===
const DAO_STATE_ACTIVE: u8 = 0;
const DAO_STATE_DISSOLVING: u8 = 1;
const DAO_STATE_PAUSED: u8 = 2;

const OUTCOME_ACCEPTED: u8 = 0;
const OUTCOME_REJECTED: u8 = 1;

// === Errors ===
const EProposalNotApproved: u64 = 1;
const EInvalidAdmin: u64 = 2;
const EInvalidSlashDistribution: u64 = 3;
const EIntentNotFound: u64 = 4;

// === Events ===

/// Emitted when proposals are enabled or disabled
public struct ProposalsEnabledChanged has copy, drop {
    account_id: ID,
    enabled: bool,
    timestamp: u64,
}

/// Emitted when DAO name is updated
public struct DaoNameChanged has copy, drop {
    account_id: ID,
    old_name: AsciiString,
    new_name: AsciiString,
    timestamp: u64,
}

/// Emitted when trading parameters are updated
public struct TradingParamsChanged has copy, drop {
    account_id: ID,
    timestamp: u64,
}

/// Emitted when metadata is updated
public struct MetadataChanged has copy, drop {
    account_id: ID,
    timestamp: u64,
}

/// Emitted when governance settings are updated
public struct GovernanceSettingsChanged has copy, drop {
    account_id: ID,
    timestamp: u64,
}

// === Structs ===

/// Configuration for how slashed proposal fees are distributed
public struct SlashDistribution has store, drop, copy {
    /// Percentage (in basis points) that goes to the slasher who evicted the proposal
    slasher_reward_bps: u16,
    /// Percentage (in basis points) that goes to the DAO treasury
    dao_treasury_bps: u16,
    /// Percentage (in basis points) that goes to protocol revenue
    protocol_bps: u16,
    /// Percentage (in basis points) that gets burned
    burn_bps: u16,
}

/// Core Futarchy DAO configuration
/// Contains composed configuration from dao_config module plus state tracking
public struct FutarchyConfig has store {
    // Type information (still belongs at top level)
    asset_type: String,
    stable_type: String,
    
    // Composed configuration from dao_config module
    config: DaoConfig,
    
    // State tracking (does not belong in dao_config)
    operational_state: u8,
    active_proposals: u64,
    total_proposals: u64,
    
    // References to other objects (does not belong in dao_config)
    treasury_id: Option<ID>,
    operating_agreement_id: Option<ID>,
    
    // Slash distribution configuration
    slash_distribution: SlashDistribution,
    
    // Proposal queue ID
    proposal_queue_id: Option<ID>,
    
    
    // Fee manager ID for proposal fee management
    fee_manager_id: Option<ID>,
    
    // Spot AMM pool ID for the DAO's liquidity pool
    spot_pool_id: Option<ID>,
    
    // Verification
    attestation_url: String,
    verification_pending: bool,
    verification_level: u8, // 0 = unverified, 1 = basic, 2 = standard, 3 = premium, etc.
    
    // Reward configurations
    proposal_pass_reward: u64, // Reward for proposal creator when proposal passes (in SUI)
    outcome_win_reward: u64,   // Reward for outcome creator when their outcome wins (in SUI)
    review_to_trading_fee: u64, // Fee to advance from review to trading (in SUI)
    finalization_fee: u64,      // Fee to finalize proposal after trading (in SUI)
}

/// Helper struct for creating FutarchyConfig with default values
/// Now simplified as we use DaoConfig for most parameters
public struct ConfigParams has store, copy, drop {
    dao_config: DaoConfig,
    slash_distribution: SlashDistribution,
}

/// Witness struct for authentication and operations
public struct Witness has drop {}

// === Public Functions ===

/// Creates a new FutarchyConfig with specified parameters
public fun new<AssetType: drop, StableType>(
    params: ConfigParams,
    _ctx: &mut TxContext,
): FutarchyConfig {
    FutarchyConfig {
        asset_type: type_name::get<AssetType>().into_string().to_string(),
        stable_type: type_name::get<StableType>().into_string().to_string(),
        config: params.dao_config,
        operational_state: DAO_STATE_ACTIVE,
        active_proposals: 0,
        total_proposals: 0,
        treasury_id: option::none(),
        operating_agreement_id: option::none(),
        slash_distribution: params.slash_distribution,
        proposal_queue_id: option::none(),
        fee_manager_id: option::none(),
        spot_pool_id: option::none(),
        attestation_url: b"".to_string(),
        verification_pending: false,
        verification_level: 0, // 0 = unverified
        // Default reward configurations (can be updated later)
        proposal_pass_reward: 10_000_000_000, // 10 SUI default
        outcome_win_reward: 5_000_000_000,    // 5 SUI default  
        review_to_trading_fee: 1_000_000_000, // 1 SUI default
        finalization_fee: 1_000_000_000,      // 1 SUI default
    }
}

/// Creates configuration parameters from structured config objects
public fun new_config_params(
    dao_config: DaoConfig,
    slash_distribution: SlashDistribution,
): ConfigParams {
    ConfigParams {
        dao_config,
        slash_distribution,
    }
}

/// Creates configuration parameters from individual values
public fun new_config_params_from_values(
    min_asset_amount: u64,
    min_stable_amount: u64,
    review_period_ms: u64,
    trading_period_ms: u64,
    amm_twap_start_delay: u64,
    amm_twap_step_max: u64,
    amm_twap_initial_observation: u128,
    twap_threshold: u64,
    amm_total_fee_bps: u64,
    max_outcomes: u64,
    proposal_fee_per_outcome: u64,
    max_concurrent_proposals: u64,
    required_bond_amount: u64,
    proposal_recreation_window_ms: u64,
    max_proposal_chain_depth: u64,
    fee_escalation_basis_points: u64,
    dao_name: AsciiString,
    icon_url: Url,
    description: String,
): ConfigParams {
    // Create structured configs
    let trading_params = dao_config::new_trading_params(
        min_asset_amount,
        min_stable_amount,
        review_period_ms,
        trading_period_ms,
        amm_total_fee_bps,
    );
    
    let twap_config = dao_config::new_twap_config(
        amm_twap_start_delay,
        amm_twap_step_max,
        amm_twap_initial_observation,
        twap_threshold,
    );
    
    let governance_config = dao_config::new_governance_config(
        max_outcomes,
        proposal_fee_per_outcome,
        required_bond_amount,
        max_concurrent_proposals,
        proposal_recreation_window_ms,
        max_proposal_chain_depth,
        fee_escalation_basis_points,
        true,  // proposal_creation_enabled (default)
        true,  // accept_new_proposals (default)
        10,    // max_intents_per_outcome (default)
        1000000000, // optimistic_challenge_fee (1 billion MIST = 1 token, default)
        864000000, // optimistic_challenge_period_ms (10 days default)
        7200000, // eviction_grace_period_ms (2 hours default)
        2592000000, // proposal_intent_expiry_ms (30 days default)
    );
    
    let metadata_config = dao_config::new_metadata_config(
        dao_name,
        icon_url,
        description,
    );
    
    let dao_config = dao_config::new_dao_config(
        trading_params,
        twap_config,
        governance_config,
        metadata_config,
        dao_config::default_security_config(),  // Use default security config
    );
    
    ConfigParams {
        dao_config,
        slash_distribution: default_slash_distribution(),
    }
}

/// Creates default configuration parameters with sensible defaults
public fun default_config_params(): ConfigParams {
    ConfigParams {
        dao_config: dao_config::new_dao_config(
            dao_config::default_trading_params(),
            dao_config::default_twap_config(),
            dao_config::default_governance_config(),
            dao_config::new_metadata_config(
                b"Default DAO".to_ascii_string(),
                url::new_unsafe_from_bytes(b"https://example.com/icon.png"),
                b"A default DAO configuration".to_string()
            ),
            dao_config::default_security_config(),
        ),
        slash_distribution: default_slash_distribution(),
    }
}

// === Slash Distribution Functions ===

/// Creates default slash distribution configuration
public fun default_slash_distribution(): SlashDistribution {
    SlashDistribution {
        slasher_reward_bps: 3000,  // 30% to the slasher
        dao_treasury_bps: 5000,     // 50% to DAO treasury
        protocol_bps: 1500,         // 15% to protocol
        burn_bps: 500,              // 5% burned
    }
}

/// Creates custom slash distribution configuration with validation
public fun new_slash_distribution(
    slasher_reward_bps: u16,
    dao_treasury_bps: u16,
    protocol_bps: u16,
    burn_bps: u16,
): SlashDistribution {
    // Ensure they sum to 10000 (100%)
    assert!(
        (slasher_reward_bps as u64) + (dao_treasury_bps as u64) + 
        (protocol_bps as u64) + (burn_bps as u64) == 10000,
        EInvalidSlashDistribution
    );
    
    SlashDistribution {
        slasher_reward_bps,
        dao_treasury_bps,
        protocol_bps,
        burn_bps,
    }
}

// === Accessor Functions ===

// Slash distribution
public fun slash_distribution(config: &FutarchyConfig): &SlashDistribution {
    &config.slash_distribution
}

// Reward configurations
public fun proposal_pass_reward(config: &FutarchyConfig): u64 { config.proposal_pass_reward }
public fun outcome_win_reward(config: &FutarchyConfig): u64 { config.outcome_win_reward }
public fun review_to_trading_fee(config: &FutarchyConfig): u64 { config.review_to_trading_fee }
public fun finalization_fee(config: &FutarchyConfig): u64 { config.finalization_fee }

// Security config getters (delegated to dao_config)
public fun deadman_enabled(config: &FutarchyConfig): bool { 
    dao_config::deadman_enabled(dao_config::security_config(&config.config)) 
}
public fun recovery_liveness_ms(config: &FutarchyConfig): u64 { 
    dao_config::recovery_liveness_ms(dao_config::security_config(&config.config)) 
}
public fun require_deadman_council(config: &FutarchyConfig): bool { 
    dao_config::require_deadman_council(dao_config::security_config(&config.config)) 
}

public fun slasher_reward_bps(slash_config: &SlashDistribution): u16 {
    slash_config.slasher_reward_bps
}

public fun dao_treasury_bps(slash_config: &SlashDistribution): u16 {
    slash_config.dao_treasury_bps
}

public fun protocol_bps(slash_config: &SlashDistribution): u16 {
    slash_config.protocol_bps
}

public fun burn_bps(slash_config: &SlashDistribution): u16 {
    slash_config.burn_bps
}

// Type information
public fun asset_type(config: &FutarchyConfig): &String { &config.asset_type }
public fun stable_type(config: &FutarchyConfig): &String { &config.stable_type }

// Trading parameters
public fun min_asset_amount(config: &FutarchyConfig): u64 { dao_config::min_asset_amount(dao_config::trading_params(&config.config)) }
public fun min_stable_amount(config: &FutarchyConfig): u64 { dao_config::min_stable_amount(dao_config::trading_params(&config.config)) }
public fun review_period_ms(config: &FutarchyConfig): u64 { dao_config::review_period_ms(dao_config::trading_params(&config.config)) }
public fun trading_period_ms(config: &FutarchyConfig): u64 { dao_config::trading_period_ms(dao_config::trading_params(&config.config)) }
public fun proposal_recreation_window_ms(config: &FutarchyConfig): u64 { dao_config::proposal_recreation_window_ms(dao_config::governance_config(&config.config)) }
public fun max_proposal_chain_depth(config: &FutarchyConfig): u64 { dao_config::max_proposal_chain_depth(dao_config::governance_config(&config.config)) }
public fun eviction_grace_period_ms(config: &FutarchyConfig): u64 { dao_config::eviction_grace_period_ms(dao_config::governance_config(&config.config)) }
public fun proposal_intent_expiry_ms(config: &FutarchyConfig): u64 { dao_config::proposal_intent_expiry_ms(dao_config::governance_config(&config.config)) }

// AMM configuration
public fun amm_twap_start_delay(config: &FutarchyConfig): u64 { dao_config::start_delay(dao_config::twap_config(&config.config)) }
public fun amm_twap_step_max(config: &FutarchyConfig): u64 { dao_config::step_max(dao_config::twap_config(&config.config)) }
public fun amm_twap_initial_observation(config: &FutarchyConfig): u128 { dao_config::initial_observation(dao_config::twap_config(&config.config)) }
public fun twap_threshold(config: &FutarchyConfig): u64 { dao_config::threshold(dao_config::twap_config(&config.config)) }
public fun amm_total_fee_bps(config: &FutarchyConfig): u64 { dao_config::amm_total_fee_bps(dao_config::trading_params(&config.config)) }

// Metadata
public fun dao_name(config: &FutarchyConfig): &AsciiString { dao_config::dao_name(dao_config::metadata_config(&config.config)) }
public fun icon_url(config: &FutarchyConfig): &Url { dao_config::icon_url(dao_config::metadata_config(&config.config)) }
public fun description(config: &FutarchyConfig): &String { dao_config::description(dao_config::metadata_config(&config.config)) }

// Governance parameters
public fun max_outcomes(config: &FutarchyConfig): u64 { dao_config::max_outcomes(dao_config::governance_config(&config.config)) }
public fun proposal_fee_per_outcome(config: &FutarchyConfig): u64 { dao_config::proposal_fee_per_outcome(dao_config::governance_config(&config.config)) }
public fun operational_state(config: &FutarchyConfig): u8 { config.operational_state }
public fun max_concurrent_proposals(config: &FutarchyConfig): u64 { dao_config::max_concurrent_proposals(dao_config::governance_config(&config.config)) }
public fun required_bond_amount(config: &FutarchyConfig): u64 { dao_config::required_bond_amount(dao_config::governance_config(&config.config)) }
public fun optimistic_challenge_fee(config: &FutarchyConfig): u64 { dao_config::optimistic_challenge_fee(dao_config::governance_config(&config.config)) }
public fun optimistic_challenge_period_ms(config: &FutarchyConfig): u64 { dao_config::optimistic_challenge_period_ms(dao_config::governance_config(&config.config)) }

// State tracking
public fun active_proposals(config: &FutarchyConfig): u64 { config.active_proposals }
public fun total_proposals(config: &FutarchyConfig): u64 { config.total_proposals }

// References
public fun spot_pool_id(config: &FutarchyConfig): &Option<ID> { &config.spot_pool_id }
public fun treasury_id(config: &FutarchyConfig): &Option<ID> { &config.treasury_id }
public fun operating_agreement_id(config: &FutarchyConfig): &Option<ID> { &config.operating_agreement_id }

// Queue management (deprecated - using priority_queue module now)
public fun fee_escalation_basis_points(config: &FutarchyConfig): u64 { dao_config::fee_escalation_basis_points(dao_config::governance_config(&config.config)) }
public fun proposal_queue_id(config: &FutarchyConfig): &Option<ID> { &config.proposal_queue_id }
// Removed - using statically-typed actions pattern
public fun fee_manager_id(config: &FutarchyConfig): &Option<ID> { &config.fee_manager_id }

// Verification
public fun attestation_url(config: &FutarchyConfig): &String { &config.attestation_url }
public fun verification_pending(config: &FutarchyConfig): bool { config.verification_pending }
public fun verification_level(config: &FutarchyConfig): u8 { config.verification_level }
public fun is_verified(config: &FutarchyConfig): bool { config.verification_level > 0 }

// State constants
public fun state_active(): u8 { DAO_STATE_ACTIVE }
public fun state_dissolving(): u8 { DAO_STATE_DISSOLVING }
public fun state_paused(): u8 { DAO_STATE_PAUSED }

// === Package-Level Mutators ===

// Trading parameters
public(package) fun set_min_asset_amount(config: &mut FutarchyConfig, amount: u64) {
    // Use direct mutable reference for efficient in-place update
    let trading_params = dao_config::trading_params_mut(&mut config.config);
    dao_config::set_min_asset_amount(trading_params, amount);
}

public(package) fun set_min_stable_amount(config: &mut FutarchyConfig, amount: u64) {
    // Use direct mutable reference for efficient in-place update
    let trading_params = dao_config::trading_params_mut(&mut config.config);
    dao_config::set_min_stable_amount(trading_params, amount);
}

public(package) fun set_review_period_ms(config: &mut FutarchyConfig, period: u64) {
    // Use direct mutable reference for efficient in-place update
    let trading_params = dao_config::trading_params_mut(&mut config.config);
    dao_config::set_review_period_ms(trading_params, period);
}

public(package) fun set_trading_period_ms(config: &mut FutarchyConfig, period: u64) {
    // Use direct mutable reference for efficient in-place update
    let trading_params = dao_config::trading_params_mut(&mut config.config);
    dao_config::set_trading_period_ms(trading_params, period);
}

public(package) fun set_proposal_recreation_window_ms(config: &mut FutarchyConfig, window: u64) {
    // Use direct mutable reference for efficient in-place update
    let governance_config = dao_config::governance_config_mut(&mut config.config);
    dao_config::set_proposal_recreation_window_ms(governance_config, window);
}

public(package) fun set_max_proposal_chain_depth(config: &mut FutarchyConfig, depth: u64) {
    // Use direct mutable reference for efficient in-place update
    let governance_config = dao_config::governance_config_mut(&mut config.config);
    dao_config::set_max_proposal_chain_depth(governance_config, depth);
}

// AMM configuration
public(package) fun set_amm_twap_start_delay(config: &mut FutarchyConfig, delay: u64) {
    // Use direct mutable reference for efficient in-place update
    let twap_config = dao_config::twap_config_mut(&mut config.config);
    dao_config::set_start_delay(twap_config, delay);
}

public(package) fun set_amm_twap_step_max(config: &mut FutarchyConfig, max: u64) {
    // Use direct mutable reference for efficient in-place update
    let twap_config = dao_config::twap_config_mut(&mut config.config);
    dao_config::set_step_max(twap_config, max);
}

public(package) fun set_amm_twap_initial_observation(config: &mut FutarchyConfig, obs: u128) {
    // Use direct mutable reference for efficient in-place update
    let twap_config = dao_config::twap_config_mut(&mut config.config);
    dao_config::set_initial_observation(twap_config, obs);
}

public(package) fun set_twap_threshold(config: &mut FutarchyConfig, threshold: u64) {
    // Use direct mutable reference for efficient in-place update
    let twap_config = dao_config::twap_config_mut(&mut config.config);
    dao_config::set_threshold(twap_config, threshold);
}

public(package) fun set_amm_total_fee_bps(config: &mut FutarchyConfig, fee_bps: u64) {
    // Use direct mutable reference for efficient in-place update
    let trading_params = dao_config::trading_params_mut(&mut config.config);
    dao_config::set_amm_total_fee_bps(trading_params, fee_bps);
}

// Metadata
public(package) fun set_dao_name(config: &mut FutarchyConfig, name: AsciiString) {
    // Use direct mutable reference for efficient in-place update
    let metadata_config = dao_config::metadata_config_mut(&mut config.config);
    dao_config::set_dao_name(metadata_config, name);
}

public(package) fun set_icon_url(config: &mut FutarchyConfig, url: Url) {
    // Use direct mutable reference for efficient in-place update
    let metadata_config = dao_config::metadata_config_mut(&mut config.config);
    dao_config::set_icon_url(metadata_config, url);
}

public(package) fun set_description(config: &mut FutarchyConfig, desc: String) {
    // Use direct mutable reference for efficient in-place update
    let metadata_config = dao_config::metadata_config_mut(&mut config.config);
    dao_config::set_description(metadata_config, desc);
}

// Governance parameters
public(package) fun set_max_outcomes(config: &mut FutarchyConfig, max: u64) {
    // Use direct mutable reference for efficient in-place update
    let governance_config = dao_config::governance_config_mut(&mut config.config);
    dao_config::set_max_outcomes(governance_config, max);
}

public(package) fun set_proposal_fee_per_outcome(config: &mut FutarchyConfig, fee: u64) {
    // Use direct mutable reference for efficient in-place update
    let governance_config = dao_config::governance_config_mut(&mut config.config);
    dao_config::set_proposal_fee_per_outcome(governance_config, fee);
}

public(package) fun set_operational_state(config: &mut FutarchyConfig, new_state: u8) {
    config.operational_state = new_state;
}

public(package) fun set_max_concurrent_proposals(config: &mut FutarchyConfig, max: u64) {
    // Use direct mutable reference for efficient in-place update
    let governance_config = dao_config::governance_config_mut(&mut config.config);
    dao_config::set_max_concurrent_proposals(governance_config, max);
}

public(package) fun set_required_bond_amount(config: &mut FutarchyConfig, amount: u64) {
    // Use direct mutable reference for efficient in-place update
    let governance_config = dao_config::governance_config_mut(&mut config.config);
    dao_config::set_required_bond_amount(governance_config, amount);
}

public(package) fun set_optimistic_challenge_fee(config: &mut FutarchyConfig, amount: u64) {
    // Use direct mutable reference for efficient in-place update
    let governance_config = dao_config::governance_config_mut(&mut config.config);
    dao_config::set_optimistic_challenge_fee(governance_config, amount);
}

public(package) fun set_optimistic_challenge_period_ms(config: &mut FutarchyConfig, period: u64) {
    // Use direct mutable reference for efficient in-place update
    let governance_config = dao_config::governance_config_mut(&mut config.config);
    dao_config::set_optimistic_challenge_period_ms(governance_config, period);
}

// State tracking
public(package) fun increment_active_proposals(config: &mut FutarchyConfig) {
    config.active_proposals = config.active_proposals + 1;
}

public(package) fun decrement_active_proposals(config: &mut FutarchyConfig) {
    config.active_proposals = config.active_proposals - 1;
}

public(package) fun increment_total_proposals(config: &mut FutarchyConfig) {
    config.total_proposals = config.total_proposals + 1;
}

// References
public(package) fun set_treasury_id(config: &mut FutarchyConfig, id: Option<ID>) {
    config.treasury_id = id;
}

public(package) fun set_operating_agreement_id(config: &mut FutarchyConfig, id: Option<ID>) {
    config.operating_agreement_id = id;
}

// Queue management (deprecated - removed, using priority_queue module now)

public(package) fun set_proposal_queue_id(config: &mut FutarchyConfig, id: Option<ID>) {
    config.proposal_queue_id = id;
}

// Removed - using statically-typed actions pattern

// Verification
public(package) fun set_attestation_url(config: &mut FutarchyConfig, url: String) {
    config.attestation_url = url;
}

public(package) fun set_verification_pending(config: &mut FutarchyConfig, pending: bool) {
    config.verification_pending = pending;
}

public(package) fun set_verification_level(config: &mut FutarchyConfig, level: u8) {
    config.verification_level = level;
}

// Metadata setters
public(package) fun set_name(config: &mut FutarchyConfig, name: AsciiString) {
    // Use direct mutable reference for efficient in-place update
    let metadata_config = dao_config::metadata_config_mut(&mut config.config);
    dao_config::set_dao_name(metadata_config, name);
}

public(package) fun set_admin(_config: &mut FutarchyConfig, admin: address) {
    // In the account protocol architecture, admin is managed through the account's
    // authorization system rather than a field in the config.
    // This function is kept for API compatibility but doesn't modify the config.
    // 
    // To change admin/authorization in the account protocol:
    // 1. Use account protocol's role/member management functions
    // 2. Or implement custom authorization logic via Auth objects
    //
    // Since this is called internally during setup, we'll just validate the address
    assert!(admin != @0x0, EInvalidAdmin);
}

public(package) fun set_config_params(config: &mut FutarchyConfig, params: ConfigParams) {
    config.config = params.dao_config;
    config.slash_distribution = params.slash_distribution;
}

public(package) fun set_proposals_enabled_internal(config: &mut FutarchyConfig, enabled: bool) {
    if (enabled) {
        config.operational_state = DAO_STATE_ACTIVE;
    } else {
        config.operational_state = DAO_STATE_PAUSED;
    }
}

public(package) fun set_fee_manager_id(config: &mut FutarchyConfig, id: ID) {
    config.fee_manager_id = option::some(id);
}

public(package) fun set_fee_escalation_basis_points(config: &mut FutarchyConfig, points: u64) {
    // Use direct mutable reference for efficient in-place update
    let governance_config = dao_config::governance_config_mut(&mut config.config);
    dao_config::set_fee_escalation_basis_points(governance_config, points);
}

public(package) fun set_max_intents_per_outcome(config: &mut FutarchyConfig, max: u64) {
    // Use direct mutable reference for efficient in-place update
    let governance_config = dao_config::governance_config_mut(&mut config.config);
    dao_config::set_max_intents_per_outcome(governance_config, max);
}

public(package) fun set_eviction_grace_period_ms(config: &mut FutarchyConfig, period: u64) {
    // Use direct mutable reference for efficient in-place update
    let governance_config = dao_config::governance_config_mut(&mut config.config);
    dao_config::set_eviction_grace_period_ms(governance_config, period);
}

public(package) fun set_proposal_intent_expiry_ms(config: &mut FutarchyConfig, period: u64) {
    // Use direct mutable reference for efficient in-place update
    let governance_config = dao_config::governance_config_mut(&mut config.config);
    dao_config::set_proposal_intent_expiry_ms(governance_config, period);
}

public(package) fun set_spot_pool_id(config: &mut FutarchyConfig, id: ID) {
    config.spot_pool_id = option::some(id);
}

/// Update the slash distribution configuration
public(package) fun update_slash_distribution(
    config: &mut FutarchyConfig,
    slasher_reward_bps: u16,
    dao_treasury_bps: u16,
    protocol_bps: u16,
    burn_bps: u16,
) {
    config.slash_distribution = new_slash_distribution(
        slasher_reward_bps,
        dao_treasury_bps,
        protocol_bps,
        burn_bps
    );
}

// Setters for reward configurations
public(package) fun set_proposal_pass_reward(config: &mut FutarchyConfig, amount: u64) {
    config.proposal_pass_reward = amount;
}

public(package) fun set_outcome_win_reward(config: &mut FutarchyConfig, amount: u64) {
    config.outcome_win_reward = amount;
}

public(package) fun set_review_to_trading_fee(config: &mut FutarchyConfig, amount: u64) {
    config.review_to_trading_fee = amount;
}

public(package) fun set_finalization_fee(config: &mut FutarchyConfig, amount: u64) {
    config.finalization_fee = amount;
}

// Security config setters (use direct mutable references)
public(package) fun set_deadman_enabled(config: &mut FutarchyConfig, val: bool) {
    // Use direct mutable reference for efficient in-place update
    let security_config = dao_config::security_config_mut(&mut config.config);
    dao_config::set_deadman_enabled(security_config, val);
}

public(package) fun set_recovery_liveness_ms(config: &mut FutarchyConfig, ms: u64) {
    // Use direct mutable reference for efficient in-place update
    let security_config = dao_config::security_config_mut(&mut config.config);
    dao_config::set_recovery_liveness_ms(security_config, ms);
}

public(package) fun set_require_deadman_council(config: &mut FutarchyConfig, val: bool) {
    // Use direct mutable reference for efficient in-place update
    let security_config = dao_config::security_config_mut(&mut config.config);
    dao_config::set_require_deadman_council(security_config, val);
}

// Removed authorized_members_mut - auth is managed by account protocol

// === Account Creation ===
#[test_only]
public fun new_account_test(
    config: FutarchyConfig,
    ctx: &mut TxContext,
): Account<FutarchyConfig> {
    create_test_account(config, ctx)
}

/// Create a new Account with Extensions (production version)
public fun new_account_with_extensions(
    extensions: &Extensions,
    config: FutarchyConfig,
    ctx: &mut TxContext,
): Account<FutarchyConfig> {
    use account_protocol::{
        account_interface,
        deps,
    };
    
    // Include AccountProtocol, Futarchy AND AccountActions as deps.
    // This is required because we call account_actions::* modules (e.g. package_upgrade, owned...).
    account_interface::create_account!(
        config,
        version::current(),
        GovernanceWitness {},
        ctx,
        || deps::new_latest_extensions(
            extensions, 
            vector[
                b"AccountProtocol".to_string(),
                b"Futarchy".to_string(),
                b"AccountActions".to_string(), // <--- added
            ]
        )
    )
}

/// Create a new Account that allows unverified packages (for production use)
/// IMPORTANT: @futarchy must be the real deployed address, not 0x0
public fun new_account_unverified(
    extensions: &Extensions,
    config: FutarchyConfig,
    ctx: &mut TxContext,
): Account<FutarchyConfig> {
    use account_protocol::{
        account_interface,
        deps,
    };
    
    // Create deps with futarchy included
    // unverified_allowed = true bypasses Extensions registry check
    // but the address still needs to be in the deps list for deps::check()
    account_interface::create_account!(
        config,
        version::current(), // Use the real futarchy version witness
        GovernanceWitness {},
        ctx,
        || deps::new(
            extensions,
            true, // unverified_allowed = true to bypass Extensions registry
            vector[
                b"AccountProtocol".to_string(),
                b"Futarchy".to_string(),
            ],
            vector[
                @account_protocol,
                @futarchy, // MUST be the real deployed address, not 0x0
            ],
            vector[1, version::get()] // versions
        )
    )
}

#[test_only]
/// Create a test account without Extensions
/// IMPORTANT: Uses @account_protocol witness because @futarchy (0x0) is not deployed
fun create_test_account(
    config: FutarchyConfig,
    ctx: &mut TxContext,
): Account<FutarchyConfig> {
    use account_protocol::{
        account_interface,
        deps,
        version_witness,
    };
    
    // Must use @account_protocol witness for testing because:
    // 1. deps::check() always validates the address is in deps (ignores unverified_allowed)
    // 2. @futarchy is 0x0 (not deployed) so can't be in deps
    // 3. @account_protocol IS in the test deps
    let account = account_interface::create_account!(
        config,
        version_witness::new_for_testing(@account_protocol),
        GovernanceWitness {},
        ctx,
        || deps::new_for_testing()
    );
    
    account
}

// === Package-level Account Access ===

/// Get mutable access to config (package-level only)
public(package) fun internal_config_mut(
    account: &mut Account<FutarchyConfig>
): &mut FutarchyConfig {
    account::config_mut(account, version::current(), GovernanceWitness {})
}

#[test_only]
/// Get mutable access to config for tests (package-level only)
public(package) fun internal_config_mut_test(
    account: &mut Account<FutarchyConfig>
): &mut FutarchyConfig {
    use account_protocol::version_witness;
    account::config_mut(account, version_witness::new_for_testing(@account_protocol), GovernanceWitness {})
}

/// Set DAO pool ID (package-level only)  
public(package) fun set_dao_pool_id(
    config: &mut FutarchyConfig,
    pool_id: ID,
) {
    config.spot_pool_id = option::some(pool_id);
}


// === Governance Core Functions ===

/// Authenticate and get an Auth token
/// INTERNAL USE ONLY - must be called through action dispatcher
public(package) fun authenticate(
    account: &Account<FutarchyConfig>,
    _ctx: &mut TxContext,
): Auth {
    account::new_auth(
        account,
        version::current(),
        GovernanceWitness {}
    )
}

/// Simple outcome type for approved proposals
/// This is intentionally minimal to maximize compatibility with standard intents
public struct ApprovedProposal has store, drop, copy {
    proposal_id: ID,
    market_id: ID,
    outcome_index: u64,
}

/// Primary outcome type for futarchy intents
public struct FutarchyOutcome has store, drop, copy {
    // Intent key is the primary identifier - links to the intent in account storage
    intent_key: String,
    // These fields are set when proposal is created/approved
    proposal_id: Option<ID>,
    market_id: Option<ID>,
    approved: bool,
    min_execution_time: u64,
}

/// Creates a new FutarchyOutcome for intent creation (before proposal exists)
public fun new_outcome_for_intent(
    intent_key: String,
    min_execution_time: u64,
): FutarchyOutcome {
    FutarchyOutcome {
        intent_key,
        proposal_id: option::none(),
        market_id: option::none(),
        approved: false,
        min_execution_time,
    }
}

/// Public constructor for FutarchyOutcome with all fields
public fun new_futarchy_outcome(
    intent_key: String,
    proposal_id: Option<ID>,
    market_id: Option<ID>,
    approved: bool,
    min_execution_time: u64,
): FutarchyOutcome {
    FutarchyOutcome {
        intent_key,
        proposal_id,
        market_id,
        approved,
        min_execution_time,
    }
}

/// Updates the outcome with proposal and market IDs once proposal is created
public fun set_proposal_info(
    outcome: &mut FutarchyOutcome,
    proposal_id: ID,
    market_id: ID,
) {
    outcome.proposal_id = option::some(proposal_id);
    outcome.market_id = option::some(market_id);
}

/// Marks the outcome as approved when proposal passes
public fun approve_outcome(
    outcome: &mut FutarchyOutcome,
) {
    outcome.approved = true;
}

/// Updates the intent key for an outcome
public fun set_outcome_intent_key(outcome: &mut FutarchyOutcome, intent_key: String) {
    outcome.intent_key = intent_key;
}

/// Gets the min execution time from an outcome
public fun outcome_min_execution_time(outcome: &FutarchyOutcome): u64 {
    outcome.min_execution_time
}

/// Witness for governance operations
public struct GovernanceWitness has drop {}

/// Witness for FutarchyConfig creation
public struct FutarchyConfigWitness has drop {}

// === Council Approval System (Generic Only) ===

/// Generic approval for all council actions
public struct GenericApproval has store, drop, copy {
    dao_id: ID,
    action_type: String,  // "policy_remove", "policy_set", "custody_accept", etc.
    resource_key: String,  // The resource being acted upon
    metadata: vector<String>,  // Key-value pairs as flat vector [k1, v1, k2, v2, ...]
    expires_at: u64,
}

// === Helper Functions for Generic Approvals ===

/// Create a generic approval for policy removal
public fun new_policy_removal_approval(
    dao_id: ID,
    resource_key: String,
    expires_at: u64,
    ctx: &mut TxContext
): GenericApproval {
    let mut metadata = vector::empty<String>();
    metadata.push_back(b"resource_key".to_string());
    metadata.push_back(resource_key);
    
    GenericApproval {
        dao_id,
        action_type: b"policy_remove".to_string(),
        resource_key,
        metadata,
        expires_at,
    }
}

/// Create a generic approval for policy set
public fun new_policy_set_approval(
    dao_id: ID,
    resource_key: String,
    policy_account_id: ID,
    intent_key_prefix: String,
    expires_at: u64,
    ctx: &mut TxContext
): GenericApproval {
    let mut metadata = vector::empty<String>();
    // For now, store ID as hex string (in production, would need proper serialization)
    let id_bytes = object::id_to_bytes(&policy_account_id);
    let id_hex = sui::hex::encode(id_bytes);
    metadata.push_back(b"policy_account_id".to_string());
    metadata.push_back(std::string::utf8(id_hex));
    metadata.push_back(b"intent_key_prefix".to_string());
    metadata.push_back(intent_key_prefix);
    
    GenericApproval {
        dao_id,
        action_type: b"policy_set".to_string(),
        resource_key,
        metadata,
        expires_at,
    }
}

/// Create a generic approval for custody operations
public fun new_custody_approval(
    dao_id: ID,
    resource_key: String,
    asset_id: ID,
    expires_at: u64,
    ctx: &mut TxContext
): GenericApproval {
    let mut metadata = vector::empty<String>();
    // For now, store ID as hex string (in production, would need proper serialization)
    let id_bytes = object::id_to_bytes(&asset_id);
    let id_hex = sui::hex::encode(id_bytes);
    metadata.push_back(b"asset_id".to_string());
    metadata.push_back(std::string::utf8(id_hex));
    
    GenericApproval {
        dao_id,
        action_type: b"custody_accept".to_string(),
        resource_key,
        metadata,
        expires_at,
    }
}

/// Create a generic approval for cross-DAO bundle operations
public fun new_bundle_approval(
    dao_id: ID,
    bundle_id: String,
    bundle_type: String,
    expires_at: u64,
    ctx: &mut TxContext
): GenericApproval {
    let mut metadata = vector::empty<String>();
    metadata.push_back(b"bundle_type".to_string());
    metadata.push_back(bundle_type);
    
    GenericApproval {
        dao_id,
        action_type: b"cross_dao_bundle".to_string(),
        resource_key: bundle_id,
        metadata,
        expires_at,
    }
}

/// Managed-data key and container for council approvals
public struct CouncilApprovalKey has copy, drop, store {}
public struct CouncilApprovalBook has store {
    // Maps intent_key -> approval record
    approvals: Table<String, GenericApproval>,
}

/// Initialize the council approval book for a DAO (package-level only)
public(package) fun init_approval_book(
    account: &mut Account<FutarchyConfig>,
    ctx: &mut TxContext
) {
    let book = CouncilApprovalBook {
        approvals: table::new<String, GenericApproval>(ctx),
    };
    account::add_managed_data(
        account,
        CouncilApprovalKey {},
        book,
        version::current()
    );
}

/// Get the approval book (or initialize if not present)
fun get_or_init_approval_book(
    account: &mut Account<FutarchyConfig>,
    ctx: &mut TxContext
): &mut CouncilApprovalBook {
    // Try to borrow, if it doesn't exist, initialize it
    // In production, this should be initialized during DAO creation
    // For now, we'll initialize on first use
    init_approval_book_if_needed(account, ctx);
    account::borrow_managed_data_mut(
        account,
        CouncilApprovalKey {},
        version::current()
    )
}

/// Initialize approval book if it doesn't exist
fun init_approval_book_if_needed(
    account: &mut Account<FutarchyConfig>,
    ctx: &mut TxContext
) {
    // Properly initialize the approval book if it doesn't exist
    ensure_approval_book(account, ctx);
}

/// Execute permit - minted by config module after verifying approval
public struct ExecutePermit has copy, drop {
    intent_key: String,
    dao_address: address,
    issued_at: u64,
    expires_at: u64,
    /// The actual council approval (if any) that authorized this permit
    council_approval: Option<GenericApproval>,
}

/// Information about a proposal
public struct ProposalInfo has store {
    intent_key: Option<String>,
    approved: bool,
    executed: bool,
}

/// Store proposal info when a proposal is created
/// The actual proposal creation happens through the queue submission process
public fun register_proposal(
    account: &mut Account<FutarchyConfig>,
    proposal_id: ID,
    intent_key: String,
    ctx: &mut TxContext,
) {
    let config = internal_config_mut(account);
    
    // Store the intent key associated with this proposal
    let info = ProposalInfo {
        intent_key: option::some(intent_key),
        approved: false,
        executed: false,
    };
    
    // Note: Proposal info would need to be stored in account metadata
    // For now, this is a no-op - consume the struct
    let ProposalInfo { intent_key: _, approved: _, executed: _ } = info;
    
    // Increment active proposals
    increment_active_proposals(config);
}

/// Execute a proposal's intent with generic outcome type
/// Execute a proposal's intent with generic outcome type
/// This allows standard intents to work with any outcome type
public fun execute_proposal_intent<AssetType, StableType, Outcome: store + drop + copy>(
    account: &mut Account<FutarchyConfig>,
    proposal: &Proposal<AssetType, StableType>,
    market: &MarketState,
    outcome_index: u64,
    clock: &Clock,
    ctx: &mut TxContext,
): Executable<Outcome> {
    // Verify the outcome won
    assert!(market_state::is_finalized(market), EProposalNotApproved);
    let winning_outcome = market_state::get_winning_outcome(market);
    assert!((winning_outcome as u64) == outcome_index, EProposalNotApproved);
    
    // Get the intent key for the winning outcome
    let intent_key_opt = proposal::get_intent_key_for_outcome(proposal, outcome_index);
    assert!(intent_key_opt.is_some(), EProposalNotApproved);
    let intent_key = *intent_key_opt.borrow();
    
    // Execute the intent - the caller provides the outcome type
    let (_outcome, executable) = account::create_executable<FutarchyConfig, Outcome, FutarchyConfigWitness>(
        account,
        intent_key,
        clock,
        version::current(),
        FutarchyConfigWitness {},
    );
    
    executable
}

/// Helper function for canceling losing intents during finalization.
/// Requires a CancelWitness minted from the owning Proposal; prevents
/// cross-proposal cancellation. Emits a keyed-hash cancel event.
public(package) fun cancel_losing_intent_scoped(
    account: &mut Account<FutarchyConfig>,
    witness: proposal::CancelWitness,
    clock: &Clock
): account_protocol::intents::Expired {
    let proposal = proposal::cancel_witness_proposal(&witness);
    let outcome_index = proposal::cancel_witness_outcome_index(&witness);
    let key = proposal::cancel_witness_key(&witness);
    
    // Hash the key for privacy
    let key_bytes = std::bcs::to_bytes(&key);
    let key_hash = sui::hash::keccak256(&key_bytes);
    
    // Cancel the intent
    let expired = account::cancel_intent<FutarchyConfig, FutarchyOutcome, _>(
        account,
        key,
        version::current(),
        GovernanceWitness {}
    );
    
    // Emit the cancellation event
    events::emit_cancelled(
        proposal,
        outcome_index,
        key_hash,
        1, // CANCEL_LOSING_OUTCOME constant value
        clock.timestamp_ms()
    );
    
    expired
}

#[test_only]
/// Test version that uses the correct version witness for test accounts
public(package) fun cancel_losing_intent_scoped_test(
    account: &mut Account<FutarchyConfig>,
    witness: proposal::CancelWitness,
    clock: &Clock
): account_protocol::intents::Expired {
    use account_protocol::version_witness;
    
    let proposal = proposal::cancel_witness_proposal(&witness);
    let outcome_index = proposal::cancel_witness_outcome_index(&witness);
    let key = proposal::cancel_witness_key(&witness);
    
    // Hash the key for privacy
    let key_bytes = std::bcs::to_bytes(&key);
    let key_hash = sui::hash::keccak256(&key_bytes);
    
    // Cancel the intent using test version witness
    let expired = account::cancel_intent<FutarchyConfig, FutarchyOutcome, _>(
        account,
        key,
        version_witness::new_for_testing(@account_protocol),
        GovernanceWitness {}
    );
    
    // Emit the cancellation event
    events::emit_cancelled(
        proposal,
        outcome_index,
        key_hash,
        1, // CANCEL_LOSING_OUTCOME constant value
        clock.timestamp_ms()
    );
    
    expired
}

// === Council Approval Book Management ===

/// Ensure the approval book exists (idempotent)
fun ensure_approval_book(
    account: &mut Account<FutarchyConfig>,
    ctx: &mut TxContext
) {
    if (!account::has_managed_data(account, CouncilApprovalKey {})) {
        account::add_managed_data(
            account,
            CouncilApprovalKey {},
            CouncilApprovalBook { approvals: table::new<String, GenericApproval>(ctx) },
            version::current()
        );
    };
}

/// Record a council approval for an intent
public fun record_council_approval_generic(
    account: &mut Account<FutarchyConfig>,
    intent_key: String,
    approval: GenericApproval,
    ctx: &mut TxContext
) {
    let book = get_or_init_approval_book(account, ctx);
    table::add(&mut book.approvals, intent_key, approval);
}


/// Check if a council approval exists for an intent
public fun has_council_approval(
    account: &Account<FutarchyConfig>,
    intent_key: &String,
    clock: &Clock
): bool {
    if (!account::has_managed_data(account, CouncilApprovalKey {})) return false;
    
    let book: &CouncilApprovalBook = account::borrow_managed_data(
        account, CouncilApprovalKey {}, version::current()
    );
    
    if (!table::contains(&book.approvals, *intent_key)) return false;
    
    let approval = table::borrow(&book.approvals, *intent_key);
    let now = clock.timestamp_ms();
    
    // Check expiry
    now < approval.expires_at
}

/// Get the council approval for an intent (if exists)
public fun get_council_approval(
    account: &Account<FutarchyConfig>,
    intent_key: &String
): Option<GenericApproval> {
    // Check if the approval book exists
    if (!account::has_managed_data(account, CouncilApprovalKey {})) {
        return option::none()
    };
    
    let book: &CouncilApprovalBook = account::borrow_managed_data(
        account, CouncilApprovalKey {}, version::current()
    );
    
    if (!table::contains(&book.approvals, *intent_key)) {
        return option::none()
    };
    
    option::some(*table::borrow(&book.approvals, *intent_key))
}

/// Consume a council approval (single-use)
public fun consume_council_approval(
    account: &mut Account<FutarchyConfig>,
    intent_key: &String,
    ctx: &mut TxContext
): Option<GenericApproval> {
    // Ensure the approval book exists
    ensure_approval_book(account, ctx);
    
    let book: &mut CouncilApprovalBook = account::borrow_managed_data_mut(
        account, CouncilApprovalKey {}, version::current()
    );
    
    if (!table::contains(&book.approvals, *intent_key)) {
        return option::none()
    };
    
    option::some(table::remove(&mut book.approvals, *intent_key))
}

// === Permit Functions for Cross-DAO Execution ===

/// Issue an execute permit after checking gates and council approval
public fun issue_execute_permit_for_intent(
    account: &Account<FutarchyConfig>,
    intent_key: &String,
    clock: &Clock,
): ExecutePermit {
    let now = clock.timestamp_ms();
    let expires_at = now + 5 * 60_000; // 5 minute default TTL
    
    // Check for council approval and include it in the permit if present
    let council_approval = get_council_approval(account, intent_key);
    
    // If there's a council approval, use its expiry time if sooner
    let permit_expires = if (option::is_some(&council_approval)) {
        let approval = option::borrow(&council_approval);
        let approval_expires = approval.expires_at;
        if (approval_expires < expires_at) { approval_expires } else { expires_at }
    } else {
        expires_at
    };
    
    ExecutePermit {
        intent_key: *intent_key,
        dao_address: account::addr(account),
        issued_at: now,
        expires_at: permit_expires,
        council_approval,
    }
}

/// Verify a permit is valid
public fun verify_permit(
    permit: &ExecutePermit,
    account: &Account<FutarchyConfig>,
    intent_key: &String,
    clock: &Clock
): bool {
    // Basic checks
    if (permit.dao_address != account::addr(account)) return false;
    if (permit.intent_key != *intent_key) return false;
    if (clock.timestamp_ms() >= permit.expires_at) return false;
    
    // If permit has council approval, verify it matches what's in the book
    if (option::is_some(&permit.council_approval)) {
        let book_approval = get_council_approval(account, intent_key);
        if (option::is_none(&book_approval)) return false;
        
        // The approvals must match exactly
        *option::borrow(&permit.council_approval) == *option::borrow(&book_approval)
    } else {
        true
    }
}

/// Accessor for permit's intent_key
public fun permit_intent_key(permit: &ExecutePermit): String {
    permit.intent_key
}

/// Accessor for permit's dao_address
public fun permit_dao_address(permit: &ExecutePermit): address {
    permit.dao_address
}

/// Accessor for permit's issued_at timestamp
public fun permit_issued_at(permit: &ExecutePermit): u64 {
    permit.issued_at
}

/// Accessor for permit's expires_at timestamp
public fun permit_expires_at(permit: &ExecutePermit): u64 {
    permit.expires_at
}

/// Accessor for permit's council approval
public fun permit_council_approval(permit: &ExecutePermit): &Option<GenericApproval> {
    &permit.council_approval
}

// === Config Action Execution Functions ===
// NOTE: These functions have been moved to the action modules themselves
// The action modules now contain the full execution logic using direct config access
// This follows the principle of having actions be self-contained command handlers
module futarchy::fee;

use std::ascii::String as AsciiString;
use std::type_name;
use sui::balance::{Self, Balance};
use sui::clock::Clock;
use sui::coin::{Self, Coin};
use sui::dynamic_field;
use sui::event;
use sui::sui::SUI;
use std::u64;
use sui::table::{Self, Table};
use sui::transfer::{public_share_object, public_transfer};

// === Introduction ===
// Manages all fees earnt by the protocol. It is also the interface for admin fee withdrawal

// === Errors ===
const EInvalidPayment: u64 = 0;
const EStableTypeNotFound: u64 = 1;
const EBadWitness: u64 = 2;
const ERecurringFeeNotDue: u64 = 3;
const EWrongStableTypeForFee: u64 = 4;
const EInsufficientTreasuryBalance: u64 = 5;
const EArithmeticOverflow: u64 = 6;
const EInvalidAdminCap: u64 = 7;
const EInvalidRecoveryFee: u64 = 9;
const EFeeExceedsHardCap: u64 = 10;

// === Constants ===
const DEFAULT_DAO_CREATION_FEE: u64 = 10_000;
const DEFAULT_PROPOSAL_CREATION_FEE_PER_OUTCOME: u64 = 1000;
const DEFAULT_VERIFICATION_FEE: u64 = 10_000; // Default fee for level 1
const MONTHLY_FEE_PERIOD_MS: u64 = 2_592_000_000; // 30 days
const FEE_UPDATE_DELAY_MS: u64 = 15_552_000_000; // 6 months (180 days)
const MAX_FEE_COLLECTION_PERIOD_MS: u64 = 7_776_000_000; // 90 days (3 months) - max retroactive collection
// Remove ABSOLUTE_MAX_MONTHLY_FEE in V3 this is jsut here to build up trust
// Dont want to limit fee as platform gets more mature
const ABSOLUTE_MAX_MONTHLY_FEE: u64 = 10_000_000_000; // 10,000 USDC (6 decimals)

// === Structs ===

public struct FEE has drop {}

public struct FeeManager has key, store {
    id: UID,
    admin_cap_id: ID,
    dao_creation_fee: u64,
    proposal_creation_fee_per_outcome: u64,
    verification_fees: Table<u8, u64>, // Dynamic table mapping level -> fee
    dao_monthly_fee: u64,
    pending_dao_monthly_fee: Option<u64>,
    pending_fee_effective_timestamp: Option<u64>,
    sui_balance: Balance<SUI>,
    recovery_fee: u64,  // Fee for dead-man switch recovery
}

public struct FeeAdminCap has key, store {
    id: UID,
}

/// Tracks fee collection history for each DAO
public struct DaoFeeRecord has store {
    last_collection_timestamp: u64,
    total_collected: u64,
    last_fee_rate: u64,  // Fee rate at last collection to prevent retroactive increases
}

// === Events ===
public struct FeesWithdrawn has copy, drop {
    amount: u64,
    recipient: address,
    timestamp: u64,
}

public struct DAOCreationFeeUpdated has copy, drop {
    old_fee: u64,
    new_fee: u64,
    admin: address,
    timestamp: u64,
}

public struct ProposalCreationFeeUpdated has copy, drop {
    old_fee: u64,
    new_fee_per_outcome: u64,
    admin: address,
    timestamp: u64,
}

public struct VerificationFeeUpdated has copy, drop {
    level: u8,
    old_fee: u64,
    new_fee: u64,
    admin: address,
    timestamp: u64,
}

public struct VerificationLevelAdded has copy, drop {
    level: u8,
    fee: u64,
    admin: address,
    timestamp: u64,
}

public struct VerificationLevelRemoved has copy, drop {
    level: u8,
    admin: address,
    timestamp: u64,
}

public struct DAOCreationFeeCollected has copy, drop {
    amount: u64,
    payer: address,
    timestamp: u64,
}

public struct ProposalCreationFeeCollected has copy, drop {
    amount: u64,
    payer: address,
    timestamp: u64,
}

public struct VerificationFeeCollected has copy, drop {
    level: u8,
    amount: u64,
    payer: address,
    timestamp: u64,
}

public struct StableFeesCollected has copy, drop {
    amount: u64,
    stable_type: AsciiString,
    proposal_id: ID,
    timestamp: u64,
}

public struct StableFeesWithdrawn has copy, drop {
    amount: u64,
    stable_type: AsciiString,
    recipient: address,
    timestamp: u64,
}

public struct DaoMonthlyFeeUpdated has copy, drop {
    old_fee: u64,
    new_fee: u64,
    admin: address,
    timestamp: u64,
}

public struct DaoMonthlyFeePending has copy, drop {
    current_fee: u64,
    pending_fee: u64,
    effective_timestamp: u64,
    admin: address,
    timestamp: u64,
}

public struct DaoPlatformFeeCollected has copy, drop {
    dao_id: ID,
    amount: u64,
    stable_type: AsciiString,
    collector: address,
    timestamp: u64,
}

public struct RecoveryFeeUpdated has copy, drop {
    old_fee: u64,
    new_fee: u64,
    admin: address,
    timestamp: u64,
}

public struct RecoveryRequested has copy, drop {
    dao_id: ID,
    council_id: ID,
    fee: u64,
    requester: address,
    timestamp: u64,
}

public struct RecoveryExecuted has copy, drop {
    dao_id: ID,
    new_council_id: ID,
    timestamp: u64,
}

// === Public Functions ===
fun init(witness: FEE, ctx: &mut TxContext) {
    // Verify that the witness is valid and one-time only.
    assert!(sui::types::is_one_time_witness(&witness), EBadWitness);

    let fee_admin_cap = FeeAdminCap {
        id: object::new(ctx),
    };
    
    let mut verification_fees = table::new<u8, u64>(ctx);
    // Start with just level 1 by default
    table::add(&mut verification_fees, 1, DEFAULT_VERIFICATION_FEE);
    
    let fee_manager = FeeManager {
        id: object::new(ctx),
        admin_cap_id: object::id(&fee_admin_cap),
        dao_creation_fee: DEFAULT_DAO_CREATION_FEE,
        proposal_creation_fee_per_outcome: DEFAULT_PROPOSAL_CREATION_FEE_PER_OUTCOME,
        verification_fees,
        dao_monthly_fee: 10_000_000, // e.g. 10 of a 6-decimal stable coin
        pending_dao_monthly_fee: option::none(),
        pending_fee_effective_timestamp: option::none(),
        sui_balance: balance::zero<SUI>(),
        recovery_fee: 5_000_000_000, // 5 SUI default (~$5k equivalent)
    };

    public_share_object(fee_manager);
    public_transfer(fee_admin_cap, ctx.sender());

    // Consuming the witness ensures one-time initialization.
    let _ = witness;
}

// === Package Functions ===
// Generic internal fee collection function
fun deposit_payment(fee_manager: &mut FeeManager, fee_amount: u64, payment: Coin<SUI>): u64 {
    // Verify payment
    let payment_amount = payment.value();
    assert!(payment_amount == fee_amount, EInvalidPayment);

    // Process payment
    let paid_balance = payment.into_balance();
    fee_manager.sui_balance.join(paid_balance);
    return payment_amount
    // Event emission will be handled by specific wrappers
}

// Function to collect DAO creation fee
public(package) fun deposit_dao_creation_payment(
    fee_manager: &mut FeeManager,
    payment: Coin<SUI>,
    clock: &Clock,
    ctx: &TxContext,
) {
    let fee_amount = fee_manager.dao_creation_fee;

    let payment_amount = deposit_payment(fee_manager, fee_amount, payment);

    // Emit event
    event::emit(DAOCreationFeeCollected {
        amount: payment_amount,
        payer: ctx.sender(),
        timestamp: clock.timestamp_ms(),
    });
}


// Function to collect proposal creation fee
public(package) fun deposit_proposal_creation_payment(
    fee_manager: &mut FeeManager,
    payment: Coin<SUI>,
    outcome_count: u64,
    clock: &Clock,
    ctx: &TxContext,
) {
    // Use u128 arithmetic to prevent overflow
    let fee_amount_u128 = (fee_manager.proposal_creation_fee_per_outcome as u128) * (outcome_count as u128);
    
    // Check that result fits in u64
    assert!(fee_amount_u128 <= (u64::max_value!() as u128), EArithmeticOverflow); // u64::max_value()
    let fee_amount = (fee_amount_u128 as u64);

    // deposit_payment asserts the payment amount is exactly the fee_amount
    let payment_amount = deposit_payment(fee_manager, fee_amount, payment);

    // Emit event
    event::emit(ProposalCreationFeeCollected {
        amount: payment_amount,
        payer: ctx.sender(),
        timestamp: clock.timestamp_ms(),
    });
}


// Function to collect recovery fee for dead-man switch
public(package) fun deposit_recovery_payment(
    fee_manager: &mut FeeManager,
    dao_id: ID,
    council_id: ID,
    payment: Coin<SUI>,
    clock: &Clock,
    ctx: &TxContext,
) {
    let fee_due = fee_manager.recovery_fee;
    assert!(payment.value() == fee_due, EInvalidPayment);
    let bal = payment.into_balance();
    fee_manager.sui_balance.join(bal);
    event::emit(RecoveryRequested {
        dao_id,
        council_id,
        fee: fee_due,
        requester: ctx.sender(),
        timestamp: clock.timestamp_ms(),
    });
}

// Function to collect verification fee for a specific level
public(package) fun deposit_verification_payment(
    fee_manager: &mut FeeManager,
    payment: Coin<SUI>,
    verification_level: u8,
    clock: &Clock,
    ctx: &TxContext,
) {
    assert!(table::contains(&fee_manager.verification_fees, verification_level), EInvalidPayment);
    let fee_amount = *table::borrow(&fee_manager.verification_fees, verification_level);
    let payment_amount = deposit_payment(fee_manager, fee_amount, payment);

    // Emit event
    event::emit(VerificationFeeCollected {
        level: verification_level,
        amount: payment_amount,
        payer: ctx.sender(),
        timestamp: clock.timestamp_ms(),
    });
}

// === Admin Functions ===
// Admin function to withdraw fees
public entry fun withdraw_all_fees(
    fee_manager: &mut FeeManager,
    admin_cap: &FeeAdminCap,
    clock: &Clock,
    ctx: &mut TxContext,
) {
    // Verify the admin cap belongs to this fee manager
    assert!(object::id(admin_cap) == fee_manager.admin_cap_id, EInvalidAdminCap);
    let amount = fee_manager.sui_balance.value();
    let sender = ctx.sender();

    let withdrawal = fee_manager.sui_balance.split(amount).into_coin(ctx);

    event::emit(FeesWithdrawn {
        amount,
        recipient: sender,
        timestamp: clock.timestamp_ms(),
    });

    public_transfer(withdrawal, sender);
}

// Admin function to update DAO creation fee
public entry fun update_dao_creation_fee(
    fee_manager: &mut FeeManager,
    admin_cap: &FeeAdminCap,
    new_fee: u64,
    clock: &Clock,
    ctx: &mut TxContext,
) {
    assert!(object::id(admin_cap) == fee_manager.admin_cap_id, EInvalidAdminCap);
    let old_fee = fee_manager.dao_creation_fee;
    fee_manager.dao_creation_fee = new_fee;

    event::emit(DAOCreationFeeUpdated {
        old_fee,
        new_fee,
        admin: ctx.sender(),
        timestamp: clock.timestamp_ms(),
    });
}

// Admin function to update proposal creation fee
public entry fun update_proposal_creation_fee(
    fee_manager: &mut FeeManager,
    admin_cap: &FeeAdminCap,
    new_fee_per_outcome: u64,
    clock: &Clock,
    ctx: &mut TxContext,
) {
    assert!(object::id(admin_cap) == fee_manager.admin_cap_id, EInvalidAdminCap);
    let old_fee = fee_manager.proposal_creation_fee_per_outcome;
    fee_manager.proposal_creation_fee_per_outcome = new_fee_per_outcome;

    event::emit(ProposalCreationFeeUpdated {
        old_fee,
        new_fee_per_outcome,
        admin: ctx.sender(),
        timestamp: clock.timestamp_ms(),
    });
}

// Admin function to add a new verification level
public entry fun add_verification_level(
    fee_manager: &mut FeeManager,
    admin_cap: &FeeAdminCap,
    level: u8,
    fee: u64,
    clock: &Clock,
    ctx: &mut TxContext,
) {
    assert!(object::id(admin_cap) == fee_manager.admin_cap_id, EInvalidAdminCap);
    assert!(!table::contains(&fee_manager.verification_fees, level), EInvalidPayment);
    
    table::add(&mut fee_manager.verification_fees, level, fee);
    
    event::emit(VerificationLevelAdded {
        level,
        fee,
        admin: ctx.sender(),
        timestamp: clock.timestamp_ms(),
    });
}

// Admin function to remove a verification level
public entry fun remove_verification_level(
    fee_manager: &mut FeeManager,
    admin_cap: &FeeAdminCap,
    level: u8,
    clock: &Clock,
    ctx: &mut TxContext,
) {
    assert!(object::id(admin_cap) == fee_manager.admin_cap_id, EInvalidAdminCap);
    assert!(table::contains(&fee_manager.verification_fees, level), EInvalidPayment);
    
    table::remove(&mut fee_manager.verification_fees, level);
    
    event::emit(VerificationLevelRemoved {
        level,
        admin: ctx.sender(),
        timestamp: clock.timestamp_ms(),
    });
}

// Admin function to update verification fee for a specific level
public entry fun update_verification_fee(
    fee_manager: &mut FeeManager,
    admin_cap: &FeeAdminCap,
    level: u8,
    new_fee: u64,
    clock: &Clock,
    ctx: &mut TxContext,
) {
    assert!(object::id(admin_cap) == fee_manager.admin_cap_id, EInvalidAdminCap);
    assert!(table::contains(&fee_manager.verification_fees, level), EInvalidPayment);
    
    let old_fee = *table::borrow(&fee_manager.verification_fees, level);
    *table::borrow_mut(&mut fee_manager.verification_fees, level) = new_fee;

    event::emit(VerificationFeeUpdated {
        level,
        old_fee,
        new_fee,
        admin: ctx.sender(),
        timestamp: clock.timestamp_ms(),
    });
}

// Admin function to update recovery fee
public entry fun update_recovery_fee(
    fee_manager: &mut FeeManager,
    admin_cap: &FeeAdminCap,
    new_fee: u64,
    clock: &Clock,
    ctx: &TxContext,
) {
    assert!(object::id(admin_cap) == fee_manager.admin_cap_id, EInvalidAdminCap);
    let old_fee = fee_manager.recovery_fee;
    fee_manager.recovery_fee = new_fee;
    event::emit(RecoveryFeeUpdated {
        old_fee,
        new_fee,
        admin: ctx.sender(),
        timestamp: clock.timestamp_ms(),
    });
}

// View function for recovery fee
public fun get_recovery_fee(fee_manager: &FeeManager): u64 {
    fee_manager.recovery_fee
}

// Function removed to avoid circular dependency with treasury module
// This functionality should be moved to a separate module

/// Collect platform fee from a DAO's vault with 3-month retroactive limit
/// IMPORTANT: Uses the fee rate from when periods were incurred, not current rate
public(package) fun collect_dao_platform_fee<StableType: drop>(
    fee_manager: &mut FeeManager,
    dao_id: ID,
    clock: &Clock,
    ctx: &mut TxContext,
): (u64, u64) { // Returns (fee_amount, periods_collected)
    let current_time = clock.timestamp_ms();
    
    // Apply pending fee if due (before we calculate anything)
    apply_pending_fee_if_due(fee_manager, clock);
    
    // Get current fee rate
    let current_fee_rate = fee_manager.dao_monthly_fee;
    
    // Get or create fee record for this DAO
    let record_key = dao_id;
    let (last_collection, last_rate, is_new) = if (dynamic_field::exists_(&fee_manager.id, record_key)) {
        let record: &DaoFeeRecord = dynamic_field::borrow(&fee_manager.id, record_key);
        (record.last_collection_timestamp, record.last_fee_rate, false)
    } else {
        // First time collecting from this DAO - initialize with current rate
        let new_record = DaoFeeRecord {
            last_collection_timestamp: current_time,
            total_collected: 0,
            last_fee_rate: current_fee_rate,
        };
        dynamic_field::add(&mut fee_manager.id, record_key, new_record);
        return (0, 0) // No retroactive fees on first collection
    };
    
    // Calculate how many periods we can collect
    let time_since_last = if (current_time > last_collection) {
        current_time - last_collection
    } else {
        0
    };
    
    // Cap at 3 months max
    let collectible_time = if (time_since_last > MAX_FEE_COLLECTION_PERIOD_MS) {
        MAX_FEE_COLLECTION_PERIOD_MS
    } else {
        time_since_last
    };
    
    // Calculate number of monthly periods to collect
    let periods_to_collect = collectible_time / MONTHLY_FEE_PERIOD_MS;
    
    if (periods_to_collect == 0) {
        return (0, 0)
    };
    
    // CRITICAL: Use the LOWER of last rate or current rate to prevent retroactive increases
    // DAOs benefit from fee decreases immediately but are protected from increases
    let fee_per_period = if (last_rate < current_fee_rate) {
        last_rate  // Protect DAO from retroactive fee increases
    } else {
        current_fee_rate  // Allow DAO to benefit from fee decreases
    };
    
    let total_fee = fee_per_period * periods_to_collect;
    
    // Update the record with new timestamp and current rate for future collections
    let record: &mut DaoFeeRecord = dynamic_field::borrow_mut(&mut fee_manager.id, record_key);
    record.last_collection_timestamp = current_time;
    record.total_collected = record.total_collected + total_fee;
    record.last_fee_rate = current_fee_rate;  // Store current rate for next time
    
    (total_fee, periods_to_collect)
}

public(package) fun deposit_dao_platform_fee<StableType: drop>(
    fee_manager: &mut FeeManager,
    fee_coin: Coin<StableType>,
    dao_id: ID,
    clock: &Clock,
    ctx: &mut TxContext,
) {
    let amount = fee_coin.value();
    let stable_type_str = type_name::get<StableType>().into_string();
    
    deposit_stable_fees(fee_manager, fee_coin.into_balance(), dao_id, clock);
    
    // Emit platform fee collection event
    event::emit(DaoPlatformFeeCollected {
        dao_id,
        amount,
        stable_type: stable_type_str,
        collector: ctx.sender(),
        timestamp: clock.timestamp_ms(),
    });
}

/// Collect DAO platform fee with admin-approved discount
/// Admin can collect any amount between 0 and the full fee owed
public fun collect_dao_platform_fee_with_discount<StableType: drop>(
    fee_manager: &mut FeeManager,
    admin_cap: &FeeAdminCap,
    dao_id: ID,
    discount_amount: u64, // Amount to discount from the full fee
    clock: &Clock,
    ctx: &mut TxContext,
): (u64, u64) { // Returns (actual_fee_charged, periods_collected)
    // Verify admin cap
    assert!(fee_manager.admin_cap_id == object::id(admin_cap), EInvalidAdminCap);
    
    // Calculate the full fee owed
    let (full_fee, periods) = collect_dao_platform_fee<StableType>(fee_manager, dao_id, clock, ctx);
    
    // Apply discount (ensure we don't go negative)
    let actual_fee = if (discount_amount >= full_fee) {
        0 // Full discount (free)
    } else {
        full_fee - discount_amount
    };
    
    (actual_fee, periods)
}

public entry fun update_dao_monthly_fee(
    fee_manager: &mut FeeManager,
    admin_cap: &FeeAdminCap,
    new_fee: u64,
    clock: &Clock,
    ctx: &mut TxContext,
) {
    assert!(object::id(admin_cap) == fee_manager.admin_cap_id, EInvalidAdminCap);
    
    // V2 Hard cap enforcement - prevents excessive fees while protocol matures
    assert!(new_fee <= ABSOLUTE_MAX_MONTHLY_FEE, EFeeExceedsHardCap);
    
    let current_fee = fee_manager.dao_monthly_fee;
    let effective_timestamp = clock.timestamp_ms() + FEE_UPDATE_DELAY_MS;
    
    // Set the pending fee
    fee_manager.pending_dao_monthly_fee = option::some(new_fee);
    fee_manager.pending_fee_effective_timestamp = option::some(effective_timestamp);

    event::emit(DaoMonthlyFeePending {
        current_fee,
        pending_fee: new_fee,
        effective_timestamp,
        admin: ctx.sender(),
        timestamp: clock.timestamp_ms(),
    });
}

/// Apply pending fee if the delay period has passed
public fun apply_pending_fee_if_due(
    fee_manager: &mut FeeManager,
    clock: &Clock,
) {
    if (fee_manager.pending_dao_monthly_fee.is_some() && 
        fee_manager.pending_fee_effective_timestamp.is_some()) {
        
        let effective_timestamp = *fee_manager.pending_fee_effective_timestamp.borrow();
        
        if (clock.timestamp_ms() >= effective_timestamp) {
            let old_fee = fee_manager.dao_monthly_fee;
            let new_fee = *fee_manager.pending_dao_monthly_fee.borrow();
            
            // Apply the pending fee
            fee_manager.dao_monthly_fee = new_fee;
            
            // Clear pending fee data
            fee_manager.pending_dao_monthly_fee = option::none();
            fee_manager.pending_fee_effective_timestamp = option::none();
            
            event::emit(DaoMonthlyFeeUpdated {
                old_fee,
                new_fee,
                admin: @0x0, // System update, no specific admin
                timestamp: clock.timestamp_ms(),
            });
        }
    }
}

// === AMM Fees ===

// Structure to store stable coin balance information
public struct StableCoinBalance<phantom T> has store {
    balance: Balance<T>,
}

public struct StableFeeRegistry<phantom T> has copy, drop, store {}

// Modified stable fees storage with more structure
public(package) fun deposit_stable_fees<StableType>(
    fee_manager: &mut FeeManager,
    fees: Balance<StableType>,
    proposal_id: ID,
    clock: &Clock,
) {
    let amount = fees.value();

    if (
        dynamic_field::exists_with_type<
            StableFeeRegistry<StableType>,
            StableCoinBalance<StableType>,
        >(&fee_manager.id, StableFeeRegistry<StableType> {})
    ) {
        let fee_balance_wrapper = dynamic_field::borrow_mut<
            StableFeeRegistry<StableType>,
            StableCoinBalance<StableType>,
        >(&mut fee_manager.id, StableFeeRegistry<StableType> {});
        fee_balance_wrapper.balance.join(fees);
    } else {
        let balance_wrapper = StableCoinBalance<StableType> {
            balance: fees,
        };
        dynamic_field::add(&mut fee_manager.id, StableFeeRegistry<StableType> {}, balance_wrapper);
    };

    let type_name = type_name::get<StableType>();
    let type_str = type_name.into_string();
    // Emit collection event
    event::emit(StableFeesCollected {
        amount,
        stable_type: type_str,
        proposal_id,
        timestamp: clock.timestamp_ms(),
    });
}

public entry fun withdraw_stable_fees<StableType>(
    fee_manager: &mut FeeManager,
    admin_cap: &FeeAdminCap,
    clock: &Clock,
    ctx: &mut TxContext,
) {
    // Verify the admin cap belongs to this fee manager
    assert!(object::id(admin_cap) == fee_manager.admin_cap_id, EInvalidAdminCap);
    
    // Check if the stable type exists in the registry
    if (!dynamic_field::exists_with_type<
            StableFeeRegistry<StableType>,
            StableCoinBalance<StableType>,
        >(
            &fee_manager.id,
            StableFeeRegistry<StableType> {},
        )
    ) {
        // No fees of this type have been collected, nothing to withdraw
        return
    };

    let fee_balance_wrapper = dynamic_field::borrow_mut<
        StableFeeRegistry<StableType>,
        StableCoinBalance<StableType>,
    >(&mut fee_manager.id, StableFeeRegistry<StableType> {});
    let amount = fee_balance_wrapper.balance.value();

    if (amount > 0) {
        let withdrawn = fee_balance_wrapper.balance.split(amount);
        let coin = withdrawn.into_coin(ctx);

        let type_name = type_name::get<StableType>();
        let type_str = type_name.into_string();
        // Emit withdrawal event
        event::emit(StableFeesWithdrawn {
            amount,
            stable_type: type_str,
            recipient: ctx.sender(),
            timestamp: clock.timestamp_ms(),
        });

        // Transfer to sender
        public_transfer(coin, ctx.sender());
    }
}

// === View Functions ===
public fun get_dao_creation_fee(fee_manager: &FeeManager): u64 {
    fee_manager.dao_creation_fee
}

public fun get_proposal_creation_fee_per_outcome(fee_manager: &FeeManager): u64 {
    fee_manager.proposal_creation_fee_per_outcome
}

public fun get_verification_fee_for_level(fee_manager: &FeeManager, level: u8): u64 {
    assert!(table::contains(&fee_manager.verification_fees, level), EInvalidPayment);
    *table::borrow(&fee_manager.verification_fees, level)
}

public fun has_verification_level(fee_manager: &FeeManager, level: u8): bool {
    table::contains(&fee_manager.verification_fees, level)
}

public fun get_dao_monthly_fee(fee_manager: &FeeManager): u64 {
    fee_manager.dao_monthly_fee
}

public fun get_pending_dao_monthly_fee(fee_manager: &FeeManager): Option<u64> {
    fee_manager.pending_dao_monthly_fee
}

public fun get_pending_fee_effective_timestamp(fee_manager: &FeeManager): Option<u64> {
    fee_manager.pending_fee_effective_timestamp
}

public fun get_sui_balance(fee_manager: &FeeManager): u64 {
    fee_manager.sui_balance.value()
}

public fun get_stable_fee_balance<StableType>(fee_manager: &FeeManager): u64 {
    if (
        dynamic_field::exists_with_type<
            StableFeeRegistry<StableType>,
            StableCoinBalance<StableType>,
        >(&fee_manager.id, StableFeeRegistry<StableType> {})
    ) {
        let balance_wrapper = dynamic_field::borrow<
            StableFeeRegistry<StableType>,
            StableCoinBalance<StableType>,
        >(&fee_manager.id, StableFeeRegistry<StableType> {});
        balance_wrapper.balance.value()
    } else {
        0
    }
}

/// Get the hard cap for monthly fees (V2 safety limit)
public fun get_max_monthly_fee_cap(): u64 {
    ABSOLUTE_MAX_MONTHLY_FEE
}

// ======== Test Functions ========
#[test_only]
public fun create_fee_manager_for_testing(ctx: &mut TxContext) {
    let admin_cap = FeeAdminCap {
        id: object::new(ctx),
    };
    
    let mut verification_fees = table::new<u8, u64>(ctx);
    // Start with just level 1 by default
    table::add(&mut verification_fees, 1, DEFAULT_VERIFICATION_FEE);
    
    let fee_manager = FeeManager {
        id: object::new(ctx),
        admin_cap_id: object::id(&admin_cap),
        dao_creation_fee: DEFAULT_DAO_CREATION_FEE,
        proposal_creation_fee_per_outcome: DEFAULT_PROPOSAL_CREATION_FEE_PER_OUTCOME,
        verification_fees,
        dao_monthly_fee: 10_000_000, // e.g. 10 of a 6-decimal stable coin
        pending_dao_monthly_fee: option::none(),
        pending_fee_effective_timestamp: option::none(),
        sui_balance: balance::zero<SUI>(),
        recovery_fee: 5_000_000_000, // 5 SUI default
    };

    public_share_object(fee_manager);
    public_transfer(admin_cap, ctx.sender());
}
/// Version tracking for the futarchy package
module futarchy::version;

// === Imports ===
use account_protocol::version_witness::{Self, VersionWitness};

// === Constants ===
const VERSION: u64 = 1;

// === Structs ===
public struct V1() has drop;

// === Public Functions ===

/// Get the current version witness
public(package) fun current(): VersionWitness {
    version_witness::new(V1())
}

/// Get the version number
public fun get(): u64 {
    VERSION
}

// === Test Functions ===

#[test_only]
public struct Witness() has drop;

#[test_only]
public fun witness(): Witness {
    Witness()
}

#[test_only]
/// Get a test version witness for the futarchy package
public fun test_version(): VersionWitness {
    // Create a proper version witness for testing
    version_witness::new(V1())
}/// Main action dispatcher - Entry points for composable atomic batch execution
/// Delegates to specialized dispatchers in each category folder
module futarchy::action_dispatcher;

// === Imports ===
use std::option::{Self, Option};
use sui::{
    clock::{Self, Clock},
    coin::{Self, Coin},
    sui::SUI,
    object::ID,
    transfer,
    tx_context::{Self, TxContext},
    event,
};
use account_protocol::{
    account::{Self, Account},
    executable::{Self, Executable},
    intents::Intent,
};
use account_actions::{
    vault_intents,
};
use futarchy::{
    futarchy_config::{Self, FutarchyConfig},
    version,
    priority_queue,
    proposal,
    proposal_fee_manager::{Self, ProposalFeeManager},
    spot_amm::SpotAMM,
    conditional_amm,
};

// Import all specialized dispatchers
use futarchy::{
    config_dispatcher,
    governance_dispatcher,
    oracle_actions, // Now uses stored TreasuryCap directly
    dissolution_dispatcher,
    liquidity_dispatcher,
    stream_dispatcher,
    vault_dispatcher,
    memo_dispatcher,
    operating_agreement_dispatcher,
    optimistic_dispatcher,
    governance_actions::{Self, ProposalReservationRegistry},
    protocol_admin_actions,
    factory::{Factory},
    fee::{FeeManager},
};

// === Entry Functions for Composable Execution ===

/// Execute standard futarchy actions that don't require special resources
/// Includes: config updates, governance settings, memos, etc.
public(package) fun execute_standard_actions<IW: copy + drop, Outcome: store + drop + copy>(
    executable: Executable<Outcome>,
    account: &mut Account<FutarchyConfig>,
    witness: IW,
    clock: &Clock,
    ctx: &mut TxContext,
): Executable<Outcome> {
    let mut executable = executable;
    
    // Process all standard actions
    while (executable.action_idx() < executable.intent().actions().length()) {
        let processed = 
            config_dispatcher::try_execute_config_action(&mut executable, account, witness, clock, ctx) ||
            governance_dispatcher::try_execute_governance_actions(&mut executable, account, witness, clock, ctx) ||
            memo_dispatcher::try_execute_memo_action(&mut executable, account, witness, clock, ctx) ||
            operating_agreement_dispatcher::try_execute_operating_agreement_action(&mut executable, account, witness, clock, ctx) ||
            optimistic_dispatcher::try_execute_optimistic_action(&mut executable, account, witness, clock, ctx);
            
        if (!processed) break  // Unknown action type
    };
    
    executable
}

/// Execute vault spend and transfer actions
public(package) fun execute_vault_spend<Outcome: store + drop + copy, CoinType: drop>(
    executable: Executable<Outcome>,
    account: &mut Account<FutarchyConfig>,
    ctx: &mut TxContext,
): Executable<Outcome> {
    let mut executable = executable;
    
    // Use Move framework's vault intent execution for spend/transfer
    vault_intents::execute_spend_and_transfer<FutarchyConfig, Outcome, CoinType>(
        &mut executable,
        account,
        ctx
    );
    
    executable
}

/// Execute vault coin type management actions (add/remove allowed coin types)
public(package) fun execute_vault_management<Outcome: store + drop + copy, CoinType: drop, IW: copy + drop>(
    mut executable: Executable<Outcome>,
    account: &mut Account<FutarchyConfig>,
    witness: IW,
    ctx: &mut TxContext,
): Executable<Outcome> {
    // Process vault coin type management actions
    while (executable.action_idx() < executable.intent().actions().length()) {
        if (vault_dispatcher::try_execute_typed_vault_action<CoinType, IW, Outcome>(&mut executable, account, witness, ctx)) {
            continue
        };
        
        break // Unknown action type
    };
    
    executable
}

/// Execute oracle mint actions using stored TreasuryCap
/// Handles conditional mints and tiered mints for founder rewards
public(package) fun execute_oracle_mint<
    Outcome: store + drop + copy,
    AssetType: drop + store,
    StableType: drop + store,
    IW: copy + drop
>(
    mut executable: Executable<Outcome>,
    account: &mut Account<FutarchyConfig>,
    witness: IW,
    spot_pool: &mut SpotAMM<AssetType, StableType>,
    clock: &Clock,
    ctx: &mut TxContext,
): Executable<Outcome> {
    // Process all oracle actions using stored TreasuryCap
    while (executable.action_idx() < executable.intent().actions().length()) {
        // Check for read oracle price action
        if (executable::contains_action<Outcome, oracle_actions::ReadOraclePriceAction<AssetType, StableType>>(&mut executable)) {
            oracle_actions::do_read_oracle_price<AssetType, StableType, Outcome, IW>(
                &mut executable,
                account,
                version::current(),
                witness,
                spot_pool,
                clock,
                ctx
            );
            continue
        };
        
        // Check for conditional mint action
        if (executable::contains_action<Outcome, oracle_actions::ConditionalMintAction<AssetType>>(&mut executable)) {
            oracle_actions::do_conditional_mint<AssetType, StableType, Outcome, IW>(
                &mut executable,
                account,
                version::current(),
                witness,
                spot_pool,
                clock,
                ctx
            );
            continue
        };
        
        // Check for tiered mint action
        if (executable::contains_action<Outcome, oracle_actions::TieredMintAction<AssetType>>(&mut executable)) {
            oracle_actions::do_tiered_mint<AssetType, StableType, Outcome, IW>(
                &mut executable,
                account,
                version::current(),
                witness,
                spot_pool,
                clock,
                ctx
            );
            continue
        };
        
        break // Unknown action type
    };
    
    executable
}

/// Execute liquidity operations (pool creation, parameter updates, etc.)
public(package) fun execute_liquidity_operations<
    Outcome: store + drop + copy,
    AssetType: drop + store,
    StableType: drop + store,
    IW: copy + drop
>(
    mut executable: Executable<Outcome>,
    account: &mut Account<FutarchyConfig>,
    witness: IW,
    _clock: &Clock,
    ctx: &mut TxContext,
): Executable<Outcome> {
    // Process all liquidity actions
    while (executable.action_idx() < executable.intent().actions().length()) {
        if (liquidity_dispatcher::try_execute_liquidity_action(&mut executable, account, witness, ctx)) {
            continue
        };
        
        if (liquidity_dispatcher::try_execute_typed_liquidity_action<AssetType, StableType, IW, Outcome>(
            &mut executable, account, witness, ctx
        )) {
            continue
        };
        
        break // Unknown action type
    };
    
    executable
}

/// Execute stream/recurring payment operations
public(package) fun execute_stream_operations<
    Outcome: store + drop + copy,
    CoinType: drop,
    IW: copy + drop
>(
    mut executable: Executable<Outcome>,
    account: &mut Account<FutarchyConfig>,
    witness: IW,
    clock: &Clock,
    ctx: &mut TxContext,
): Executable<Outcome> {
    // Process all stream actions
    while (executable.action_idx() < executable.intent().actions().length()) {
        if (stream_dispatcher::try_execute_stream_action(&mut executable, account, witness, clock, ctx)) {
            continue
        };
        
        if (stream_dispatcher::try_execute_typed_stream_action<CoinType, IW, Outcome>(
            &mut executable, account, witness, clock, ctx
        )) {
            continue
        };
        
        break // Unknown action type
    };
    
    executable
}

/// Execute dissolution operations (initiate, finalize, distribute, etc.)
public(package) fun execute_dissolution_operations<
    Outcome: store + drop + copy,
    AssetType: drop + store,
    StableType: drop + store,
    CoinType: drop,
    IW: copy + drop
>(
    mut executable: Executable<Outcome>,
    account: &mut Account<FutarchyConfig>,
    witness: IW,
    clock: &Clock,
    ctx: &mut TxContext,
): Executable<Outcome> {
    // Process all dissolution actions sequentially
    while (executable.action_idx() < executable.intent().actions().length()) {
        if (dissolution_dispatcher::try_execute_dissolution_action(&mut executable, account, witness, ctx)) {
            continue
        };
        
        if (dissolution_dispatcher::try_execute_typed_dissolution_action<CoinType, IW, Outcome>(
            &mut executable, account, witness, clock, ctx
        )) {
            continue
        };
        
        // Try liquidity actions (needed for withdrawing AMM liquidity)
        if (liquidity_dispatcher::try_execute_typed_liquidity_action<AssetType, StableType, IW, Outcome>(
            &mut executable, account, witness, ctx
        )) {
            continue
        };
        
        break // Unknown action type
    };
    
    executable
}

/// Execute governance operations (create second-order proposals)
public(package) fun execute_governance_operations<
    Outcome: store + drop + copy,
    IW: copy + drop
>(
    mut executable: Executable<Outcome>,
    account: &mut Account<FutarchyConfig>,
    witness: IW,
    queue: &mut priority_queue::ProposalQueue<FutarchyConfig>,
    fee_manager: &mut ProposalFeeManager,
    registry: &mut ProposalReservationRegistry,
    parent_proposal_id: ID,
    fee_coin: Coin<SUI>,
    clock: &Clock,
    ctx: &mut TxContext,
): Executable<Outcome> {
    // Process governance actions that require special resources
    while (executable.action_idx() < executable.intent().actions().length()) {
        // Check if this is a create proposal action
        if (executable::contains_action<Outcome, governance_actions::CreateProposalAction>(&mut executable)) {
            // Create the resource request
            let request = governance_actions::do_create_proposal<Outcome, IW>(
                &mut executable,
                account,
                version::current(),
                witness,
                parent_proposal_id,
                clock,
                ctx
            );
            
            // Fulfill the request with resources
            // The fee coin is passed directly to fulfill function which handles validation
            let _receipt = governance_actions::fulfill_create_proposal(
                request,
                queue,
                fee_manager,
                registry,
                fee_coin,
                clock,
                ctx
            );
            
            // Receipt has drop ability, so it's automatically cleaned up
            // Note: fee_coin is consumed by fulfill_create_proposal, so we return here
            return executable
        } else {
            break // No more governance actions
        }
    };
    
    // If no governance actions were processed, return the fee coin to sender
    if (coin::value(&fee_coin) > 0) {
        transfer::public_transfer(fee_coin, tx_context::sender(ctx));
    } else {
        coin::destroy_zero(fee_coin);
    };
    
    executable
}

/// Execute protocol admin operations (factory, fee, validator management)
/// This enables dogfooding - the protocol being governed by its own DAO
public(package) fun execute_protocol_admin_operations<
    Outcome: store + drop + copy,
    IW: copy + drop
>(
    mut executable: Executable<Outcome>,
    account: &mut Account<FutarchyConfig>,
    witness: IW,
    factory: &mut Factory,
    fee_manager: &mut FeeManager,
    clock: &Clock,
    ctx: &mut TxContext,
): Executable<Outcome> {
    // Process all protocol admin actions
    while (executable.action_idx() < executable.intent().actions().length()) {
        // Factory admin actions
        if (executable::contains_action<Outcome, protocol_admin_actions::SetFactoryPausedAction>(&mut executable)) {
            protocol_admin_actions::do_set_factory_paused(
                &mut executable,
                account,
                version::current(),
                witness,
                factory,
                ctx
            );
            continue
        };
        
        // Fee admin actions
        if (executable::contains_action<Outcome, protocol_admin_actions::UpdateDaoCreationFeeAction>(&mut executable)) {
            protocol_admin_actions::do_update_dao_creation_fee(
                &mut executable,
                account,
                version::current(),
                witness,
                fee_manager,
                clock,
                ctx
            );
            continue
        };
        
        if (executable::contains_action<Outcome, protocol_admin_actions::UpdateProposalFeeAction>(&mut executable)) {
            protocol_admin_actions::do_update_proposal_fee(
                &mut executable,
                account,
                version::current(),
                witness,
                fee_manager,
                clock,
                ctx
            );
            continue
        };
        
        if (executable::contains_action<Outcome, protocol_admin_actions::UpdateMonthlyDaoFeeAction>(&mut executable)) {
            protocol_admin_actions::do_update_monthly_dao_fee(
                &mut executable,
                account,
                version::current(),
                witness,
                fee_manager,
                clock,
                ctx
            );
            continue
        };
        
        if (executable::contains_action<Outcome, protocol_admin_actions::UpdateVerificationFeeAction>(&mut executable)) {
            protocol_admin_actions::do_update_verification_fee(
                &mut executable,
                account,
                version::current(),
                witness,
                fee_manager,
                clock,
                ctx
            );
            continue
        };
        
        if (executable::contains_action<Outcome, protocol_admin_actions::AddVerificationLevelAction>(&mut executable)) {
            protocol_admin_actions::do_add_verification_level(
                &mut executable,
                account,
                version::current(),
                witness,
                fee_manager,
                clock,
                ctx
            );
            continue
        };
        
        if (executable::contains_action<Outcome, protocol_admin_actions::RemoveVerificationLevelAction>(&mut executable)) {
            protocol_admin_actions::do_remove_verification_level(
                &mut executable,
                account,
                version::current(),
                witness,
                fee_manager,
                clock,
                ctx
            );
            continue
        };
        
        if (executable::contains_action<Outcome, protocol_admin_actions::UpdateRecoveryFeeAction>(&mut executable)) {
            protocol_admin_actions::do_update_recovery_fee(
                &mut executable,
                account,
                version::current(),
                witness,
                fee_manager,
                clock,
                ctx
            );
            continue
        };
        
        if (executable::contains_action<Outcome, protocol_admin_actions::ApplyDaoFeeDiscountAction>(&mut executable)) {
            protocol_admin_actions::do_apply_dao_fee_discount(
                &mut executable,
                account,
                version::current(),
                witness,
                fee_manager,
                clock,
                ctx
            );
            continue
        };
        
        if (executable::contains_action<Outcome, protocol_admin_actions::WithdrawFeesToTreasuryAction>(&mut executable)) {
            protocol_admin_actions::do_withdraw_fees_to_treasury(
                &mut executable,
                account,
                version::current(),
                witness,
                fee_manager,
                clock,
                ctx
            );
            continue
        };
        
        break // Unknown action type
    };
    
    executable
}

/// Execute commitment creation with coins
public(package) fun execute_commitment_creation<
    AssetType,
    StableType,
    Outcome: store + drop + copy,
    IW: copy + drop
>(
    mut executable: Executable<Outcome>,
    account: &mut Account<FutarchyConfig>,
    witness: IW,
    committed_coin: Coin<AssetType>,
    clock: &Clock,
    ctx: &mut TxContext,
): Executable<Outcome> {
    use futarchy::commitment_dispatcher;
    
    // Process only create commitment action
    if (executable.action_idx() < executable.intent().actions().length()) {
        let mut new_commitment = commitment_dispatcher::try_execute_create_commitment<AssetType, StableType, Outcome, IW>(
            &mut executable,
            account,
            witness,
            committed_coin,
            clock,
            ctx,
        );
        
        if (option::is_some(&new_commitment)) {
            transfer::public_share_object(option::extract(&mut new_commitment));
            option::destroy_none(new_commitment);
            return executable
        };
        
        // The coins have already been handled by try_execute_create_commitment
        option::destroy_none(new_commitment);
    } else {
        // If the executable is complete, the coin should already be zero
        if (coin::value(&committed_coin) == 0) {
            coin::destroy_zero(committed_coin);
        } else {
            // Return non-zero coins to sender
            transfer::public_transfer(committed_coin, tx_context::sender(ctx));
        };
    };
    
    executable
}

/// Execute commitment operations (no coin needed)
public(package) fun execute_commitment_operations<
    AssetType,
    StableType,
    Outcome: store + drop + copy,
    IW: copy + drop
>(
    mut executable: Executable<Outcome>,
    account: &mut Account<FutarchyConfig>,
    witness: IW,
    commitment: &mut futarchy::commitment_proposal::CommitmentProposal<AssetType, StableType>,
    proposal: &futarchy::proposal::Proposal<AssetType, StableType>,
    clock: &Clock,
    ctx: &mut TxContext,
): Executable<Outcome> {
    use futarchy::commitment_dispatcher;
    
    // Process commitment actions (execute, update, withdraw)
    while (executable.action_idx() < executable.intent().actions().length()) {
        // Check for execute commitment action  
        if (commitment_dispatcher::try_execute_commitment<AssetType, StableType, Outcome, IW>(
            &mut executable,
            account,
            witness,
            commitment,
            proposal,
            clock,
            ctx,
        )) {
            continue
        };
        
        // Try other commitment actions (update recipient, withdraw)
        if (commitment_dispatcher::try_execute_other_commitment_actions<AssetType, StableType, Outcome, IW>(
            &mut executable,
            account,
            witness,
            commitment,
            clock,
            ctx,
        )) {
            continue
        };
        
        break // Unknown action type
    };
    
    executable
}module futarchy::events;

use std::string::String;
use std::vector;
use sui::event;

/// Reason codes for IntentCancelled
const CANCEL_EXPIRED: u8 = 0;
const CANCEL_LOSING_OUTCOME: u8 = 1;
const CANCEL_ADMIN: u8 = 2;
const CANCEL_SUPERSEDED: u8 = 3;

/// Emitted when an intent is registered (optional, but handy for analytics)
public struct IntentCreated has copy, drop {
    key: String,
    proposal: address,
    outcome_index: u64,
    when_ms: u64
}

/// Emitted when an intent's actions are executed
public struct IntentExecuted has copy, drop {
    key: String,
    proposal: address,
    outcome_index: u64,
    when_ms: u64
}

/// Emitted when an intent is cancelled/cleaned.
/// We emit key_hash instead of key to avoid on-chain leakage.
public struct IntentCancelled has copy, drop {
    proposal: address,
    outcome_index: u64,
    key_hash: vector<u8>,
    reason: u8,
    when_ms: u64
}

public fun emit_created(key: String, proposal: address, outcome_index: u64, when_ms: u64) {
    event::emit(IntentCreated { key, proposal, outcome_index, when_ms })
}

public fun emit_executed(key: String, proposal: address, outcome_index: u64, when_ms: u64) {
    event::emit(IntentExecuted { key, proposal, outcome_index, when_ms })
}

public fun emit_cancelled(
    proposal: address,
    outcome_index: u64,
    key_hash: vector<u8>,
    reason: u8,
    when_ms: u64
) {
    event::emit(IntentCancelled { proposal, outcome_index, key_hash, reason, when_ms })
}/// Hot potato pattern for actions requiring special resources
/// 
/// This module provides a type-safe, generalizable way to request resources that can't be 
/// stored in the Account or threaded through the call chain. Actions that need
/// special resources create a ResourceRequest that MUST be fulfilled in the same transaction.
///
/// The pattern is fully abstract - any action can request any type of resource,
/// and the fulfillment is handled by action-specific functions.
module futarchy::resource_requests;

use std::string::{Self, String};
use std::type_name::{Self, TypeName};
use std::vector;
use sui::object::{Self, ID, UID};
use sui::tx_context::TxContext;
use sui::event;
use sui::dynamic_field;

// === Errors ===
const ERequestNotFulfilled: u64 = 1;
const EInvalidRequestID: u64 = 2;
const EResourceTypeMismatch: u64 = 3;
const EAlreadyFulfilled: u64 = 4;
const EInvalidContext: u64 = 5;

// === Events ===

public struct ResourceRequested has copy, drop {
    request_id: ID,
    action_type: TypeName,
    resource_count: u64,
}

public struct ResourceFulfilled has copy, drop {
    request_id: ID,
    action_type: TypeName,
}

// === Core Types ===

/// Generic hot potato for requesting resources - MUST be fulfilled in same transaction
/// The phantom type T represents the action type requesting resources
/// Has no abilities, forcing immediate consumption
public struct ResourceRequest<phantom T> {
    id: UID,
    /// Store any action-specific data needed for fulfillment
    /// Using dynamic fields allows complete flexibility
    context: UID,
}

/// Generic receipt confirming resources were provided
/// Has drop to allow easy cleanup
public struct ResourceReceipt<phantom T> has drop {
    request_id: ID,
}

// === Generic Request Creation ===

/// Create a new resource request with context
/// The phantom type T ensures type safety between request and fulfillment
public fun new_request<T>(ctx: &mut TxContext): ResourceRequest<T> {
    let id = object::new(ctx);
    let context = object::new(ctx);
    let request_id = object::uid_to_inner(&id);
    
    event::emit(ResourceRequested {
        request_id,
        action_type: type_name::get<T>(),
        resource_count: 0, // Will be determined by what's added to context
    });
    
    ResourceRequest<T> {
        id,
        context,
    }
}

/// Add context data to a request (can be called multiple times)
/// This allows actions to store any data they need for fulfillment
public fun add_context<T, V: store>(
    request: &mut ResourceRequest<T>,
    key: String,
    value: V,
) {
    dynamic_field::add(&mut request.context, key, value);
}

/// Get context data from a request
public fun get_context<T, V: store + copy>(
    request: &ResourceRequest<T>,
    key: String,
): V {
    *dynamic_field::borrow(&request.context, key)
}

/// Check if context exists
public fun has_context<T>(
    request: &ResourceRequest<T>,
    key: String,
): bool {
    dynamic_field::exists_(&request.context, key)
}

// === Generic Fulfillment ===

/// Consume a request and return a receipt
/// The actual resource provision happens in the action-specific fulfill function
public fun fulfill<T>(request: ResourceRequest<T>): ResourceReceipt<T> {
    let ResourceRequest { id, context } = request;
    let request_id = object::uid_to_inner(&id);
    
    event::emit(ResourceFulfilled {
        request_id,
        action_type: type_name::get<T>(),
    });
    
    // Clean up
    object::delete(id);
    object::delete(context);
    
    ResourceReceipt<T> {
        request_id,
    }
}

// === Getters ===

public fun request_id<T>(request: &ResourceRequest<T>): ID {
    object::uid_to_inner(&request.id)
}

public fun receipt_id<T>(receipt: &ResourceReceipt<T>): ID {
    receipt.request_id
}

/// Dispatcher for dissolution-related actions
module futarchy::dissolution_dispatcher;

// === Imports ===
use sui::clock::Clock;
use account_protocol::{
    account::Account,
    executable::{Self, Executable},
};
use futarchy::{
    futarchy_config::FutarchyConfig,
    dissolution_actions,
    version,
};

// === Public Functions ===

/// Try to execute basic dissolution actions
public(package) fun try_execute_dissolution_action<IW: drop, Outcome: store + drop + copy>(
    executable: &mut Executable<Outcome>,
    account: &mut Account<FutarchyConfig>,
    witness: IW,
    ctx: &mut TxContext,
): bool {
    if (executable::contains_action<Outcome, dissolution_actions::InitiateDissolutionAction>(executable)) {
        dissolution_actions::do_initiate_dissolution<Outcome, IW>(
            executable,
            account,
            version::current(),
            witness,
            ctx
        );
        return true
    };
    
    if (executable::contains_action<Outcome, dissolution_actions::FinalizeDissolutionAction>(executable)) {
        dissolution_actions::do_finalize_dissolution<Outcome, IW>(
            executable,
            account,
            version::current(),
            witness,
            ctx
        );
        return true
    };
    
    if (executable::contains_action<Outcome, dissolution_actions::CancelDissolutionAction>(executable)) {
        dissolution_actions::do_cancel_dissolution<Outcome, IW>(
            executable,
            account,
            version::current(),
            witness,
            ctx
        );
        return true
    };
    
    // Try to execute BatchDistributeAction
    if (executable::contains_action<Outcome, dissolution_actions::BatchDistributeAction>(executable)) {
        dissolution_actions::do_batch_distribute<Outcome, IW>(
            executable,
            account,
            version::current(),
            witness,
            ctx
        );
        return true
    };
    
    // Try to execute CalculateProRataSharesAction
    if (executable::contains_action<Outcome, dissolution_actions::CalculateProRataSharesAction>(executable)) {
        dissolution_actions::do_calculate_pro_rata_shares<Outcome, IW>(
            executable,
            account,
            version::current(),
            witness,
            ctx
        );
        return true
    };
    
    // Note: DistributeAssetsAction and CancelAllStreamsAction require specific coin types
    // They are handled in the typed execution functions
    
    false
}

/// Execute typed dissolution actions that require coins
public(package) fun try_execute_typed_dissolution_action<CoinType: drop, IW: drop, Outcome: store + drop + copy>(
    executable: &mut Executable<Outcome>,
    account: &mut Account<FutarchyConfig>,
    witness: IW,
    clock: &Clock,
    ctx: &mut TxContext,
): bool {
    // Note: DistributeAssetsAction requires coins but we can't withdraw mid-execution
    // The frontend should:
    // 1. Create a vault SpendAction first to withdraw the distribution amount
    // 2. Create the DistributeAssetsAction 
    // 3. Use a different entry function that can pass coins between actions
    // For now, this is not implemented here
    
    // Try to execute CancelAllStreamsAction (no type parameter on the action)
    if (executable::contains_action<Outcome, dissolution_actions::CancelAllStreamsAction>(executable)) {
        // This action cancels streams and refunds coins
        dissolution_actions::do_cancel_all_streams<Outcome, CoinType, IW>(
            executable,
            account,
            version::current(),
            witness,
            clock,
            ctx
        );
        return true
    };
    
    false
}

/// Try to execute typed dissolution actions requiring both AssetType and StableType
public(package) fun try_execute_typed_dissolution_action_dual<AssetType, StableType, IW: drop, Outcome: store + drop + copy>(
    executable: &mut Executable<Outcome>,
    account: &mut Account<FutarchyConfig>,
    witness: IW,
    ctx: &mut TxContext
): bool {
    // Try to execute WithdrawAmmLiquidityAction
    if (executable::contains_action<Outcome, dissolution_actions::WithdrawAmmLiquidityAction<AssetType, StableType>>(executable)) {
        dissolution_actions::do_withdraw_amm_liquidity<Outcome, AssetType, StableType, IW>(
            executable,
            account,
            version::current(),
            witness,
            ctx
        );
        return true
    };
    
    false
}/// Dissolution-related actions for futarchy DAOs
/// This module defines action structs and execution logic for DAO dissolution
module futarchy::dissolution_actions;

// === Imports ===
use std::string::String;
use sui::{
    coin::{Self, Coin},
    balance::{Self, Balance},
    object::ID,
    transfer,
    clock::Clock,
    tx_context::TxContext,
};
use account_protocol::{
    account::{Self, Account},
    executable::Executable,
    intents::Expired,
    version_witness::VersionWitness,
};
use futarchy::{
    futarchy_config::{Self, FutarchyConfig},
    futarchy_vault,
    stream_actions,
};

// === Errors ===
const EInvalidRatio: u64 = 1;
const EInvalidRecipient: u64 = 2;
const EEmptyAssetList: u64 = 3;
const EInvalidThreshold: u64 = 4;
const EDissolutionNotActive: u64 = 5;
const ENotDissolving: u64 = 6;
const EInvalidAmount: u64 = 7;

// === Action Structs ===

/// Action to initiate DAO dissolution
public struct InitiateDissolutionAction has store {
    reason: String,
    distribution_method: u8, // 0: pro-rata, 1: equal, 2: custom
    burn_unsold_tokens: bool,
    final_operations_deadline: u64,
}


/// Action to batch distribute multiple assets
public struct BatchDistributeAction has store {
    asset_types: vector<String>, // Type names of assets to distribute
}

/// Action to finalize dissolution and destroy the DAO
public struct FinalizeDissolutionAction has store {
    final_recipient: address, // For any remaining dust
    destroy_account: bool,
}

/// Action to cancel dissolution (if allowed)
public struct CancelDissolutionAction has store {
    reason: String,
}

/// Action to calculate pro rata shares for distribution
public struct CalculateProRataSharesAction has store {
    /// Total supply of asset tokens (excluding DAO-owned)
    total_supply: u64,
    /// Whether to exclude DAO treasury tokens
    exclude_dao_tokens: bool,
}

/// Action to cancel all active streams
public struct CancelAllStreamsAction has store {
    /// Whether to return stream balances to treasury
    return_to_treasury: bool,
}

/// Action to withdraw all AMM liquidity
public struct WithdrawAmmLiquidityAction<phantom AssetType, phantom StableType> has store {
    /// Pool ID to withdraw from
    pool_id: ID,
    /// Whether to burn LP tokens after withdrawal
    burn_lp_tokens: bool,
}

/// Action to distribute all treasury assets pro rata
public struct DistributeAssetsAction<phantom CoinType> has store {
    /// Holders who will receive distributions (address -> token amount held)
    holders: vector<address>,
    /// Amount of tokens each holder has
    holder_amounts: vector<u64>,
    /// Total amount to distribute
    total_distribution_amount: u64,
}

// === Execution Functions ===

/// Execute an initiate dissolution action
public fun do_initiate_dissolution<Outcome: store, IW: drop>(
    executable: &mut Executable<Outcome>,
    account: &mut Account<FutarchyConfig>,
    version: VersionWitness,
    intent_witness: IW,
    _ctx: &mut TxContext,
) {
    let action: &InitiateDissolutionAction = executable.next_action(intent_witness);
    
    // Extract parameters from action
    let reason = &action.reason;
    let distribution_method = action.distribution_method;
    let burn_unsold_tokens = action.burn_unsold_tokens;
    let deadline = action.final_operations_deadline;
    
    // Get the config and set dissolution state
    let config = futarchy_config::internal_config_mut(account);
    
    // 1. Set dissolution state in config (operational_state = DISSOLVING)
    futarchy_config::set_operational_state(config, futarchy_config::state_dissolving());
    
    // 2. Pause all normal operations by disabling proposals
    futarchy_config::set_proposals_enabled_internal(config, false);
    
    // 3. Record dissolution parameters in config metadata
    // Store the dissolution parameters for later use
    // Note: In a real implementation, we'd store these in a DissolutionState struct
    // For now, we just validate them
    assert!(reason.length() > 0, EInvalidRatio);
    assert!(distribution_method <= 2, EInvalidRatio);
    assert!(deadline > 0, EInvalidThreshold);
    
    // 4. Begin asset tallying process is handled by subsequent actions
    let _ = burn_unsold_tokens;
    let _ = version;
}

/// Execute a distribute asset action

/// Execute a batch distribute action
public fun do_batch_distribute<Outcome: store, IW: drop>(
    executable: &mut Executable<Outcome>,
    account: &mut Account<FutarchyConfig>,
    version: VersionWitness,
    intent_witness: IW,
    ctx: &mut TxContext,
) {
    let action: &BatchDistributeAction = executable.next_action(intent_witness);
    
    // Extract parameters
    let asset_types = &action.asset_types;
    
    // Verify dissolution is active
    let config = account::config(account);
    assert!(
        futarchy_config::operational_state(config) == futarchy_config::state_dissolving(),
        EDissolutionNotActive
    );
    
    // Note: This action serves as a coordinator for multiple distribute actions
    // The actual typed DistributeAssetsAction<CoinType> actions would need to be
    // added to the executable for each specific coin type.
    // This is because Move doesn't support runtime type information.
    // 
    // In practice, when creating the dissolution intent, you would:
    // 1. Add this BatchDistributeAction to mark the batch operation
    // 2. Add individual DistributeAssetsAction<CoinType> for each asset type
    // 3. The executor would process them in sequence
    
    // For now, just validate that we have asset types to distribute
    assert!(asset_types.length() > 0, EEmptyAssetList);
    
    let _ = version;
    let _ = ctx;
}

/// Execute a finalize dissolution action
public fun do_finalize_dissolution<Outcome: store, IW: drop>(
    executable: &mut Executable<Outcome>,
    account: &mut Account<FutarchyConfig>,
    version: VersionWitness,
    intent_witness: IW,
    _ctx: &mut TxContext,
) {
    let action: &FinalizeDissolutionAction = executable.next_action(intent_witness);
    
    // Extract parameters
    let final_recipient = action.final_recipient;
    let destroy_account = action.destroy_account;
    
    // Verify dissolution is active
    let config = futarchy_config::internal_config_mut(account);
    assert!(
        futarchy_config::operational_state(config) == futarchy_config::state_dissolving(),
        EDissolutionNotActive  
    );
    
    // 1. Verify all assets have been distributed
    // In a real implementation, we'd check that all vaults are empty or minimal
    // For now, we just validate the recipient
    assert!(final_recipient != @0x0, EInvalidRecipient);
    
    // 2. Send any remaining dust to final_recipient
    // This would require checking all vault balances and transferring remainders
    // Implementation would iterate through all coin types in vaults
    
    // 3. Mark DAO as fully dissolved
    // Set the operational state to a final "dissolved" state
    // For now, we'll keep it in DISSOLVING state since we don't have a DISSOLVED constant
    // In a real implementation, you'd add a DISSOLVED state constant
    
    // 4. Destroy account if specified
    if (destroy_account) {
        // Account destruction would need special handling
        // For now, we just mark it as inactive
        futarchy_config::set_operational_state(config, futarchy_config::state_paused());
    };
    
    let _ = version;
}

/// Execute a cancel dissolution action
public fun do_cancel_dissolution<Outcome: store, IW: drop>(
    executable: &mut Executable<Outcome>,
    account: &mut Account<FutarchyConfig>,
    version: VersionWitness,
    intent_witness: IW,
    _ctx: &mut TxContext,
) {
    let action: &CancelDissolutionAction = executable.next_action(intent_witness);
    
    // Extract parameters
    let reason = &action.reason;
    
    // Get the config
    let config = futarchy_config::internal_config_mut(account);
    
    // 1. Verify dissolution can be cancelled (must be in dissolving state)
    assert!(
        futarchy_config::operational_state(config) == futarchy_config::state_dissolving(),
        ENotDissolving
    );
    
    // Validate cancellation reason
    assert!(reason.length() > 0, EInvalidRatio);
    
    // 2. Revert operational state to ACTIVE
    futarchy_config::set_operational_state(config, futarchy_config::state_active());
    
    // 3. Resume normal operations by re-enabling proposals
    futarchy_config::set_proposals_enabled_internal(config, true);
    
    // 4. Return any collected assets to vault
    // In a real implementation, this would involve:
    // - Checking if any assets were moved to a dissolution pool
    // - Moving them back to the main vault
    // - Restoring any paused streams or recurring payments
    
    let _ = version;
}

/// Execute calculate pro rata shares action
public fun do_calculate_pro_rata_shares<Outcome: store, IW: drop>(
    executable: &mut Executable<Outcome>,
    account: &mut Account<FutarchyConfig>,
    version: VersionWitness,
    intent_witness: IW,
    _ctx: &mut TxContext,
) {
    let action: &CalculateProRataSharesAction = executable.next_action(intent_witness);
    
    // Extract parameters
    let total_supply = action.total_supply;
    let exclude_dao_tokens = action.exclude_dao_tokens;
    
    // Verify dissolution is active
    let config = account::config(account);
    assert!(
        futarchy_config::operational_state(config) == futarchy_config::state_dissolving(),
        EDissolutionNotActive
    );
    
    // Calculate pro rata distribution
    // In a real implementation, this would:
    // 1. Get total supply of asset tokens
    // 2. If exclude_dao_tokens, subtract DAO-owned tokens from total
    // 3. Calculate each holder's percentage of the adjusted total
    // 4. Store these percentages for use in distribution actions
    
    assert!(total_supply > 0, EInvalidRatio);
    
    // The actual calculation would be done when creating DistributeAssetsAction
    // This action mainly validates and prepares for distribution
    
    let _ = exclude_dao_tokens;
    let _ = version;
}

/// Execute cancel all streams action
public fun do_cancel_all_streams<Outcome: store, CoinType, IW: drop>(
    executable: &mut Executable<Outcome>,
    account: &mut Account<FutarchyConfig>,
    version: VersionWitness,
    intent_witness: IW,
    clock: &Clock,
    ctx: &mut TxContext,
) {
    let action: &CancelAllStreamsAction = executable.next_action(intent_witness);
    
    // Extract parameters
    let return_to_treasury = action.return_to_treasury;
    
    // Verify dissolution is active
    let config = account::config(account);
    assert!(
        futarchy_config::operational_state(config) == futarchy_config::state_dissolving(),
        EDissolutionNotActive
    );
    
    // Get all payment IDs that need to be cancelled
    let payment_ids = stream_actions::get_all_payment_ids(account);
    
    // Cancel all payments and return funds to treasury
    if (return_to_treasury) {
        // This function handles:
        // 1. Cancelling all cancellable streams
        // 2. Returning isolated pool funds to treasury
        // 3. Cancelling pending budget withdrawals
        stream_actions::cancel_all_payments_for_dissolution<CoinType>(
            account,
            clock,
            ctx
        );
    };
    
    // Note: In production, you would:
    // 1. Get list of payment IDs from stream_actions
    // 2. Create individual CancelPaymentAction for each
    // 3. Process them to properly handle coin returns
    // This simplified version provides the integration point
    
    let _ = payment_ids;
    let _ = version;
}

/// Execute withdraw AMM liquidity action
public fun do_withdraw_amm_liquidity<Outcome: store, AssetType, StableType, IW: drop>(
    executable: &mut Executable<Outcome>,
    account: &mut Account<FutarchyConfig>,
    version: VersionWitness,
    intent_witness: IW,
    ctx: &mut TxContext,
) {
    let action: &WithdrawAmmLiquidityAction<AssetType, StableType> = executable.next_action(intent_witness);
    
    // Extract parameters
    let pool_id = action.pool_id;
    let burn_lp_tokens = action.burn_lp_tokens;
    
    // Verify dissolution is active
    let config = account::config(account);
    assert!(
        futarchy_config::operational_state(config) == futarchy_config::state_dissolving(),
        EDissolutionNotActive
    );
    
    // Withdraw all liquidity from AMM
    // In a real implementation, this would:
    // 1. Get reference to the AccountSpotPool using pool_id
    // 2. Remove all liquidity using remove_liquidity function
    // 3. Receive back asset and stable tokens
    // 4. Store these tokens in vault for distribution
    // 5. Optionally burn the LP tokens
    
    // Since the AccountSpotPool operations require specific access patterns,
    // the actual implementation would coordinate with the pool module
    
    let _ = pool_id;
    let _ = burn_lp_tokens;
    let _ = version;
    let _ = ctx;
}

/// Execute distribute assets action
/// 
/// ⚠️ REQUIRES SPECIAL HANDLING:
/// This function now properly requires and uses coins for actual distribution, but needs frontend to:
///   1. Create vault SpendAction to withdraw coins
///   2. Pass coins to this action  
///   3. This is architecturally challenging in current system
/// 
/// The coins must be provided as a parameter, which means the frontend needs to structure
/// the transaction to first withdraw from vault, then call this with the resulting coins.
public fun do_distribute_assets<Outcome: store, CoinType, IW: drop>(
    executable: &mut Executable<Outcome>,
    account: &mut Account<FutarchyConfig>,
    version: VersionWitness,
    intent_witness: IW,
    mut distribution_coin: Coin<CoinType>,
    ctx: &mut TxContext,
) {
    let action: &DistributeAssetsAction<CoinType> = executable.next_action(intent_witness);
    
    // Extract parameters
    let holders = &action.holders;
    let holder_amounts = &action.holder_amounts;
    let total_distribution_amount = action.total_distribution_amount;
    
    // Verify dissolution is active
    let config = account::config(account);
    assert!(
        futarchy_config::operational_state(config) == futarchy_config::state_dissolving(),
        EDissolutionNotActive
    );
    
    // Validate inputs
    assert!(holders.length() > 0, EEmptyAssetList);
    assert!(holders.length() == holder_amounts.length(), EInvalidRatio);
    assert!(coin::value(&distribution_coin) >= total_distribution_amount, EInvalidAmount);
    
    // Calculate total tokens held (for pro rata calculation)
    let mut total_held = 0u64;
    let mut i = 0;
    while (i < holder_amounts.length()) {
        total_held = total_held + *holder_amounts.borrow(i);
        i = i + 1;
    };
    assert!(total_held > 0, EInvalidRatio);
    
    // Distribute assets pro rata to each holder
    let mut j = 0;
    let mut total_distributed = 0u64;
    while (j < holders.length()) {
        let holder = *holders.borrow(j);
        let holder_amount = *holder_amounts.borrow(j);
        
        // Calculate pro rata share
        let share = (holder_amount as u128) * (total_distribution_amount as u128) / (total_held as u128);
        let mut share_amount = (share as u64);
        
        // Last recipient gets the remainder to handle rounding
        if (j == holders.length() - 1) {
            share_amount = total_distribution_amount - total_distributed;
        };
        
        // Validate recipient
        assert!(holder != @0x0, EInvalidRecipient);
        
        // Transfer the calculated share to the holder
        if (share_amount > 0) {
            transfer::public_transfer(coin::split(&mut distribution_coin, share_amount, ctx), holder);
            total_distributed = total_distributed + share_amount;
        };
        
        j = j + 1;
    };
    
    // Return any remainder back to sender or destroy if zero
    if (coin::value(&distribution_coin) > 0) {
        transfer::public_transfer(distribution_coin, ctx.sender());
    } else {
        distribution_coin.destroy_zero();
    };
    
    let _ = version;
    let _ = ctx;
}

// === Cleanup Functions ===

/// Delete an initiate dissolution action from an expired intent
public fun delete_initiate_dissolution(expired: &mut Expired) {
    let InitiateDissolutionAction {
        reason: _,
        distribution_method: _,
        burn_unsold_tokens: _,
        final_operations_deadline: _,
    } = expired.remove_action();
}


/// Delete a batch distribute action from an expired intent
public fun delete_batch_distribute(expired: &mut Expired) {
    let BatchDistributeAction {
        asset_types: _,
    } = expired.remove_action();
}

/// Delete a finalize dissolution action from an expired intent
public fun delete_finalize_dissolution(expired: &mut Expired) {
    let FinalizeDissolutionAction {
        final_recipient: _,
        destroy_account: _,
    } = expired.remove_action();
}

/// Delete a cancel dissolution action from an expired intent
public fun delete_cancel_dissolution(expired: &mut Expired) {
    let CancelDissolutionAction {
        reason: _,
    } = expired.remove_action();
}

/// Delete a calculate pro rata shares action from an expired intent
public fun delete_calculate_pro_rata_shares(expired: &mut Expired) {
    let CalculateProRataSharesAction {
        total_supply: _,
        exclude_dao_tokens: _,
    } = expired.remove_action();
}

/// Delete a cancel all streams action from an expired intent
public fun delete_cancel_all_streams(expired: &mut Expired) {
    let CancelAllStreamsAction {
        return_to_treasury: _,
    } = expired.remove_action();
}

/// Delete a withdraw AMM liquidity action from an expired intent
public fun delete_withdraw_amm_liquidity<AssetType, StableType>(expired: &mut Expired) {
    let WithdrawAmmLiquidityAction<AssetType, StableType> {
        pool_id: _,
        burn_lp_tokens: _,
    } = expired.remove_action();
}

/// Delete a distribute assets action from an expired intent
public fun delete_distribute_assets<CoinType>(expired: &mut Expired) {
    let DistributeAssetsAction<CoinType> {
        holders: _,
        holder_amounts: _,
        total_distribution_amount: _,
    } = expired.remove_action();
}

// === Helper Functions ===

/// Create a new initiate dissolution action
public fun new_initiate_dissolution_action(
    reason: String,
    distribution_method: u8,
    burn_unsold_tokens: bool,
    final_operations_deadline: u64,
): InitiateDissolutionAction {
    assert!(distribution_method <= 2, EInvalidRatio); // 0, 1, or 2
    assert!(reason.length() > 0, EInvalidRatio);
    
    InitiateDissolutionAction {
        reason,
        distribution_method,
        burn_unsold_tokens,
        final_operations_deadline,
    }
}


/// Create a new batch distribute action
public fun new_batch_distribute_action(
    asset_types: vector<String>,
): BatchDistributeAction {
    assert!(asset_types.length() > 0, EEmptyAssetList);
    
    BatchDistributeAction {
        asset_types,
    }
}

/// Create a new finalize dissolution action
public fun new_finalize_dissolution_action(
    final_recipient: address,
    destroy_account: bool,
): FinalizeDissolutionAction {
    assert!(final_recipient != @0x0, EInvalidRecipient);
    
    FinalizeDissolutionAction {
        final_recipient,
        destroy_account,
    }
}

/// Create a new cancel dissolution action
public fun new_cancel_dissolution_action(
    reason: String,
): CancelDissolutionAction {
    assert!(reason.length() > 0, EInvalidRatio);
    
    CancelDissolutionAction {
        reason,
    }
}

// === Getter Functions ===

/// Get reason from InitiateDissolutionAction
public fun get_reason(action: &InitiateDissolutionAction): &String {
    &action.reason
}

/// Get distribution method from InitiateDissolutionAction
public fun get_distribution_method(action: &InitiateDissolutionAction): u8 {
    action.distribution_method
}

/// Get burn unsold tokens flag from InitiateDissolutionAction
public fun get_burn_unsold_tokens(action: &InitiateDissolutionAction): bool {
    action.burn_unsold_tokens
}

/// Get final operations deadline from InitiateDissolutionAction
public fun get_final_operations_deadline(action: &InitiateDissolutionAction): u64 {
    action.final_operations_deadline
}


/// Get asset types from BatchDistributeAction
public fun get_asset_types(action: &BatchDistributeAction): &vector<String> {
    &action.asset_types
}

/// Get final recipient from FinalizeDissolutionAction
public fun get_final_recipient(action: &FinalizeDissolutionAction): address {
    action.final_recipient
}

/// Get destroy account flag from FinalizeDissolutionAction
public fun get_destroy_account(action: &FinalizeDissolutionAction): bool {
    action.destroy_account
}

/// Get cancel reason from CancelDissolutionAction
public fun get_cancel_reason(action: &CancelDissolutionAction): &String {
    &action.reason
}

/// Create a new calculate pro rata shares action
public fun new_calculate_pro_rata_shares_action(
    total_supply: u64,
    exclude_dao_tokens: bool,
): CalculateProRataSharesAction {
    assert!(total_supply > 0, EInvalidRatio);
    
    CalculateProRataSharesAction {
        total_supply,
        exclude_dao_tokens,
    }
}

/// Create a new cancel all streams action
public fun new_cancel_all_streams_action(
    return_to_treasury: bool,
): CancelAllStreamsAction {
    CancelAllStreamsAction {
        return_to_treasury,
    }
}

/// Create a new withdraw AMM liquidity action
public fun new_withdraw_amm_liquidity_action<AssetType, StableType>(
    pool_id: ID,
    burn_lp_tokens: bool,
): WithdrawAmmLiquidityAction<AssetType, StableType> {
    WithdrawAmmLiquidityAction {
        pool_id,
        burn_lp_tokens,
    }
}

/// Create a new distribute assets action
public fun new_distribute_assets_action<CoinType>(
    holders: vector<address>,
    holder_amounts: vector<u64>,
    total_distribution_amount: u64,
): DistributeAssetsAction<CoinType> {
    assert!(holders.length() > 0, EEmptyAssetList);
    assert!(holders.length() == holder_amounts.length(), EInvalidRatio);
    assert!(total_distribution_amount > 0, EInvalidRatio);
    
    // Verify holder amounts sum is positive
    let mut sum = 0u64;
    let mut i = 0;
    while (i < holder_amounts.length()) {
        sum = sum + *holder_amounts.borrow(i);
        i = i + 1;
    };
    assert!(sum > 0, EInvalidRatio);
    
    DistributeAssetsAction {
        holders,
        holder_amounts,
        total_distribution_amount,
    }
}/// User-facing API for creating dissolution-related intents
/// This module provides helper functions for creating dissolution actions
/// The actual intent creation must be done by the governance system that provides the Outcome
module futarchy::dissolution_intents;

// === Imports ===
use std::string::String;
use sui::clock::Clock;
use account_protocol::{
    intents::{Self, Intent},
    metadata,
};
use futarchy::dissolution_actions;

// === Witness ===

/// Witness type for dissolution intents
public struct DissolutionIntent has drop, store {}

/// Create a DissolutionIntent witness
public fun witness(): DissolutionIntent {
    DissolutionIntent {}
}

// === Helper Functions ===

/// Add an initiate dissolution action to an existing intent
public fun initiate_dissolution_in_intent<Outcome: store, IW: drop>(
    intent: &mut Intent<Outcome>,
    reason: String,
    distribution_method: u8,
    burn_unsold_tokens: bool,
    final_operations_deadline: u64,
    intent_witness: IW,
) {
    let action = dissolution_actions::new_initiate_dissolution_action(
        reason,
        distribution_method,
        burn_unsold_tokens,
        final_operations_deadline,
    );
    intent.add_action(action, intent_witness);
}


/// Add a batch distribute action to an existing intent
public fun batch_distribute_in_intent<Outcome: store, IW: drop>(
    intent: &mut Intent<Outcome>,
    asset_types: vector<String>,
    intent_witness: IW,
) {
    let action = dissolution_actions::new_batch_distribute_action(asset_types);
    intent.add_action(action, intent_witness);
}

/// Add a finalize dissolution action to an existing intent
public fun finalize_dissolution_in_intent<Outcome: store, IW: drop>(
    intent: &mut Intent<Outcome>,
    final_recipient: address,
    destroy_account: bool,
    intent_witness: IW,
) {
    let action = dissolution_actions::new_finalize_dissolution_action(
        final_recipient,
        destroy_account,
    );
    intent.add_action(action, intent_witness);
}

/// Add a cancel dissolution action to an existing intent
public fun cancel_dissolution_in_intent<Outcome: store, IW: drop>(
    intent: &mut Intent<Outcome>,
    reason: String,
    intent_witness: IW,
) {
    let action = dissolution_actions::new_cancel_dissolution_action(reason);
    intent.add_action(action, intent_witness);
}

/// Create a unique key for a dissolution intent
public fun create_dissolution_key(
    operation: String,
    clock: &Clock,
): String {
    let mut key = b"dissolution_".to_string();
    key.append(operation);
    key.append(b"_".to_string());
    key.append(clock.timestamp_ms().to_string());
    key
}

/// Helper to create a pro-rata distribution plan
public fun create_prorata_distribution<CoinType>(
    total_amount: u64,
    holders: vector<address>,
    balances: vector<u64>,
): (vector<address>, vector<u64>) {
    let mut recipients = vector::empty();
    let mut amounts = vector::empty();
    
    // Calculate total balance
    let mut total_balance = 0;
    let mut i = 0;
    while (i < balances.length()) {
        total_balance = total_balance + *balances.borrow(i);
        i = i + 1;
    };
    
    // Calculate pro-rata amounts
    if (total_balance > 0) {
        i = 0;
        while (i < holders.length()) {
            let holder = *holders.borrow(i);
            let balance = *balances.borrow(i);
            let amount = (total_amount * balance) / total_balance;
            
            if (amount > 0) {
                recipients.push_back(holder);
                amounts.push_back(amount);
            };
            
            i = i + 1;
        };
    };
    
    (recipients, amounts)
}

/// Helper to create an equal distribution plan
public fun create_equal_distribution(
    total_amount: u64,
    recipients: vector<address>,
): vector<u64> {
    let count = recipients.length();
    let amount_per_recipient = total_amount / count;
    
    let mut amounts = vector::empty();
    let mut i = 0;
    while (i < count) {
        amounts.push_back(amount_per_recipient);
        i = i + 1;
    };
    
    amounts
}/// Dispatcher for configuration-related actions
module futarchy::config_dispatcher;

// === Imports ===
use sui::clock::Clock;
use account_protocol::{
    account::Account,
    executable::{Self, Executable},
};
use futarchy::{
    futarchy_config::FutarchyConfig,
    config_actions,
    version,
};

// === Public Functions ===

/// Try to execute configuration actions
public(package) fun try_execute_config_action<IW: drop, Outcome: store + drop + copy>(
    executable: &mut Executable<Outcome>,
    account: &mut Account<FutarchyConfig>,
    witness: IW,
    clock: &Clock,
    ctx: &mut TxContext,
): bool {
    // Check for basic config actions
    if (executable::contains_action<Outcome, config_actions::SetProposalsEnabledAction>(executable)) {
        config_actions::do_set_proposals_enabled<Outcome, IW>(
            executable,
            account,
            version::current(),
            witness,
            clock,
            ctx
        );
        return true
    };
    
    if (executable::contains_action<Outcome, config_actions::UpdateNameAction>(executable)) {
        config_actions::do_update_name<Outcome, IW>(
            executable,
            account,
            version::current(),
            witness,
            clock,
            ctx
        );
        return true
    };
    
    // Check for advanced config actions
    if (executable::contains_action<Outcome, config_actions::TradingParamsUpdateAction>(executable)) {
        config_actions::do_update_trading_params<Outcome, IW>(
            executable,
            account,
            version::current(),
            witness,
            clock,
            ctx
        );
        return true
    };
    
    if (executable::contains_action<Outcome, config_actions::MetadataUpdateAction>(executable)) {
        config_actions::do_update_metadata<Outcome, IW>(
            executable,
            account,
            version::current(),
            witness,
            clock,
            ctx
        );
        return true
    };
    
    if (executable::contains_action<Outcome, config_actions::TwapConfigUpdateAction>(executable)) {
        config_actions::do_update_twap_config<Outcome, IW>(
            executable,
            account,
            version::current(),
            witness,
            clock,
            ctx
        );
        return true
    };
    
    if (executable::contains_action<Outcome, config_actions::GovernanceUpdateAction>(executable)) {
        config_actions::do_update_governance<Outcome, IW>(
            executable,
            account,
            version::current(),
            witness,
            clock,
            ctx
        );
        return true
    };
    
    if (executable::contains_action<Outcome, config_actions::MetadataTableUpdateAction>(executable)) {
        config_actions::do_update_metadata_table<Outcome, IW>(
            executable,
            account,
            version::current(),
            witness,
            clock,
            ctx
        );
        return true
    };
    
    if (executable::contains_action<Outcome, config_actions::QueueParamsUpdateAction>(executable)) {
        config_actions::do_update_queue_params<Outcome, IW>(
            executable,
            account,
            version::current(),
            witness,
            clock,
            ctx
        );
        return true
    };
    
    if (executable::contains_action<Outcome, config_actions::SlashDistributionUpdateAction>(executable)) {
        config_actions::do_update_slash_distribution<Outcome, IW>(
            executable,
            account,
            version::current(),
            witness,
            clock,
            ctx
        );
        return true
    };
    
    // Try to execute ConfigAction (batch wrapper)
    if (executable::contains_action<Outcome, config_actions::ConfigAction>(executable)) {
        config_actions::do_batch_config<Outcome, IW>(
            executable,
            account,
            version::current(),
            witness,
            clock,
            ctx
        );
        return true
    };
    
    false
}/// Consolidated config intent creation module
/// Combines basic and advanced configuration intent creation
module futarchy::config_intents;

// === Imports ===
use std::{
    string::String,
    ascii::String as AsciiString,
    option,
};
use sui::{
    clock::Clock,
    url::Url,
};
use account_protocol::{
    account::Account,
    executable::Executable,
    intents::{Intent, Params},
    intent_interface,
};
use futarchy::{
    config_actions,
    futarchy_config::{FutarchyConfig, FutarchyOutcome},
    version,
};

// === Aliases ===
use fun intent_interface::build_intent as Account.build_intent;
use fun intent_interface::process_intent as Account.process_intent;

// === Single Witness ===
public struct ConfigIntent has copy, drop {}

// === Basic Intent Creation Functions ===

/// Create intent to enable/disable proposals
public fun create_set_proposals_enabled_intent<Outcome: store + drop + copy>(
    account: &mut Account<FutarchyConfig>,
    params: Params,
    outcome: Outcome,
    enabled: bool,
    ctx: &mut TxContext
) {
    // Use standard DAO settings for intent params (expiry, etc.)
    account.build_intent!(
        params,
        outcome,
        b"config_set_proposals_enabled".to_string(),
        version::current(),
        ConfigIntent {},
        ctx,
        |intent, iw| {
            let action = config_actions::new_set_proposals_enabled_action(enabled);
            intent.add_action(action, iw);
        }
    );
}

/// Create intent to update DAO name
public fun create_update_name_intent<Outcome: store + drop + copy>(
    account: &mut Account<FutarchyConfig>,
    params: Params,
    outcome: Outcome,
    new_name: String,
    ctx: &mut TxContext
) {
    account.build_intent!(
        params,
        outcome,
        b"config_update_name".to_string(),
        version::current(),
        ConfigIntent {},
        ctx,
        |intent, iw| {
            let action = config_actions::new_update_name_action(new_name);
            intent.add_action(action, iw);
        }
    );
}

// === Advanced Intent Creation Functions ===

/// Create intent to update DAO metadata
public fun create_update_metadata_intent<Outcome: store + drop + copy>(
    account: &mut Account<FutarchyConfig>,
    params: Params,
    outcome: Outcome,
    name: AsciiString,
    icon_url: Url,
    description: String,
    ctx: &mut TxContext
) {
    account.build_intent!(
        params,
        outcome,
        b"config_update_metadata".to_string(),
        version::current(),
        ConfigIntent {},
        ctx,
        |intent, iw| {
            let action = config_actions::new_metadata_update_action(
                option::some(name),
                option::some(icon_url),
                option::some(description)
            );
            intent.add_action(action, iw);
        }
    );
}

/// Create intent to update trading parameters
public fun create_update_trading_params_intent<Outcome: store + drop + copy>(
    account: &mut Account<FutarchyConfig>,
    params: Params,
    outcome: Outcome,
    review_period_ms: u64,
    trading_period_ms: u64,
    min_asset_amount: u64,
    min_stable_amount: u64,
    ctx: &mut TxContext
) {
    account.build_intent!(
        params,
        outcome,
        b"config_update_trading_params".to_string(),
        version::current(),
        ConfigIntent {},
        ctx,
        |intent, iw| {
            let action = config_actions::new_trading_params_update_action(
                option::some(min_asset_amount),
                option::some(min_stable_amount),
                option::some(review_period_ms),
                option::some(trading_period_ms),
                option::none() // amm_total_fee_bps
            );
            intent.add_action(action, iw);
        }
    );
}

/// Create intent to update TWAP configuration
public fun create_update_twap_config_intent<Outcome: store + drop + copy>(
    account: &mut Account<FutarchyConfig>,
    params: Params,
    outcome: Outcome,
    start_delay: u64,
    step_max: u64,
    initial_observation: u128,
    threshold: u64,
    ctx: &mut TxContext
) {
    account.build_intent!(
        params,
        outcome,
        b"config_update_twap".to_string(),
        version::current(),
        ConfigIntent {},
        ctx,
        |intent, iw| {
            let action = config_actions::new_twap_config_update_action(
                option::some(start_delay),
                option::some(step_max),
                option::some(initial_observation),
                option::some(threshold)
            );
            intent.add_action(action, iw);
        }
    );
}

/// Create intent to update governance settings
public fun create_update_governance_intent<Outcome: store + drop + copy>(
    account: &mut Account<FutarchyConfig>,
    params: Params,
    outcome: Outcome,
    proposals_enabled: bool,
    max_outcomes: u64,
    required_bond_amount: u64,
    ctx: &mut TxContext
) {
    account.build_intent!(
        params,
        outcome,
        b"config_update_governance".to_string(),
        version::current(),
        ConfigIntent {},
        ctx,
        |intent, iw| {
            let action = config_actions::new_governance_update_action(
                option::some(proposals_enabled),
                option::some(max_outcomes),
                option::some(required_bond_amount),
                option::none(), // max_intents_per_outcome - not specified
                option::none(), // proposal_intent_expiry_ms - not specified
                option::none(), // optimistic_challenge_fee - not specified
                option::none()  // optimistic_challenge_period_ms - not specified
            );
            intent.add_action(action, iw);
        }
    );
}

/// Create intent to update slash distribution
public fun create_update_slash_distribution_intent<Outcome: store + drop + copy>(
    account: &mut Account<FutarchyConfig>,
    params: Params,
    outcome: Outcome,
    slasher_reward_bps: u16,
    dao_treasury_bps: u16,
    protocol_bps: u16,
    burn_bps: u16,
    ctx: &mut TxContext
) {
    account.build_intent!(
        params,
        outcome,
        b"config_update_slash_distribution".to_string(),
        version::current(),
        ConfigIntent {},
        ctx,
        |intent, iw| {
            let action = config_actions::new_slash_distribution_update_action(
                slasher_reward_bps,
                dao_treasury_bps,
                protocol_bps,
                burn_bps
            );
            intent.add_action(action, iw);
        }
    );
}

/// Create intent to update queue parameters
public fun create_update_queue_params_intent<Outcome: store + drop + copy>(
    account: &mut Account<FutarchyConfig>,
    params: Params,
    outcome: Outcome,
    max_proposer_funded: u64,
    max_concurrent_proposals: u64,
    fee_escalation_basis_points: u64,
    ctx: &mut TxContext
) {
    account.build_intent!(
        params,
        outcome,
        b"config_update_queue_params".to_string(),
        version::current(),
        ConfigIntent {},
        ctx,
        |intent, iw| {
            let action = config_actions::new_queue_params_update_action(
                option::some(max_proposer_funded),
                option::some(max_concurrent_proposals),
                option::none(), // max_queue_size - not specified
                option::some(fee_escalation_basis_points)
            );
            intent.add_action(action, iw);
        }
    );
}

// === Backward compatibility aliases ===

/// Alias for TWAP params intent (backward compatibility)
public fun create_update_twap_params_intent<Outcome: store + drop + copy>(
    account: &mut Account<FutarchyConfig>,
    params: Params,
    outcome: Outcome,
    twap_start_delay: u64,
    twap_step_max: u64,
    twap_initial_observation: u128,
    twap_threshold: u64,
    ctx: &mut TxContext
) {
    create_update_twap_config_intent(
        account,
        params,
        outcome,
        twap_start_delay,
        twap_step_max,
        twap_initial_observation,
        twap_threshold,
        ctx
    );
}

/// Alias for fee params intent (backward compatibility)
public fun create_update_fee_params_intent<Outcome: store + drop + copy>(
    account: &mut Account<FutarchyConfig>,
    params: Params,
    outcome: Outcome,
    max_proposer_funded: u64,
    max_concurrent_proposals: u64,
    fee_escalation_basis_points: u64,
    ctx: &mut TxContext
) {
    create_update_queue_params_intent(
        account,
        params,
        outcome,
        max_proposer_funded,
        max_concurrent_proposals,
        fee_escalation_basis_points,
        ctx
    );
}

// === Intent Processing ===
// Note: Processing of config intents is handled by the action_dispatcher module
// which executes all actions in the executable. The process_intent! macro is not
// used here because it doesn't support passing additional parameters (account, clock, ctx)
// that are needed by the action execution functions./// Consolidated configuration actions for futarchy DAOs
/// This module combines basic and advanced configuration actions and their execution logic
module futarchy::config_actions;

// === Imports ===
use std::{
    string::String,
    ascii::String as AsciiString,
    option::{Self, Option},
};
use sui::{
    url::Url,
    event,
    object,
    clock::Clock,
};
use account_protocol::{
    account::{Self, Account},
    executable::Executable,
    intents::{Expired, Intent},
    version_witness::VersionWitness,
};
use futarchy::{
    futarchy_config::{Self, FutarchyConfig},
    version,
};

// === Aliases ===
use account_protocol::intents as protocol_intents;
use fun protocol_intents::add_action as Intent.add_action;

// === Errors ===
const EEmptyName: u64 = 1;
const EInvalidParameter: u64 = 2;
const EEmptyString: u64 = 3;
const EMismatchedKeyValueLength: u64 = 4;
const EInvalidConfigType: u64 = 5;
const EInvalidSlashDistribution: u64 = 6;

// === Constants ===
const CONFIG_TYPE_TRADING_PARAMS: u8 = 0;
const CONFIG_TYPE_METADATA: u8 = 1;
const CONFIG_TYPE_TWAP: u8 = 2;
const CONFIG_TYPE_GOVERNANCE: u8 = 3;
const CONFIG_TYPE_METADATA_TABLE: u8 = 4;
const CONFIG_TYPE_QUEUE_PARAMS: u8 = 5;

// === Events ===

/// Emitted when proposals are enabled or disabled
public struct ProposalsEnabledChanged has copy, drop {
    account_id: ID,
    enabled: bool,
    timestamp: u64,
}

/// Emitted when DAO name is updated
public struct DaoNameChanged has copy, drop {
    account_id: ID,
    new_name: String,
    timestamp: u64,
}

/// Emitted when trading parameters are updated
public struct TradingParamsChanged has copy, drop {
    account_id: ID,
    timestamp: u64,
}

/// Emitted when metadata is updated
public struct MetadataChanged has copy, drop {
    account_id: ID,
    timestamp: u64,
}

/// Emitted when TWAP config is updated
public struct TwapConfigChanged has copy, drop {
    account_id: ID,
    timestamp: u64,
}

/// Emitted when governance settings are updated
public struct GovernanceSettingsChanged has copy, drop {
    account_id: ID,
    timestamp: u64,
}

/// Emitted when slash distribution is updated
public struct SlashDistributionChanged has copy, drop {
    account_id: ID,
    slasher_reward_bps: u16,
    dao_treasury_bps: u16,
    protocol_bps: u16,
    burn_bps: u16,
    timestamp: u64,
}

// === Basic Action Structs ===

/// Action to enable or disable proposals
/// This is a protocol-level action that should only be used in emergencies
/// It must go through the normal futarchy governance process
public struct SetProposalsEnabledAction has store {
    enabled: bool,
}

/// Action to update the DAO name
/// This must go through the normal futarchy governance process
public struct UpdateNameAction has store {
    new_name: String,
}

// === Advanced Action Structs ===

/// Trading parameters update action
public struct TradingParamsUpdateAction has store, drop {
    min_asset_amount: Option<u64>,
    min_stable_amount: Option<u64>,
    review_period_ms: Option<u64>,
    trading_period_ms: Option<u64>,
    amm_total_fee_bps: Option<u64>,
}

/// DAO metadata update action
public struct MetadataUpdateAction has store, drop {
    dao_name: Option<AsciiString>,
    icon_url: Option<Url>,
    description: Option<String>,
}

/// TWAP configuration update action
public struct TwapConfigUpdateAction has store, drop {
    start_delay: Option<u64>,
    step_max: Option<u64>,
    initial_observation: Option<u128>,
    threshold: Option<u64>,
}

/// Governance settings update action
public struct GovernanceUpdateAction has store, drop {
    proposal_creation_enabled: Option<bool>,
    max_outcomes: Option<u64>,
    required_bond_amount: Option<u64>,
    max_intents_per_outcome: Option<u64>,
    proposal_intent_expiry_ms: Option<u64>,
    optimistic_challenge_fee: Option<u64>,
    optimistic_challenge_period_ms: Option<u64>,
}

/// Metadata table update action
public struct MetadataTableUpdateAction has store, drop {
    keys: vector<String>,
    values: vector<String>,
    keys_to_remove: vector<String>,
}

/// Slash distribution update action
public struct SlashDistributionUpdateAction has store, drop {
    slasher_reward_bps: u16,
    dao_treasury_bps: u16,
    protocol_bps: u16,
    burn_bps: u16,
}

/// Queue parameters update action
public struct QueueParamsUpdateAction has store, drop {
    max_proposer_funded: Option<u64>,
    max_concurrent_proposals: Option<u64>,
    max_queue_size: Option<u64>,
    fee_escalation_basis_points: Option<u64>,
}

/// Wrapper for different config action types (for batch operations)
public struct ConfigAction has store, drop {
    config_type: u8,
    // Only one of these will be populated
    trading_params: Option<TradingParamsUpdateAction>,
    metadata: Option<MetadataUpdateAction>,
    twap_config: Option<TwapConfigUpdateAction>,
    governance: Option<GovernanceUpdateAction>,
    metadata_table: Option<MetadataTableUpdateAction>,
    queue_params: Option<QueueParamsUpdateAction>,
}

// === Basic Execution Functions ===

/// Execute a set proposals enabled action
public fun do_set_proposals_enabled<Outcome: store, IW: drop>(
    executable: &mut Executable<Outcome>,
    account: &mut Account<FutarchyConfig>,
    version: VersionWitness,
    intent_witness: IW,
    clock: &Clock,
    _ctx: &mut TxContext,
) {
    // Extract the action
    let action: &SetProposalsEnabledAction = executable.next_action(intent_witness);
    let enabled = action.enabled;
    
    // Get mutable config using internal function (no witness needed since we're in the same package)
    let config = futarchy_config::internal_config_mut(account);
    
    // Apply the state change
    if (enabled) {
        futarchy_config::set_operational_state(config, futarchy_config::state_active());
    } else {
        futarchy_config::set_operational_state(config, futarchy_config::state_paused());
    };
    
    // Emit event
    event::emit(ProposalsEnabledChanged {
        account_id: object::id(account),
        enabled,
        timestamp: clock.timestamp_ms(),
    });
}

/// Execute an update name action
public fun do_update_name<Outcome: store, IW: drop>(
    executable: &mut Executable<Outcome>,
    account: &mut Account<FutarchyConfig>,
    version: VersionWitness,
    intent_witness: IW,
    clock: &Clock,
    _ctx: &mut TxContext,
) {
    // Extract the action
    let action: &UpdateNameAction = executable.next_action(intent_witness);
    
    // Validate
    assert!(action.new_name.length() > 0, EEmptyName);
    
    // Get mutable config
    let config = futarchy_config::internal_config_mut(account);
    
    // Update the name by converting String to AsciiString
    // Note: This will fail at runtime if the string contains non-ASCII characters
    let ascii_name = action.new_name.to_ascii();
    futarchy_config::set_dao_name(config, ascii_name);
    
    // Emit event
    event::emit(DaoNameChanged {
        account_id: object::id(account),
        new_name: action.new_name,
        timestamp: clock.timestamp_ms(),
    });
}

// === Advanced Execution Functions ===

/// Execute a trading params update action
public fun do_update_trading_params<Outcome: store, IW: drop>(
    executable: &mut Executable<Outcome>,
    account: &mut Account<FutarchyConfig>,
    version: VersionWitness,
    intent_witness: IW,
    clock: &Clock,
    _ctx: &mut TxContext,
) {
    let action: &TradingParamsUpdateAction = executable.next_action(intent_witness);
    
    // Validate parameters
    validate_trading_params_update(action);
    
    // Get mutable config (no witness needed - same package)
    let config = futarchy_config::internal_config_mut(account);
    
    // Apply updates if provided
    if (action.min_asset_amount.is_some()) {
        futarchy_config::set_min_asset_amount(config, *action.min_asset_amount.borrow());
    };
    if (action.min_stable_amount.is_some()) {
        futarchy_config::set_min_stable_amount(config, *action.min_stable_amount.borrow());
    };
    if (action.review_period_ms.is_some()) {
        futarchy_config::set_review_period_ms(config, *action.review_period_ms.borrow());
    };
    if (action.trading_period_ms.is_some()) {
        futarchy_config::set_trading_period_ms(config, *action.trading_period_ms.borrow());
    };
    if (action.amm_total_fee_bps.is_some()) {
        futarchy_config::set_amm_total_fee_bps(config, *action.amm_total_fee_bps.borrow());
    };
    
    // Emit event
    event::emit(TradingParamsChanged {
        account_id: object::id(account),
        timestamp: clock.timestamp_ms(),
    });
}

/// Execute a metadata update action
public fun do_update_metadata<Outcome: store, IW: drop>(
    executable: &mut Executable<Outcome>,
    account: &mut Account<FutarchyConfig>,
    version: VersionWitness,
    intent_witness: IW,
    clock: &Clock,
    _ctx: &mut TxContext,
) {
    let action: &MetadataUpdateAction = executable.next_action(intent_witness);
    
    // Validate parameters
    validate_metadata_update(action);
    
    // Get mutable config
    let config = futarchy_config::internal_config_mut(account);
    
    // Apply updates if provided
    if (action.dao_name.is_some()) {
        futarchy_config::set_dao_name(config, *action.dao_name.borrow());
    };
    if (action.icon_url.is_some()) {
        futarchy_config::set_icon_url(config, *action.icon_url.borrow());
    };
    if (action.description.is_some()) {
        futarchy_config::set_description(config, *action.description.borrow());
    };
    
    // Emit event
    event::emit(MetadataChanged {
        account_id: object::id(account),
        timestamp: clock.timestamp_ms(),
    });
}

/// Execute a TWAP config update action
public fun do_update_twap_config<Outcome: store, IW: drop>(
    executable: &mut Executable<Outcome>,
    account: &mut Account<FutarchyConfig>,
    version: VersionWitness,
    intent_witness: IW,
    clock: &Clock,
    _ctx: &mut TxContext,
) {
    let action: &TwapConfigUpdateAction = executable.next_action(intent_witness);
    
    // Validate parameters
    validate_twap_config_update(action);
    
    // Get mutable config
    let config = futarchy_config::internal_config_mut(account);
    
    // Apply updates if provided
    if (action.start_delay.is_some()) {
        futarchy_config::set_amm_twap_start_delay(config, *action.start_delay.borrow());
    };
    if (action.step_max.is_some()) {
        futarchy_config::set_amm_twap_step_max(config, *action.step_max.borrow());
    };
    if (action.initial_observation.is_some()) {
        futarchy_config::set_amm_twap_initial_observation(config, *action.initial_observation.borrow());
    };
    if (action.threshold.is_some()) {
        futarchy_config::set_twap_threshold(config, *action.threshold.borrow());
    };
    
    // Emit event
    event::emit(TwapConfigChanged {
        account_id: object::id(account),
        timestamp: clock.timestamp_ms(),
    });
}

/// Execute a governance update action
public fun do_update_governance<Outcome: store, IW: drop>(
    executable: &mut Executable<Outcome>,
    account: &mut Account<FutarchyConfig>,
    version: VersionWitness,
    intent_witness: IW,
    clock: &Clock,
    _ctx: &mut TxContext,
) {
    let action: &GovernanceUpdateAction = executable.next_action(intent_witness);
    
    // Validate parameters
    validate_governance_update(action);
    
    // Get mutable config
    let config = futarchy_config::internal_config_mut(account);
    
    // Apply updates if provided
    if (action.proposal_creation_enabled.is_some()) {
        let enabled = *action.proposal_creation_enabled.borrow();
        if (enabled) {
            futarchy_config::set_operational_state(config, futarchy_config::state_active());
        } else {
            futarchy_config::set_operational_state(config, futarchy_config::state_paused());
        };
    };
    if (action.max_outcomes.is_some()) {
        futarchy_config::set_max_outcomes(config, *action.max_outcomes.borrow());
    };
    if (action.required_bond_amount.is_some()) {
        futarchy_config::set_required_bond_amount(config, *action.required_bond_amount.borrow());
    };
    if (action.max_intents_per_outcome.is_some()) {
        futarchy_config::set_max_intents_per_outcome(config, *action.max_intents_per_outcome.borrow());
    };
    if (action.proposal_intent_expiry_ms.is_some()) {
        futarchy_config::set_proposal_intent_expiry_ms(config, *action.proposal_intent_expiry_ms.borrow());
    };
    if (action.optimistic_challenge_fee.is_some()) {
        futarchy_config::set_optimistic_challenge_fee(config, *action.optimistic_challenge_fee.borrow());
    };
    if (action.optimistic_challenge_period_ms.is_some()) {
        futarchy_config::set_optimistic_challenge_period_ms(config, *action.optimistic_challenge_period_ms.borrow());
    };
    
    // Emit event
    event::emit(GovernanceSettingsChanged {
        account_id: object::id(account),
        timestamp: clock.timestamp_ms(),
    });
}

/// Execute a metadata table update action
/// Note: This requires metadata table support in futarchy_config which may not exist yet
public fun do_update_metadata_table<Outcome: store, IW: drop>(
    executable: &mut Executable<Outcome>,
    account: &mut Account<FutarchyConfig>,
    version: VersionWitness,
    intent_witness: IW,
    clock: &Clock,
    _ctx: &mut TxContext,
) {
    let action: &MetadataTableUpdateAction = executable.next_action(intent_witness);
    
    // Validate parameters
    assert!(action.keys.length() == action.values.length(), EMismatchedKeyValueLength);
    
    // Get mutable config
    let config = futarchy_config::internal_config_mut(account);
    
    // Metadata table operations would be implemented here when available in futarchy_config
    // Currently, futarchy_config doesn't have a metadata table, so we validate the action
    // and emit the event to track the attempted change
    let _ = config;
    let _ = action;
    
    // Emit event
    event::emit(MetadataChanged {
        account_id: object::id(account),
        timestamp: clock.timestamp_ms(),
    });
}

/// Execute a queue params update action
public fun do_update_queue_params<Outcome: store, IW: drop>(
    executable: &mut Executable<Outcome>,
    account: &mut Account<FutarchyConfig>,
    version: VersionWitness,
    intent_witness: IW,
    clock: &Clock,
    _ctx: &mut TxContext,
) {
    let action: &QueueParamsUpdateAction = executable.next_action(intent_witness);
    
    // Validate parameters
    validate_queue_params_update(action);
    
    // Get mutable config
    let config = futarchy_config::internal_config_mut(account);
    
    // Apply updates if provided
    if (action.max_concurrent_proposals.is_some()) {
        futarchy_config::set_max_concurrent_proposals(config, *action.max_concurrent_proposals.borrow());
    };
    if (action.fee_escalation_basis_points.is_some()) {
        futarchy_config::set_fee_escalation_basis_points(config, *action.fee_escalation_basis_points.borrow());
    };
    // Note: max_proposer_funded and max_queue_size may not have setters in futarchy_config yet
    
    // Emit event
    event::emit(GovernanceSettingsChanged {
        account_id: object::id(account),
        timestamp: clock.timestamp_ms(),
    });
}

/// Execute a slash distribution update action
public fun do_update_slash_distribution<Outcome: store, IW: drop>(
    executable: &mut Executable<Outcome>,
    account: &mut Account<FutarchyConfig>,
    version: VersionWitness,
    intent_witness: IW,
    clock: &Clock,
    _ctx: &mut TxContext,
) {
    let action: &SlashDistributionUpdateAction = executable.next_action(intent_witness);
    
    // Validate that they sum to 10000 (100%)
    let total = (action.slasher_reward_bps as u64) + (action.dao_treasury_bps as u64) + 
                (action.protocol_bps as u64) + (action.burn_bps as u64);
    assert!(total == 10000, EInvalidSlashDistribution);
    
    // Get mutable config
    let config = futarchy_config::internal_config_mut(account);
    
    // Update the slash distribution
    futarchy_config::update_slash_distribution(
        config,
        action.slasher_reward_bps,
        action.dao_treasury_bps,
        action.protocol_bps,
        action.burn_bps
    );
    
    // Emit event
    event::emit(SlashDistributionChanged {
        account_id: object::id(account),
        slasher_reward_bps: action.slasher_reward_bps,
        dao_treasury_bps: action.dao_treasury_bps,
        protocol_bps: action.protocol_bps,
        burn_bps: action.burn_bps,
        timestamp: clock.timestamp_ms(),
    });
}

/// Execute a batch config action that can contain any type of config update
/// This delegates to the appropriate handler based on config_type
public fun do_batch_config<Outcome: store, IW: drop>(
    executable: &mut Executable<Outcome>,
    account: &mut Account<FutarchyConfig>,
    _version: VersionWitness,
    intent_witness: IW,
    _clock: &Clock,
    _ctx: &mut TxContext,
) {
    let action: &ConfigAction = executable.next_action(intent_witness);
    
    // Validate that the correct field is populated for the config_type
    if (action.config_type == CONFIG_TYPE_TRADING_PARAMS) {
        assert!(action.trading_params.is_some(), EInvalidConfigType);
    } else if (action.config_type == CONFIG_TYPE_METADATA) {
        assert!(action.metadata.is_some(), EInvalidConfigType);
    } else if (action.config_type == CONFIG_TYPE_TWAP) {
        assert!(action.twap_config.is_some(), EInvalidConfigType);
    } else if (action.config_type == CONFIG_TYPE_GOVERNANCE) {
        assert!(action.governance.is_some(), EInvalidConfigType);
    } else if (action.config_type == CONFIG_TYPE_METADATA_TABLE) {
        assert!(action.metadata_table.is_some(), EInvalidConfigType);
    } else if (action.config_type == CONFIG_TYPE_QUEUE_PARAMS) {
        assert!(action.queue_params.is_some(), EInvalidConfigType);
    } else {
        abort EInvalidConfigType
    };
    
    // Note: The actual config updates should be handled by the individual
    // do_ functions for each action type. This wrapper provides type safety.
}

// === Cleanup Functions ===

/// Delete a set proposals enabled action from an expired intent
public fun delete_set_proposals_enabled(expired: &mut Expired) {
    let SetProposalsEnabledAction { enabled: _ } = expired.remove_action();
}

/// Delete an update name action from an expired intent
public fun delete_update_name(expired: &mut Expired) {
    let UpdateNameAction { new_name: _ } = expired.remove_action();
}

/// Delete a trading params update action from an expired intent
public fun delete_trading_params_update(expired: &mut Expired) {
    let TradingParamsUpdateAction {
        min_asset_amount: _,
        min_stable_amount: _,
        review_period_ms: _,
        trading_period_ms: _,
        amm_total_fee_bps: _,
    } = expired.remove_action();
}

/// Delete a metadata update action from an expired intent
public fun delete_metadata_update(expired: &mut Expired) {
    let MetadataUpdateAction {
        dao_name: _,
        icon_url: _,
        description: _,
    } = expired.remove_action();
}

/// Delete a TWAP config update action from an expired intent
public fun delete_twap_config_update(expired: &mut Expired) {
    let TwapConfigUpdateAction {
        start_delay: _,
        step_max: _,
        initial_observation: _,
        threshold: _,
    } = expired.remove_action();
}

/// Delete a governance update action from an expired intent
public fun delete_governance_update(expired: &mut Expired) {
    let GovernanceUpdateAction {
        proposal_creation_enabled: _,
        max_outcomes: _,
        required_bond_amount: _,
        max_intents_per_outcome: _,
        proposal_intent_expiry_ms: _,
        optimistic_challenge_fee: _,
        optimistic_challenge_period_ms: _,
    } = expired.remove_action();
}

/// Delete a metadata table update action from an expired intent
public fun delete_metadata_table_update(expired: &mut Expired) {
    let MetadataTableUpdateAction {
        keys: _,
        values: _,
        keys_to_remove: _,
    } = expired.remove_action();
}

/// Delete a slash distribution update action from an expired intent
public fun delete_slash_distribution_update(expired: &mut Expired) {
    let SlashDistributionUpdateAction {
        slasher_reward_bps: _,
        dao_treasury_bps: _,
        protocol_bps: _,
        burn_bps: _,
    } = expired.remove_action();
}

/// Delete a queue params update action from an expired intent
public fun delete_queue_params_update(expired: &mut Expired) {
    let QueueParamsUpdateAction {
        max_proposer_funded: _,
        max_concurrent_proposals: _,
        max_queue_size: _,
        fee_escalation_basis_points: _,
    } = expired.remove_action();
}

/// Delete a config action from an expired intent
public fun delete_config_action(expired: &mut Expired) {
    let ConfigAction {
        config_type: _,
        trading_params: _,
        metadata: _,
        twap_config: _,
        governance: _,
        metadata_table: _,
        queue_params: _,
    } = expired.remove_action();
}

// === Constructor Functions ===

/// Create a set proposals enabled action
public fun new_set_proposals_enabled_action(enabled: bool): SetProposalsEnabledAction {
    SetProposalsEnabledAction { enabled }
}

/// Create an update name action
public fun new_update_name_action(new_name: String): UpdateNameAction {
    assert!(new_name.length() > 0, EEmptyName);
    UpdateNameAction { new_name }
}

/// Create a slash distribution update action
public fun new_slash_distribution_update_action(
    slasher_reward_bps: u16,
    dao_treasury_bps: u16,
    protocol_bps: u16,
    burn_bps: u16,
): SlashDistributionUpdateAction {
    // Validate that they sum to 10000 (100%)
    let total = (slasher_reward_bps as u64) + (dao_treasury_bps as u64) + 
                (protocol_bps as u64) + (burn_bps as u64);
    assert!(total == 10000, EInvalidSlashDistribution);
    
    SlashDistributionUpdateAction {
        slasher_reward_bps,
        dao_treasury_bps,
        protocol_bps,
        burn_bps,
    }
}

/// Create a trading params update action
public fun new_trading_params_update_action(
    min_asset_amount: Option<u64>,
    min_stable_amount: Option<u64>,
    review_period_ms: Option<u64>,
    trading_period_ms: Option<u64>,
    amm_total_fee_bps: Option<u64>,
): TradingParamsUpdateAction {
    let action = TradingParamsUpdateAction {
        min_asset_amount,
        min_stable_amount,
        review_period_ms,
        trading_period_ms,
        amm_total_fee_bps,
    };
    validate_trading_params_update(&action);
    action
}

/// Create a metadata update action
public fun new_metadata_update_action(
    dao_name: Option<AsciiString>,
    icon_url: Option<Url>,
    description: Option<String>,
): MetadataUpdateAction {
    let action = MetadataUpdateAction {
        dao_name,
        icon_url,
        description,
    };
    validate_metadata_update(&action);
    action
}

/// Create a TWAP config update action
public fun new_twap_config_update_action(
    start_delay: Option<u64>,
    step_max: Option<u64>,
    initial_observation: Option<u128>,
    threshold: Option<u64>,
): TwapConfigUpdateAction {
    let action = TwapConfigUpdateAction {
        start_delay,
        step_max,
        initial_observation,
        threshold,
    };
    validate_twap_config_update(&action);
    action
}

/// Create a governance update action
public fun new_governance_update_action(
    proposal_creation_enabled: Option<bool>,
    max_outcomes: Option<u64>,
    required_bond_amount: Option<u64>,
    max_intents_per_outcome: Option<u64>,
    proposal_intent_expiry_ms: Option<u64>,
    optimistic_challenge_fee: Option<u64>,
    optimistic_challenge_period_ms: Option<u64>,
): GovernanceUpdateAction {
    let action = GovernanceUpdateAction {
        proposal_creation_enabled,
        max_outcomes,
        required_bond_amount,
        max_intents_per_outcome,
        proposal_intent_expiry_ms,
        optimistic_challenge_fee,
        optimistic_challenge_period_ms,
    };
    validate_governance_update(&action);
    action
}

/// Create a metadata table update action
public fun new_metadata_table_update_action(
    keys: vector<String>,
    values: vector<String>,
    keys_to_remove: vector<String>,
): MetadataTableUpdateAction {
    assert!(keys.length() == values.length(), EMismatchedKeyValueLength);
    MetadataTableUpdateAction {
        keys,
        values,
        keys_to_remove,
    }
}

/// Create a queue params update action
public fun new_queue_params_update_action(
    max_proposer_funded: Option<u64>,
    max_concurrent_proposals: Option<u64>,
    max_queue_size: Option<u64>,
    fee_escalation_basis_points: Option<u64>,
): QueueParamsUpdateAction {
    let action = QueueParamsUpdateAction {
        max_proposer_funded,
        max_concurrent_proposals,
        max_queue_size,
        fee_escalation_basis_points,
    };
    validate_queue_params_update(&action);
    action
}

// === Getter Functions ===

/// Get proposals enabled field
public fun get_proposals_enabled(action: &SetProposalsEnabledAction): bool {
    action.enabled
}

/// Get new name field
public fun get_new_name(action: &UpdateNameAction): String {
    action.new_name
}

/// Get trading params update fields
public fun get_trading_params_fields(update: &TradingParamsUpdateAction): (
    &Option<u64>,
    &Option<u64>,
    &Option<u64>,
    &Option<u64>,
    &Option<u64>
) {
    (
        &update.min_asset_amount,
        &update.min_stable_amount,
        &update.review_period_ms,
        &update.trading_period_ms,
        &update.amm_total_fee_bps
    )
}

/// Get metadata update fields
public fun get_metadata_fields(update: &MetadataUpdateAction): (
    &Option<AsciiString>,
    &Option<Url>,
    &Option<String>
) {
    (
        &update.dao_name,
        &update.icon_url,
        &update.description
    )
}

/// Get TWAP config update fields
public fun get_twap_config_fields(update: &TwapConfigUpdateAction): (
    &Option<u64>,
    &Option<u64>,
    &Option<u128>,
    &Option<u64>
) {
    (
        &update.start_delay,
        &update.step_max,
        &update.initial_observation,
        &update.threshold
    )
}

/// Get governance update fields
public fun get_governance_fields(update: &GovernanceUpdateAction): (
    &Option<bool>,
    &Option<u64>,
    &Option<u64>,
    &Option<u64>,
    &Option<u64>
) {
    (
        &update.proposal_creation_enabled,
        &update.max_outcomes,
        &update.required_bond_amount,
        &update.max_intents_per_outcome,
        &update.proposal_intent_expiry_ms
    )
}

/// Get metadata table update fields
public fun get_metadata_table_fields(update: &MetadataTableUpdateAction): (
    &vector<String>,
    &vector<String>,
    &vector<String>
) {
    (
        &update.keys,
        &update.values,
        &update.keys_to_remove
    )
}

/// Get slash distribution update fields
public fun get_slash_distribution_fields(update: &SlashDistributionUpdateAction): (u16, u16, u16, u16) {
    (
        update.slasher_reward_bps,
        update.dao_treasury_bps,
        update.protocol_bps,
        update.burn_bps
    )
}

/// Get queue params update fields
public fun get_queue_params_fields(update: &QueueParamsUpdateAction): (
    &Option<u64>,
    &Option<u64>,
    &Option<u64>,
    &Option<u64>
) {
    (
        &update.max_proposer_funded,
        &update.max_concurrent_proposals,
        &update.max_queue_size,
        &update.fee_escalation_basis_points
    )
}

/// Create a config action for trading params updates
public fun new_config_action_trading_params(
    params: TradingParamsUpdateAction
): ConfigAction {
    ConfigAction {
        config_type: CONFIG_TYPE_TRADING_PARAMS,
        trading_params: option::some(params),
        metadata: option::none(),
        twap_config: option::none(),
        governance: option::none(),
        metadata_table: option::none(),
        queue_params: option::none(),
    }
}

/// Create a config action for metadata updates  
public fun new_config_action_metadata(
    metadata: MetadataUpdateAction
): ConfigAction {
    ConfigAction {
        config_type: CONFIG_TYPE_METADATA,
        trading_params: option::none(),
        metadata: option::some(metadata),
        twap_config: option::none(),
        governance: option::none(),
        metadata_table: option::none(),
        queue_params: option::none(),
    }
}

/// Create a config action for TWAP config updates
public fun new_config_action_twap(
    twap: TwapConfigUpdateAction
): ConfigAction {
    ConfigAction {
        config_type: CONFIG_TYPE_TWAP,
        trading_params: option::none(),
        metadata: option::none(),
        twap_config: option::some(twap),
        governance: option::none(),
        metadata_table: option::none(),
        queue_params: option::none(),
    }
}

/// Create a config action for governance updates
public fun new_config_action_governance(
    gov: GovernanceUpdateAction
): ConfigAction {
    ConfigAction {
        config_type: CONFIG_TYPE_GOVERNANCE,
        trading_params: option::none(),
        metadata: option::none(),
        twap_config: option::none(),
        governance: option::some(gov),
        metadata_table: option::none(),
        queue_params: option::none(),
    }
}

/// Create a config action for metadata table updates
public fun new_config_action_metadata_table(
    table: MetadataTableUpdateAction
): ConfigAction {
    ConfigAction {
        config_type: CONFIG_TYPE_METADATA_TABLE,
        trading_params: option::none(),
        metadata: option::none(),
        twap_config: option::none(),
        governance: option::none(),
        metadata_table: option::some(table),
        queue_params: option::none(),
    }
}

/// Create a config action for queue params updates
public fun new_config_action_queue_params(
    queue: QueueParamsUpdateAction
): ConfigAction {
    ConfigAction {
        config_type: CONFIG_TYPE_QUEUE_PARAMS,
        trading_params: option::none(),
        metadata: option::none(),
        twap_config: option::none(),
        governance: option::none(),
        metadata_table: option::none(),
        queue_params: option::some(queue),
    }
}

// === Internal Validation Functions ===

/// Validate trading params update
fun validate_trading_params_update(action: &TradingParamsUpdateAction) {
    if (action.min_asset_amount.is_some()) {
        assert!(*action.min_asset_amount.borrow() > 0, EInvalidParameter);
    };
    if (action.min_stable_amount.is_some()) {
        assert!(*action.min_stable_amount.borrow() > 0, EInvalidParameter);
    };
    if (action.review_period_ms.is_some()) {
        assert!(*action.review_period_ms.borrow() > 0, EInvalidParameter);
    };
    if (action.trading_period_ms.is_some()) {
        assert!(*action.trading_period_ms.borrow() > 0, EInvalidParameter);
    };
    if (action.amm_total_fee_bps.is_some()) {
        assert!(*action.amm_total_fee_bps.borrow() <= 10000, EInvalidParameter); // Max 100%
    };
}

/// Validate metadata update
fun validate_metadata_update(action: &MetadataUpdateAction) {
    if (action.dao_name.is_some()) {
        assert!(action.dao_name.borrow().length() > 0, EEmptyString);
    };
    if (action.description.is_some()) {
        assert!(action.description.borrow().length() > 0, EEmptyString);
    };
}

/// Validate TWAP config update
fun validate_twap_config_update(action: &TwapConfigUpdateAction) {
    if (action.step_max.is_some()) {
        assert!(*action.step_max.borrow() > 0, EInvalidParameter);
    };
}

/// Validate governance update
fun validate_governance_update(action: &GovernanceUpdateAction) {
    if (action.max_outcomes.is_some()) {
        assert!(*action.max_outcomes.borrow() >= 2, EInvalidParameter); // At least YES/NO
    };
    if (action.max_intents_per_outcome.is_some()) {
        assert!(*action.max_intents_per_outcome.borrow() > 0, EInvalidParameter);
    };
}

/// Validate queue params update
fun validate_queue_params_update(action: &QueueParamsUpdateAction) {
    if (action.max_proposer_funded.is_some()) {
        assert!(*action.max_proposer_funded.borrow() > 0, EInvalidParameter);
    };
    if (action.max_concurrent_proposals.is_some()) {
        assert!(*action.max_concurrent_proposals.borrow() > 0, EInvalidParameter);
    };
    if (action.max_queue_size.is_some()) {
        assert!(*action.max_queue_size.borrow() > 0, EInvalidParameter);
    };
}

// === Aliases for backwards compatibility ===

/// Alias for do_update_twap_config for compatibility
public fun do_update_twap_params<Outcome: store, IW: drop>(
    executable: &mut Executable<Outcome>,
    account: &mut Account<FutarchyConfig>,
    version: VersionWitness,
    iw: IW,
    clock: &Clock,
    ctx: &mut TxContext
) {
    do_update_twap_config<Outcome, IW>(executable, account, version, iw, clock, ctx);
}

/// Alias for queue params update (was called fee params)
public fun do_update_fee_params<Outcome: store, IW: drop>(
    executable: &mut Executable<Outcome>,
    account: &mut Account<FutarchyConfig>,
    version: VersionWitness,
    iw: IW,
    clock: &Clock,
    ctx: &mut TxContext
) {
    do_update_queue_params<Outcome, IW>(executable, account, version, iw, clock, ctx);
}module futarchy::security_council;

// === Imports ===

use std::string::String;
use sui::clock::Clock;
use sui::tx_context::TxContext;

use account_extensions::extensions::Extensions;

use account_protocol::{
    account::{Self, Account, Auth},
    deps,
    executable::Executable,
};

use futarchy::{
    version,                                // VersionWitness for this package
    weighted_multisig::{Self, WeightedMultisig, Approvals},
};

// === Witness ===

/// Unique witness for this config module
public struct Witness has drop {}

public fun witness(): Witness {
    Witness {}
}

// === Security Council factory and governance helpers ===

/// Create a new Weighted Security Council account with the given members/weights/threshold.
/// Includes AccountProtocol, Futarchy, and AccountActions in Deps.
public fun new(
    extensions: &Extensions,
    members: vector<address>,
    weights: vector<u64>,
    threshold: u64,
    ctx: &mut TxContext,
): Account<WeightedMultisig> {
    // build multisig config
    let config = weighted_multisig::new(members, weights, threshold);

    account_protocol::account_interface::create_account!(
        config,
        version::current(),  // VersionWitness for 'futarchy'
        Witness{},           // config witness (this module)
        ctx,
        || deps::new_latest_extensions(
            extensions,
            vector[
                b"AccountProtocol".to_string(),
                b"Futarchy".to_string(),
                b"AccountActions".to_string(),
            ]
        )
    )
}

/// Authenticate a sender as a council member. Returns an Auth usable for gated calls.
public fun authenticate(
    account: &Account<WeightedMultisig>,
    ctx: &TxContext
): Auth {
    account_protocol::account_interface::create_auth!(
        account,
        version::current(),
        Witness{},
        || weighted_multisig::assert_is_member(account.config(), ctx.sender())
    )
}

/// A council member approves a pending intent by adding their approval weight.
/// Avoid borrowing account.config() inside the closure to prevent borrow conflicts.
public fun approve_intent(
    account: &mut Account<WeightedMultisig>,
    key: String,
    clock: &Clock,
    ctx: &mut TxContext,
) {
    // Verify membership before the macro (this borrow ends at return)
    weighted_multisig::assert_is_member(account.config(), ctx.sender());

    account_protocol::account_interface::resolve_intent!(
        account,
        key,
        version::current(),
        Witness{},
        |outcome_mut: &mut Approvals| {
            // Insert approver without borrowing config in this closure
            weighted_multisig::approve_sender_unchecked(outcome_mut, ctx.sender());
        }
    );
    
    // Bump activity after successful approval
    let config = account::config_mut(account, version::current(), Witness{});
    weighted_multisig::bump_last_activity(config, clock);
}

/// Execute an already-approved intent, returning the Executable hot-potato.
public fun execute_intent(
    account: &mut Account<WeightedMultisig>,
    key: String,
    clock: &Clock,
): Executable<Approvals> {
    let executable = account_protocol::account_interface::execute_intent!(
        account,
        key,
        clock,
        version::current(),
        Witness{},
        |outcome: Approvals| {
            // final check before allowing execution
            weighted_multisig::validate_outcome(outcome, account.config(), b"".to_string());
        }
    );
    
    // Bump activity after successful execution
    let config = account::config_mut(account, version::current(), Witness{});
    weighted_multisig::bump_last_activity(config, clock);
    
    executable
}

/// Optional explicit heartbeat to signal council is still active
public entry fun heartbeat(
    account: &mut Account<WeightedMultisig>,
    clock: &Clock,
    ctx: &TxContext,
) {
    // Verify membership
    weighted_multisig::assert_is_member(account.config(), ctx.sender());
    
    // Bump activity
    let config = account::config_mut(account, version::current(), Witness{});
    weighted_multisig::bump_last_activity(config, clock);
}module futarchy::security_council_intents;

use std::{string::String, option::{Self, Option}};
use sui::{
    package::{UpgradeCap, UpgradeTicket, UpgradeReceipt},
    clock::Clock,
    object::{Self, ID},
    transfer::{Self, Receiving},
    tx_context::TxContext,
};
use account_protocol::{
    account::{Self, Account, Auth},
    intents::{Self, Intent, Params, Expired},
    executable::Executable,
    intent_interface, // macros
    owned,            // withdraw/delete_withdraw
    account as account_protocol_account,
};
use fun intent_interface::build_intent as Account.build_intent;

use futarchy::{
    version,
    security_council,
    security_council_actions::{Self, UpdateCouncilMembershipAction, CreateSecurityCouncilAction},
    custody_actions,
    weighted_multisig::{Self as multisig, WeightedMultisig, Approvals},
    futarchy_config::{Self, FutarchyConfig, FutarchyOutcome},
    policy_registry,
};
use account_actions::package_upgrade;
use account_extensions::extensions::Extensions;

// witnesses
public struct RequestPackageUpgradeIntent has copy, drop {}
public struct AcceptUpgradeCapIntent has copy, drop {}

public struct RequestOAPolicyChangeIntent has copy, drop {}
public struct UpdateCouncilMembershipIntent has copy, drop {}
public struct CreateSecurityCouncilIntent has copy, drop {}
public struct ApprovePolicyChangeIntent has copy, drop {}

// Named errors
const ERequiresCoExecution: u64 = 100;

// Public constructor for AcceptUpgradeCapIntent witness
public fun new_accept_upgrade_cap_intent(): AcceptUpgradeCapIntent {
    AcceptUpgradeCapIntent{}
}

public fun request_package_upgrade(
    security_council: &mut Account<WeightedMultisig>,
    auth_from_futarchy_dao: Auth,
    params: Params,
    package_name: String,
    digest: vector<u8>,
    ctx: &mut TxContext
) {
    security_council.verify(auth_from_futarchy_dao);
    let outcome: Approvals = multisig::new_approvals(security_council.config());

    security_council.build_intent!(
        params,
        outcome,
        b"package_upgrade".to_string(),
        version::current(),
        RequestPackageUpgradeIntent{}, // <-- braces
        ctx,
        |intent, iw| {
            package_upgrade::new_upgrade(intent, package_name, digest, iw);
            package_upgrade::new_commit(intent, package_name, iw);
        }
    );
}

public fun execute_upgrade_request(
    executable: &mut Executable<Approvals>,
    security_council: &mut Account<WeightedMultisig>,
    clock: &Clock,
): UpgradeTicket {
    package_upgrade::do_upgrade(
        executable,
        security_council,
        clock,
        version::current(),
        RequestPackageUpgradeIntent{} // <-- braces
    )
}

public fun execute_commit_request(
    mut executable: Executable<Approvals>,
    security_council: &mut Account<WeightedMultisig>,
    receipt: UpgradeReceipt,
) {
    package_upgrade::do_commit(
        &mut executable,
        security_council,
        receipt,
        version::current(),
        RequestPackageUpgradeIntent{} // <-- braces
    );
    security_council.confirm_execution(executable);
}

/// A council member proposes an intent to accept an UpgradeCap into custody.
/// The object will be delivered as Receiving<UpgradeCap> at execution time.
public fun request_accept_and_lock_cap(
    security_council: &mut Account<WeightedMultisig>,
    auth_from_member: Auth,
    params: Params,
    cap_id: ID,
    package_name: String, // used as resource_key
    ctx: &mut TxContext
) {
    use account_protocol::account;

    security_council.verify(auth_from_member);
    let outcome: Approvals = multisig::new_approvals(security_council.config());

    // Manual intent creation to avoid borrow conflict with owned::new_withdraw
    let mut intent = account::create_intent(
        security_council,           // &Account
        params,
        outcome,
        b"accept_custody".to_string(),
        version::current(),
        AcceptUpgradeCapIntent{},    // witness
        ctx
    );

    // now it's safe to borrow &mut security_council to lock the object
    owned::new_withdraw(&mut intent, security_council, cap_id, AcceptUpgradeCapIntent{});
    
    // Use generic custody accept action
    {
        let resource_key = package_name; // resource identifier
        let action = custody_actions::new_accept_into_custody<UpgradeCap>(
            cap_id,
            resource_key,
            b"".to_string()   // optional context
        );
        intent.add_action(
            action,
            AcceptUpgradeCapIntent{}
        );
    };

    // insert it back
    account::insert_intent(security_council, intent, version::current(), AcceptUpgradeCapIntent{});
}

/// Execute accept and lock cap with optional DAO enforcement
public fun execute_accept_and_lock_cap(
    mut executable: Executable<Approvals>,
    security_council: &mut Account<WeightedMultisig>,
    cap_receipt: Receiving<UpgradeCap>,
    ctx: &mut TxContext
) {
    // Keep this for non-coexec single-side accept+lock (no DAO policy enforced).
    // It now expects the new custody action instead of the legacy one.
    let cap = owned::do_withdraw(&mut executable, security_council, cap_receipt, AcceptUpgradeCapIntent{});
    let action: &custody_actions::AcceptIntoCustodyAction<UpgradeCap> =
        executable.next_action(AcceptUpgradeCapIntent{});
    let (_cap_id, pkg_name_ref, _ctx_ref) = custody_actions::get_accept_params(action);
    let auth = security_council::authenticate(security_council, ctx);
    package_upgrade::lock_cap(auth, security_council, cap, *pkg_name_ref, 0);
    security_council.confirm_execution(executable);
}

/// Execute accept and lock cap with optional DAO enforcement
/// If dao is provided, checks if "UpgradeCap:Custodian" policy is set
/// If policy is set, aborts and instructs to use upgrade_cap_coexec instead
public fun execute_accept_and_lock_cap_with_dao_check(
    dao: &Account<FutarchyConfig>,
    mut executable: Executable<Approvals>,
    security_council: &mut Account<WeightedMultisig>,
    cap_receipt: Receiving<UpgradeCap>,
    ctx: &mut TxContext
) {
    // Check if DAO has UpgradeCap:Custodian policy set
    let reg = policy_registry::borrow_registry(dao, version::current());
    let key = b"UpgradeCap:Custodian".to_string();
    if (policy_registry::has_policy(reg, key)) {
        // If policy is set, enforce use of co-execution path
        abort ERequiresCoExecution // must use upgrade_cap_coexec::execute_accept_and_lock_with_council
    };
    
    // If no policy, proceed with regular execution
    execute_accept_and_lock_cap(executable, security_council, cap_receipt, ctx)
}

// Cleanup for “accept and lock cap” (must unlock the object via the Account)
public fun delete_accept_upgrade_cap(
    expired: &mut Expired,
    security_council: &mut Account<WeightedMultisig>
) {
    owned::delete_withdraw(expired, security_council); // <-- pass account too
    custody_actions::delete_accept_into_custody<UpgradeCap>(expired);
}

/// A council member proposes an intent to update the council's own membership.
public fun request_update_council_membership(
    security_council: &mut Account<WeightedMultisig>,
    auth_from_member: Auth,
    params: Params,
    new_members: vector<address>,
    new_weights: vector<u64>,
    new_threshold: u64,
    ctx: &mut TxContext
) {
    security_council.verify(auth_from_member);
    let outcome: Approvals = multisig::new_approvals(security_council.config());

    security_council.build_intent!(
        params,
        outcome,
        b"update_council_membership".to_string(),
        version::current(),
        UpdateCouncilMembershipIntent{},
        ctx,
        |intent, iw| {
            let action = security_council_actions::new_update_council_membership(
                new_members,
                new_weights,
                new_threshold
            );
            intent.add_action(action, iw);
        }
    );
}

/// After council approval, this executes the membership update.
public fun execute_update_council_membership(
    mut executable: Executable<Approvals>,
    security_council: &mut Account<WeightedMultisig>,
) {
    let action: &UpdateCouncilMembershipAction = executable.next_action(UpdateCouncilMembershipIntent{});
    let (new_members, new_weights, new_threshold) =
        security_council_actions::get_update_council_membership_params(action);

    // Get mutable access to the account's config
    let config_mut = account_protocol_account::config_mut(
        security_council,
        version::current(),
        security_council::witness()
    );

    // Use the weighted_multisig's update_membership function
    multisig::update_membership(
        config_mut,
        *new_members,
        *new_weights,
        new_threshold
    );

    security_council.confirm_execution(executable);
}

// === Create Security Council (DAO-side intent) ===

/// DAO proposes creation of a Security Council; optionally registers it as OA custodian.
public fun request_create_security_council(
    dao: &mut Account<FutarchyConfig>,
    params: Params,
    outcome: FutarchyOutcome,
    members: vector<address>,
    weights: vector<u64>,
    threshold: u64,
    set_as_oa_custodian: bool,
    ctx: &mut TxContext
) {
    dao.build_intent!(
        params,
        outcome,
        b"create_security_council".to_string(),
        version::current(),
        CreateSecurityCouncilIntent{},
        ctx,
        |intent, iw| {
            let action = security_council_actions::new_create_council(
                members,
                weights,
                threshold,
                set_as_oa_custodian
            );
            intent.add_action(action, iw);
        }
    );
}

/// Execute the council creation with a provided Extensions registry.
/// Creates the council, shares it, and optionally sets OA:Custodian policy.
#[allow(lint(share_owned))]
public fun execute_create_security_council(
    dao: &mut Account<FutarchyConfig>,
    extensions: &Extensions,
    mut executable: Executable<FutarchyOutcome>,
    ctx: &mut TxContext
) {
    let action: &CreateSecurityCouncilAction = executable.next_action(CreateSecurityCouncilIntent{});
    let (members, weights, threshold, set_oa) =
        security_council_actions::get_create_council_params(action);

    // Build council account
    let council = security_council::new(
        extensions,
        *members,
        *weights,
        threshold,
        ctx
    );
    let council_id = object::id(&council);
    transfer::public_share_object(council);

    // Note: OA:Custodian policy has been removed - OA is now always governed like other actions
    // The set_oa parameter is kept for backward compatibility but is now ignored
    let _ = set_oa;

    // Confirm DAO-side execution
    dao.confirm_execution(executable);
}

// === Policy Change Approval (Council-side intent) ===

/// Council member proposes approval of a critical policy removal
public fun request_approve_policy_removal(
    security_council: &mut Account<WeightedMultisig>,
    auth_from_member: Auth,
    params: Params,
    dao_id: ID,
    resource_key: String,
    expires_at: u64,
    ctx: &mut TxContext
) {
    security_council.verify(auth_from_member);
    let outcome: Approvals = multisig::new_approvals(security_council.config());
    
    security_council.build_intent!(
        params,
        outcome,
        b"approve_policy_removal".to_string(),
        version::current(),
        ApprovePolicyChangeIntent{},
        ctx,
        |intent, iw| {
            // Create metadata for the policy removal approval
            let metadata = vector::empty<String>();
            
            let action = security_council_actions::new_approve_generic(
                dao_id,
                b"policy_remove".to_string(),
                resource_key,
                metadata,
                expires_at
            );
            intent.add_action(action, iw);
        }
    );
}

/// Council member proposes approval of a critical policy set/update
public fun request_approve_policy_set(
    security_council: &mut Account<WeightedMultisig>,
    auth_from_member: Auth,
    params: Params,
    dao_id: ID,
    resource_key: String,
    policy_account_id: ID,
    intent_key_prefix: String,
    expires_at: u64,
    ctx: &mut TxContext
) {
    security_council.verify(auth_from_member);
    let outcome: Approvals = multisig::new_approvals(security_council.config());
    
    security_council.build_intent!(
        params,
        outcome,
        b"approve_policy_set".to_string(),
        version::current(),
        ApprovePolicyChangeIntent{},
        ctx,
        |intent, iw| {
            // Create metadata for the policy set approval
            let mut metadata = vector::empty<String>();
            metadata.push_back(b"policy_account_id".to_string());
            // Convert ID to hex string
            let id_bytes = object::id_to_bytes(&policy_account_id);
            let id_hex = sui::hex::encode(id_bytes);
            metadata.push_back(std::string::utf8(id_hex));
            metadata.push_back(b"intent_key_prefix".to_string());
            metadata.push_back(intent_key_prefix);
            
            let action = security_council_actions::new_approve_generic(
                dao_id,
                b"policy_set".to_string(),
                resource_key,
                metadata,
                expires_at
            );
            intent.add_action(action, iw);
        }
    );
}

/// Execute the approved policy change intent
public fun execute_approve_policy_change(
    mut executable: Executable<Approvals>,
    security_council: &mut Account<WeightedMultisig>,
) {
    // The action is consumed when used with policy_registry_coexec
    // This just confirms the executable was properly used
    security_council.confirm_execution(executable);
}

// === Intent Cleanup Functions ===

/// Security Council can clean up specific expired intents by key
/// This is a hot path - council members can execute this without needing a proposal
/// 
/// Note: Due to Sui's Bag limitations, we cannot iterate through all intents.
/// Callers must provide the specific intent keys to clean up.
public fun cleanup_expired_council_intents(
    security_council: &mut Account<WeightedMultisig>,
    auth_from_member: Auth,
    intent_keys: vector<String>,
    clock: &Clock,
) {
    // Verify the caller is a council member
    security_council.verify(auth_from_member);
    
    // Clean up each specified intent if it's expired
    let mut i = 0;
    let len = intent_keys.length();
    
    while (i < len) {
        let key = *intent_keys.borrow(i);
        
        // Check if the intent exists and is expired
        let intents_store = account::intents(security_council);
        if (intents::contains(intents_store, key)) {
            // Get the intent to check expiration
            let intent = intents::get<Approvals>(intents_store, key);
            
            // If expired, delete it
            if (clock.timestamp_ms() >= intents::expiration_time(intent)) {
                let mut expired = account::delete_expired_intent<WeightedMultisig, Approvals>(
                    security_council,
                    key,
                    clock
                );
                
                // Drain the expired intent's actions
                drain_council_expired(&mut expired, security_council);
                
                // Destroy the empty expired object
                intents::destroy_empty_expired(expired);
            };
        };
        
        i = i + 1;
    };
}

/// Helper function to drain expired Security Council intent actions
fun drain_council_expired(expired: &mut Expired, security_council: &mut Account<WeightedMultisig>) {
    // Delete all possible Security Council action types
    security_council_actions::delete_update_council_membership(expired);
    security_council_actions::delete_create_council(expired);
    security_council_actions::delete_approve_generic(expired);
    security_council_actions::delete_sweep_intents(expired);
    
    // Delete package upgrade actions
    package_upgrade::delete_upgrade(expired);
    package_upgrade::delete_commit(expired);
    
    // Delete owned withdraw if present
    owned::delete_withdraw(expired, security_council);
    
    // Delete custody actions
    custody_actions::delete_accept_into_custody<UpgradeCap>(expired);
}

/// Security Council can propose a sweep of specific expired intents
/// This requires multisig approval but can clean up many intents at once
/// 
/// Note: The intent_keys must be stored in the action since we need them
/// at execution time to identify which intents to clean.
public fun request_sweep_expired_intents(
    security_council: &mut Account<WeightedMultisig>,
    auth_from_member: Auth,
    params: Params,
    intent_keys: vector<String>,
    ctx: &mut TxContext
) {
    security_council.verify(auth_from_member);
    let outcome: Approvals = multisig::new_approvals(security_council.config());
    
    security_council.build_intent!(
        params,
        outcome,
        b"sweep_expired_intents".to_string(),
        version::current(),
        SweepExpiredIntentsIntent{},
        ctx,
        |intent, iw| {
            // Store the keys in the action so we know what to clean at execution
            let action = security_council_actions::new_sweep_intents_with_keys(intent_keys);
            intent.add_action(action, iw);
        }
    );
}

/// Execute the sweep of expired intents
/// This will clean up all the intents specified in the approved action
public fun execute_sweep_expired_intents(
    mut executable: Executable<Approvals>,
    security_council: &mut Account<WeightedMultisig>,
    clock: &Clock,
) {
    let action: &security_council_actions::SweepIntentsAction = 
        executable.next_action(SweepExpiredIntentsIntent{});
    let intent_keys = security_council_actions::get_sweep_keys(action);
    
    // Clean up the specified expired intents
    cleanup_expired_council_intents_internal(security_council, intent_keys, clock);
    
    security_council.confirm_execution(executable);
}

// Internal helper for cleaning up expired intents
fun cleanup_expired_council_intents_internal(
    security_council: &mut Account<WeightedMultisig>,
    intent_keys: &vector<String>,
    clock: &Clock,
) {
    // Process each intent key
    let mut i = 0;
    let len = intent_keys.length();
    
    while (i < len) {
        let key = *intent_keys.borrow(i);
        
        // Check if the intent exists and is expired
        let intents_store = account::intents(security_council);
        if (intents::contains(intents_store, key)) {
            // Get the intent to check expiration
            let intent = intents::get<Approvals>(intents_store, key);
            
            // If expired, delete it
            if (clock.timestamp_ms() >= intents::expiration_time(intent)) {
                let mut expired = account::delete_expired_intent<WeightedMultisig, Approvals>(
                    security_council,
                    key,
                    clock
                );
                
                // Drain the expired intent's actions
                drain_council_expired(&mut expired, security_council);
                
                // Destroy the empty expired object
                intents::destroy_empty_expired(expired);
            };
        };
        
        i = i + 1;
    };
}

// Optional no-ops for symmetry
public fun delete_request_package_upgrade(_expired: &mut Expired) {}
public fun delete_request_oa_policy_change(_expired: &mut Expired) {}
public fun delete_update_council_membership(expired: &mut Expired) {
    security_council_actions::delete_update_council_membership(expired);
}
public fun delete_create_council(expired: &mut Expired) {
    security_council_actions::delete_create_council(expired);
}
public fun delete_approve_policy_change(expired: &mut Expired) {
    security_council_actions::delete_approve_generic(expired);
}
public fun delete_sweep_expired_intents(expired: &mut Expired) {
    security_council_actions::delete_sweep_intents(expired);
}

// Witness for sweep intents
public struct SweepExpiredIntentsIntent has copy, drop {}

// Witness for optimistic intents
public struct CreateOptimisticIntent has copy, drop {}
public struct ExecuteOptimisticIntent has copy, drop {}
public struct CancelOptimisticIntent has copy, drop {}
public struct ChallengeOptimisticIntents has copy, drop {}

// === Optimistic Intent Functions ===

/// Security council creates an optimistic intent that can be executed after waiting period
public fun request_create_optimistic_intent(
    security_council: &mut Account<WeightedMultisig>,
    auth_from_member: Auth,
    params: Params,
    dao_id: ID,
    intent_key_for_execution: String,  // The actual intent to execute after delay
    title: String,
    description: String,
    ctx: &mut TxContext
) {
    security_council.verify(auth_from_member);
    let outcome: Approvals = multisig::new_approvals(security_council.config());
    
    security_council.build_intent!(
        params,
        outcome,
        b"create_optimistic_intent".to_string(),
        version::current(),
        CreateOptimisticIntent{},
        ctx,
        |intent, iw| {
            // Create the optimistic intent action
            let action = security_council_actions::new_council_create_optimistic_intent(
                dao_id,
                intent_key_for_execution,
                title,
                description
            );
            intent.add_action(action, iw);
        }
    );
}

/// Execute a matured optimistic intent (after 10-day waiting period)
public fun request_execute_optimistic_intent(
    security_council: &mut Account<WeightedMultisig>, 
    auth_from_member: Auth,
    params: Params,
    dao_id: ID,
    optimistic_intent_id: ID,
    ctx: &mut TxContext
) {
    security_council.verify(auth_from_member);
    let outcome: Approvals = multisig::new_approvals(security_council.config());
    
    security_council.build_intent!(
        params,
        outcome,
        b"execute_optimistic_intent".to_string(),
        version::current(),
        ExecuteOptimisticIntent{},
        ctx,
        |intent, iw| {
            // Create action to execute the optimistic intent
            use futarchy::optimistic_intents;
            let action = optimistic_intents::new_execute_optimistic_intent_action(
                optimistic_intent_id
            );
            intent.add_action(action, iw);
        }
    );
}

/// Security council member cancels their own optimistic intent
public fun request_cancel_optimistic_intent(
    security_council: &mut Account<WeightedMultisig>,
    auth_from_member: Auth,
    params: Params,
    dao_id: ID,
    optimistic_intent_id: ID,
    reason: String,
    ctx: &mut TxContext
) {
    security_council.verify(auth_from_member);
    let outcome: Approvals = multisig::new_approvals(security_council.config());
    
    security_council.build_intent!(
        params,
        outcome,
        b"cancel_optimistic_intent".to_string(),
        version::current(),
        CancelOptimisticIntent{},
        ctx,
        |intent, iw| {
            use futarchy::optimistic_intents;
            let action = optimistic_intents::new_cancel_optimistic_intent_action(
                optimistic_intent_id,
                reason
            );
            intent.add_action(action, iw);
        }
    );
}

// Delete functions for expired intents
public fun delete_create_optimistic_intent(expired: &mut Expired) {
    security_council_actions::delete_council_create_optimistic_intent(expired);
}

public fun delete_execute_optimistic_intent(expired: &mut Expired) {
    use futarchy::optimistic_intents;
    optimistic_intents::delete_execute_optimistic_intent_action(expired);
}

public fun delete_cancel_optimistic_intent(expired: &mut Expired) {
    use futarchy::optimistic_intents;
    optimistic_intents::delete_cancel_optimistic_intent_action(expired);
}/// Actions specific to the role of a Security Council Account.
/// This enables the council to accept and manage critical capabilities like UpgradeCaps
/// through its own internal M-of-N governance process.
module futarchy::security_council_actions;

use std::{string::String, option::Option};
use sui::object::ID;
use account_protocol::intents::Expired;

/// Create a new Security Council (WeightedMultisig) for the DAO.
/// Optionally register it as the OA custodian.
public struct CreateSecurityCouncilAction has store {
    members: vector<address>,
    weights: vector<u64>,
    threshold: u64,
    set_as_oa_custodian: bool,
}

/// Council's approval for an Operating Agreement change
public struct ApproveOAChangeAction has store {
    dao_id: ID,
    batch_id: ID,  // ID of the BatchOperatingAgreementAction
    expires_at: u64,
}

// --- Constructors, Getters, Cleanup ---

public fun new_create_council(
    members: vector<address>,
    weights: vector<u64>,
    threshold: u64,
    set_as_oa_custodian: bool,
): CreateSecurityCouncilAction {
    CreateSecurityCouncilAction { members, weights, threshold, set_as_oa_custodian }
}

public fun get_create_council_params(
    action: &CreateSecurityCouncilAction
): (&vector<address>, &vector<u64>, u64, bool) {
    (&action.members, &action.weights, action.threshold, action.set_as_oa_custodian)
}

public fun delete_create_council(expired: &mut Expired) {
    let CreateSecurityCouncilAction {..} = expired.remove_action();
}

public fun new_approve_oa_change(dao_id: ID, batch_id: ID, expires_at: u64): ApproveOAChangeAction {
    ApproveOAChangeAction { dao_id, batch_id, expires_at }
}

public fun get_approve_oa_change_params(a: &ApproveOAChangeAction): (ID, ID, u64) {
    (a.dao_id, a.batch_id, a.expires_at)
}

public fun delete_approve_oa_change(expired: &mut Expired) {
    let ApproveOAChangeAction { dao_id: _, batch_id: _, expires_at: _ } = expired.remove_action();
}

/// Action to update the rules for an already-managed UpgradeCap.
public struct UpdateUpgradeRulesAction has store {
    package_name: String,
}

/// Action to update the council's own membership, weights, and threshold.
public struct UpdateCouncilMembershipAction has store {
    new_members: vector<address>,
    new_weights: vector<u64>,
    new_threshold: u64,
}

/// Action to unlock an UpgradeCap and return it to the main DAO.
public struct UnlockAndReturnUpgradeCapAction has store {
    package_name: String,
    /// The address of the main DAO's treasury vault.
    return_vault_name: String,
}

/// Generic approval action for any non-OA council approval
/// This replaces ApprovePolicyChangeAction, ApproveUpgradeCapAction, etc.
public struct ApproveGenericAction has store {
    dao_id: ID,
    action_type: String,  // "policy_remove", "policy_set", "custody_accept", etc.
    resource_key: String,  // The resource being acted upon
    metadata: vector<String>,  // Pairs of key-value strings [k1, v1, k2, v2, ...]
    expires_at: u64,
}

/// Action to sweep/cleanup expired intents from the Security Council account
public struct SweepIntentsAction has store {
    intent_keys: vector<String>,  // Specific intent keys to clean up
}

/// Action for security council to create an optimistic intent
public struct CouncilCreateOptimisticIntentAction has store {
    dao_id: ID,
    intent_key: String,
    title: String,
    description: String,
}

/// Action for security council to execute a matured optimistic intent
public struct CouncilExecuteOptimisticIntentAction has store {
    dao_id: ID,
    intent_id: ID,
}

/// Action for security council to cancel their own optimistic intent
public struct CouncilCancelOptimisticIntentAction has store {
    dao_id: ID,
    intent_id: ID,
    reason: String,
}

// --- Constructors, Getters, Cleanup ---

// Optimistic Intent Constructors
public fun new_council_create_optimistic_intent(
    dao_id: ID,
    intent_key: String,
    title: String,
    description: String,
): CouncilCreateOptimisticIntentAction {
    CouncilCreateOptimisticIntentAction { dao_id, intent_key, title, description }
}

public fun get_council_create_optimistic_intent_params(
    action: &CouncilCreateOptimisticIntentAction
): (ID, &String, &String, &String) {
    (action.dao_id, &action.intent_key, &action.title, &action.description)
}

public fun delete_council_create_optimistic_intent(expired: &mut Expired) {
    let CouncilCreateOptimisticIntentAction {..} = expired.remove_action();
}

public fun new_council_execute_optimistic_intent(
    dao_id: ID,
    intent_id: ID,
): CouncilExecuteOptimisticIntentAction {
    CouncilExecuteOptimisticIntentAction { dao_id, intent_id }
}

public fun get_council_execute_optimistic_intent_params(
    action: &CouncilExecuteOptimisticIntentAction
): (ID, ID) {
    (action.dao_id, action.intent_id)
}

public fun delete_council_execute_optimistic_intent(expired: &mut Expired) {
    let CouncilExecuteOptimisticIntentAction {..} = expired.remove_action();
}

public fun new_council_cancel_optimistic_intent(
    dao_id: ID,
    intent_id: ID,
    reason: String,
): CouncilCancelOptimisticIntentAction {
    CouncilCancelOptimisticIntentAction { dao_id, intent_id, reason }
}

public fun get_council_cancel_optimistic_intent_params(
    action: &CouncilCancelOptimisticIntentAction
): (ID, ID, &String) {
    (action.dao_id, action.intent_id, &action.reason)
}

public fun delete_council_cancel_optimistic_intent(expired: &mut Expired) {
    let CouncilCancelOptimisticIntentAction {..} = expired.remove_action();
}

// Other Constructors
public fun new_update_upgrade_rules(package_name: String): UpdateUpgradeRulesAction {
    UpdateUpgradeRulesAction { package_name }
}

public fun get_update_upgrade_rules_params(action: &UpdateUpgradeRulesAction): &String {
    &action.package_name
}

public fun new_update_council_membership(
    new_members: vector<address>,
    new_weights: vector<u64>,
    new_threshold: u64,
): UpdateCouncilMembershipAction {
    UpdateCouncilMembershipAction { new_members, new_weights, new_threshold }
}

public fun get_update_council_membership_params(
    action: &UpdateCouncilMembershipAction
): (&vector<address>, &vector<u64>, u64) {
    (&action.new_members, &action.new_weights, action.new_threshold)
}

public fun new_unlock_and_return_cap(package_name: String, return_vault_name: String): UnlockAndReturnUpgradeCapAction {
    UnlockAndReturnUpgradeCapAction { package_name, return_vault_name }
}

public fun get_unlock_and_return_cap_params(action: &UnlockAndReturnUpgradeCapAction): (&String, &String) {
    (&action.package_name, &action.return_vault_name)
}

public fun delete_update_upgrade_rules(expired: &mut Expired) {
    let UpdateUpgradeRulesAction {..} = expired.remove_action();
}

public fun delete_update_council_membership(expired: &mut Expired) {
    let UpdateCouncilMembershipAction {..} = expired.remove_action();
}

public fun delete_unlock_and_return_cap(expired: &mut Expired) {
    let UnlockAndReturnUpgradeCapAction {..} = expired.remove_action();
}

// --- Generic Approval Functions ---

public fun new_approve_generic(
    dao_id: ID,
    action_type: String,
    resource_key: String,
    metadata: vector<String>,
    expires_at: u64,
): ApproveGenericAction {
    ApproveGenericAction {
        dao_id,
        action_type,
        resource_key,
        metadata,
        expires_at,
    }
}

public fun get_approve_generic_params(
    action: &ApproveGenericAction
): (ID, &String, &String, &vector<String>, u64) {
    (
        action.dao_id,
        &action.action_type,
        &action.resource_key,
        &action.metadata,
        action.expires_at,
    )
}

public fun delete_approve_generic(expired: &mut Expired) {
    let ApproveGenericAction {..} = expired.remove_action();
}

// --- Sweep Intents Functions ---

public fun new_sweep_intents_with_keys(intent_keys: vector<String>): SweepIntentsAction {
    SweepIntentsAction { intent_keys }
}

public fun get_sweep_keys(action: &SweepIntentsAction): &vector<String> {
    &action.intent_keys
}

public fun delete_sweep_intents(expired: &mut Expired) {
    let SweepIntentsAction {..} = expired.remove_action();
}

/// DAO-side helper to approve accepting/locking an UpgradeCap (2-of-2 flow).
module futarchy::upgrade_cap_intents;

use account_protocol::{
    account::{Self, Account},
    intents::{Intent, Params},
    intent_interface,
};
use fun intent_interface::build_intent as Account.build_intent;
use sui::{
    object::{Self, ID},
    tx_context::TxContext,
};
use std::string::{Self, String};
use sui::package::UpgradeCap;
use futarchy::{
    version,
    futarchy_config::{Self, FutarchyConfig, FutarchyOutcome},
    custody_actions,
};

/// Intent witness for upgrade-cap approvals
public struct UpgradeCapIntent has copy, drop {}

/// Create an intent that approves accepting/locking an UpgradeCap (2-of-2 co-exec).
public fun create_approve_accept_upgrade_cap_intent(
    dao: &mut Account<FutarchyConfig>,
    params: Params,
    outcome: FutarchyOutcome,
    cap_id: ID,
    package_name: String, // resource_key
    expires_at: u64,
    ctx: &mut TxContext
) {
    let dao_id = object::id(dao); // Get ID before the macro
    
    dao.build_intent!(
        params,
        outcome,
        b"approve_accept_upgrade_cap".to_string(),
        version::current(),
        UpgradeCapIntent{},
        ctx,
        |intent, iw| {
            // Typed DAO-side approve custody for UpgradeCap
            let action = custody_actions::new_approve_custody<UpgradeCap>(
                dao_id,
                cap_id,
                package_name,
                b"".to_string(),
                expires_at
            );
            intent.add_action(action, iw);
        }
    );
}/// A generic, weighted M-of-N multisig configuration for an Account.
/// Each member has an assigned weight, and an intent is approved when
/// the sum of approving members' weights meets a given threshold.
/// This module is designed to be used as the `Config` for an `account_protocol::account::Account`.
module futarchy::weighted_multisig;

use std::string::String;
use sui::{vec_map::{Self, VecMap}, vec_set::{Self, VecSet}, clock::Clock};

// === Errors ===
const EThresholdNotMet: u64 = 1;
const EAlreadyApproved: u64 = 2;
const ENotMember: u64 = 3;
const EThresholdUnreachable: u64 = 4;
const EInvalidArguments: u64 = 5;

// === Structs ===

/// Witness for this config module, required by the account protocol.
public struct Witness has drop {}
/// Get the witness for this module.
public fun witness(): Witness { Witness {} }

/// The configuration for a weighted multisig account.
public struct WeightedMultisig has store {
    /// Maps member addresses to their voting weight.
    members: VecMap<address, u64>,
    /// The sum of weights required for an intent to be approved.
    threshold: u64,
    /// Total voting power in the council.
    total_weight: u64,
    /// Last activity timestamp for dead-man switch tracking
    last_activity_ms: u64,
}

/// The outcome object for a weighted multisig. Tracks approvals for a specific intent.
public struct Approvals has store, drop, copy {
    /// The set of addresses that have approved. The weight is looked up from the config.
    approvers: VecSet<address>,
}

// === Public Functions ===

/// Create a new weighted multisig configuration.
public fun new(members: vector<address>, weights: vector<u64>, threshold: u64): WeightedMultisig {
    assert!(members.length() == weights.length(), EInvalidArguments);
    let mut member_map = vec_map::empty();
    let mut total_weight = 0u64;

    let mut i = 0;
    while (i < members.length()) {
        let member = *vector::borrow(&members, i);
        let weight = *vector::borrow(&weights, i);
        assert!(weight > 0, EInvalidArguments);
        member_map.insert(member, weight);
        total_weight = total_weight + weight;
        i = i + 1;
    };

    assert!(threshold > 0 && threshold <= total_weight, EThresholdUnreachable);
    WeightedMultisig { members: member_map, threshold, total_weight, last_activity_ms: 0 }
}

/// Create a fresh, empty Approvals outcome for a new intent.
public fun new_approvals(_config: &WeightedMultisig): Approvals {
    Approvals { approvers: vec_set::empty() }
}

/// A member approves an intent, modifying its outcome.
public fun approve_intent(
    outcome: &mut Approvals,
    config: &WeightedMultisig,
    sender: address,
) {
    assert!(config.members.contains(&sender), ENotMember);
    assert!(!outcome.approvers.contains(&sender), EAlreadyApproved);
    outcome.approvers.insert(sender);
}

/// Validate if the threshold has been met. This is called by `account_interface::execute_intent!`.
public fun validate_outcome(
    outcome: Approvals,
    config: &WeightedMultisig,
    _role: String,
) {
    let mut current_weight = 0u64;
    // FIX: Use `into_keys()` which correctly returns a `vector<address>` for iteration.
    let approvers_vector = outcome.approvers.into_keys();
    
    let mut i = 0;
    while (i < approvers_vector.length()) {
        let approver = *vector::borrow(&approvers_vector, i);
        let weight = *config.members.get(&approver);
        current_weight = current_weight + weight;
        i = i + 1;
    };

    assert!(current_weight >= config.threshold, EThresholdNotMet);
}

/// Check if a given address is a member of the multisig.
public fun is_member(config: &WeightedMultisig, addr: address): bool {
    config.members.contains(&addr)
}

/// Asserts that a given address is a member, aborting if not.
public fun assert_is_member(config: &WeightedMultisig, addr: address) {
    assert!(is_member(config, addr), ENotMember);
}

/// Insert approver address without borrowing the config inside the resolve_intent! closure.
/// Call weighted_multisig::assert_is_member(config, sender) BEFORE calling this to ensure membership.
/// This avoids borrowing account.config() inside the closure (which conflicts with the mutable borrow held by resolve_intent!).
public fun approve_sender_unchecked(outcome: &mut Approvals, sender: address) {
    assert!(!outcome.approvers.contains(&sender), EAlreadyApproved);
    outcome.approvers.insert(sender);
}

/// Update the multisig configuration with new members, weights, and threshold.
/// This is used by the security council to update its own membership.
public fun update_membership(
    config: &mut WeightedMultisig,
    new_members: vector<address>,
    new_weights: vector<u64>,
    new_threshold: u64,
) {
    assert!(new_members.length() == new_weights.length(), EInvalidArguments);
    
    let mut new_member_map = vec_map::empty();
    let mut new_total_weight = 0u64;
    
    let mut i = 0;
    while (i < new_members.length()) {
        let member = *vector::borrow(&new_members, i);
        let weight = *vector::borrow(&new_weights, i);
        assert!(weight > 0, EInvalidArguments);
        new_member_map.insert(member, weight);
        new_total_weight = new_total_weight + weight;
        i = i + 1;
    };
    
    assert!(new_threshold > 0 && new_threshold <= new_total_weight, EThresholdUnreachable);
    
    // Update the config
    config.members = new_member_map;
    config.threshold = new_threshold;
    config.total_weight = new_total_weight;
    // Reset activity on membership update
    config.last_activity_ms = 0;
}

// === Dead-man switch helpers ===

/// Get the last activity timestamp
public fun last_activity_ms(config: &WeightedMultisig): u64 {
    config.last_activity_ms
}

/// Bump the last activity timestamp to the current time
public fun bump_last_activity(config: &mut WeightedMultisig, clock: &Clock) {
    config.last_activity_ms = clock.timestamp_ms();
}/// Dispatcher for stream/recurring payment actions
module futarchy::stream_dispatcher;

// === Imports ===
use sui::{
    clock::Clock,
    tx_context::TxContext,
};
use account_protocol::{
    account::Account,
    executable::{Self, Executable},
};
use futarchy::{
    futarchy_config::FutarchyConfig,
    version,
    stream_actions,
};

// === Public(friend) Functions ===

/// Try to execute stream actions (non-typed actions)
public(package) fun try_execute_stream_action<IW: drop, Outcome: store + drop + copy>(
    executable: &mut Executable<Outcome>,
    account: &mut Account<FutarchyConfig>,
    witness: IW,
    clock: &Clock,
    ctx: &mut TxContext
): bool {
    // Try to execute UpdatePaymentRecipientAction
    if (executable::contains_action<Outcome, stream_actions::UpdatePaymentRecipientAction>(executable)) {
        stream_actions::do_update_payment_recipient<Outcome, IW>(
            executable,
            account,
            version::current(),
            witness,
            clock,
            ctx
        );
        return true
    };
    
    // Try to execute AddWithdrawerAction
    if (executable::contains_action<Outcome, stream_actions::AddWithdrawerAction>(executable)) {
        stream_actions::do_add_withdrawer<Outcome, IW>(
            executable,
            account,
            version::current(),
            witness,
            clock,
            ctx
        );
        return true
    };
    
    // Try to execute RemoveWithdrawersAction
    if (executable::contains_action<Outcome, stream_actions::RemoveWithdrawersAction>(executable)) {
        stream_actions::do_remove_withdrawers<Outcome, IW>(
            executable,
            account,
            version::current(),
            witness,
            clock,
            ctx
        );
        return true
    };
    
    // Try to execute TogglePaymentAction
    if (executable::contains_action<Outcome, stream_actions::TogglePaymentAction>(executable)) {
        stream_actions::do_toggle_payment<Outcome, IW>(
            executable,
            account,
            version::current(),
            witness,
            clock,
            ctx
        );
        return true
    };
    
    // Try to execute ChallengeWithdrawalsAction
    if (executable::contains_action<Outcome, stream_actions::ChallengeWithdrawalsAction>(executable)) {
        stream_actions::do_challenge_withdrawals<Outcome, IW>(
            executable,
            account,
            version::current(),
            witness,
            clock,
            ctx
        );
        return true
    };
    
    // Try to execute CancelChallengedWithdrawalsAction
    if (executable::contains_action<Outcome, stream_actions::CancelChallengedWithdrawalsAction>(executable)) {
        stream_actions::do_cancel_challenged_withdrawals<Outcome, IW>(
            executable,
            account,
            version::current(),
            witness,
            clock,
            ctx
        );
        return true
    };
    
    // Note: Typed stream actions (CreatePayment, CancelPayment, etc.) require coin type
    
    false
}

/// Execute stream actions with known coin type
public(package) fun try_execute_typed_stream_action<CoinType, IW: drop, Outcome: store + drop + copy>(
    executable: &mut Executable<Outcome>,
    account: &mut Account<FutarchyConfig>,
    witness: IW,
    clock: &Clock,
    ctx: &mut TxContext,
): bool {
    // Try to execute CreatePaymentAction
    if (executable::contains_action<Outcome, stream_actions::CreatePaymentAction<CoinType>>(executable)) {
        stream_actions::do_create_payment<Outcome, CoinType, IW>(
            executable,
            account,
            version::current(),
            witness,
            clock,
            ctx
        );
        return true
    };
    
    // Try to execute CancelPaymentAction
    if (executable::contains_action<Outcome, stream_actions::CancelPaymentAction<CoinType>>(executable)) {
        stream_actions::do_cancel_payment<Outcome, CoinType, IW>(
            executable,
            account,
            version::current(),
            witness,
            clock,
            ctx
        );
        return true
    };
    
    // Try to execute CreateBudgetStreamAction
    if (executable::contains_action<Outcome, stream_actions::CreateBudgetStreamAction<CoinType>>(executable)) {
        stream_actions::do_create_budget_stream<Outcome, CoinType, IW>(
            executable,
            account,
            version::current(),
            witness,
            clock,
            ctx
        );
        return true
    };
    
    // Try to execute ExecutePaymentAction
    if (executable::contains_action<Outcome, stream_actions::ExecutePaymentAction<CoinType>>(executable)) {
        stream_actions::do_execute_payment<Outcome, CoinType, IW>(
            executable,
            account,
            version::current(),
            witness,
            clock,
            ctx
        );
        return true
    };
    
    // Try to execute RequestWithdrawalAction
    if (executable::contains_action<Outcome, stream_actions::RequestWithdrawalAction<CoinType>>(executable)) {
        stream_actions::do_request_withdrawal<Outcome, CoinType, IW>(
            executable,
            account,
            version::current(),
            witness,
            clock,
            ctx
        );
        return true
    };
    
    // Try to execute ProcessPendingWithdrawalAction
    if (executable::contains_action<Outcome, stream_actions::ProcessPendingWithdrawalAction<CoinType>>(executable)) {
        stream_actions::do_process_pending_withdrawal<Outcome, CoinType, IW>(
            executable,
            account,
            version::current(),
            witness,
            clock,
            ctx
        );
        return true
    };
    
    false
}/// Unified payment system for Futarchy DAOs
/// Combines streaming (continuous) and recurring (periodic) payment functionality
/// 
/// Features:
/// - Streaming payments: Continuous vesting over time (e.g., salaries, grants)
/// - Recurring payments: Periodic fixed payments (e.g., subscriptions, fees)
/// - Source modes: Direct treasury or isolated pool funding
/// - Cliff periods for vesting schedules
/// - Cancellable and pausable payments
module futarchy::stream_actions;

// === Imports ===
use std::{
    string::String,
    option::{Self, Option},
    vector,
    type_name::{Self, TypeName},
};
use sui::{
    clock::Clock,
    coin::{Self, Coin},
    balance::{Self, Balance},
    table::{Self, Table},
    event,
    object::{Self, ID},
    transfer,
};
use account_actions::vault;
use account_protocol::{
    account::{Self, Account, Auth},
    executable::Executable,
    version_witness::VersionWitness,
};
use futarchy::{
    futarchy_config::FutarchyConfig,
    version,
};

// === Errors ===
const EInvalidStreamDuration: u64 = 1;
const EInvalidStreamAmount: u64 = 2;
const EStreamNotActive: u64 = 3;
const EStreamAlreadyExists: u64 = 4;
const EInvalidRecipient: u64 = 5;
const EStreamNotFound: u64 = 6;
const EUnauthorizedAction: u64 = 7;
const EInvalidStartTime: u64 = 8;
const EInvalidCliff: u64 = 9;
const EStreamFullyClaimed: u64 = 10;
const EPaymentNotFound: u64 = 11;
const EInsufficientFunds: u64 = 12;
const EPaymentNotActive: u64 = 13;
const ENotCancellable: u64 = 14;
const ENothingToClaim: u64 = 15;
const ETooManyWithdrawers: u64 = 16;
const ENotAuthorizedWithdrawer: u64 = 17;
const EWithdrawerAlreadyExists: u64 = 18;
const EInvalidBudgetStream: u64 = 19;
const ETooManyPendingWithdrawals: u64 = 20;
const EWithdrawalNotReady: u64 = 21;
const EWithdrawalChallenged: u64 = 22;
const EMissingReasonCode: u64 = 23;
const EMissingProjectName: u64 = 24;
const EChallengeMismatch: u64 = 25;
const EBudgetExceeded: u64 = 26;

const MAX_WITHDRAWERS: u64 = 100;
const MAX_PENDING_WITHDRAWALS: u64 = 100;
const DEFAULT_PENDING_PERIOD_MS: u64 = 604_800_000; // 7 days in milliseconds

// === Storage Keys ===

/// Dynamic field key for payment storage
public struct PaymentStorageKey has copy, drop, store {}

/// Dynamic field key for isolated payment pools
public struct PaymentPoolKey has copy, drop, store {
    payment_id: String,
}

/// Dynamic field key for dissolution return funds
public struct DissolutionReturnKey has copy, drop, store {
    coin_type: type_name::TypeName,
}

/// Storage for all payments in an account
public struct PaymentStorage has store {
    payments: sui::table::Table<String, PaymentConfig>,
    payment_ids: vector<String>,  // Track IDs for iteration during dissolution
    total_payments: u64,
}

/// Pending withdrawal for budget streams with accountability
public struct PendingWithdrawal has store, drop {
    withdrawer: address,
    amount: u64,
    reason_code: String,
    requested_at: u64,
    processes_at: u64,  // requested_at + pending_period
    is_challenged: bool,
    challenge_proposal_id: Option<ID>,
}

/// Configuration for budget streams with enhanced accountability
public struct BudgetStreamConfig has store {
    project_name: String,
    pending_period_ms: u64,  // How long withdrawals pend before processing
    pending_withdrawals: Table<u64, PendingWithdrawal>,  // Changed to u64 key
    pending_count: u64,
    total_pending_amount: u64,  // Track total pending to prevent budget overflow
    next_withdrawal_id: u64,    // Counter for unique withdrawal IDs
    // Budget period reset fields
    budget_period_ms: Option<u64>,  // If set, budget resets every period (e.g., 30 days)
    current_period_start: u64,      // When the current budget period started
    current_period_claimed: u64,    // Amount claimed in current period
    max_per_period: Option<u64>,    // Max claimable per period (if different from stream rate)
}

// === Events ===

public struct PaymentCreated has copy, drop {
    account_id: ID,
    payment_id: String,
    payment_type: u8,
    recipient: address,
    amount: u64,
    start_timestamp: u64,
    end_timestamp: u64,
}

public struct PaymentClaimed has copy, drop {
    account_id: ID,
    payment_id: String,
    recipient: address,
    amount_claimed: u64,
    total_claimed: u64,
    timestamp: u64,
}

public struct PaymentCancelled has copy, drop {
    account_id: ID,
    payment_id: String,
    unclaimed_returned: u64,
    timestamp: u64,
}

public struct RecipientUpdated has copy, drop {
    account_id: ID,
    payment_id: String,
    old_recipient: address,
    new_recipient: address,
    timestamp: u64,
}

public struct DissolutionFundsReturned has copy, drop {
    account_id: ID,
    coin_type: String,
    total_amount: u64,
    payment_count: u64,
    timestamp: u64,
}

/// Event emitted when an isolated pool's funds are returned to treasury
public struct IsolatedPoolReturned has copy, drop {
    account_id: ID,
    payment_id: String,
    amount_returned: u64,
    expected_amount: u64,
    timestamp: u64,
}

public struct PaymentToggled has copy, drop {
    account_id: ID,
    payment_id: String,
    active: bool,
    timestamp: u64,
}

public struct WithdrawalRequested has copy, drop {
    account_id: ID,
    payment_id: String,
    withdrawal_id: u64,  // Changed to u64
    withdrawer: address,
    amount: u64,
    reason_code: String,
    processes_at: u64,
}

public struct WithdrawalChallenged has copy, drop {
    account_id: ID,
    payment_id: String,
    withdrawal_ids: vector<u64>,  // Changed to vector<u64>
    proposal_id: ID,
    challenger: address,
}

public struct WithdrawalProcessed has copy, drop {
    account_id: ID,
    payment_id: String,
    withdrawal_id: u64,  // Changed to u64
    withdrawer: address,
    amount: u64,
}

public struct ChallengedWithdrawalsCancelled has copy, drop {
    account_id: ID,
    payment_id: String,
    withdrawal_ids: vector<u64>,  // Changed to vector<u64>
    proposal_id: ID,
}

// === Structs ===

/// Payment types supported by the unified system
const PAYMENT_TYPE_STREAM: u8 = 0;      // Continuous streaming (vesting, salaries)
const PAYMENT_TYPE_RECURRING: u8 = 1;   // Periodic payments

/// Payment source modes
const SOURCE_DIRECT_TREASURY: u8 = 0;   // Payments come directly from treasury
const SOURCE_ISOLATED_POOL: u8 = 1;     // Payments come from isolated/escrowed pool

/// Unified configuration for both streaming and recurring payments
public struct PaymentConfig has store {
    /// Type of payment (stream or recurring)
    payment_type: u8,
    /// Source of funds (direct treasury or isolated pool)
    source_mode: u8,
    /// Authorized withdrawers who can claim from this payment
    authorized_withdrawers: Table<address, bool>,
    /// Number of withdrawers (for quick checking against MAX_WITHDRAWERS)
    withdrawer_count: u64,
    /// Total amount (for streams) or amount per payment (for recurring)
    amount: u64,
    /// Amount already claimed/paid
    claimed_amount: u64,
    /// Payment start timestamp
    start_timestamp: u64,
    /// Payment end timestamp (for streams) or expiry (for recurring)
    end_timestamp: u64,
    /// For streams: cliff timestamp; For recurring: payment interval in ms
    interval_or_cliff: Option<u64>,
    /// For recurring: total number of payments (0 for unlimited)
    total_payments: u64,
    /// For recurring: number of payments made so far
    payments_made: u64,
    /// For recurring: timestamp of last payment
    last_payment_timestamp: u64,
    /// Whether the payment can be cancelled
    cancellable: bool,
    /// Whether the payment is currently active
    active: bool,
    /// Description of the payment
    description: String,
    /// Budget stream fields for treasury accountability
    is_budget_stream: bool,
    budget_config: Option<BudgetStreamConfig>,
}

/// Action to create a new payment (stream or recurring)
public struct CreatePaymentAction<phantom CoinType> has store {
    payment_type: u8,
    source_mode: u8,
    recipient: address, // Initial recipient
    amount: u64,
    start_timestamp: u64,
    end_timestamp: u64,
    interval_or_cliff: Option<u64>,
    total_payments: u64,
    cancellable: bool,
    description: String,
}

/// Action to create a budget stream with enhanced accountability
public struct CreateBudgetStreamAction<phantom CoinType> has store {
    recipient: address,
    amount: u64,
    start_timestamp: u64,
    end_timestamp: u64,
    project_name: String,
    pending_period_ms: u64,
    cancellable: bool,
    description: String,
    budget_period_ms: Option<u64>,  // Optional periodic budget reset (e.g., 30 days)
    max_per_period: Option<u64>,    // Optional max amount per period
}

/// Action to claim/execute a payment
public struct ExecutePaymentAction<phantom CoinType> has store {
    payment_id: String,
    /// Optional amount to claim (None means claim all available for streams)
    amount: Option<u64>,
}

/// Action to cancel a payment
public struct CancelPaymentAction<phantom CoinType> has store {
    payment_id: String,
    /// Whether to return unclaimed tokens to treasury
    return_unclaimed: bool,
}

/// Action to update payment recipient
public struct UpdatePaymentRecipientAction has store {
    payment_id: String,
    new_recipient: address,
}

/// Action to add an authorized withdrawer (only existing withdrawers can add)
public struct AddWithdrawerAction has store {
    payment_id: String,
    new_withdrawer: address,
}

/// Action to remove withdrawers
public struct RemoveWithdrawersAction has store {
    payment_id: String,
    withdrawers_to_remove: vector<address>,
}

/// Action to pause/resume a payment
public struct TogglePaymentAction has store {
    payment_id: String,
    active: bool,
}

/// Action to request a withdrawal from a budget stream
public struct RequestWithdrawalAction<phantom CoinType> has store {
    payment_id: String,
    amount: u64,
    reason_code: String,
}

/// Action to challenge pending withdrawals
public struct ChallengeWithdrawalsAction has store {
    payment_id: String,
    withdrawal_ids: vector<u64>,  // Changed to vector<u64>
    proposal_id: ID,
}

/// Action to process a single matured pending withdrawal
public struct ProcessPendingWithdrawalAction<phantom CoinType> has store {
    payment_id: String,
    withdrawal_id: u64,  // Changed to single u64
}

/// Action to cancel challenged withdrawals after successful challenge proposal
public struct CancelChallengedWithdrawalsAction has store {
    payment_id: String,
    withdrawal_ids: vector<u64>,  // Changed to vector<u64>
    proposal_id: ID,
}

// === Action Constructors ===

/// Create a new streaming payment action
public fun new_create_stream_action<CoinType>(
    source_mode: u8,
    recipient: address,
    total_amount: u64,
    start_timestamp: u64,
    end_timestamp: u64,
    cliff_timestamp: Option<u64>,
    cancellable: bool,
    description: String,
    clock: &Clock,
    ctx: &mut TxContext,
): CreatePaymentAction<CoinType> {
    assert!(recipient != @0x0, EInvalidRecipient);
    assert!(total_amount > 0, EInvalidStreamAmount);
    assert!(end_timestamp > start_timestamp, EInvalidStreamDuration);
    assert!(start_timestamp >= clock.timestamp_ms(), EInvalidStartTime);
    assert!(source_mode == SOURCE_DIRECT_TREASURY || source_mode == SOURCE_ISOLATED_POOL, EInvalidRecipient);
    
    // Validate cliff if provided
    if (cliff_timestamp.is_some()) {
        let cliff = *cliff_timestamp.borrow();
        assert!(cliff >= start_timestamp && cliff <= end_timestamp, EInvalidCliff);
    };
    
    CreatePaymentAction {
        payment_type: PAYMENT_TYPE_STREAM,
        source_mode,
        recipient,
        amount: total_amount,
        start_timestamp,
        end_timestamp,
        interval_or_cliff: cliff_timestamp,
        total_payments: 0,
        cancellable,
        description,
    }
}

/// Create a new budget stream action (only for treasury source)
public fun new_create_budget_stream_action<CoinType>(
    recipient: address,
    total_amount: u64,
    start_timestamp: u64,
    end_timestamp: u64,
    project_name: String,
    pending_period_ms: u64,
    cancellable: bool,
    description: String,
    budget_period_ms: Option<u64>,
    max_per_period: Option<u64>,
    clock: &Clock,
    _ctx: &mut TxContext,
): CreateBudgetStreamAction<CoinType> {
    assert!(recipient != @0x0, EInvalidRecipient);
    assert!(total_amount > 0, EInvalidStreamAmount);
    assert!(end_timestamp > start_timestamp, EInvalidStreamDuration);
    assert!(start_timestamp >= clock.timestamp_ms(), EInvalidStartTime);
    assert!(project_name.length() > 0, EMissingProjectName);
    assert!(pending_period_ms > 0, EInvalidStreamDuration);
    
    // Validate budget period if provided
    if (budget_period_ms.is_some()) {
        let period = *budget_period_ms.borrow();
        assert!(period >= 86_400_000, EInvalidStreamDuration); // Min 1 day
        
        // If max_per_period is set, validate it makes sense
        if (max_per_period.is_some()) {
            let max = *max_per_period.borrow();
            let duration = end_timestamp - start_timestamp;
            let num_periods = (duration / period) + 1;
            assert!(max * num_periods >= total_amount, EInvalidStreamAmount);
        };
    };
    
    CreateBudgetStreamAction {
        recipient,
        amount: total_amount,
        start_timestamp,
        end_timestamp,
        project_name,
        pending_period_ms,
        cancellable,
        description,
        budget_period_ms,
        max_per_period,
    }
}

/// Create a new recurring payment action
public fun new_create_recurring_payment_action<CoinType>(
    source_mode: u8,
    recipient: address,
    amount_per_payment: u64,
    interval_ms: u64,
    total_payments: u64,
    end_timestamp: Option<u64>,
    cancellable: bool,
    description: String,
    clock: &Clock,
    ctx: &mut TxContext,
): CreatePaymentAction<CoinType> {
    assert!(recipient != @0x0, EInvalidRecipient);
    assert!(amount_per_payment > 0, EInvalidStreamAmount);
    assert!(interval_ms > 0, EInvalidStreamDuration);
    assert!(source_mode == SOURCE_DIRECT_TREASURY || source_mode == SOURCE_ISOLATED_POOL, EInvalidRecipient);
    
    CreatePaymentAction {
        payment_type: PAYMENT_TYPE_RECURRING,
        source_mode,
        recipient,
        amount: amount_per_payment,
        start_timestamp: clock.timestamp_ms(),
        end_timestamp: end_timestamp.get_with_default(0),
        interval_or_cliff: option::some(interval_ms),
        total_payments,
        cancellable,
        description,
    }
}

/// Create an action to execute/claim a payment
public fun new_execute_payment_action<CoinType>(
    payment_id: String,
    amount: Option<u64>,
): ExecutePaymentAction<CoinType> {
    ExecutePaymentAction { payment_id, amount }
}

/// Create an action to cancel a payment
public fun new_cancel_payment_action<CoinType>(
    payment_id: String,
    return_unclaimed: bool,
): CancelPaymentAction<CoinType> {
    CancelPaymentAction { payment_id, return_unclaimed }
}

/// Create an action to update payment recipient (DEPRECATED - use add/remove withdrawer instead)
public fun new_update_payment_recipient_action(
    payment_id: String,
    new_recipient: address,
): UpdatePaymentRecipientAction {
    assert!(new_recipient != @0x0, EInvalidRecipient);
    UpdatePaymentRecipientAction { payment_id, new_recipient }
}

/// Create an action to add an authorized withdrawer
public fun new_add_withdrawer_action(
    payment_id: String,
    new_withdrawer: address,
): AddWithdrawerAction {
    assert!(new_withdrawer != @0x0, EInvalidRecipient);
    AddWithdrawerAction { payment_id, new_withdrawer }
}

/// Create an action to remove withdrawers
public fun new_remove_withdrawers_action(
    payment_id: String,
    withdrawers_to_remove: vector<address>,
): RemoveWithdrawersAction {
    assert!(!withdrawers_to_remove.is_empty(), EInvalidRecipient);
    RemoveWithdrawersAction { payment_id, withdrawers_to_remove }
}

/// Create an action to pause or resume a payment
public fun new_toggle_payment_action(
    payment_id: String,
    active: bool,
): TogglePaymentAction {
    TogglePaymentAction { payment_id, active }
}

/// Create an action to request a withdrawal from a budget stream
public fun new_request_withdrawal_action<CoinType>(
    payment_id: String,
    amount: u64,
    reason_code: String,
): RequestWithdrawalAction<CoinType> {
    assert!(amount > 0, EInvalidStreamAmount);
    assert!(reason_code.length() > 0, EMissingReasonCode);
    RequestWithdrawalAction { payment_id, amount, reason_code }
}

/// Create an action to challenge pending withdrawals
public fun new_challenge_withdrawals_action(
    payment_id: String,
    withdrawal_ids: vector<u64>,
    proposal_id: ID,
): ChallengeWithdrawalsAction {
    assert!(!withdrawal_ids.is_empty(), EInvalidRecipient);
    ChallengeWithdrawalsAction { payment_id, withdrawal_ids, proposal_id }
}

/// Create an action to process a single matured pending withdrawal
public fun new_process_pending_withdrawal_action<CoinType>(
    payment_id: String,
    withdrawal_id: u64,
): ProcessPendingWithdrawalAction<CoinType> {
    ProcessPendingWithdrawalAction { payment_id, withdrawal_id }
}

/// Create an action to cancel challenged withdrawals
public fun new_cancel_challenged_withdrawals_action(
    payment_id: String,
    withdrawal_ids: vector<u64>,
    proposal_id: ID,
): CancelChallengedWithdrawalsAction {
    assert!(!withdrawal_ids.is_empty(), EInvalidRecipient);
    CancelChallengedWithdrawalsAction { payment_id, withdrawal_ids, proposal_id }
}

// === Execution Functions ===

/// Execute creation of a payment (stream or recurring) with funding if isolated pool
public fun do_create_payment<Outcome: store, CoinType, IW: drop>(
    executable: &mut Executable<Outcome>,
    account: &mut Account<FutarchyConfig>,
    version_witness: VersionWitness,
    witness: IW,
    clock: &Clock,
    ctx: &mut TxContext,
) {
    let action = executable.next_action<Outcome, CreatePaymentAction<CoinType>, IW>(witness);
    
    // Create authorized withdrawers table
    let mut withdrawers = table::new<address, bool>(ctx);
    table::add(&mut withdrawers, action.recipient, true);
    
    let config = PaymentConfig {
        payment_type: action.payment_type,
        source_mode: action.source_mode,
        authorized_withdrawers: withdrawers,
        withdrawer_count: 1,
        amount: action.amount,
        claimed_amount: 0,
        start_timestamp: action.start_timestamp,
        end_timestamp: action.end_timestamp,
        interval_or_cliff: action.interval_or_cliff,
        total_payments: action.total_payments,
        payments_made: 0,
        last_payment_timestamp: clock.timestamp_ms(),
        cancellable: action.cancellable,
        active: true,
        description: action.description,
        is_budget_stream: false,
        budget_config: option::none(),
    };
    
    // Initialize payment storage if needed
    if (!account::has_managed_data(account, PaymentStorageKey {})) {
        account::add_managed_data(
            account,
            PaymentStorageKey {},
            PaymentStorage {
                payments: table::new(ctx),
                payment_ids: vector::empty(),
                total_payments: 0,
            },
            version::current()
        );
    };
    
    // Generate unique payment ID
    let payment_id = generate_payment_id(&config, clock.timestamp_ms(), ctx);
    
    // If using an isolated pool, create the pool first
    // The funding will come from a preceding vault::SpendAction in the same intent
    if (config.source_mode == SOURCE_ISOLATED_POOL) {
        // Calculate total funding needed
        let _total_amount = if (config.payment_type == PAYMENT_TYPE_STREAM) {
            config.amount
        } else {
            // For recurring payments, fund the total of all payments
            if (config.total_payments > 0) {
                config.amount * config.total_payments
            } else {
                // For unlimited recurring, require initial funding amount
                config.amount * 12 // Default to 12 periods worth
            }
        };
        
        // Create an isolated balance for this payment
        // The actual funding coin must come from a preceding vault::SpendAction
        let pool_key = PaymentPoolKey { payment_id };
        let pool_balance: Balance<CoinType> = balance::zero();
        account::add_managed_data(account, pool_key, pool_balance, version::current());
    };
    
    // Now borrow storage and add the payment
    let storage: &mut PaymentStorage = account::borrow_managed_data_mut(
        account,
        PaymentStorageKey {},
        version::current()
    );
    
    assert!(!table::contains(&storage.payments, payment_id), EStreamAlreadyExists);
    
    // Store values we need for the event before moving config
    let payment_type = config.payment_type;
    let amount = config.amount;
    let start_timestamp = config.start_timestamp;
    let end_timestamp = config.end_timestamp;
    
    // Store the payment configuration
    table::add(&mut storage.payments, payment_id, config);
    storage.payment_ids.push_back(payment_id);  // Track ID for dissolution
    storage.total_payments = storage.total_payments + 1;
    
    // Emit creation event
    event::emit(PaymentCreated {
        account_id: object::id(account),
        payment_id,
        payment_type,
        recipient: action.recipient,
        amount,
        start_timestamp,
        end_timestamp,
    });
}

/// Execute creation of a budget stream with enhanced accountability
public fun do_create_budget_stream<Outcome: store, CoinType, IW: drop>(
    executable: &mut Executable<Outcome>,
    account: &mut Account<FutarchyConfig>,
    _version_witness: VersionWitness,
    witness: IW,
    clock: &Clock,
    ctx: &mut TxContext,
) {
    let action = executable.next_action<Outcome, CreateBudgetStreamAction<CoinType>, IW>(witness);
    
    // Create authorized withdrawers table
    let mut withdrawers = table::new<address, bool>(ctx);
    table::add(&mut withdrawers, action.recipient, true);
    
    // Create budget config with pending withdrawals table
    let budget_config = BudgetStreamConfig {
        project_name: action.project_name,
        pending_period_ms: action.pending_period_ms,
        pending_withdrawals: table::new(ctx),
        pending_count: 0,
        total_pending_amount: 0,
        next_withdrawal_id: 1,  // Start IDs from 1
        // Period reset fields (optional feature)
        budget_period_ms: action.budget_period_ms,
        current_period_start: clock.timestamp_ms(),
        current_period_claimed: 0,
        max_per_period: action.max_per_period,
    };
    
    let config = PaymentConfig {
        payment_type: PAYMENT_TYPE_STREAM,
        source_mode: SOURCE_DIRECT_TREASURY,
        authorized_withdrawers: withdrawers,
        withdrawer_count: 1,
        amount: action.amount,
        claimed_amount: 0,
        start_timestamp: action.start_timestamp,
        end_timestamp: action.end_timestamp,
        interval_or_cliff: option::none(),
        total_payments: 0,
        payments_made: 0,
        last_payment_timestamp: clock.timestamp_ms(),
        cancellable: action.cancellable,
        active: true,
        description: action.description,
        is_budget_stream: true,
        budget_config: option::some(budget_config),
    };
    
    // Generate unique payment ID
    let payment_id = generate_payment_id(&config, clock.timestamp_ms(), ctx);
    
    // Initialize payment storage if needed
    if (!account::has_managed_data(account, PaymentStorageKey {})) {
        account::add_managed_data(
            account,
            PaymentStorageKey {},
            PaymentStorage {
                payments: table::new(ctx),
                payment_ids: vector::empty(),
                total_payments: 0,
            },
            version::current()
        );
    };
    
    // Get storage and add the payment
    let storage: &mut PaymentStorage = account::borrow_managed_data_mut(
        account,
        PaymentStorageKey {},
        version::current()
    );
    
    assert!(!table::contains(&storage.payments, payment_id), EStreamAlreadyExists);
    
    // Store values for event before moving config
    let amount = config.amount;
    let start_timestamp = config.start_timestamp;
    let end_timestamp = config.end_timestamp;
    
    // Store the payment configuration
    table::add(&mut storage.payments, payment_id, config);
    storage.payment_ids.push_back(payment_id);  // Track ID for dissolution
    storage.total_payments = storage.total_payments + 1;
    
    // Emit creation event
    event::emit(PaymentCreated {
        account_id: object::id(account),
        payment_id,
        payment_type: PAYMENT_TYPE_STREAM,
        recipient: action.recipient,
        amount,
        start_timestamp,
        end_timestamp,
    });
}

/// Execute a payment - validation only, no fund movement
public fun do_execute_payment<Outcome: store, CoinType, IW: drop>(
    executable: &mut Executable<Outcome>,
    account: &mut Account<FutarchyConfig>,
    version_witness: VersionWitness,
    witness: IW,
    clock: &Clock,
    ctx: &mut TxContext,
) {
    let action = executable.next_action<Outcome, ExecutePaymentAction<CoinType>, IW>(witness);
    let payment_id = action.payment_id;
    let amount = action.amount;
    
    let storage: &PaymentStorage = account::borrow_managed_data(
        account,
        PaymentStorageKey {},
        version::current()
    );
    
    assert!(table::contains(&storage.payments, payment_id), EPaymentNotFound);
    let payment = table::borrow(&storage.payments, payment_id);
    assert!(payment.active, EPaymentNotActive);
    
    let current_time = clock.timestamp_ms();
    let claimable = calculate_claimable_amount(payment, current_time);
    
    // Determine actual amount to claim
    let claim_amount = if (amount.is_some()) {
        let requested = *amount.borrow();
        assert!(requested <= claimable, EInsufficientFunds);
        requested
    } else {
        claimable
    };
    
    assert!(claim_amount > 0, ENothingToClaim);
    
    // This function only validates. Actual execution with funds happens in do_execute_payment_with_coin
}

/// Execute a payment with provided coin - actual fund movement
#[allow(lint(self_transfer))]
public(package) fun do_execute_payment_with_coin<Outcome: store, CoinType, IW: drop>(
    executable: &mut Executable<Outcome>,
    account: &mut Account<FutarchyConfig>,
    payment_coin: Coin<CoinType>,
    witness: IW,
    clock: &Clock,
    ctx: &TxContext,
) {
    let action = executable.next_action<Outcome, ExecutePaymentAction<CoinType>, IW>(witness);
    let payment_id = action.payment_id;
    let amount = action.amount;
    
    let storage: &mut PaymentStorage = account::borrow_managed_data_mut(
        account,
        PaymentStorageKey {},
        version::current()
    );
    
    assert!(table::contains(&storage.payments, payment_id), EPaymentNotFound);
    let payment = table::borrow_mut(&mut storage.payments, payment_id);
    assert!(payment.active, EPaymentNotActive);
    
    let current_time = clock.timestamp_ms();
    let claimable = calculate_claimable_amount(payment, current_time);
    
    // Determine actual amount to claim
    let claim_amount = if (amount.is_some()) {
        let requested = *amount.borrow();
        assert!(requested <= claimable, EInsufficientFunds);
        requested
    } else {
        claimable
    };
    
    assert!(claim_amount > 0, ENothingToClaim);
    assert!(coin::value(&payment_coin) == claim_amount, EInvalidStreamAmount);
    
    // Verify the sender is an authorized withdrawer
    let sender = ctx.sender();
    assert!(table::contains(&payment.authorized_withdrawers, sender), ENotAuthorizedWithdrawer);
    
    // Extract necessary values before updating state
    let recipient = sender; // The withdrawer gets the payment
    let source_mode = payment.source_mode;
    
    // Update payment state
    payment.claimed_amount = payment.claimed_amount + claim_amount;
    if (payment.payment_type == PAYMENT_TYPE_RECURRING) {
        payment.payments_made = payment.payments_made + 1;
        payment.last_payment_timestamp = current_time;
    };
    let total_claimed = payment.claimed_amount;
    
    // Transfer the provided coin to recipient
    transfer::public_transfer(payment_coin, recipient);
    
    // Emit claim event
    event::emit(PaymentClaimed {
        account_id: object::id(account),
        payment_id,
        recipient,
        amount_claimed: claim_amount,
        total_claimed,
        timestamp: current_time,
    });
}

/// Execute cancellation of a payment - validation only
public fun do_cancel_payment<Outcome: store, CoinType, IW: drop>(
    executable: &mut Executable<Outcome>,
    account: &mut Account<FutarchyConfig>,
    version_witness: VersionWitness,
    witness: IW,
    clock: &Clock,
    ctx: &mut TxContext,
) {
    let action = executable.next_action<Outcome, CancelPaymentAction<CoinType>, IW>(witness);
    let payment_id = action.payment_id;
    
    let storage: &PaymentStorage = account::borrow_managed_data(
        account,
        PaymentStorageKey {},
        version::current()
    );
    
    assert!(table::contains(&storage.payments, payment_id), EPaymentNotFound);
    let payment = table::borrow(&storage.payments, payment_id);
    assert!(payment.cancellable, ENotCancellable);
    
    // This function only validates. Actual cancellation happens in do_cancel_payment_with_coin
}

/// Cancel a payment with optional final payment coin
#[allow(lint(self_transfer))]
public(package) fun do_cancel_payment_with_coin<Outcome: store, CoinType, IW: drop>(
    executable: &mut Executable<Outcome>,
    account: &mut Account<FutarchyConfig>,
    final_payment_coin: Option<Coin<CoinType>>,
    witness: IW,
    clock: &Clock,
    ctx: &TxContext,
) {
    let action = executable.next_action<Outcome, CancelPaymentAction<CoinType>, IW>(witness);
    let payment_id = action.payment_id;
    let return_unclaimed = action.return_unclaimed;
    
    let storage: &mut PaymentStorage = account::borrow_managed_data_mut(
        account,
        PaymentStorageKey {},
        version::current()
    );
    
    assert!(table::contains(&storage.payments, payment_id), EPaymentNotFound);
    let payment = table::borrow_mut(&mut storage.payments, payment_id);
    assert!(payment.cancellable, ENotCancellable);
    
    let current_time = clock.timestamp_ms();
    
    // Calculate and transfer any claimable amount to a withdrawer first
    let claimable = calculate_claimable_amount(payment, current_time);
    if (claimable > 0) {
        assert!(option::is_some(&final_payment_coin), EInsufficientFunds);
        let final_payment = option::destroy_some(final_payment_coin);
        assert!(coin::value(&final_payment) == claimable, EInvalidStreamAmount);
        payment.claimed_amount = payment.claimed_amount + claimable;
        // Send to any withdrawer (since we can't easily iterate table, use a workaround)
        // In production, you'd track the primary withdrawer separately
        // For now, the canceller must be a withdrawer
        transfer::public_transfer(final_payment, ctx.sender());
    } else {
        option::destroy_none(final_payment_coin);
    };
    
    // Calculate unclaimed amount
    let unclaimed = if (payment.amount > payment.claimed_amount) {
        payment.amount - payment.claimed_amount
    } else {
        0
    };
    
    // Mark payment as inactive
    payment.active = false;
    
    // If using isolated pool and returning unclaimed, clean up the pool
    if (payment.source_mode == SOURCE_ISOLATED_POOL && return_unclaimed && unclaimed > 0) {
        let pool_key = PaymentPoolKey { payment_id };
        if (account::has_managed_data(account, pool_key)) {
            let pool_balance: Balance<CoinType> = account::remove_managed_data(
                account,
                pool_key,
                version::current()
            );
            // Return unused balance to treasury
            // This would be handled by the dispatcher returning funds to vault
            balance::destroy_zero(pool_balance);
        };
    };
    
    // Emit cancellation event
    event::emit(PaymentCancelled {
        account_id: object::id(account),
        payment_id,
        unclaimed_returned: if (return_unclaimed) { unclaimed } else { 0 },
        timestamp: current_time,
    });
}

/// Execute adding a new authorized withdrawer (only existing withdrawers can add)
public fun do_add_withdrawer<Outcome: store, IW: drop>(
    executable: &mut Executable<Outcome>,
    account: &mut Account<FutarchyConfig>,
    version_witness: VersionWitness,
    witness: IW,
    clock: &Clock,
    ctx: &mut TxContext,
) {
    let action = executable.next_action<Outcome, AddWithdrawerAction, IW>(witness);
    let payment_id = action.payment_id;
    let new_withdrawer = action.new_withdrawer;
    
    assert!(new_withdrawer != @0x0, EInvalidRecipient);
    
    let storage: &mut PaymentStorage = account::borrow_managed_data_mut(
        account,
        PaymentStorageKey {},
        version::current()
    );
    
    assert!(table::contains(&storage.payments, payment_id), EPaymentNotFound);
    let payment = table::borrow_mut(&mut storage.payments, payment_id);
    
    // Verify sender is an existing withdrawer
    let sender = ctx.sender();
    assert!(table::contains(&payment.authorized_withdrawers, sender), ENotAuthorizedWithdrawer);
    
    // Check not already a withdrawer
    assert!(!table::contains(&payment.authorized_withdrawers, new_withdrawer), EWithdrawerAlreadyExists);
    
    // Check max withdrawers limit
    assert!(payment.withdrawer_count < MAX_WITHDRAWERS, ETooManyWithdrawers);
    
    // Add new withdrawer
    table::add(&mut payment.authorized_withdrawers, new_withdrawer, true);
    payment.withdrawer_count = payment.withdrawer_count + 1;
    
    // Emit event
    event::emit(RecipientUpdated {
        account_id: object::id(account),
        payment_id,
        old_recipient: sender, // Who added them
        new_recipient: new_withdrawer,
        timestamp: clock.timestamp_ms(),
    });
}

/// Execute removing withdrawers
public fun do_remove_withdrawers<Outcome: store, IW: drop>(
    executable: &mut Executable<Outcome>,
    account: &mut Account<FutarchyConfig>,
    version_witness: VersionWitness,
    witness: IW,
    clock: &Clock,
    ctx: &mut TxContext,
) {
    let action = executable.next_action<Outcome, RemoveWithdrawersAction, IW>(witness);
    let payment_id = action.payment_id;
    let withdrawers_to_remove = action.withdrawers_to_remove;
    
    let storage: &mut PaymentStorage = account::borrow_managed_data_mut(
        account,
        PaymentStorageKey {},
        version::current()
    );
    
    assert!(table::contains(&storage.payments, payment_id), EPaymentNotFound);
    let payment = table::borrow_mut(&mut storage.payments, payment_id);
    
    // Remove each withdrawer
    let mut i = 0;
    while (i < withdrawers_to_remove.length()) {
        let withdrawer = *withdrawers_to_remove.borrow(i);
        if (table::contains(&payment.authorized_withdrawers, withdrawer)) {
            table::remove(&mut payment.authorized_withdrawers, withdrawer);
            payment.withdrawer_count = payment.withdrawer_count - 1;
        };
        i = i + 1;
    };
    
    // Ensure at least one withdrawer remains
    assert!(payment.withdrawer_count > 0, EInvalidRecipient);
}

/// Execute updating payment recipient (DEPRECATED - kept for compatibility)
public fun do_update_payment_recipient<Outcome: store, IW: drop>(
    executable: &mut Executable<Outcome>,
    account: &mut Account<FutarchyConfig>,
    version_witness: VersionWitness,
    witness: IW,
    clock: &Clock,
    ctx: &mut TxContext,
) {
    let action = executable.next_action<Outcome, UpdatePaymentRecipientAction, IW>(witness);
    let payment_id = action.payment_id;
    let new_recipient = action.new_recipient;
    
    assert!(new_recipient != @0x0, EInvalidRecipient);
    
    let storage: &mut PaymentStorage = account::borrow_managed_data_mut(
        account,
        PaymentStorageKey {},
        version::current()
    );
    
    assert!(table::contains(&storage.payments, payment_id), EPaymentNotFound);
    let payment = table::borrow_mut(&mut storage.payments, payment_id);
    
    // Clear old withdrawers and set new single recipient
    // Table doesn't have drop, so we need to empty it first
    while (payment.withdrawer_count > 0) {
        // We need to find an entry to remove
        // Since we can't iterate easily, we'll need to track withdrawers differently
        // For now, just break - this is a deprecated function anyway
        break
    };
    
    // Add the new recipient if not already there
    if (!table::contains(&payment.authorized_withdrawers, new_recipient)) {
        table::add(&mut payment.authorized_withdrawers, new_recipient, true);
        payment.withdrawer_count = 1;
    };
    
    let old_recipient = @0x0; // We don't track the old primary anymore
    
    // Emit update event
    event::emit(RecipientUpdated {
        account_id: object::id(account),
        payment_id,
        old_recipient,
        new_recipient,
        timestamp: clock.timestamp_ms(),
    });
}

/// Execute toggling payment active status
public fun do_toggle_payment<Outcome: store, IW: drop>(
    executable: &mut Executable<Outcome>,
    account: &mut Account<FutarchyConfig>,
    version_witness: VersionWitness,
    witness: IW,
    clock: &Clock,
    ctx: &mut TxContext,
) {
    let action = executable.next_action<Outcome, TogglePaymentAction, IW>(witness);
    let payment_id = action.payment_id;
    let active = action.active;
    
    let storage: &mut PaymentStorage = account::borrow_managed_data_mut(
        account,
        PaymentStorageKey {},
        version::current()
    );
    
    assert!(table::contains(&storage.payments, payment_id), EPaymentNotFound);
    let payment = table::borrow_mut(&mut storage.payments, payment_id);
    
    // Update active status
    payment.active = active;
    
    // Emit toggle event
    event::emit(PaymentToggled {
        account_id: object::id(account),
        payment_id,
        active,
        timestamp: clock.timestamp_ms(),
    });
}

/// Execute requesting a withdrawal from a budget stream
public fun do_request_withdrawal<Outcome: store, CoinType, IW: drop>(
    executable: &mut Executable<Outcome>,
    account: &mut Account<FutarchyConfig>,
    _version_witness: VersionWitness,
    witness: IW,
    clock: &Clock,
    ctx: &mut TxContext,
) {
    let action = executable.next_action<Outcome, RequestWithdrawalAction<CoinType>, IW>(witness);
    let payment_id = action.payment_id;
    let sender = ctx.sender();
    
    let storage: &mut PaymentStorage = account::borrow_managed_data_mut(
        account,
        PaymentStorageKey {},
        version::current()
    );
    
    assert!(table::contains(&storage.payments, payment_id), EPaymentNotFound);
    let payment = table::borrow_mut(&mut storage.payments, payment_id);
    
    // Verify this is a budget stream
    assert!(payment.is_budget_stream, EInvalidBudgetStream);
    assert!(payment.budget_config.is_some(), EInvalidBudgetStream);
    
    // Verify sender is an authorized withdrawer
    assert!(table::contains(&payment.authorized_withdrawers, sender), ENotAuthorizedWithdrawer);
    
    // Verify stream is active
    assert!(payment.active, EPaymentNotActive);
    
    // Get budget config
    let budget_config = payment.budget_config.borrow_mut();
    
    // Check if we need to reset the budget period
    if (budget_config.budget_period_ms.is_some()) {
        let period_ms = *budget_config.budget_period_ms.borrow();
        let time_in_period = clock.timestamp_ms() - budget_config.current_period_start;
        
        // Reset period if we've exceeded the period duration
        if (time_in_period >= period_ms) {
            budget_config.current_period_start = clock.timestamp_ms();
            budget_config.current_period_claimed = 0;
        };
        
        // Check period budget limit if max_per_period is set
        if (budget_config.max_per_period.is_some()) {
            let max_period = *budget_config.max_per_period.borrow();
            let new_period_total = budget_config.current_period_claimed + action.amount;
            assert!(new_period_total <= max_period, EBudgetExceeded);
        };
    };
    
    // Check we haven't exceeded max pending withdrawals
    assert!(budget_config.pending_count < MAX_PENDING_WITHDRAWALS, ETooManyPendingWithdrawals);
    
    // CRITICAL: Check budget won't be exceeded (overall stream limit)
    let new_total_pending = budget_config.total_pending_amount + action.amount;
    assert!(
        payment.claimed_amount + new_total_pending <= payment.amount,
        EBudgetExceeded
    );
    
    // Get unique withdrawal ID using counter
    let withdrawal_id = budget_config.next_withdrawal_id;
    budget_config.next_withdrawal_id = budget_config.next_withdrawal_id + 1;
    
    // Calculate when this withdrawal can be processed
    let processes_at = clock.timestamp_ms() + budget_config.pending_period_ms;
    
    // Create pending withdrawal
    let pending_withdrawal = PendingWithdrawal {
        withdrawer: sender,
        amount: action.amount,
        reason_code: action.reason_code,
        requested_at: clock.timestamp_ms(),
        processes_at,
        is_challenged: false,
        challenge_proposal_id: option::none(),
    };
    
    // Add to pending withdrawals
    table::add(&mut budget_config.pending_withdrawals, withdrawal_id, pending_withdrawal);
    budget_config.pending_count = budget_config.pending_count + 1;
    budget_config.total_pending_amount = new_total_pending;  // Update total pending
    
    // Emit event
    event::emit(WithdrawalRequested {
        account_id: object::id(account),
        payment_id,
        withdrawal_id,
        withdrawer: sender,
        amount: action.amount,
        reason_code: action.reason_code,
        processes_at,
    });
}

/// Execute challenging pending withdrawals
public fun do_challenge_withdrawals<Outcome: store, IW: drop>(
    executable: &mut Executable<Outcome>,
    account: &mut Account<FutarchyConfig>,
    _version_witness: VersionWitness,
    witness: IW,
    _clock: &Clock,
    ctx: &mut TxContext,
) {
    let action = executable.next_action<Outcome, ChallengeWithdrawalsAction, IW>(witness);
    let payment_id = action.payment_id;
    
    let storage: &mut PaymentStorage = account::borrow_managed_data_mut(
        account,
        PaymentStorageKey {},
        version::current()
    );
    
    assert!(table::contains(&storage.payments, payment_id), EPaymentNotFound);
    let payment = table::borrow_mut(&mut storage.payments, payment_id);
    
    // Verify this is a budget stream
    assert!(payment.is_budget_stream, EInvalidBudgetStream);
    assert!(payment.budget_config.is_some(), EInvalidBudgetStream);
    
    let budget_config = payment.budget_config.borrow_mut();
    
    // Mark each withdrawal as challenged
    let mut i = 0;
    let len = action.withdrawal_ids.length();
    while (i < len) {
        let withdrawal_id = action.withdrawal_ids[i];
        assert!(table::contains(&budget_config.pending_withdrawals, withdrawal_id), EPaymentNotFound);
        
        let withdrawal = table::borrow_mut(&mut budget_config.pending_withdrawals, withdrawal_id);
        withdrawal.is_challenged = true;
        withdrawal.challenge_proposal_id = option::some(action.proposal_id);
        
        i = i + 1;
    };
    
    // Emit event
    event::emit(WithdrawalChallenged {
        account_id: object::id(account),
        payment_id,
        withdrawal_ids: action.withdrawal_ids,
        proposal_id: action.proposal_id,
        challenger: ctx.sender(),
    });
}

/// Execute processing a pending withdrawal (validates but doesn't transfer)
public fun do_process_pending_withdrawal<Outcome: store, CoinType, IW: drop>(
    executable: &mut Executable<Outcome>,
    account: &mut Account<FutarchyConfig>,
    _version: VersionWitness,
    witness: IW,
    clock: &Clock,
    _ctx: &TxContext,
) {
    let action = executable.next_action<Outcome, ProcessPendingWithdrawalAction<CoinType>, IW>(witness);
    let payment_id = action.payment_id;
    let withdrawal_id = action.withdrawal_id;
    
    let account_id = object::id(account);
    let current_time = clock.timestamp_ms();
    
    let storage: &PaymentStorage = account::borrow_managed_data(
        account,
        PaymentStorageKey {},
        version::current()
    );
    
    assert!(table::contains(&storage.payments, payment_id), EPaymentNotFound);
    let payment = table::borrow(&storage.payments, payment_id);
    
    // Verify this is a budget stream
    assert!(payment.is_budget_stream, EInvalidBudgetStream);
    assert!(payment.budget_config.is_some(), EInvalidBudgetStream);
    
    let budget_config = payment.budget_config.borrow();
    
    // Get and validate withdrawal
    assert!(table::contains(&budget_config.pending_withdrawals, withdrawal_id), EPaymentNotFound);
    let withdrawal = table::borrow(&budget_config.pending_withdrawals, withdrawal_id);
    
    // Verify withdrawal is ready and not challenged
    assert!(current_time >= withdrawal.processes_at, EWithdrawalNotReady);
    assert!(!withdrawal.is_challenged, EWithdrawalChallenged);
    
    // Note: Actual coin transfer would need to be handled by a specialized executor
    // that provides the coin, similar to dissolution actions
}

/// Execute processing a single matured pending withdrawal with coin
public(package) fun do_process_pending_withdrawal_with_coin<Outcome: store, CoinType, IW: drop>(
    executable: &mut Executable<Outcome>,
    account: &mut Account<FutarchyConfig>,
    payment_coin: Coin<CoinType>,  // Receive the actual coin
    witness: IW,
    clock: &Clock,
    _ctx: &TxContext,
) {
    let action = executable.next_action<Outcome, ProcessPendingWithdrawalAction<CoinType>, IW>(witness);
    let payment_id = action.payment_id;
    let withdrawal_id = action.withdrawal_id;
    
    let account_id = object::id(account);
    let current_time = clock.timestamp_ms();
    
    let storage: &mut PaymentStorage = account::borrow_managed_data_mut(
        account,
        PaymentStorageKey {},
        version::current()
    );
    
    assert!(table::contains(&storage.payments, payment_id), EPaymentNotFound);
    let payment = table::borrow_mut(&mut storage.payments, payment_id);
    
    // Verify this is a budget stream
    assert!(payment.is_budget_stream, EInvalidBudgetStream);
    assert!(payment.budget_config.is_some(), EInvalidBudgetStream);
    
    let budget_config = payment.budget_config.borrow_mut();
    
    // Get and validate withdrawal
    assert!(table::contains(&budget_config.pending_withdrawals, withdrawal_id), EPaymentNotFound);
    let withdrawal = table::remove(&mut budget_config.pending_withdrawals, withdrawal_id);
    
    // Verify withdrawal is ready and not challenged
    assert!(current_time >= withdrawal.processes_at, EWithdrawalNotReady);
    assert!(!withdrawal.is_challenged, EWithdrawalChallenged);
    
    // Verify coin amount matches withdrawal
    assert!(coin::value(&payment_coin) == withdrawal.amount, EInvalidStreamAmount);
    
    // Extract values before moving withdrawal
    let withdrawer_address = withdrawal.withdrawer;
    let withdrawal_amount = withdrawal.amount;
    
    // Update payment state
    payment.claimed_amount = payment.claimed_amount + withdrawal_amount;
    budget_config.pending_count = budget_config.pending_count - 1;
    budget_config.total_pending_amount = budget_config.total_pending_amount - withdrawal_amount;
    
    // Update period tracking if budget periods are enabled
    if (budget_config.budget_period_ms.is_some()) {
        budget_config.current_period_claimed = budget_config.current_period_claimed + withdrawal_amount;
    };
    
    // Transfer the coin to withdrawer
    transfer::public_transfer(payment_coin, withdrawer_address);
    
    // Emit event
    event::emit(WithdrawalProcessed {
        account_id,
        payment_id,
        withdrawal_id,
        withdrawer: withdrawer_address,
        amount: withdrawal_amount,
    });
}

/// Execute cancelling challenged withdrawals after successful challenge
public fun do_cancel_challenged_withdrawals<Outcome: store, IW: drop>(
    executable: &mut Executable<Outcome>,
    account: &mut Account<FutarchyConfig>,
    _version_witness: VersionWitness,
    witness: IW,
    _clock: &Clock,
    _ctx: &mut TxContext,
) {
    let action = executable.next_action<Outcome, CancelChallengedWithdrawalsAction, IW>(witness);
    let payment_id = action.payment_id;
    
    let storage: &mut PaymentStorage = account::borrow_managed_data_mut(
        account,
        PaymentStorageKey {},
        version::current()
    );
    
    assert!(table::contains(&storage.payments, payment_id), EPaymentNotFound);
    let payment = table::borrow_mut(&mut storage.payments, payment_id);
    
    // Verify this is a budget stream
    assert!(payment.is_budget_stream, EInvalidBudgetStream);
    assert!(payment.budget_config.is_some(), EInvalidBudgetStream);
    
    let budget_config = payment.budget_config.borrow_mut();
    
    // Cancel each challenged withdrawal
    let mut i = 0;
    let len = action.withdrawal_ids.length();
    while (i < len) {
        let withdrawal_id = action.withdrawal_ids[i];
        assert!(table::contains(&budget_config.pending_withdrawals, withdrawal_id), EPaymentNotFound);
        
        let withdrawal = table::remove(&mut budget_config.pending_withdrawals, withdrawal_id);
        
        // Verify this withdrawal was challenged with the given proposal
        assert!(withdrawal.is_challenged, EChallengeMismatch);
        assert!(withdrawal.challenge_proposal_id.is_some(), EChallengeMismatch);
        assert!(*withdrawal.challenge_proposal_id.borrow() == action.proposal_id, EChallengeMismatch);
        
        // Extract amount before dropping withdrawal
        let withdrawal_amount = withdrawal.amount;
        
        // Update pending count and amount
        budget_config.pending_count = budget_config.pending_count - 1;
        budget_config.total_pending_amount = budget_config.total_pending_amount - withdrawal_amount;
        
        i = i + 1;
    };
    
    // Emit event
    event::emit(ChallengedWithdrawalsCancelled {
        account_id: object::id(account),
        payment_id,
        withdrawal_ids: action.withdrawal_ids,
        proposal_id: action.proposal_id,
    });
}

// === Dissolution Support Functions ===

/// Get all payment IDs for batch cancellation during dissolution
public fun get_all_payment_ids(account: &Account<FutarchyConfig>): vector<String> {
    if (!account::has_managed_data(account, PaymentStorageKey {})) {
        return vector::empty()
    };
    
    let storage: &PaymentStorage = account::borrow_managed_data(
        account,
        PaymentStorageKey {},
        version::current()
    );
    
    // Return the actual payment IDs we've been tracking
    storage.payment_ids
}

/// Cancel ALL payments and return funds to treasury (for dissolution)
/// This guarantees ALL streams are cancelled, not just the ones passed in
public fun cancel_all_payments_for_dissolution<CoinType>(
    account: &mut Account<FutarchyConfig>,
    clock: &Clock,
    ctx: &mut TxContext,
) {
    if (!account::has_managed_data(account, PaymentStorageKey {})) {
        return
    };
    
    let account_id = object::id(account);  // Get ID before mutable borrow
    
    // First pass: collect isolated pool payment IDs and amounts
    let mut isolated_pool_payments = vector::empty<String>();
    let mut isolated_pool_amounts = vector::empty<u64>();
    
    {
        let storage: &PaymentStorage = account::borrow_managed_data(
            account,
            PaymentStorageKey {},
            version::current()
        );
        
        let mut i = 0;
        let len = storage.payment_ids.length();
        
        while (i < len) {
            let payment_id = *storage.payment_ids.borrow(i);
            
            if (table::contains(&storage.payments, payment_id)) {
                let payment = table::borrow(&storage.payments, payment_id);
                
                if (payment.active && payment.cancellable && payment.source_mode == SOURCE_ISOLATED_POOL) {
                    let unclaimed = if (payment.amount > payment.claimed_amount) {
                        payment.amount - payment.claimed_amount
                    } else {
                        0
                    };
                    
                    if (unclaimed > 0) {
                        vector::push_back(&mut isolated_pool_payments, payment_id);
                        vector::push_back(&mut isolated_pool_amounts, unclaimed);
                    };
                };
            };
            
            i = i + 1;
        };
    };
    
    // Second pass: cancel all payments
    let storage: &mut PaymentStorage = account::borrow_managed_data_mut(
        account,
        PaymentStorageKey {},
        version::current()
    );
    
    // CRITICAL: Iterate through ALL payment IDs we've tracked
    let mut i = 0;
    let len = storage.payment_ids.length();
    
    while (i < len) {
        let payment_id = *storage.payment_ids.borrow(i);
        
        if (table::contains(&storage.payments, payment_id)) {
            let payment = table::borrow_mut(&mut storage.payments, payment_id);
            
            // Only cancel if payment is active and cancellable
            if (payment.active && payment.cancellable) {
                // Mark as cancelled
                payment.active = false;
                
                // Handle budget streams - cancel all pending withdrawals
                if (payment.is_budget_stream && payment.budget_config.is_some()) {
                    let budget_config = payment.budget_config.borrow_mut();
                    // Clear all pending withdrawals
                    budget_config.pending_count = 0;
                    budget_config.total_pending_amount = 0;
                    // Note: In production, properly iterate and remove from table
                };
                
                // Isolated pool payments are handled in the third pass
                
                // Calculate and record unclaimed amount for accounting
                let unclaimed = if (payment.amount > payment.claimed_amount) {
                    payment.amount - payment.claimed_amount
                } else {
                    0
                };
                
                // Emit cancellation event
                event::emit(PaymentCancelled {
                    account_id,
                    payment_id,
                    unclaimed_returned: unclaimed,
                    timestamp: clock.timestamp_ms(),
                });
            };
        };
        
        i = i + 1;
    };
    
    // Third pass: handle isolated pool funds
    // Process each isolated pool payment to return funds to treasury
    if (!isolated_pool_payments.is_empty()) {
        let mut total_returned = 0u64;
        let mut returned_balances: vector<Balance<CoinType>> = vector::empty();
        let mut i = 0;
        
        while (i < isolated_pool_payments.length()) {
            let payment_id = *isolated_pool_payments.borrow(i);
            let expected_amount = *isolated_pool_amounts.borrow(i);
            let pool_key = PaymentPoolKey { payment_id };
            
            // Check if the pool exists and retrieve remaining balance
            if (account::has_managed_data(account, pool_key)) {
                // Remove the pool balance entirely
                let pool_balance: Balance<CoinType> = account::remove_managed_data(
                    account,
                    pool_key,
                    version::current()
                );
                
                let actual_amount = balance::value(&pool_balance);
                
                // Collect the balance to return later
                if (actual_amount > 0) {
                    total_returned = total_returned + actual_amount;
                    vector::push_back(&mut returned_balances, pool_balance);
                    
                    // Emit event for this specific pool return
                    event::emit(IsolatedPoolReturned {
                        account_id,
                        payment_id,
                        amount_returned: actual_amount,
                        expected_amount,
                        timestamp: clock.timestamp_ms(),
                    });
                } else {
                    // Destroy empty balance
                    balance::destroy_zero(pool_balance);
                };
            };
            
            i = i + 1;
        };
        
        // Combine all returned balances into one
        if (!vector::is_empty(&returned_balances)) {
            let mut combined_balance = vector::pop_back(&mut returned_balances);
            while (!vector::is_empty(&returned_balances)) {
                let next_balance = vector::pop_back(&mut returned_balances);
                balance::join(&mut combined_balance, next_balance);
            };
            
            // Store the combined balance back as managed data with a special key
            // This will be available for the account to withdraw back to treasury
            // The account protocol handles the actual treasury management
            let return_key = DissolutionReturnKey { coin_type: type_name::get<CoinType>() };
            if (account::has_managed_data(account, return_key)) {
                let existing: &mut Balance<CoinType> = account::borrow_managed_data_mut(
                    account,
                    return_key,
                    version::current()
                );
                balance::join(existing, combined_balance);
            } else {
                account::add_managed_data(account, return_key, combined_balance, version::current());
            };
        };
        
        vector::destroy_empty(returned_balances);
        
        // Emit summary event for all isolated pool returns
        event::emit(DissolutionFundsReturned {
            account_id,
            coin_type: type_name::get<CoinType>().into_string().to_string(),
            total_amount: total_returned,
            payment_count: isolated_pool_payments.length(),
            timestamp: clock.timestamp_ms(),
        });
    };
}

// === Helper Functions ===

/// Calculate claimable amount for a payment
fun calculate_claimable_amount(payment: &PaymentConfig, current_time: u64): u64 {
    if (!payment.active || current_time < payment.start_timestamp) {
        return 0
    };
    
    // Budget streams don't have time-based vesting, only a total budget ceiling
    if (payment.is_budget_stream) {
        return 0  // Budget streams use withdrawal requests, not direct claims
    };
    
    if (payment.payment_type == PAYMENT_TYPE_STREAM) {
        // Handle cliff period if present
        if (payment.interval_or_cliff.is_some()) {
            let cliff = *payment.interval_or_cliff.borrow();
            if (current_time < cliff) {
                return 0
            };
        };
        
        // Calculate vested amount based on time elapsed
        let total_duration = payment.end_timestamp - payment.start_timestamp;
        let elapsed = if (current_time >= payment.end_timestamp) {
            total_duration
        } else {
            current_time - payment.start_timestamp
        };
        
        let vested_amount = (payment.amount * elapsed) / total_duration;
        
        // Return claimable (vested minus already claimed)
        if (vested_amount > payment.claimed_amount) {
            vested_amount - payment.claimed_amount
        } else {
            0
        }
    } else if (payment.payment_type == PAYMENT_TYPE_RECURRING) {
        // Calculate number of payments due
        let interval = if (payment.interval_or_cliff.is_some()) {
            *payment.interval_or_cliff.borrow()
        } else {
            30 * 24 * 60 * 60 * 1000 // Default to monthly (30 days in ms)
        };
        
        let time_since_start = current_time - payment.start_timestamp;
        let payments_due = (time_since_start / interval) + 1;
        
        // Check if we've reached the maximum number of payments
        let max_payments = if (payment.total_payments > 0) {
            payment.total_payments
        } else {
            payments_due // Unlimited payments
        };
        
        let actual_payments_due = if (payments_due > max_payments) {
            max_payments
        } else {
            payments_due
        };
        
        if (actual_payments_due > payment.payments_made) {
            // Amount per payment * number of payments due
            payment.amount * (actual_payments_due - payment.payments_made)
        } else {
            0
        }
    } else {
        0
    }
}

/// Generate a unique payment ID using UID for guaranteed uniqueness
fun generate_payment_id(config: &PaymentConfig, _timestamp: u64, ctx: &mut TxContext): String {
    use std::string;
    use sui::object;
    use sui::hex;
    
    // Create a new UID for guaranteed uniqueness
    let uid = object::new(ctx);
    let id_bytes = object::uid_to_bytes(&uid);
    object::delete(uid);
    
    // Convert to hex string for readable ID
    let hex_bytes = hex::encode(id_bytes);
    let hex_str = string::utf8(hex_bytes);
    
    // Add prefix based on payment type for readability
    let mut id = if (config.payment_type == PAYMENT_TYPE_STREAM) {
        string::utf8(b"stream_")
    } else {
        string::utf8(b"recurring_")
    };
    
    // Append the unique hex ID
    string::append(&mut id, hex_str);
    
    id
}


/// Check if a recurring payment is due
public fun is_recurring_payment_due(
    config: &PaymentConfig,
    clock: &Clock,
): bool {
    assert!(config.payment_type == PAYMENT_TYPE_RECURRING, EInvalidStartTime);
    
    if (!config.active) {
        return false
    };
    
    // Check if payment has ended
    if (config.total_payments > 0 && config.payments_made >= config.total_payments) {
        return false
    };
    
    // Check if payment has expired
    if (config.end_timestamp > 0 && clock.timestamp_ms() >= config.end_timestamp) {
        return false
    };
    
    // Check if enough time has passed since last payment
    let interval = *option::borrow(&config.interval_or_cliff);
    let time_since_last = clock.timestamp_ms() - config.last_payment_timestamp;
    time_since_last >= interval
}

/// Check if a payment is fully vested/completed
public fun is_payment_complete(config: &PaymentConfig, clock: &Clock): bool {
    if (config.payment_type == PAYMENT_TYPE_STREAM) {
        clock.timestamp_ms() >= config.end_timestamp
    } else {
        (config.total_payments > 0 && config.payments_made >= config.total_payments) ||
        (config.end_timestamp > 0 && clock.timestamp_ms() >= config.end_timestamp)
    }
}

/// Check if a payment is fully claimed/paid
public fun is_fully_claimed(config: &PaymentConfig): bool {
    if (config.payment_type == PAYMENT_TYPE_STREAM) {
        config.claimed_amount >= config.amount
    } else {
        config.total_payments > 0 && config.payments_made >= config.total_payments
    }
}

/// Get remaining payment amount
public fun remaining_amount(config: &PaymentConfig): u64 {
    if (config.payment_type == PAYMENT_TYPE_STREAM) {
        if (config.amount > config.claimed_amount) {
            config.amount - config.claimed_amount
        } else {
            0
        }
    } else {
        if (config.total_payments > 0) {
            (config.total_payments - config.payments_made) * config.amount
        } else {
            0 // Unlimited payments
        }
    }
}

/// Fund an isolated payment pool with the provided coin
public(package) fun fund_isolated_pool<CoinType>(
    account: &mut Account<FutarchyConfig>,
    payment_id: String,
    funding_coin: Coin<CoinType>,
    version_witness: VersionWitness,
) {
    let pool_key = PaymentPoolKey { payment_id };
    assert!(account::has_managed_data(account, pool_key), EPaymentNotFound);
    
    let pool_balance: &mut Balance<CoinType> = account::borrow_managed_data_mut(
        account,
        pool_key,
        version_witness
    );
    
    balance::join(pool_balance, coin::into_balance(funding_coin));
}

/// Withdraw from an isolated payment pool
public(package) fun withdraw_from_pool<CoinType>(
    account: &mut Account<FutarchyConfig>,
    payment_id: String,
    amount: u64,
    version_witness: VersionWitness,
    ctx: &mut TxContext,
): Coin<CoinType> {
    let pool_key = PaymentPoolKey { payment_id };
    let pool_balance: &mut Balance<CoinType> = account::borrow_managed_data_mut(
        account,
        pool_key,
        version_witness
    );
    
    coin::take(pool_balance, amount, ctx)
}

/// Get payment progress percentage (basis points)
public fun payment_progress_bps(config: &PaymentConfig, clock: &Clock): u64 {
    if (config.payment_type == PAYMENT_TYPE_STREAM) {
        let current_time = clock.timestamp_ms();
        
        if (current_time <= config.start_timestamp) {
            0
        } else if (current_time >= config.end_timestamp) {
            10000 // 100% in basis points
        } else {
            let elapsed = current_time - config.start_timestamp;
            let duration = config.end_timestamp - config.start_timestamp;
            (elapsed * 10000) / duration
        }
    } else {
        if (config.total_payments == 0) {
            0 // Unlimited payments, no progress concept
        } else {
            (config.payments_made * 10000) / config.total_payments
        }
    }
}

// === Getter Functions for Actions ===

/// Get source mode from CreatePaymentAction
public fun get_source_mode<CoinType>(action: &CreatePaymentAction<CoinType>): u8 {
    action.source_mode
}

/// Get payment type from CreatePaymentAction  
public fun get_payment_type<CoinType>(action: &CreatePaymentAction<CoinType>): u8 {
    action.payment_type
}

/// Get amount from CreatePaymentAction
public fun get_amount<CoinType>(action: &CreatePaymentAction<CoinType>): u64 {
    action.amount
}

/// Get total payments from CreatePaymentAction
public fun get_total_payments<CoinType>(action: &CreatePaymentAction<CoinType>): u64 {
    action.total_payments
}

// === Exported Constants ===

/// Get source mode constant for direct treasury
public fun source_direct_treasury(): u8 { SOURCE_DIRECT_TREASURY }

/// Get source mode constant for isolated pool
public fun source_isolated_pool(): u8 { SOURCE_ISOLATED_POOL }

/// Get payment type constant for stream
public fun payment_type_stream(): u8 { PAYMENT_TYPE_STREAM }

/// Get payment type constant for recurring
public fun payment_type_recurring(): u8 { PAYMENT_TYPE_RECURRING }/// User-facing API for creating stream-related intents
/// This module provides helper functions for creating stream actions
/// The actual intent creation must be done by the governance system that provides the Outcome
module futarchy::stream_intents;

// === Imports ===
use std::{
    string::String,
    option::Option,
};
use sui::clock::Clock;
use account_actions::vault;
use account_protocol::{
    intents::Intent,
};
use futarchy::stream_actions;

// === Witness ===

/// Witness type for stream intents
public struct StreamIntent has drop {}

/// Create a StreamIntent witness
public fun witness(): StreamIntent {
    StreamIntent {}
}

// === Helper Functions ===

/// Add a create stream action to an existing intent with direct treasury funding
public fun create_stream_in_intent<Outcome: store, CoinType, IW: drop>(
    intent: &mut Intent<Outcome>,
    recipient: address,
    total_amount: u64,
    start_timestamp: u64,
    end_timestamp: u64,
    cliff_timestamp: Option<u64>,
    cancellable: bool,
    description: String,
    clock: &Clock,
    intent_witness: IW,
    ctx: &mut TxContext,
) {
    let action = stream_actions::new_create_stream_action<CoinType>(
        stream_actions::source_direct_treasury(),
        recipient,
        total_amount,
        start_timestamp,
        end_timestamp,
        cliff_timestamp,
        cancellable,
        description,
        clock,
        ctx,
    );
    intent.add_action(action, intent_witness);
    
    // Direct treasury streams don't need upfront funding
    // Funds will be withdrawn on each claim via vault::SpendAction
}

/// Add a create stream action with isolated pool funding
/// Note: This requires two witnesses since we add two actions
public fun create_isolated_stream_in_intent<Outcome: store, CoinType, IW: copy + drop>(
    intent: &mut Intent<Outcome>,
    recipient: address,
    total_amount: u64,
    start_timestamp: u64,
    end_timestamp: u64,
    cliff_timestamp: Option<u64>,
    cancellable: bool,
    description: String,
    clock: &Clock,
    intent_witness: IW,
    ctx: &mut TxContext,
) {
    // First add the stream creation action
    let action = stream_actions::new_create_stream_action<CoinType>(
        stream_actions::source_isolated_pool(),
        recipient,
        total_amount,
        start_timestamp,
        end_timestamp,
        cliff_timestamp,
        cancellable,
        description,
        clock,
        ctx,
    );
    intent.add_action(action, intent_witness);
    
    // Then add a vault spend action to fund the isolated pool
    vault::new_spend<Outcome, CoinType, IW>(
        intent,
        b"treasury".to_string(),
        total_amount,
        intent_witness
    );
}

/// Add a create recurring payment with isolated pool
public fun create_recurring_payment_in_intent<Outcome: store, CoinType, IW: copy + drop>(
    intent: &mut Intent<Outcome>,
    recipient: address,
    amount_per_payment: u64,
    interval_ms: u64,
    total_payments: u64,
    end_timestamp: Option<u64>,
    cancellable: bool,
    description: String,
    clock: &Clock,
    intent_witness: IW,
    ctx: &mut TxContext,
) {
    // First add the recurring payment action
    let action = stream_actions::new_create_recurring_payment_action<CoinType>(
        stream_actions::source_isolated_pool(),
        recipient,
        amount_per_payment,
        interval_ms,
        total_payments,
        end_timestamp,
        cancellable,
        description,
        clock,
        ctx,
    );
    intent.add_action(action, intent_witness);
    
    // Calculate total funding needed
    let total_funding = if (total_payments > 0) {
        amount_per_payment * total_payments
    } else {
        // For unlimited payments, fund initial amount (e.g., 12 payments worth)
        amount_per_payment * 12
    };
    
    // Add vault spend action to fund the pool
    vault::new_spend<Outcome, CoinType, IW>(
        intent,
        b"treasury".to_string(),
        total_funding,
        intent_witness
    );
}

/// Add an execute payment action to an intent (claim from stream)
public fun execute_payment_in_intent<Outcome: store, CoinType, IW: copy + drop>(
    intent: &mut Intent<Outcome>,
    payment_id: String,
    amount: Option<u64>,
    intent_witness: IW,
) {
    // For direct treasury payments, add a vault spend action first
    // The dispatcher will coordinate passing the coin to the execution
    if (amount.is_some()) {
        vault::new_spend<Outcome, CoinType, IW>(
            intent,
            b"treasury".to_string(),
            *amount.borrow(),
            intent_witness
        );
    };
    
    // Then add the execute payment action
    let action = stream_actions::new_execute_payment_action<CoinType>(
        payment_id,
        amount,
    );
    intent.add_action(action, intent_witness);
}

/// Add a cancel stream action to an existing intent
public fun cancel_stream_in_intent<Outcome: store, CoinType, IW: drop>(
    intent: &mut Intent<Outcome>,
    stream_id: String,
    return_unclaimed: bool,
    intent_witness: IW,
) {
    // Note: If there's a final claimable amount, a vault::SpendAction
    // should be added before this action to provide the final payment coin
    let action = stream_actions::new_cancel_payment_action<CoinType>(
        stream_id,
        return_unclaimed,
    );
    intent.add_action(action, intent_witness);
}

/// Create a unique key for a stream intent
public fun create_stream_key(
    operation: String,
    clock: &Clock,
): String {
    let mut key = b"stream_".to_string();
    key.append(operation);
    key.append(b"_".to_string());
    key.append(clock.timestamp_ms().to_string());
    key
}
module futarchy::cross_dao_bundle;
// Two-phase commit for cross-DAO atomic execution:
//  - Phase 1 (async): Each DAO prepares a sealed commitment containing their executable
//  - Phase 2 (atomic): Single transaction executes all commitments or aborts entirely

use std::{string::{Self, String}, vector, option::{Self, Option}};
use sui::{
    clock::Clock,
    tx_context::TxContext,
    bag::{Self, Bag},
    event,
    dynamic_object_field as dof,
    object::{Self, ID, UID},
    transfer,
};

use account_protocol::{
    account::{Self, Account},
    executable::Executable,
    intents,
};

use futarchy::{
    futarchy_config::{Self, FutarchyConfig, FutarchyOutcome, GovernanceWitness, ExecutePermit},
    execute,
    version,
    gc_janitor,
};

// === Error Codes ===
const EBundleExpired: u64 = 7001;
const EAlreadyCommitted: u64 = 7002;
const ENotEnoughCommitments: u64 = 7003;
const ETooManyCommitments: u64 = 7004;
const EBundleAlreadyExecuted: u64 = 7005;
const EUnauthorizedDAO: u64 = 7006;
const EEmptyBundleId: u64 = 7007;
const ECommitmentMismatch: u64 = 7008;
const EInvalidMinParticipants: u64 = 7009;
const ENoCommitmentFound: u64 = 7010;
const ECannotWithdrawAfterExecution: u64 = 7011;
const EWithdrawWindowExpired: u64 = 7012;
const EInvalidTemplate: u64 = 7013;
const ETemplateMismatch: u64 = 7014;
const EHookFailed: u64 = 7015;

// === Events ===

public struct BundleCreated has copy, drop {
    bundle_id: String,
    creator: address,
    min_participants: u64,
    max_participants: u64,
    expires_at: u64,
}

public struct CommitmentAdded has copy, drop {
    bundle_id: String,
    dao_address: address,
    intent_key: String,
    commitment_number: u64,
    timestamp: u64,
}

public struct BundleExecuted has copy, drop {
    bundle_id: String,
    executed_count: u64,
    timestamp: u64,
    executor: address,
}

public struct BundleExpired has copy, drop {
    bundle_id: String,
    commitments_returned: u64,
}

public struct CommitmentWithdrawn has copy, drop {
    bundle_id: String,
    dao_address: address,
    timestamp: u64,
}

// === Bundle Templates ===

/// Pre-defined bundle types for common coordination patterns
public enum BundleType has store, copy, drop {
    LiquidityMerge,      // Merge liquidity pools across DAOs
    TreasurySwap,        // Swap treasury assets between DAOs
    GovernanceUpgrade,   // Coordinated governance parameter changes
    JointInvestment,     // Joint investment or acquisition
    Custom               // Custom coordination pattern
}

/// Template for common bundle patterns
public struct BundleTemplate has store, copy, drop {
    template_type: BundleType,
    min_participants: u64,
    max_participants: u64,
    required_duration_ms: u64,
    withdrawal_window_ms: u64,  // How long participants can withdraw
    requires_all_or_nothing: bool,
    description_template: String,
}

/// Execution hooks for pre/post processing
public struct ExecutionHooks has store, drop {
    // Executed before any commitments are processed
    pre_execution: Option<vector<u8>>, // Serialized action
    // Executed after successful execution
    post_execution: Option<vector<u8>>, // Serialized action
    // Executed if execution fails (for cleanup)
    on_failure: Option<vector<u8>>, // Serialized action
}

// === Core Types ===

/// Shared bundle that collects async commitments from DAOs
public struct Bundle has key, store {
    id: UID,
    bundle_id: String,
    description: String,
    
    // Template (if using one)
    template: Option<BundleTemplate>,
    
    // Participation requirements
    min_participants: u64,
    max_participants: u64,
    authorized_daos: Option<vector<address>>, // None = any DAO can join
    
    // Timing
    created_at: u64,
    expires_at: u64,
    withdrawal_deadline: u64, // After this, no withdrawals allowed
    
    // State
    commitments: Bag, // address -> Commitment
    commitment_count: u64,
    executed: bool,
    
    // Execution hooks
    hooks: Option<ExecutionHooks>,
    
    // Metadata for coordination
    metadata: Bag, // For extensibility
}

/// Individual DAO's commitment (sealed executable)
public struct Commitment has store, drop {
    dao_address: address,
    intent_key: String,
    executable_id: ID,  // Store the ID instead of the executable itself
    committed_at: u64,
    commitment_hash: vector<u8>,
}

/// Receipt given to DAO when they commit (for tracking)
public struct CommitmentReceipt has key, store {
    id: UID,
    bundle_id: String,
    dao_address: address,
    intent_key: String,
    committed_at: u64,
}

// === Template Functions ===

/// Create standard templates
public fun liquidity_merge_template(): BundleTemplate {
    BundleTemplate {
        template_type: BundleType::LiquidityMerge,
        min_participants: 2,
        max_participants: 5,
        required_duration_ms: 7 * 24 * 60 * 60 * 1000, // 7 days
        withdrawal_window_ms: 24 * 60 * 60 * 1000,     // 24 hours
        requires_all_or_nothing: true,
        description_template: b"Cross-DAO Liquidity Pool Merge".to_string(),
    }
}

public fun treasury_swap_template(): BundleTemplate {
    BundleTemplate {
        template_type: BundleType::TreasurySwap,
        min_participants: 2,
        max_participants: 2,
        required_duration_ms: 3 * 24 * 60 * 60 * 1000, // 3 days
        withdrawal_window_ms: 12 * 60 * 60 * 1000,     // 12 hours
        requires_all_or_nothing: true,
        description_template: b"Treasury Asset Swap".to_string(),
    }
}

public fun governance_upgrade_template(): BundleTemplate {
    BundleTemplate {
        template_type: BundleType::GovernanceUpgrade,
        min_participants: 2,
        max_participants: 10,
        required_duration_ms: 14 * 24 * 60 * 60 * 1000, // 14 days
        withdrawal_window_ms: 48 * 60 * 60 * 1000,       // 48 hours
        requires_all_or_nothing: false,
        description_template: b"Coordinated Governance Upgrade".to_string(),
    }
}

// === Bundle Creation ===

/// Create a new bundle for cross-DAO coordination
public entry fun create_bundle(
    bundle_id: String,
    description: String,
    min_participants: u64,
    max_participants: u64,
    authorized_daos: Option<vector<address>>,
    duration_ms: u64,
    withdrawal_window_ms: u64,
    clock: &Clock,
    ctx: &mut TxContext,
) {
    assert!(bundle_id.length() > 0, EEmptyBundleId);
    assert!(min_participants > 0 && min_participants <= max_participants, EInvalidMinParticipants);
    
    let now = clock.timestamp_ms();
    let bundle = Bundle {
        id: object::new(ctx),
        bundle_id: bundle_id,
        description,
        template: option::none(),
        min_participants,
        max_participants,
        authorized_daos,
        created_at: now,
        expires_at: now + duration_ms,
        withdrawal_deadline: now + duration_ms - withdrawal_window_ms,
        commitments: bag::new(ctx),
        commitment_count: 0,
        executed: false,
        hooks: option::none(),
        metadata: bag::new(ctx),
    };
    
    event::emit(BundleCreated {
        bundle_id: bundle.bundle_id,
        creator: tx_context::sender(ctx),
        min_participants,
        max_participants,
        expires_at: bundle.expires_at,
    });
    
    transfer::share_object(bundle);
}

/// Create bundle from template - using separate parameters instead of structs
public entry fun create_bundle_from_template(
    bundle_id: String,
    template_type: u8,  // 0=LiquidityMerge, 1=TreasurySwap, 2=GovernanceUpgrade, 3=JointInvestment, 4=Custom
    min_participants: u64,
    max_participants: u64,
    required_duration_ms: u64,
    withdrawal_window_ms: u64,
    clock: &Clock,
    ctx: &mut TxContext,
) {
    assert!(bundle_id.length() > 0, EEmptyBundleId);
    
    let now = clock.timestamp_ms();
    
    // Convert u8 back to BundleType
    let bundle_type = if (template_type == 0) {
        BundleType::LiquidityMerge
    } else if (template_type == 1) {
        BundleType::TreasurySwap
    } else if (template_type == 2) {
        BundleType::GovernanceUpgrade
    } else if (template_type == 3) {
        BundleType::JointInvestment
    } else {
        BundleType::Custom
    };
    
    let template = BundleTemplate {
        template_type: bundle_type,
        min_participants,
        max_participants,
        required_duration_ms,
        withdrawal_window_ms,
        requires_all_or_nothing: true,
        description_template: b"Cross-DAO Bundle".to_string(),
    };
    
    let bundle = Bundle {
        id: object::new(ctx),
        bundle_id,
        description: template.description_template,
        template: option::some(template),
        min_participants,
        max_participants,
        authorized_daos: option::none(),
        created_at: now,
        expires_at: now + required_duration_ms,
        withdrawal_deadline: now + required_duration_ms - withdrawal_window_ms,
        commitments: bag::new(ctx),
        commitment_count: 0,
        executed: false,
        hooks: option::none(),
        metadata: bag::new(ctx),
    };
    
    event::emit(BundleCreated {
        bundle_id: bundle.bundle_id,
        creator: tx_context::sender(ctx),
        min_participants,
        max_participants,
        expires_at: bundle.expires_at,
    });
    
    transfer::share_object(bundle);
}

// === Phase 1: Asynchronous Commitments ===

/// Prepare and commit a DAO's participation in the bundle
public fun prepare_commitment(
    account: &mut Account<FutarchyConfig>,
    bundle: &mut Bundle,
    intent_key: String,
    clock: &Clock,
    ctx: &mut TxContext,
) {
    let dao_addr = account::addr(account);
    
    // Validations
    assert!(!bundle.executed, EBundleAlreadyExecuted);
    assert!(clock.timestamp_ms() < bundle.expires_at, EBundleExpired);
    assert!(!bag::contains(&bundle.commitments, dao_addr), EAlreadyCommitted);
    assert!(bundle.commitment_count < bundle.max_participants, ETooManyCommitments);
    
    // Check authorization if restricted
    if (option::is_some(&bundle.authorized_daos)) {
        let authorized = option::borrow(&bundle.authorized_daos);
        assert!(vector::contains(authorized, &dao_addr), EUnauthorizedDAO);
    };
    
    // Create the executable (validates DAO's internal approval)
    // We need to use an approach that doesn't require GovernanceWitness from outside module
    let executable_id = object::id_from_address(dao_addr);  // Placeholder for executable ID
    
    // Create commitment
    let commitment = Commitment {
        dao_address: dao_addr,
        intent_key: intent_key,
        executable_id,
        committed_at: clock.timestamp_ms(),
        commitment_hash: sui::hash::keccak256(bundle.bundle_id.as_bytes()),
    };
    
    // Store commitment
    bag::add(&mut bundle.commitments, dao_addr, commitment);
    bundle.commitment_count = bundle.commitment_count + 1;
    
    event::emit(CommitmentAdded {
        bundle_id: bundle.bundle_id,
        dao_address: dao_addr,
        intent_key,
        commitment_number: bundle.commitment_count,
        timestamp: clock.timestamp_ms(),
    });
    
    // Return receipt
    let receipt = CommitmentReceipt {
        id: object::new(ctx),
        bundle_id: bundle.bundle_id,
        dao_address: dao_addr,
        intent_key,
        committed_at: clock.timestamp_ms(),
    };
    
    transfer::transfer(receipt, tx_context::sender(ctx))
}

/// Entry function for committing
public entry fun commit_to_bundle(
    account: &mut Account<FutarchyConfig>,
    bundle: &mut Bundle,
    intent_key: String,
    clock: &Clock,
    ctx: &mut TxContext,
) {
    prepare_commitment(account, bundle, intent_key, clock, ctx);
}

// === Commitment Withdrawal ===

/// Withdraw a commitment before bundle execution
/// Can only be done before withdrawal deadline and if bundle hasn't executed
public fun withdraw_commitment(
    account: &mut Account<FutarchyConfig>,
    bundle: &mut Bundle,
    clock: &Clock,
    ctx: &mut TxContext,
): ID {
    let dao_addr = account::addr(account);
    let now = clock.timestamp_ms();
    
    // Validations
    assert!(!bundle.executed, ECannotWithdrawAfterExecution);
    assert!(now < bundle.withdrawal_deadline, EWithdrawWindowExpired);
    assert!(bag::contains(&bundle.commitments, dao_addr), ENoCommitmentFound);
    
    // Remove and return the commitment
    let commitment: Commitment = bag::remove(&mut bundle.commitments, dao_addr);
    bundle.commitment_count = bundle.commitment_count - 1;
    
    // Destructure to get the executable_id
    let Commitment {
        dao_address: _,
        intent_key: _,
        executable_id,
        committed_at: _,
        commitment_hash: _,
    } = commitment;
    
    event::emit(CommitmentWithdrawn {
        bundle_id: bundle.bundle_id,
        dao_address: dao_addr,
        timestamp: now,
    });
    
    // Return the executable ID to the DAO
    executable_id
}

/// Entry function for withdrawal
public entry fun withdraw_from_bundle(
    account: &mut Account<FutarchyConfig>,
    bundle: &mut Bundle,
    clock: &Clock,
    ctx: &mut TxContext,
) {
    let _executable_id = withdraw_commitment(account, bundle, clock, ctx);
    // The executable ID is returned - the actual executable handling
    // would be done by the account module or through other mechanisms
}

// === Phase 2: Atomic Execution ===

/// Internal: Execute pre-execution hook if present
fun execute_pre_hook(
    hooks: &Option<ExecutionHooks>,
    bundle_id: &String,
    clock: &Clock,
) {
    if (option::is_some(hooks)) {
        let hook_data = option::borrow(hooks);
        if (option::is_some(&hook_data.pre_execution)) {
            // In production, deserialize and execute the action
            // For now, we just log that it would be executed
            event::emit(BundleEvent {
                bundle_id: *bundle_id,
                event_type: b"PRE_EXECUTION_HOOK".to_string(),
                timestamp: clock.timestamp_ms(),
            });
        }
    }
}

/// Internal: Execute post-execution hook if present
fun execute_post_hook(
    hooks: &Option<ExecutionHooks>,
    bundle_id: &String,
    clock: &Clock,
) {
    if (option::is_some(hooks)) {
        let hook_data = option::borrow(hooks);
        if (option::is_some(&hook_data.post_execution)) {
            // In production, deserialize and execute the action
            event::emit(BundleEvent {
                bundle_id: *bundle_id,
                event_type: b"POST_EXECUTION_HOOK".to_string(),
                timestamp: clock.timestamp_ms(),
            });
        }
    }
}

/// Internal: Execute failure hook if present
fun execute_failure_hook(
    hooks: &Option<ExecutionHooks>,
    bundle_id: &String,
    clock: &Clock,
) {
    if (option::is_some(hooks)) {
        let hook_data = option::borrow(hooks);
        if (option::is_some(&hook_data.on_failure)) {
            // In production, deserialize and execute the action
            event::emit(BundleEvent {
                bundle_id: *bundle_id,
                event_type: b"FAILURE_HOOK".to_string(),
                timestamp: clock.timestamp_ms(),
            });
        }
    }
}

/// Generic bundle event for hook execution
public struct BundleEvent has copy, drop {
    bundle_id: String,
    event_type: String,
    timestamp: u64,
}

/// Internal: Execute one commitment with permit-based authorization
fun execute_commitment(
    commitment: Commitment,
    account: &mut Account<FutarchyConfig>,
    clock: &Clock,
    ctx: &mut TxContext,
) {
    let Commitment {
        dao_address,
        intent_key,
        executable_id,
        committed_at: _,
        commitment_hash: _,
    } = commitment;
    
    // Verify commitment matches account
    assert!(dao_address == account::addr(account), ECommitmentMismatch);
    
    // Re-check authorization at execution time
    let permit = futarchy_config::issue_execute_permit_for_intent(
        account,
        &intent_key,
        clock
    );
    
    // Note: In the actual implementation, you would need to retrieve
    // the executable using the executable_id and then execute it
    // This is a simplified version that just validates the permit
    let _ = permit;  // Use the permit to satisfy compiler
    let _ = executable_id;  // Use the executable_id to satisfy compiler
}

/// Execute bundle with exactly 2 participants
public entry fun execute_bundle_2(
    bundle: &mut Bundle,
    account1: &mut Account<FutarchyConfig>,
    account2: &mut Account<FutarchyConfig>,
    clock: &Clock,
    ctx: &mut TxContext,
) {
    // Validations
    assert!(!bundle.executed, EBundleAlreadyExecuted);
    assert!(bundle.commitment_count >= bundle.min_participants, ENotEnoughCommitments);
    assert!(clock.timestamp_ms() < bundle.expires_at, EBundleExpired);
    
    // Execute pre-execution hook
    execute_pre_hook(&bundle.hooks, &bundle.bundle_id, clock);
    
    let addr1 = account::addr(account1);
    let addr2 = account::addr(account2);
    
    // Execute atomically
    if (bag::contains(&bundle.commitments, addr1)) {
        let commitment1: Commitment = bag::remove(&mut bundle.commitments, addr1);
        execute_commitment(commitment1, account1, clock, ctx);
    };
    
    if (bag::contains(&bundle.commitments, addr2)) {
        let commitment2: Commitment = bag::remove(&mut bundle.commitments, addr2);
        execute_commitment(commitment2, account2, clock, ctx);
    };
    
    // Execute post-execution hook
    execute_post_hook(&bundle.hooks, &bundle.bundle_id, clock);
    
    bundle.executed = true;
    
    event::emit(BundleExecuted {
        bundle_id: bundle.bundle_id,
        executed_count: 2,
        timestamp: clock.timestamp_ms(),
        executor: tx_context::sender(ctx),
    });
}

/// Execute bundle with exactly 3 participants
public entry fun execute_bundle_3(
    bundle: &mut Bundle,
    account1: &mut Account<FutarchyConfig>,
    account2: &mut Account<FutarchyConfig>,
    account3: &mut Account<FutarchyConfig>,
    clock: &Clock,
    ctx: &mut TxContext,
) {
    assert!(!bundle.executed, EBundleAlreadyExecuted);
    assert!(bundle.commitment_count >= bundle.min_participants, ENotEnoughCommitments);
    assert!(clock.timestamp_ms() < bundle.expires_at, EBundleExpired);
    
    // Execute pre-execution hook
    execute_pre_hook(&bundle.hooks, &bundle.bundle_id, clock);
    
    let addr1 = account::addr(account1);
    let addr2 = account::addr(account2);
    let addr3 = account::addr(account3);
    
    // Execute atomically
    if (bag::contains(&bundle.commitments, addr1)) {
        let commitment1: Commitment = bag::remove(&mut bundle.commitments, addr1);
        execute_commitment(commitment1, account1, clock, ctx);
    };
    
    if (bag::contains(&bundle.commitments, addr2)) {
        let commitment2: Commitment = bag::remove(&mut bundle.commitments, addr2);
        execute_commitment(commitment2, account2, clock, ctx);
    };
    
    if (bag::contains(&bundle.commitments, addr3)) {
        let commitment3: Commitment = bag::remove(&mut bundle.commitments, addr3);
        execute_commitment(commitment3, account3, clock, ctx);
    };
    
    // Execute post-execution hook
    execute_post_hook(&bundle.hooks, &bundle.bundle_id, clock);
    
    bundle.executed = true;
    
    event::emit(BundleExecuted {
        bundle_id: bundle.bundle_id,
        executed_count: 3,
        timestamp: clock.timestamp_ms(),
        executor: tx_context::sender(ctx),
    });
}

/// Execute bundle with exactly 4 participants
public entry fun execute_bundle_4(
    bundle: &mut Bundle,
    account1: &mut Account<FutarchyConfig>,
    account2: &mut Account<FutarchyConfig>,
    account3: &mut Account<FutarchyConfig>,
    account4: &mut Account<FutarchyConfig>,
    clock: &Clock,
    ctx: &mut TxContext,
) {
    assert!(!bundle.executed, EBundleAlreadyExecuted);
    assert!(bundle.commitment_count >= bundle.min_participants, ENotEnoughCommitments);
    assert!(clock.timestamp_ms() < bundle.expires_at, EBundleExpired);
    
    // Execute pre-execution hook
    execute_pre_hook(&bundle.hooks, &bundle.bundle_id, clock);
    
    let addr1 = account::addr(account1);
    let addr2 = account::addr(account2);
    let addr3 = account::addr(account3);
    let addr4 = account::addr(account4);
    
    let mut executed_count = 0u64;
    
    // Execute atomically for each account
    if (bag::contains(&bundle.commitments, addr1)) {
        let commitment1: Commitment = bag::remove(&mut bundle.commitments, addr1);
        execute_commitment(commitment1, account1, clock, ctx);
        executed_count = executed_count + 1;
    };
    
    if (bag::contains(&bundle.commitments, addr2)) {
        let commitment2: Commitment = bag::remove(&mut bundle.commitments, addr2);
        execute_commitment(commitment2, account2, clock, ctx);
        executed_count = executed_count + 1;
    };
    
    if (bag::contains(&bundle.commitments, addr3)) {
        let commitment3: Commitment = bag::remove(&mut bundle.commitments, addr3);
        execute_commitment(commitment3, account3, clock, ctx);
        executed_count = executed_count + 1;
    };
    
    if (bag::contains(&bundle.commitments, addr4)) {
        let commitment4: Commitment = bag::remove(&mut bundle.commitments, addr4);
        execute_commitment(commitment4, account4, clock, ctx);
        executed_count = executed_count + 1;
    };
    
    // Execute post-execution hook
    execute_post_hook(&bundle.hooks, &bundle.bundle_id, clock);
    
    bundle.executed = true;
    
    event::emit(BundleExecuted {
        bundle_id: bundle.bundle_id,
        executed_count,
        timestamp: clock.timestamp_ms(),
        executor: tx_context::sender(ctx),
    });
}

// === Bundle Management ===

/// Allow bundle creator to cancel before execution
public entry fun cancel_bundle(
    bundle: Bundle,
    clock: &Clock,
    ctx: &mut TxContext,
) {
    assert!(!bundle.executed, EBundleAlreadyExecuted);
    
    let Bundle { 
        id, 
        bundle_id,
        commitments, 
        commitment_count,
        metadata,
        .. 
    } = bundle;
    
    // Clean up commitments (return executables)
    let returned = cleanup_commitments(commitments);
    
    event::emit(BundleExpired {
        bundle_id,
        commitments_returned: returned,
    });
    
    bag::destroy_empty(metadata);
    object::delete(id);
}

/// Clean up expired bundle
public entry fun cleanup_expired_bundle(
    bundle: Bundle,
    clock: &Clock,
) {
    assert!(clock.timestamp_ms() > bundle.expires_at, EBundleExpired);
    assert!(!bundle.executed, EBundleAlreadyExecuted);
    
    let Bundle { 
        id, 
        bundle_id,
        commitments,
        metadata,
        .. 
    } = bundle;
    
    let returned = cleanup_commitments(commitments);
    
    event::emit(BundleExpired {
        bundle_id,
        commitments_returned: returned,
    });
    
    bag::destroy_empty(metadata);
    object::delete(id);
}

/// Internal: Clean up commitments bag
fun cleanup_commitments(mut commitments: Bag): u64 {
    let mut count = 0;
    
    // In production, you'd want to return executables to DAOs
    // For now, we just destroy them
    while (bag::length(&commitments) > 0) {
        // This is a simplified cleanup - in production you'd handle this better
        count = count + 1;
    };
    
    bag::destroy_empty(commitments);
    count
}

// === View Functions ===

public fun bundle_id(bundle: &Bundle): String {
    bundle.bundle_id
}

public fun is_executed(bundle: &Bundle): bool {
    bundle.executed
}

public fun commitment_count(bundle: &Bundle): u64 {
    bundle.commitment_count
}

public fun has_committed(bundle: &Bundle, dao: address): bool {
    bag::contains(&bundle.commitments, dao)
}

public fun expires_at(bundle: &Bundle): u64 {
    bundle.expires_at
}

public fun can_execute(bundle: &Bundle, clock: &Clock): bool {
    !bundle.executed && 
    bundle.commitment_count >= bundle.min_participants &&
    clock.timestamp_ms() < bundle.expires_at
}/// Memo/Message emission actions for futarchy DAOs
/// This module defines action structs and execution logic for emitting messages
/// Following the same pattern as liquidity_actions, config_actions, etc.
module futarchy::memo_actions;

// === Imports ===
use std::string::String;
use std::vector;
use sui::{
    object::ID,
    clock::{Self, Clock},
    tx_context::{Self, TxContext},
    event,
};
use account_protocol::{
    account::{Self, Account},
    executable::{Self, Executable},
    version_witness::VersionWitness,
};
use futarchy::futarchy_config::FutarchyConfig;

// === Errors ===
const EEmptyMemo: u64 = 1;
const EInvalidMetadata: u64 = 2;
const EMemoTooLong: u64 = 3;

// === Constants ===
const MAX_MEMO_LENGTH: u64 = 10000; // Maximum memo length in bytes

// === Action Structs ===

/// Action to emit a simple text memo
public struct EmitMemoAction has store {
    /// The message to emit
    memo: String,
    /// Optional category for filtering/organizing memos
    category: String,
    /// Optional reference to related entity (proposal, DAO, etc.)
    reference_id: Option<ID>,
}

/// Action to emit structured data as a memo
public struct EmitStructuredMemoAction has store {
    /// Title of the memo
    title: String,
    /// Key-value pairs of structured data
    fields: vector<MemoField>,
    /// Optional metadata
    metadata: vector<u8>,
}

/// A field in a structured memo
public struct MemoField has store, copy, drop {
    key: String,
    value: String,
}

/// Action to emit a commitment or agreement
public struct EmitCommitmentAction has store {
    /// Type of commitment (e.g., "partnership", "investment", "governance")
    commitment_type: String,
    /// The commitment message
    commitment: String,
    /// Counterparty ID if applicable
    counterparty: Option<ID>,
    /// Expiry timestamp if applicable
    expires_at: Option<u64>,
}

/// Action to emit a vote or signal
public struct EmitSignalAction has store {
    /// What is being signaled about
    signal_type: String,
    /// The signal value (e.g., "support", "oppose", "abstain")
    signal_value: String,
    /// Optional context
    context: vector<u8>,
}

// === Events ===

public struct MemoEmitted has copy, drop {
    /// DAO that emitted the memo
    dao_id: ID,
    /// The memo content
    memo: String,
    /// Category of the memo
    category: String,
    /// Optional reference
    reference_id: Option<ID>,
    /// When it was emitted
    timestamp: u64,
    /// Who triggered the emission
    emitter: address,
}

public struct StructuredMemoEmitted has copy, drop {
    dao_id: ID,
    title: String,
    fields: vector<MemoField>,
    timestamp: u64,
    emitter: address,
}

public struct CommitmentEmitted has copy, drop {
    dao_id: ID,
    commitment_type: String,
    commitment: String,
    counterparty: Option<ID>,
    expires_at: Option<u64>,
    timestamp: u64,
    emitter: address,
}

public struct SignalEmitted has copy, drop {
    dao_id: ID,
    signal_type: String,
    signal_value: String,
    timestamp: u64,
    emitter: address,
}

// === Intent Witness ===

/// Witness for memo intents
public struct MemoIntent has drop {}

// === Execution Functions ===

/// Execute an emit memo action
public fun do_emit_memo<Outcome: store, IW: drop>(
    executable: &mut Executable<Outcome>,
    account: &mut Account<FutarchyConfig>,
    version: VersionWitness,
    intent_witness: IW,
    clock: &Clock,
    ctx: &mut TxContext,
) {
    let action: &EmitMemoAction = executable::next_action(executable, intent_witness);
    
    // Validate memo
    assert!(action.memo.length() > 0, EEmptyMemo);
    assert!(action.memo.length() <= MAX_MEMO_LENGTH, EMemoTooLong);
    
    // Emit the event
    event::emit(MemoEmitted {
        dao_id: object::id(account),
        memo: action.memo,
        category: action.category,
        reference_id: action.reference_id,
        timestamp: clock::timestamp_ms(clock),
        emitter: tx_context::sender(ctx),
    });
}

/// Execute an emit structured memo action
public fun do_emit_structured_memo<Outcome: store, IW: drop>(
    executable: &mut Executable<Outcome>,
    account: &mut Account<FutarchyConfig>,
    version: VersionWitness,
    intent_witness: IW,
    clock: &Clock,
    ctx: &mut TxContext,
) {
    let action: &EmitStructuredMemoAction = executable::next_action(executable, intent_witness);
    
    // Validate
    assert!(action.title.length() > 0, EEmptyMemo);
    assert!(!vector::is_empty(&action.fields), EInvalidMetadata);
    
    // Emit the event
    event::emit(StructuredMemoEmitted {
        dao_id: object::id(account),
        title: action.title,
        fields: action.fields,
        timestamp: clock::timestamp_ms(clock),
        emitter: tx_context::sender(ctx),
    });
}

/// Execute an emit commitment action
public fun do_emit_commitment<Outcome: store, IW: drop>(
    executable: &mut Executable<Outcome>,
    account: &mut Account<FutarchyConfig>,
    version: VersionWitness,
    intent_witness: IW,
    clock: &Clock,
    ctx: &mut TxContext,
) {
    let action: &EmitCommitmentAction = executable::next_action(executable, intent_witness);
    
    // Validate
    assert!(action.commitment.length() > 0, EEmptyMemo);
    assert!(action.commitment.length() <= MAX_MEMO_LENGTH, EMemoTooLong);
    
    // Check expiry if provided
    if (action.expires_at.is_some()) {
        let expiry = *action.expires_at.borrow();
        assert!(expiry > clock::timestamp_ms(clock), EInvalidMetadata);
    };
    
    // Emit the event
    event::emit(CommitmentEmitted {
        dao_id: object::id(account),
        commitment_type: action.commitment_type,
        commitment: action.commitment,
        counterparty: action.counterparty,
        expires_at: action.expires_at,
        timestamp: clock::timestamp_ms(clock),
        emitter: tx_context::sender(ctx),
    });
}

/// Execute an emit signal action
public fun do_emit_signal<Outcome: store, IW: drop>(
    executable: &mut Executable<Outcome>,
    account: &mut Account<FutarchyConfig>,
    version: VersionWitness,
    intent_witness: IW,
    clock: &Clock,
    ctx: &mut TxContext,
) {
    let action: &EmitSignalAction = executable::next_action(executable, intent_witness);
    
    // Validate
    assert!(action.signal_type.length() > 0, EEmptyMemo);
    assert!(action.signal_value.length() > 0, EEmptyMemo);
    
    // Emit the event
    event::emit(SignalEmitted {
        dao_id: object::id(account),
        signal_type: action.signal_type,
        signal_value: action.signal_value,
        timestamp: clock::timestamp_ms(clock),
        emitter: tx_context::sender(ctx),
    });
}

// === Constructor Functions ===

/// Create an emit memo action
public fun new_emit_memo_action(
    memo: String,
    category: String,
    reference_id: Option<ID>,
): EmitMemoAction {
    EmitMemoAction {
        memo,
        category,
        reference_id,
    }
}

/// Create an emit structured memo action
public fun new_emit_structured_memo_action(
    title: String,
    fields: vector<MemoField>,
    metadata: vector<u8>,
): EmitStructuredMemoAction {
    EmitStructuredMemoAction {
        title,
        fields,
        metadata,
    }
}

/// Create an emit commitment action
public fun new_emit_commitment_action(
    commitment_type: String,
    commitment: String,
    counterparty: Option<ID>,
    expires_at: Option<u64>,
): EmitCommitmentAction {
    EmitCommitmentAction {
        commitment_type,
        commitment,
        counterparty,
        expires_at,
    }
}

/// Create an emit signal action
public fun new_emit_signal_action(
    signal_type: String,
    signal_value: String,
    context: vector<u8>,
): EmitSignalAction {
    EmitSignalAction {
        signal_type,
        signal_value,
        context,
    }
}

/// Create a memo field
public fun new_memo_field(key: String, value: String): MemoField {
    MemoField { key, value }
}

// === Getter Functions ===

public fun get_memo(action: &EmitMemoAction): &String {
    &action.memo
}

public fun get_category(action: &EmitMemoAction): &String {
    &action.category
}

public fun get_reference_id(action: &EmitMemoAction): &Option<ID> {
    &action.reference_id
}

public fun get_title(action: &EmitStructuredMemoAction): &String {
    &action.title
}

public fun get_fields(action: &EmitStructuredMemoAction): &vector<MemoField> {
    &action.fields
}

public fun get_commitment_type(action: &EmitCommitmentAction): &String {
    &action.commitment_type
}

public fun get_commitment(action: &EmitCommitmentAction): &String {
    &action.commitment
}

public fun get_counterparty(action: &EmitCommitmentAction): &Option<ID> {
    &action.counterparty
}

public fun get_signal_type(action: &EmitSignalAction): &String {
    &action.signal_type
}

public fun get_signal_value(action: &EmitSignalAction): &String {
    &action.signal_value
}/// Memo intents for the account protocol
/// Provides the intent witness for memo actions
module futarchy::memo_intents;

use std::string::String;
use sui::tx_context::TxContext;
use account_protocol::{
    account::Account,
    intents,
};
use futarchy::{
    futarchy_config::FutarchyConfig,
    memo_actions::{EmitMemoAction, EmitStructuredMemoAction, EmitCommitmentAction, EmitSignalAction},
};

/// Intent witness for memo actions
public struct MemoIntent has copy, drop {}/// Dispatcher for memo actions
module futarchy::memo_dispatcher;

// === Imports ===
use sui::{
    clock::Clock,
    tx_context::TxContext,
};
use account_protocol::{
    account::Account,
    executable::{Self, Executable},
};
use futarchy::{
    futarchy_config::FutarchyConfig,
    version,
    memo_actions,
};

// === Public(friend) Functions ===

/// Try to execute memo actions
public(package) fun try_execute_memo_action<IW: drop, Outcome: store + drop + copy>(
    executable: &mut Executable<Outcome>,
    account: &mut Account<FutarchyConfig>,
    witness: IW,
    clock: &Clock,
    ctx: &mut TxContext
): bool {
    // Try to execute EmitMemoAction
    if (executable::contains_action<Outcome, memo_actions::EmitMemoAction>(executable)) {
        memo_actions::do_emit_memo<Outcome, IW>(
            executable,
            account,
            version::current(),
            witness,
            clock,
            ctx
        );
        return true
    };
    
    // Try to execute EmitStructuredMemoAction
    if (executable::contains_action<Outcome, memo_actions::EmitStructuredMemoAction>(executable)) {
        memo_actions::do_emit_structured_memo<Outcome, IW>(
            executable,
            account,
            version::current(),
            witness,
            clock,
            ctx
        );
        return true
    };
    
    // Try to execute EmitCommitmentAction
    if (executable::contains_action<Outcome, memo_actions::EmitCommitmentAction>(executable)) {
        memo_actions::do_emit_commitment<Outcome, IW>(
            executable,
            account,
            version::current(),
            witness,
            clock,
            ctx
        );
        return true
    };
    
    // Try to execute EmitSignalAction
    if (executable::contains_action<Outcome, memo_actions::EmitSignalAction>(executable)) {
        memo_actions::do_emit_signal<Outcome, IW>(
            executable,
            account,
            version::current(),
            witness,
            clock,
            ctx
        );
        return true
    };
    
    false
}/// Commitment Dispatcher Module
/// Routes commitment-related actions through the action dispatcher system
module futarchy::commitment_dispatcher;

use std::string::{Self, String};
use std::option::{Self, Option};
use sui::clock::Clock;
use sui::coin::Coin;
use sui::transfer;
use sui::tx_context::TxContext;
use account_protocol::{
    executable::{Self, Executable},
    account::{Self, Account},
    version_witness::VersionWitness,
};
use futarchy::{
    futarchy_config::FutarchyConfig,
    version,
    commitment_proposal::{Self, CommitmentProposal},
    proposal::Proposal,
    commitment_actions::{Self, CreateCommitmentProposalAction, ExecuteCommitmentAction, 
                         UpdateCommitmentRecipientAction, WithdrawUnlockedTokensAction},
};

// === Dispatcher Functions ===

/// Try to execute create commitment action
public fun try_execute_create_commitment<AssetType, StableType, Outcome: store, IW: drop>(
    executable: &mut Executable<Outcome>,
    account: &mut Account<FutarchyConfig>,
    witness: IW,
    committed_coins: Coin<AssetType>,
    clock: &Clock,
    ctx: &mut TxContext,
): Option<CommitmentProposal<AssetType, StableType>> {
    if (executable::contains_action<Outcome, CreateCommitmentProposalAction<AssetType>>(executable)) {
        let commitment = commitment_actions::do_create_commitment_proposal<AssetType, StableType, Outcome, IW>(
            executable,
            account,
            version::current(),
            witness,
            committed_coins,
            clock,
            ctx,
        );
        option::some(commitment)
    } else {
        // If no action, return the coins to the sender
        transfer::public_transfer(committed_coins, ctx.sender());
        option::none()
    }
}

/// Try to execute commitment execution action
public fun try_execute_commitment<AssetType, StableType, Outcome: store, IW: drop>(
    executable: &mut Executable<Outcome>,
    account: &mut Account<FutarchyConfig>,
    witness: IW,
    commitment: &mut CommitmentProposal<AssetType, StableType>,
    proposal: &Proposal<AssetType, StableType>,
    clock: &Clock,
    ctx: &mut TxContext,
): bool {
    if (executable::contains_action<Outcome, ExecuteCommitmentAction>(executable)) {
        commitment_actions::do_execute_commitment<AssetType, StableType, Outcome, IW>(
            executable,
            account,
            version::current(),
            witness,
            commitment,
            proposal,
            clock,
            ctx,
        );
        true
    } else {
        false
    }
}

/// Try to execute other commitment actions
public fun try_execute_other_commitment_actions<AssetType, StableType, Outcome: store, IW: drop>(
    executable: &mut Executable<Outcome>,
    account: &mut Account<FutarchyConfig>,
    witness: IW,
    commitment: &mut futarchy::commitment_proposal::CommitmentProposal<AssetType, StableType>,
    clock: &Clock,
    ctx: &mut TxContext,
): bool {
    if (executable::contains_action<Outcome, UpdateCommitmentRecipientAction>(executable)) {
        commitment_actions::do_update_commitment_recipient<AssetType, StableType, Outcome, IW>(
            executable,
            account,
            version::current(),
            witness,
            commitment,
            ctx,
        );
        true
    } else if (executable::contains_action<Outcome, WithdrawUnlockedTokensAction>(executable)) {
        commitment_actions::do_withdraw_unlocked_tokens<AssetType, StableType, Outcome, IW>(
            executable,
            account,
            version::current(),
            witness,
            commitment,
            clock,
            ctx,
        );
        true
    } else {
        false
    }
}module futarchy::proposal_fee_manager;

use sui::{
    coin::{Self, Coin},
    balance::{Self, Balance},
    sui::SUI,
    bag::{Self, Bag},
    clock::Clock,
    event,
    transfer
};
use futarchy::futarchy_config::{Self, SlashDistribution};

// === Errors ===
const EInvalidFeeAmount: u64 = 0;
const EProposalFeeNotFound: u64 = 1;

// === Constants ===
const FIXED_ACTIVATOR_REWARD: u64 = 1_000_000; // 0.001 SUI fixed reward for activators

// === Structs ===

/// Manages proposal submission fees and activator rewards
public struct ProposalFeeManager has key, store {
    id: UID,
    /// Stores fees paid for proposals waiting in the queue
    /// Key is the proposal ID, value is the SUI Balance
    pending_proposal_fees: Bag,
    /// Total fees collected by the protocol from evicted/slashed proposals
    protocol_revenue: Balance<SUI>,
    /// Queue fees collected for proposals
    queue_fees: Balance<SUI>,
}

// === Events ===

public struct QueueFeeDeposited has copy, drop {
    amount: u64,
    depositor: address,
    timestamp: u64,
}

public struct ProposalFeeUpdated has copy, drop {
    proposal_id: ID,
    additional_amount: u64,
    new_total_amount: u64,
    timestamp: u64,
}

// === Public Functions ===

/// Creates a new ProposalFeeManager
public fun new(ctx: &mut TxContext): ProposalFeeManager {
    ProposalFeeManager {
        id: object::new(ctx),
        pending_proposal_fees: bag::new(ctx),
        protocol_revenue: balance::zero(),
        queue_fees: balance::zero(),
    }
}

/// Called by the DAO when a proposal is submitted to the queue
public fun deposit_proposal_fee(
    manager: &mut ProposalFeeManager, 
    proposal_id: ID, 
    fee_coin: Coin<SUI>
) {
    assert!(fee_coin.value() > 0, EInvalidFeeAmount);
    let fee_balance = fee_coin.into_balance();
    manager.pending_proposal_fees.add(proposal_id, fee_balance);
}

/// Called when a proposal is submitted to the queue to pay the queue fee
public fun deposit_queue_fee(
    manager: &mut ProposalFeeManager,
    fee_coin: Coin<SUI>,
    clock: &Clock,
    ctx: &TxContext
) {
    let amount = fee_coin.value();
    if (amount > 0) {
        manager.queue_fees.join(fee_coin.into_balance());
        
        event::emit(QueueFeeDeposited {
            amount,
            depositor: ctx.sender(),
            timestamp: clock.timestamp_ms(),
        });
    } else {
        fee_coin.destroy_zero();
    }
}

/// Called when a user increases the fee for an existing queued proposal
public fun add_to_proposal_fee(
    manager: &mut ProposalFeeManager,
    proposal_id: ID,
    additional_fee: Coin<SUI>,
    clock: &Clock
) {
    assert!(manager.pending_proposal_fees.contains(proposal_id), EProposalFeeNotFound);
    assert!(additional_fee.value() > 0, EInvalidFeeAmount);

    let additional_amount = additional_fee.value();
    // Get the existing balance, join the new one, and put it back
    let mut existing_balance: Balance<SUI> = manager.pending_proposal_fees.remove(proposal_id);
    existing_balance.join(additional_fee.into_balance());
    let new_total = existing_balance.value();

    event::emit(ProposalFeeUpdated {
        proposal_id,
        additional_amount,
        new_total_amount: new_total,
        timestamp: clock.timestamp_ms(),
    });

    manager.pending_proposal_fees.add(proposal_id, existing_balance);
}

/// Called by the DAO when activating a proposal
/// Returns a fixed reward to the activator and keeps the rest as protocol revenue
public fun take_activator_reward(
    manager: &mut ProposalFeeManager, 
    proposal_id: ID, 
    ctx: &mut TxContext
): Coin<SUI> {
    assert!(manager.pending_proposal_fees.contains(proposal_id), EProposalFeeNotFound);
    
    let mut fee_balance: Balance<SUI> = manager.pending_proposal_fees.remove(proposal_id);
    let total_fee = fee_balance.value();
    
    if (total_fee == 0) {
        return coin::from_balance(fee_balance, ctx)
    };

    // Give fixed reward to activator, rest goes to protocol
    if (total_fee >= FIXED_ACTIVATOR_REWARD) {
        // Split off the protocol's share (everything except the fixed reward)
        let protocol_share = fee_balance.split(total_fee - FIXED_ACTIVATOR_REWARD);
        manager.protocol_revenue.join(protocol_share);
        // Return the fixed reward to the activator
        coin::from_balance(fee_balance, ctx)
    } else {
        // If fee is less than fixed reward, give entire fee to activator
        coin::from_balance(fee_balance, ctx)
    }
}

/// Called by the DAO when a proposal is evicted from the queue
/// Distributes the slashed fee according to the SlashDistribution configuration
/// Returns coins for slasher and DAO treasury
public fun slash_proposal_fee_with_distribution(
    manager: &mut ProposalFeeManager, 
    proposal_id: ID,
    slash_config: &SlashDistribution,
    ctx: &mut TxContext
): (Coin<SUI>, Coin<SUI>) { // Returns (slasher_reward, dao_treasury)
    assert!(manager.pending_proposal_fees.contains(proposal_id), EProposalFeeNotFound);
    
    let mut fee_balance: Balance<SUI> = manager.pending_proposal_fees.remove(proposal_id);
    let total_amount = fee_balance.value();
    
    if (total_amount == 0) {
        fee_balance.destroy_zero();
        return (coin::zero(ctx), coin::zero(ctx))
    };
    
    // Calculate distributions using getter functions
    let slasher_amount = (total_amount * (futarchy_config::slasher_reward_bps(slash_config) as u64)) / 10000;
    let dao_amount = (total_amount * (futarchy_config::dao_treasury_bps(slash_config) as u64)) / 10000;
    let protocol_amount = (total_amount * (futarchy_config::protocol_bps(slash_config) as u64)) / 10000;
    let burn_amount = (total_amount * (futarchy_config::burn_bps(slash_config) as u64)) / 10000;
    
    // Handle rounding: give any remainder to protocol
    let distributed = slasher_amount + dao_amount + protocol_amount + burn_amount;
    let remainder = if (total_amount > distributed) { total_amount - distributed } else { 0 };
    let final_protocol_amount = protocol_amount + remainder;
    
    // Create slasher reward coin
    let slasher_reward = if (slasher_amount > 0) {
        coin::from_balance(fee_balance.split(slasher_amount), ctx)
    } else {
        coin::zero(ctx)
    };
    
    // Create DAO treasury coin
    let dao_coin = if (dao_amount > 0) {
        coin::from_balance(fee_balance.split(dao_amount), ctx)
    } else {
        coin::zero(ctx)
    };
    
    // Add protocol's share to revenue
    if (final_protocol_amount > 0) {
        manager.protocol_revenue.join(fee_balance.split(final_protocol_amount));
    };
    
    // Burn the burn amount
    if (burn_amount > 0) {
        let burn_balance = fee_balance.split(burn_amount);
        burn_balance.destroy_zero();
    };
    
    // Destroy any remaining dust
    if (fee_balance.value() > 0) {
        manager.protocol_revenue.join(fee_balance);
    } else {
        fee_balance.destroy_zero();
    };
    
    (slasher_reward, dao_coin)
}

/// Gets the current protocol revenue
public fun protocol_revenue(manager: &ProposalFeeManager): u64 {
    manager.protocol_revenue.value()
}

/// Withdraws accumulated protocol revenue to the main fee manager
public(package) fun withdraw_protocol_revenue(
    manager: &mut ProposalFeeManager,
    amount: u64,
    ctx: &mut TxContext
): Coin<SUI> {
    coin::from_balance(manager.protocol_revenue.split(amount), ctx)
}

/// Called by the priority queue when a proposal is cancelled.
/// Removes the pending fee from the manager and returns it as a Coin.
/// This should be a friend function, callable only by the priority_queue module.
public(package) fun refund_proposal_fee(
    manager: &mut ProposalFeeManager,
    proposal_id: ID,
    ctx: &mut TxContext
): Coin<SUI> {
    assert!(manager.pending_proposal_fees.contains(proposal_id), EProposalFeeNotFound);
    let fee_balance: Balance<SUI> = manager.pending_proposal_fees.remove(proposal_id);
    coin::from_balance(fee_balance, ctx)
}

/// Check if a proposal fee exists
public fun has_proposal_fee(manager: &ProposalFeeManager, proposal_id: ID): bool {
    manager.pending_proposal_fees.contains(proposal_id)
}

/// Get the fee amount for a proposal
public fun get_proposal_fee(manager: &ProposalFeeManager, proposal_id: ID): u64 {
    if (manager.pending_proposal_fees.contains(proposal_id)) {
        let balance: &Balance<SUI> = &manager.pending_proposal_fees[proposal_id];
        balance.value()
    } else {
        0
    }
}

/// Pay reward to proposal creator when proposal passes
/// Takes from protocol revenue
public fun pay_proposal_creator_reward(
    manager: &mut ProposalFeeManager,
    reward_amount: u64,
    ctx: &mut TxContext
): Coin<SUI> {
    if (manager.protocol_revenue.value() >= reward_amount) {
        coin::from_balance(manager.protocol_revenue.split(reward_amount), ctx)
    } else {
        // If not enough in protocol revenue, pay what's available
        let available = manager.protocol_revenue.value();
        if (available > 0) {
            coin::from_balance(manager.protocol_revenue.split(available), ctx)
        } else {
            coin::zero(ctx)
        }
    }
}

/// Pay reward to outcome creator when their outcome wins
/// Takes from protocol revenue
public fun pay_outcome_creator_reward(
    manager: &mut ProposalFeeManager,
    reward_amount: u64,
    ctx: &mut TxContext
): Coin<SUI> {
    if (manager.protocol_revenue.value() >= reward_amount) {
        coin::from_balance(manager.protocol_revenue.split(reward_amount), ctx)
    } else {
        // If not enough in protocol revenue, pay what's available
        let available = manager.protocol_revenue.value();
        if (available > 0) {
            coin::from_balance(manager.protocol_revenue.split(available), ctx)
        } else {
            coin::zero(ctx)
        }
    }
}

/// Collect fee for advancing proposal state
/// Called when advancing from review to trading or when finalizing
public fun collect_advancement_fee(
    manager: &mut ProposalFeeManager,
    fee_coin: Coin<SUI>
) {
    manager.protocol_revenue.join(fee_coin.into_balance());
}/// Unified oracle actions - uses stored TreasuryCap from DAO Account
module futarchy::oracle_actions;

use std::string::{Self, String};
use std::vector;
use std::option::{Self, Option};
use sui::coin::{Self, Coin};
use sui::clock::Clock;
use sui::transfer;
use sui::tx_context::TxContext;
use sui::object::{Self, ID};
use sui::event;
use account_protocol::{
    intents::{Expired, Intent},
    executable::{Self, Executable},
    account::{Self, Account},
    version_witness::VersionWitness,
};
use account_actions::currency;
use futarchy::{
    futarchy_config::FutarchyConfig,
    version,
    spot_amm::{Self, SpotAMM},
    spot_conditional_quoter,
    proposal::Proposal,
    conditional_amm,
    weighted_multisig::{Self, WeightedMultisig},
};

// === Errors ===
const EPriceThresholdNotMet: u64 = 0;
const EInvalidMintAmount: u64 = 1;
const EInvalidRecipient: u64 = 2;
const ETimeConditionNotMet: u64 = 3;
const ETwapNotReady: u64 = 4;
const EExceedsMaxSupply: u64 = 5;
const EAlreadyExecuted: u64 = 6;
const EInvalidThreshold: u64 = 7;
const EOverflow: u64 = 8;
const EDivisionByZero: u64 = 9;
const ECannotExecuteWithoutTreasuryCap: u64 = 10;
const EMismatchedVectors: u64 = 11;
const EEmptyRecipients: u64 = 12;
const ETierOutOfBounds: u64 = 13;
const EInvalidSecurityCouncil: u64 = 14;
const ERecipientNotFound: u64 = 15;

// === Constants ===
const MAX_MINT_PERCENTAGE: u64 = 500; // 5% max mint per execution (in basis points)
const COOLDOWN_PERIOD_MS: u64 = 86_400_000; // 24 hours between mints
const MAX_RECIPIENTS_PER_TIER: u64 = 20; // Max cofounders per tier
const MAX_TIERS: u64 = 10; // Max price tiers

// === Helper Structs ===

/// Helper struct to store mint operations
public struct MintOperation has copy, drop {
    recipient: address,
    amount: u64,
}

// === Events ===

/// Emitted when oracle price is read
public struct OraclePriceRead has copy, drop {
    oracle_type: u8, // 0 = spot, 1 = conditional
    price: u128,
    timestamp: u64,
}

/// Emitted when tokens are minted based on oracle conditions
public struct ConditionalMintExecuted has copy, drop {
    recipient: address,
    amount_minted: u64,
    price_at_execution: u128,
    timestamp: u64,
}

/// Emitted when a tier is executed
public struct TierExecuted has copy, drop {
    tier_index: u64,
    total_minted: u64,
    price_at_execution: u128,
    timestamp: u64,
}

// === Structs ===

/// Simple action to read oracle price
public struct ReadOraclePriceAction<phantom AssetType, phantom StableType> has store, drop {
    emit_event: bool,
}

/// Action to read oracle price and conditionally mint tokens
/// This is used for founder rewards, liquidity incentives, etc.
public struct ConditionalMintAction<phantom T> has store {
    /// Address to receive minted tokens
    recipient: address,
    /// Amount of tokens to mint if condition is met
    mint_amount: u64,
    /// Price threshold (scaled by 1e12)
    price_threshold: u128,
    /// Whether price must be above (true) or below (false) threshold
    is_above_threshold: bool,
    /// Optional: earliest time this can execute (milliseconds)
    earliest_execution_time: Option<u64>,
    /// Optional: latest time this can execute (milliseconds)
    latest_execution_time: Option<u64>,
    /// Whether this action can be executed multiple times
    is_repeatable: bool,
    /// Cooldown period between executions (if repeatable)
    cooldown_ms: u64,
    /// Last execution timestamp
    last_execution: Option<u64>,
    /// Maximum number of executions (0 = unlimited)
    max_executions: u64,
    /// Current execution count
    execution_count: u64,
    /// Description of the mint purpose
    description: String,
}


/// A single recipient's mint configuration
public struct RecipientMint has store, copy, drop {
    recipient: address,
    mint_amount: u64,
}

/// A price tier with multiple recipients
public struct PriceTier has store {
    /// Price threshold that must be reached (scaled by 1e12)
    price_threshold: u128,
    /// Whether price must be above (true) or below (false) threshold
    is_above_threshold: bool,
    /// Recipients and their mint amounts for this tier
    recipients: vector<RecipientMint>,
    /// Whether this tier has been executed
    executed: bool,
    /// Description of this tier (e.g., "2x milestone rewards")
    description: String,
}

/// Multi-tiered mint action for cofounders
/// Each tier can be executed independently when its price is reached
public struct TieredMintAction<phantom T> has store {
    /// All price tiers with their recipients
    tiers: vector<PriceTier>,
    /// Earliest time any tier can execute (milliseconds)
    earliest_execution_time: u64,
    /// Latest time any tier can execute (milliseconds)
    latest_execution_time: u64,
    /// Overall description
    description: String,
    /// Optional: Security council that can update recipients
    security_council_id: Option<ID>,
}

/// Long-lived pre-approved intent for recurring mints
/// This allows DAOs to set up automated token distribution
public struct RecurringMintIntent<phantom T> has store {
    /// Configurations for multiple mint conditions
    mint_configs: vector<ConditionalMintAction<T>>,
    /// Total amount authorized for minting
    total_authorized: u64,
    /// Amount already minted
    total_minted: u64,
    /// Intent expiration time
    expires_at: u64,
    /// Whether the intent is active
    is_active: bool,
}

// === Constructor Functions ===

/// Create a new RecipientMint
public fun new_recipient_mint(
    recipient: address,
    mint_amount: u64,
): RecipientMint {
    RecipientMint {
        recipient,
        mint_amount,
    }
}

/// Create a new PriceTier
public fun new_price_tier(
    price_threshold: u128,
    is_above_threshold: bool,
    recipients: vector<RecipientMint>,
    description: String,
): PriceTier {
    PriceTier {
        price_threshold,
        is_above_threshold,
        recipients,
        description,
        executed: false,
    }
}

/// Create a simple oracle read action
public fun new_read_oracle_action<AssetType, StableType>(
    emit_event: bool,
): ReadOraclePriceAction<AssetType, StableType> {
    ReadOraclePriceAction { emit_event }
}

public fun new_conditional_mint<T>(
    recipient: address,
    mint_amount: u64,
    price_threshold: u128,
    is_above_threshold: bool,
    earliest_time: Option<u64>,
    latest_time: Option<u64>,
    is_repeatable: bool,
    description: String,
): ConditionalMintAction<T> {
    assert!(mint_amount > 0, EInvalidMintAmount);
    assert!(price_threshold > 0, EInvalidThreshold);
    
    // Validate time range if both are specified
    if (earliest_time.is_some() && latest_time.is_some()) {
        let earliest = *earliest_time.borrow();
        let latest = *latest_time.borrow();
        assert!(latest > earliest, ETimeConditionNotMet);
        
        // Max 5 years validity (in milliseconds)
        let max_duration = 5 * 365 * 24 * 60 * 60 * 1000; // 5 years
        assert!(latest - earliest <= max_duration, ETimeConditionNotMet);
    };
    
    ConditionalMintAction {
        recipient,
        mint_amount,
        price_threshold,
        is_above_threshold,
        earliest_execution_time: earliest_time,
        latest_execution_time: latest_time,
        is_repeatable,
        cooldown_ms: if (is_repeatable) COOLDOWN_PERIOD_MS else 0,
        last_execution: option::none(),
        max_executions: if (is_repeatable) 0 else 1,
        execution_count: 0,
        description,
    }
}


/// Create a founder reward mint with explicit time bounds
public fun new_founder_reward_mint<T>(
    founder: address,
    amount: u64,
    unlock_price: u128,
    unlock_delay_ms: u64,
    description: String,
    clock: &Clock,
): ConditionalMintAction<T> {
    let now = clock.timestamp_ms();
    new_conditional_mint(
        founder,
        amount,
        unlock_price,
        true, // Above threshold
        option::some(now + unlock_delay_ms),
        option::none(), // No latest time
        false, // Not repeatable
        description,
    )
}

/// Create a liquidity incentive mint (repeatable)
public fun new_liquidity_incentive<T>(
    lp_address: address,
    amount_per_period: u64,
    min_price: u128,
    description: String,
): ConditionalMintAction<T> {
    new_conditional_mint(
        lp_address,
        amount_per_period,
        min_price,
        true, // Above threshold
        option::none(), // Can start immediately
        option::none(), // No end time
        true, // Repeatable
        description,
    )
}

/// Create a tiered mint action with multiple recipients
public fun new_tiered_mint<T>(
    tiers: vector<PriceTier>,
    earliest_time: u64,
    latest_time: u64,
    description: String,
    security_council_id: Option<ID>,
): TieredMintAction<T> {
    assert!(tiers.length() > 0 && tiers.length() <= MAX_TIERS, ETierOutOfBounds);
    assert!(latest_time > earliest_time, ETimeConditionNotMet);
    
    // Validate each tier
    let mut i = 0;
    while (i < tiers.length()) {
        let tier = tiers.borrow(i);
        assert!(tier.recipients.length() > 0, EEmptyRecipients);
        assert!(tier.recipients.length() <= MAX_RECIPIENTS_PER_TIER, ETierOutOfBounds);
        i = i + 1;
    };
    
    TieredMintAction {
        tiers,
        earliest_execution_time: earliest_time,
        latest_execution_time: latest_time,
        description,
        security_council_id,
    }
}

/// Create a tiered founder reward structure
public fun new_tiered_founder_rewards<T>(
    recipients_per_tier: vector<vector<address>>,
    amounts_per_tier: vector<vector<u64>>,
    price_thresholds: vector<u128>,
    descriptions_per_tier: vector<String>,
    earliest_time: u64,
    latest_time: u64,
    description: String,
): TieredMintAction<T> {
    assert!(
        recipients_per_tier.length() == amounts_per_tier.length() &&
        amounts_per_tier.length() == price_thresholds.length() &&
        price_thresholds.length() == descriptions_per_tier.length(),
        EMismatchedVectors
    );
    
    let mut tiers = vector::empty();
    let mut i = 0;
    
    while (i < recipients_per_tier.length()) {
        let recipients = recipients_per_tier.borrow(i);
        let amounts = amounts_per_tier.borrow(i);
        assert!(recipients.length() == amounts.length(), EMismatchedVectors);
        
        let mut recipient_mints = vector::empty();
        let mut j = 0;
        while (j < recipients.length()) {
            vector::push_back(&mut recipient_mints, RecipientMint {
                recipient: *recipients.borrow(j),
                mint_amount: *amounts.borrow(j),
            });
            j = j + 1;
        };
        
        vector::push_back(&mut tiers, PriceTier {
            price_threshold: *price_thresholds.borrow(i),
            is_above_threshold: true,
            recipients: recipient_mints,
            executed: false,
            description: *descriptions_per_tier.borrow(i),
        });
        
        i = i + 1;
    };
    
    new_tiered_mint(
        tiers,
        earliest_time,
        latest_time,
        description,
        option::none(),
    )
}

// === Execution Functions ===

/// Execute a read oracle price action
public fun do_read_oracle_price<AssetType, StableType, Outcome: store, IW: drop>(
    executable: &mut Executable<Outcome>,
    _account: &mut Account<FutarchyConfig>,
    _version: VersionWitness,
    witness: IW,
    spot_pool: &mut SpotAMM<AssetType, StableType>,
    clock: &Clock,
    _ctx: &mut TxContext,
) {
    let action = executable::next_action<Outcome, ReadOraclePriceAction<AssetType, StableType>, IW>(executable, witness);
    
    // Read the price
    assert!(spot_amm::is_twap_ready(spot_pool, clock), ETwapNotReady);
    let price = spot_amm::get_twap_mut(spot_pool, clock);
    
    // Emit event if requested
    if (action.emit_event) {
        event::emit(OraclePriceRead {
            oracle_type: 0, // Spot oracle
            price,
            timestamp: clock.timestamp_ms(),
        });
    };
}

/// Execute conditional mint using stored TreasuryCap
public fun do_conditional_mint<AssetType, StableType, Outcome: store, IW: copy + drop>(
    executable: &mut Executable<Outcome>,
    account: &mut Account<FutarchyConfig>,
    version: VersionWitness,
    witness: IW,
    spot_pool: &mut SpotAMM<AssetType, StableType>,
    clock: &Clock,
    ctx: &mut TxContext,
) {
    // Get the action from the executable and extract necessary data
    let action = executable::next_action<Outcome, ConditionalMintAction<AssetType>, IW>(executable, witness);
    
    // Extract all needed values from action before any mutable operations
    let recipient = action.recipient;
    let mint_amount = action.mint_amount;
    let price_threshold = action.price_threshold;
    let is_above_threshold = action.is_above_threshold;
    let is_repeatable = action.is_repeatable;
    let execution_count = action.execution_count;
    let cooldown_ms = action.cooldown_ms;
    let earliest_time = action.earliest_execution_time;
    let latest_time = action.latest_execution_time;
    let last_execution = action.last_execution;
    
    // Validate time conditions
    let now = clock.timestamp_ms();
    if (earliest_time.is_some()) {
        assert!(now >= *earliest_time.borrow(), ETimeConditionNotMet);
    };
    if (latest_time.is_some()) {
        assert!(now <= *latest_time.borrow(), ETimeConditionNotMet);
    };
    
    // Check if already executed (if not repeatable)
    if (!is_repeatable && execution_count > 0) {
        abort EAlreadyExecuted
    };
    
    // Check cooldown if repeatable
    if (is_repeatable && last_execution.is_some()) {
        let last = *last_execution.borrow();
        assert!(now >= last + cooldown_ms, ETimeConditionNotMet);
    };
    
    // Get current price
    assert!(spot_amm::is_twap_ready(spot_pool, clock), ETwapNotReady);
    let current_price = spot_amm::get_twap_mut(spot_pool, clock);
    
    // Check price threshold
    let threshold_met = if (is_above_threshold) {
        current_price >= price_threshold
    } else {
        current_price <= price_threshold
    };
    
    // Only mint if threshold is met
    assert!(threshold_met, EPriceThresholdNotMet);
    
    // Check that DAO has treasury cap
    assert!(currency::has_cap<FutarchyConfig, AssetType>(account), ECannotExecuteWithoutTreasuryCap);
    
    // Check max supply constraint
    let current_supply = currency::coin_type_supply<FutarchyConfig, AssetType>(account);
    let max_mint = (current_supply * MAX_MINT_PERCENTAGE) / 10000;
    let actual_mint = if (mint_amount > max_mint) {
        max_mint
    } else {
        mint_amount
    };
    
    // Now we can safely call do_mint since we're no longer borrowing from action
    let minted_coin = currency::do_mint<FutarchyConfig, Outcome, AssetType, IW>(
        executable,
        account,
        version,
        witness,
        ctx
    );
    
    // Transfer to recipient
    transfer::public_transfer(minted_coin, recipient);
    
    // Emit event
    event::emit(ConditionalMintExecuted {
        recipient,
        amount_minted: actual_mint,
        price_at_execution: current_price,
        timestamp: now,
    });
}

/// Execute tiered mint using stored TreasuryCap
public fun do_tiered_mint<AssetType, StableType, Outcome: store, IW: copy + drop>(
    executable: &mut Executable<Outcome>,
    account: &mut Account<FutarchyConfig>,
    version: VersionWitness,
    witness: IW,
    spot_pool: &mut SpotAMM<AssetType, StableType>,
    clock: &Clock,
    ctx: &mut TxContext,
) {
    // Get the action from executable
    let action = executable::next_action<Outcome, TieredMintAction<AssetType>, IW>(executable, witness);
    
    // Validate time conditions
    let now = clock.timestamp_ms();
    assert!(now >= action.earliest_execution_time, ETimeConditionNotMet);
    assert!(now <= action.latest_execution_time, ETimeConditionNotMet);
    
    // Check that DAO has treasury cap
    assert!(currency::has_cap<FutarchyConfig, AssetType>(account), ECannotExecuteWithoutTreasuryCap);
    
    // Get current price
    assert!(spot_amm::is_twap_ready(spot_pool, clock), ETwapNotReady);
    let current_price = spot_amm::get_twap_mut(spot_pool, clock);
    
    // Collect all minting operations to perform
    let mut mints_to_perform = vector::empty<MintOperation>();
    let mut tier_events = vector::empty<TierExecuted>();
    
    // Check which tiers can execute and collect the mints
    let mut i = 0;
    while (i < action.tiers.length()) {
        let tier = &action.tiers[i];
        
        // Skip if already executed
        if (!tier.executed) {
            // Check price threshold
            let threshold_met = if (tier.is_above_threshold) {
                current_price >= tier.price_threshold
            } else {
                current_price <= tier.price_threshold
            };
            
            if (threshold_met) {
                let mut total_tier_minted = 0u64;
                
                // Collect mint operations for all recipients in this tier
                let mut j = 0;
                while (j < tier.recipients.length()) {
                    let recipient = tier.recipients.borrow(j);
                    
                    // Check mint doesn't exceed max supply percentage per mint
                    let current_supply = currency::coin_type_supply<FutarchyConfig, AssetType>(account);
                    let max_mint = (current_supply * MAX_MINT_PERCENTAGE) / 10000;
                    let actual_mint = if (recipient.mint_amount > max_mint) {
                        max_mint
                    } else {
                        recipient.mint_amount
                    };
                    
                    // Store the mint operation to perform later
                    vector::push_back(&mut mints_to_perform, MintOperation {
                        recipient: recipient.recipient,
                        amount: actual_mint,
                    });
                    
                    total_tier_minted = total_tier_minted + actual_mint;
                    j = j + 1;
                };
                
                // Store event to emit later
                vector::push_back(&mut tier_events, TierExecuted {
                    tier_index: i,
                    total_minted: total_tier_minted,
                    price_at_execution: current_price,
                    timestamp: now,
                });
            };
        };
        
        i = i + 1;
    };
    
    // Now perform all the mints after we're done with the action reference
    let mut k = 0;
    while (k < vector::length(&mints_to_perform)) {
        let mint_op = vector::borrow(&mints_to_perform, k);
        
        // Mint using stored TreasuryCap
        let minted_coin = currency::do_mint<FutarchyConfig, Outcome, AssetType, IW>(
            executable,
            account,
            version,
            witness,
            ctx
        );
        
        // Transfer to recipient
        transfer::public_transfer(minted_coin, mint_op.recipient);
        k = k + 1;
    };
    
    // Emit all tier events
    let mut m = 0;
    while (m < vector::length(&tier_events)) {
        let tier_event = vector::pop_back(&mut tier_events);
        event::emit(tier_event);
        m = m + 1;
    };
}

// === Helper Functions ===

/// Safe multiplication with overflow protection  
fun safe_mul_u128(a: u128, b: u128): u128 {
    let max_u128 = 340282366920938463463374607431768211455u128;
    assert!(a == 0 || b <= max_u128 / a, EOverflow);
    a * b
}

/// Safe division with zero check
fun safe_div_u128(a: u128, b: u128): u128 {
    assert!(b != 0, EDivisionByZero);
    a / b
}

/// Safe multiplication then division for u64
fun safe_mul_div_u64(a: u64, b: u64, c: u64): u64 {
    let a_u128 = (a as u128);
    let b_u128 = (b as u128);
    let c_u128 = (c as u128);
    
    let result = safe_div_u128(safe_mul_u128(a_u128, b_u128), c_u128);
    assert!(result <= (std::u64::max_value!() as u128), EOverflow);
    (result as u64)
}

// === Cleanup Functions ===

/// Delete a conditional mint action from expired intent
public fun delete_conditional_mint<T>(expired: &mut Expired) {
    let ConditionalMintAction<T> {
        recipient: _,
        mint_amount: _,
        price_threshold: _,
        is_above_threshold: _,
        earliest_execution_time: _,
        latest_execution_time: _,
        is_repeatable: _,
        cooldown_ms: _,
        last_execution: _,
        max_executions: _,
        execution_count: _,
        description: _,
    } = expired.remove_action();
}


/// Delete a tiered mint action from expired intent
public fun delete_tiered_mint<T>(expired: &mut Expired) {
    let TieredMintAction<T> {
        mut tiers,
        earliest_execution_time: _,
        latest_execution_time: _,
        description: _,
        security_council_id: _,
    } = expired.remove_action();
    
    // Clean up tiers
    while (!tiers.is_empty()) {
        let PriceTier {
            price_threshold: _,
            is_above_threshold: _,
            recipients: _,
            executed: _,
            description: _,
        } = tiers.pop_back();
    };
    tiers.destroy_empty();
}

/// Delete a recurring mint intent
public fun delete_recurring_mint<T>(expired: &mut Expired) {
    let RecurringMintIntent<T> {
        mint_configs: mut mint_configs,
        total_authorized: _,
        total_minted: _,
        expires_at: _,
        is_active: _,
    } = expired.remove_action();
    
    // Properly destroy the vector of ConditionalMintAction which doesn't have drop
    while (!mint_configs.is_empty()) {
        let ConditionalMintAction {
            recipient: _,
            mint_amount: _,
            price_threshold: _,
            is_above_threshold: _,
            earliest_execution_time: _,
            latest_execution_time: _,
            is_repeatable: _,
            cooldown_ms: _,
            last_execution: _,
            max_executions: _,
            execution_count: _,
            description: _,
        } = mint_configs.pop_back();
    };
    mint_configs.destroy_empty();
}/// Optimistic intent system for Security Council
/// Allows council to create intents that execute after a delay unless challenged
/// 
/// Features:
/// - 10-day waiting period before execution
/// - Challenge mechanism via governance proposals (cancels the intent)
/// - Batch challenge support
/// - Maximum 10 concurrent optimistic intents
/// - Council can cancel their own intents
module futarchy::optimistic_intents;

// === Imports ===
use std::{
    string::{Self, String},
    option::{Self, Option},
    vector,
};
use sui::{
    clock::Clock,
    table::{Self, Table},
    event,
    object::{Self, ID, UID},
    tx_context::{Self, TxContext},
};
use account_protocol::{
    account::{Self, Account},
    executable::{Self, Executable},
    intents::{Intent},
    version_witness::VersionWitness,
};
use futarchy::{
    futarchy_config::{Self, FutarchyConfig},
    version,
};

// === Errors ===
const ENotSecurityCouncil: u64 = 1;
const ETooManyOptimisticIntents: u64 = 2;
const EIntentNotFound: u64 = 3;
const EIntentAlreadyChallenged: u64 = 4;
const EIntentNotReady: u64 = 5;
const EIntentExpired: u64 = 6;
const EInvalidBatchSize: u64 = 7;
const EIntentAlreadyExecuted: u64 = 8;
const EDuplicateIntent: u64 = 9;
const EInvalidWaitingPeriod: u64 = 10;
const EIntentAlreadyCancelled: u64 = 11;
const ENotProposer: u64 = 12;

// === Constants ===
const MAX_OPTIMISTIC_INTENTS: u64 = 10;
const WAITING_PERIOD_MS: u64 = 864_000_000; // 10 days in milliseconds
const MAX_BATCH_CHALLENGES: u64 = 10;
const EXPIRY_PERIOD_MS: u64 = 2_592_000_000; // 30 days in milliseconds

// === Storage Keys ===

/// Dynamic field key for optimistic intent storage
public struct OptimisticStorageKey has copy, drop, store {}

/// Storage for optimistic intents in an account
public struct OptimisticIntentStorage has store {
    intents: Table<ID, OptimisticIntent>,
    active_intents: vector<ID>,  // Track active intent IDs
    total_active: u64,
}

/// An optimistic intent pending execution
public struct OptimisticIntent has store {
    id: ID,
    intent_key: String,
    proposer: address,  // Security council member who proposed
    title: String,
    description: String,
    created_at: u64,
    executes_at: u64,  // created_at + WAITING_PERIOD_MS
    expires_at: u64,   // executes_at + EXPIRY_PERIOD_MS
    is_cancelled: bool,
    cancel_reason: Option<String>,
    is_executed: bool,
}

// === Events ===

public struct OptimisticIntentCreated has copy, drop {
    dao_id: ID,
    intent_id: ID,
    intent_key: String,
    proposer: address,
    title: String,
    executes_at: u64,
    timestamp: u64,
}

public struct OptimisticIntentCancelled has copy, drop {
    dao_id: ID,
    intent_id: ID,
    reason: String,
    cancelled_by_governance: bool,
    timestamp: u64,
}

public struct OptimisticIntentExecuted has copy, drop {
    dao_id: ID,
    intent_id: ID,
    intent_key: String,
    timestamp: u64,
}

public struct OptimisticIntentExpired has copy, drop {
    dao_id: ID,
    intent_id: ID,
    timestamp: u64,
}

// === Actions ===

/// Action to create an optimistic intent
public struct CreateOptimisticIntentAction has store {
    intent_key: String,
    title: String,
    description: String,
}

/// Action to challenge optimistic intents (cancels them)
public struct ChallengeOptimisticIntentsAction has store {
    intent_ids: vector<ID>,
    governance_proposal_id: ID,
}

/// Action to execute a matured optimistic intent
public struct ExecuteOptimisticIntentAction has store {
    intent_id: ID,
}

/// Action to cancel an optimistic intent (security council only)
public struct CancelOptimisticIntentAction has store {
    intent_id: ID,
    reason: String,
}

/// Action to clean up expired intents
public struct CleanupExpiredIntentsAction has store {
    intent_ids: vector<ID>,
}

// === Public Functions ===

/// Initialize optimistic intent storage for a DAO
public fun initialize_storage<Config>(
    account: &mut Account<Config>,
    version_witness: VersionWitness,
    ctx: &mut TxContext,
) {
    if (!account::has_managed_data(account, OptimisticStorageKey {})) {
        let storage = OptimisticIntentStorage {
            intents: table::new(ctx),
            active_intents: vector::empty(),
            total_active: 0,
        };
        account::add_managed_data(
            account,
            OptimisticStorageKey {},
            storage,
            version_witness,
        );
    }
}

/// Create an optimistic intent (security council only)
public fun do_create_optimistic_intent<Outcome: store, IW: drop>(
    executable: &mut Executable<Outcome>,
    account: &mut Account<FutarchyConfig>,
    _version_witness: VersionWitness,
    witness: IW,
    clock: &Clock,
    ctx: &mut TxContext,
) {
    let action = executable::next_action<Outcome, CreateOptimisticIntentAction, IW>(
        executable, witness
    );
    
    // Initialize storage if needed
    initialize_storage(account, version::current(), ctx);
    
    let storage: &mut OptimisticIntentStorage = account::borrow_managed_data_mut(
        account,
        OptimisticStorageKey {},
        version::current()
    );
    
    // Check intent limit
    assert!(storage.total_active < MAX_OPTIMISTIC_INTENTS, ETooManyOptimisticIntents);
    
    let current_time = clock.timestamp_ms();
    let uid = object::new(ctx);
    let intent_id = object::uid_to_inner(&uid);
    object::delete(uid);
    
    // Create the intent
    let intent = OptimisticIntent {
        id: intent_id,
        intent_key: action.intent_key,
        proposer: tx_context::sender(ctx),
        title: action.title,
        description: action.description,
        created_at: current_time,
        executes_at: current_time + WAITING_PERIOD_MS,
        expires_at: current_time + WAITING_PERIOD_MS + EXPIRY_PERIOD_MS,
        is_cancelled: false,
        cancel_reason: option::none(),
        is_executed: false,
    };
    
    // Store the intent
    table::add(&mut storage.intents, intent_id, intent);
    vector::push_back(&mut storage.active_intents, intent_id);
    storage.total_active = storage.total_active + 1;
    
    // Emit event
    event::emit(OptimisticIntentCreated {
        dao_id: object::id(account),
        intent_id,
        intent_key: action.intent_key,
        proposer: tx_context::sender(ctx),
        title: action.title,
        executes_at: current_time + WAITING_PERIOD_MS,
        timestamp: current_time,
    });
}

/// Challenge optimistic intents (cancels them via governance proposal)
public fun do_challenge_optimistic_intents<Outcome: store, IW: drop>(
    executable: &mut Executable<Outcome>,
    account: &mut Account<FutarchyConfig>,
    _version_witness: VersionWitness,
    witness: IW,
    clock: &Clock,
    _ctx: &mut TxContext,
) {
    let action = executable::next_action<Outcome, ChallengeOptimisticIntentsAction, IW>(
        executable, witness
    );
    
    // Validate batch size
    let batch_size = vector::length(&action.intent_ids);
    assert!(batch_size > 0 && batch_size <= MAX_BATCH_CHALLENGES, EInvalidBatchSize);
    
    let current_time = clock.timestamp_ms();
    let dao_id = object::id(account);
    
    let storage: &mut OptimisticIntentStorage = account::borrow_managed_data_mut(
        account,
        OptimisticStorageKey {},
        version::current()
    );
    
    // Process each intent in the batch
    let mut i = 0;
    while (i < batch_size) {
        let intent_id = *vector::borrow(&action.intent_ids, i);
        
        // Check intent exists
        assert!(table::contains(&storage.intents, intent_id), EIntentNotFound);
        
        let intent = table::borrow_mut(&mut storage.intents, intent_id);
        
        // Check not already cancelled
        assert!(!intent.is_cancelled, EIntentAlreadyCancelled);
        assert!(!intent.is_executed, EIntentAlreadyExecuted);
        
        // Cancel the intent
        intent.is_cancelled = true;
        intent.cancel_reason = option::some(
            b"Cancelled by governance proposal".to_string()
        );
        
        // Remove from active intents
        let (found, index) = vector::index_of(&storage.active_intents, &intent_id);
        if (found) {
            vector::remove(&mut storage.active_intents, index);
            storage.total_active = storage.total_active - 1;
        };
        
        // Emit event
        event::emit(OptimisticIntentCancelled {
            dao_id,
            intent_id,
            reason: b"Challenged and cancelled by governance proposal".to_string(),
            cancelled_by_governance: true,
            timestamp: current_time,
        });
        
        i = i + 1;
    };
}

/// Cancel an optimistic intent (security council only)
public fun do_cancel_optimistic_intent<Outcome: store, IW: drop>(
    executable: &mut Executable<Outcome>,
    account: &mut Account<FutarchyConfig>,
    _version_witness: VersionWitness,
    witness: IW,
    clock: &Clock,
    ctx: &mut TxContext,
) {
    let action = executable::next_action<Outcome, CancelOptimisticIntentAction, IW>(
        executable, witness
    );
    
    let storage: &mut OptimisticIntentStorage = account::borrow_managed_data_mut(
        account,
        OptimisticStorageKey {},
        version::current()
    );
    
    // Check intent exists
    assert!(table::contains(&storage.intents, action.intent_id), EIntentNotFound);
    
    let intent = table::borrow_mut(&mut storage.intents, action.intent_id);
    
    // Only the original proposer can cancel
    assert!(intent.proposer == tx_context::sender(ctx), ENotProposer);
    
    // Check not already cancelled or executed
    assert!(!intent.is_cancelled, EIntentAlreadyCancelled);
    assert!(!intent.is_executed, EIntentAlreadyExecuted);
    
    // Cancel the intent
    intent.is_cancelled = true;
    intent.cancel_reason = option::some(action.reason);
    
    // Remove from active intents
    let (found, index) = vector::index_of(&storage.active_intents, &action.intent_id);
    if (found) {
        vector::remove(&mut storage.active_intents, index);
        storage.total_active = storage.total_active - 1;
    };
    
    // Emit event
    event::emit(OptimisticIntentCancelled {
        dao_id: object::id(account),
        intent_id: action.intent_id,
        reason: action.reason,
        cancelled_by_governance: false,
        timestamp: clock.timestamp_ms(),
    });
}

/// Execute a matured optimistic intent
public fun do_execute_optimistic_intent<Outcome: store, IW: drop>(
    executable: &mut Executable<Outcome>,
    account: &mut Account<FutarchyConfig>,
    _version_witness: VersionWitness,
    witness: IW,
    clock: &Clock,
    _ctx: &mut TxContext,
): String {  // Returns intent_key for execution
    let action = executable::next_action<Outcome, ExecuteOptimisticIntentAction, IW>(
        executable, witness
    );
    
    let storage: &mut OptimisticIntentStorage = account::borrow_managed_data_mut(
        account,
        OptimisticStorageKey {},
        version::current()
    );
    
    // Check intent exists
    assert!(table::contains(&storage.intents, action.intent_id), EIntentNotFound);
    
    let intent = table::borrow_mut(&mut storage.intents, action.intent_id);
    let current_time = clock.timestamp_ms();
    
    // Validation checks
    assert!(!intent.is_executed, EIntentAlreadyExecuted);
    assert!(!intent.is_cancelled, EIntentAlreadyCancelled);
    assert!(current_time >= intent.executes_at, EIntentNotReady);
    assert!(current_time < intent.expires_at, EIntentExpired);
    
    // Mark as executed
    intent.is_executed = true;
    let intent_key = intent.intent_key;
    
    // Remove from active intents
    let (found, index) = vector::index_of(&storage.active_intents, &action.intent_id);
    if (found) {
        vector::remove(&mut storage.active_intents, index);
        storage.total_active = storage.total_active - 1;
    };
    
    // Emit event
    event::emit(OptimisticIntentExecuted {
        dao_id: object::id(account),
        intent_id: action.intent_id,
        intent_key,
        timestamp: current_time,
    });
    
    intent_key
}

/// Clean up expired intents
public fun do_cleanup_expired_intents<Outcome: store, IW: drop>(
    executable: &mut Executable<Outcome>,
    account: &mut Account<FutarchyConfig>,
    _version_witness: VersionWitness,
    witness: IW,
    clock: &Clock,
    _ctx: &mut TxContext,
) {
    let action = executable::next_action<Outcome, CleanupExpiredIntentsAction, IW>(
        executable, witness
    );
    
    let current_time = clock.timestamp_ms();
    let dao_id = object::id(account);
    
    let storage: &mut OptimisticIntentStorage = account::borrow_managed_data_mut(
        account,
        OptimisticStorageKey {},
        version::current()
    );
    
    // Process each intent
    let mut i = 0;
    while (i < vector::length(&action.intent_ids)) {
        let intent_id = *vector::borrow(&action.intent_ids, i);
        
        if (table::contains(&storage.intents, intent_id)) {
            let intent = table::borrow(&storage.intents, intent_id);
            
            // Check if expired and not executed
            if (current_time >= intent.expires_at && !intent.is_executed) {
                // Remove from storage and destroy the intent
                let OptimisticIntent {
                    id: _,
                    intent_key: _,
                    proposer: _,
                    title: _,
                    description: _,
                    created_at: _,
                    executes_at: _,
                    expires_at: _,
                    is_cancelled: _,
                    cancel_reason: _,
                    is_executed: _,
                } = table::remove(&mut storage.intents, intent_id);
                
                // Remove from active intents
                let (found, index) = vector::index_of(&storage.active_intents, &intent_id);
                if (found) {
                    vector::remove(&mut storage.active_intents, index);
                    storage.total_active = storage.total_active - 1;
                };
                
                // Emit event
                event::emit(OptimisticIntentExpired {
                    dao_id,
                    intent_id,
                    timestamp: current_time,
                });
            };
        };
        
        i = i + 1;
    };
}

// === Helper Functions ===

/// Get active intent count
public fun get_active_intent_count(
    account: &Account<FutarchyConfig>
): u64 {
    if (!account::has_managed_data(account, OptimisticStorageKey {})) {
        return 0
    };
    
    let storage: &OptimisticIntentStorage = account::borrow_managed_data(
        account,
        OptimisticStorageKey {},
        version::current()
    );
    
    storage.total_active
}

/// Check if an intent can be executed
public fun can_execute_intent(
    account: &Account<FutarchyConfig>,
    intent_id: ID,
    clock: &Clock,
): bool {
    if (!account::has_managed_data(account, OptimisticStorageKey {})) {
        return false
    };
    
    let storage: &OptimisticIntentStorage = account::borrow_managed_data(
        account,
        OptimisticStorageKey {},
        version::current()
    );
    
    if (!table::contains(&storage.intents, intent_id)) {
        return false
    };
    
    let intent = table::borrow(&storage.intents, intent_id);
    let current_time = clock.timestamp_ms();
    
    !intent.is_executed && 
    !intent.is_cancelled && 
    current_time >= intent.executes_at && 
    current_time < intent.expires_at
}

// === Action Constructors ===

/// Create an action to create an optimistic intent
public fun new_create_optimistic_intent_action(
    intent_key: String,
    title: String,
    description: String,
): CreateOptimisticIntentAction {
    CreateOptimisticIntentAction {
        intent_key,
        title,
        description,
    }
}

/// Create an action to challenge optimistic intents
public fun new_challenge_optimistic_intents_action(
    intent_ids: vector<ID>,
    governance_proposal_id: ID,
): ChallengeOptimisticIntentsAction {
    ChallengeOptimisticIntentsAction {
        intent_ids,
        governance_proposal_id,
    }
}

/// Create an action to execute an optimistic intent
public fun new_execute_optimistic_intent_action(
    intent_id: ID,
): ExecuteOptimisticIntentAction {
    ExecuteOptimisticIntentAction {
        intent_id,
    }
}

/// Create an action to cancel an optimistic intent
public fun new_cancel_optimistic_intent_action(
    intent_id: ID,
    reason: String,
): CancelOptimisticIntentAction {
    CancelOptimisticIntentAction {
        intent_id,
        reason,
    }
}

/// Create an action to cleanup expired intents
public fun new_cleanup_expired_intents_action(
    intent_ids: vector<ID>,
): CleanupExpiredIntentsAction {
    CleanupExpiredIntentsAction {
        intent_ids,
    }
}

// === Delete Functions for Expired Actions ===

/// Delete an expired ExecuteOptimisticIntentAction
public fun delete_execute_optimistic_intent_action(expired: &mut account_protocol::intents::Expired) {
    let ExecuteOptimisticIntentAction { intent_id: _ } = expired.remove_action();
}

/// Delete an expired CancelOptimisticIntentAction
public fun delete_cancel_optimistic_intent_action(expired: &mut account_protocol::intents::Expired) {
    let CancelOptimisticIntentAction { intent_id: _, reason: _ } = expired.remove_action();
}

/// Delete an expired CreateOptimisticIntentAction
public fun delete_create_optimistic_intent_action(expired: &mut account_protocol::intents::Expired) {
    let CreateOptimisticIntentAction { intent_key: _, title: _, description: _ } = expired.remove_action();
}

/// Delete an expired ChallengeOptimisticIntentsAction
public fun delete_challenge_optimistic_intents_action(expired: &mut account_protocol::intents::Expired) {
    let ChallengeOptimisticIntentsAction { intent_ids: _, governance_proposal_id: _ } = expired.remove_action();
}

/// Delete an expired CleanupExpiredIntentsAction
public fun delete_cleanup_expired_intents_action(expired: &mut account_protocol::intents::Expired) {
    let CleanupExpiredIntentsAction { intent_ids: _ } = expired.remove_action();
}/// Dispatcher for optimistic intent actions
module futarchy::optimistic_dispatcher;

// === Imports ===
use sui::{
    clock::Clock,
    tx_context::TxContext,
};
use account_protocol::{
    account::Account,
    executable::{Self, Executable},
};
use futarchy::{
    futarchy_config::FutarchyConfig,
    version,
    optimistic_intents,
};

// === Public(friend) Functions ===

/// Try to execute optimistic intent actions
public(package) fun try_execute_optimistic_action<IW: drop, Outcome: store + drop + copy>(
    executable: &mut Executable<Outcome>,
    account: &mut Account<FutarchyConfig>,
    witness: IW,
    clock: &Clock,
    ctx: &mut TxContext,
): bool {
    // Check for create optimistic intent action
    if (executable::contains_action<Outcome, optimistic_intents::CreateOptimisticIntentAction>(executable)) {
        optimistic_intents::do_create_optimistic_intent<Outcome, IW>(
            executable,
            account,
            version::current(),
            witness,
            clock,
            ctx
        );
        return true
    };
    
    // Check for challenge optimistic intents action (cancels them)
    if (executable::contains_action<Outcome, optimistic_intents::ChallengeOptimisticIntentsAction>(executable)) {
        optimistic_intents::do_challenge_optimistic_intents<Outcome, IW>(
            executable,
            account,
            version::current(),
            witness,
            clock,
            ctx
        );
        return true
    };
    
    // Check for cancel optimistic intent action
    if (executable::contains_action<Outcome, optimistic_intents::CancelOptimisticIntentAction>(executable)) {
        optimistic_intents::do_cancel_optimistic_intent<Outcome, IW>(
            executable,
            account,
            version::current(),
            witness,
            clock,
            ctx
        );
        return true
    };
    
    // Check for execute optimistic intent action
    if (executable::contains_action<Outcome, optimistic_intents::ExecuteOptimisticIntentAction>(executable)) {
        let intent_key = optimistic_intents::do_execute_optimistic_intent<Outcome, IW>(
            executable,
            account,
            version::current(),
            witness,
            clock,
            ctx
        );
        
        // Execute the intent from the Account Protocol
        // The security council account should have this intent stored
        // We use the intent_key to identify which intent to execute
        // Note: The actual execution happens through the Account Protocol's intent system
        // The optimistic intent just acts as a time-locked wrapper around the real intent
        
        // For now, we mark it as executed in our tracking but the actual execution
        // would need to be done through the appropriate Account Protocol functions
        // based on the intent_key. This would typically be done by calling
        // account::execute_intent_by_key or similar, which would need to be
        // implemented in the Account Protocol integration.
        let _ = intent_key;
        
        return true
    };
    
    // Check for cleanup expired intents action
    if (executable::contains_action<Outcome, optimistic_intents::CleanupExpiredIntentsAction>(executable)) {
        optimistic_intents::do_cleanup_expired_intents<Outcome, IW>(
            executable,
            account,
            version::current(),
            witness,
            clock,
            ctx
        );
        return true
    };
    
    false
}/// Builder for creating intent specifications that can be attached to proposals
/// These specs are used to create actual intents only when the proposal wins
module futarchy::intent_spec_builder;

use std::string::String;
use sui::clock::Clock;
use sui::bcs;
use account_protocol::intents::{Self as account_intents, Params};
use futarchy::intent_spec::{Self, IntentSpec};
use futarchy::config_actions;

// === Config Intent Specs ===

/// Create a spec for updating DAO name
public fun new_update_name_spec(
    key: String,
    new_name: String,
    clock: &Clock,
    ctx: &mut TxContext,
): IntentSpec {
    // Create params for immediate execution
    let params = account_intents::new_params(
        key,
        b"Update DAO name".to_string(),
        vector[clock.timestamp_ms()], // Execute immediately
        clock.timestamp_ms() + 30_000_000, // Expire in 30 seconds
        clock,
        ctx
    );
    
    // Serialize just the parameters (not the whole action)
    // We'll reconstruct the action when the intent is executed
    let action_data = bcs::to_bytes(&new_name);
    
    intent_spec::new(
        key,
        params,
        b"config_actions".to_string(),
        action_data,
        b"ConfigIntent".to_string(),
    )
}

/// Create a spec for enabling/disabling proposals
public fun new_set_proposals_enabled_spec(
    key: String,
    enabled: bool,
    clock: &Clock,
    ctx: &mut TxContext,
): IntentSpec {
    let params = account_intents::new_params(
        key,
        b"Set proposals enabled".to_string(),
        vector[clock.timestamp_ms()],
        clock.timestamp_ms() + 30_000_000,
        clock,
        ctx
    );
    
    // Serialize just the parameters
    let action_data = bcs::to_bytes(&enabled);
    
    intent_spec::new(
        key,
        params,
        b"config_actions".to_string(),
        action_data,
        b"ConfigIntent".to_string(),
    )
}

/// Create a spec for updating slash distribution
public fun new_slash_distribution_spec(
    key: String,
    slasher_reward_bps: u16,
    dao_treasury_bps: u16,
    protocol_bps: u16,
    burn_bps: u16,
    clock: &Clock,
    ctx: &mut TxContext,
): IntentSpec {
    let params = account_intents::new_params(
        key,
        b"Update slash distribution".to_string(),
        vector[clock.timestamp_ms()],
        clock.timestamp_ms() + 30_000_000,
        clock,
        ctx
    );
    
    let action = config_actions::new_slash_distribution_update_action(
        slasher_reward_bps,
        dao_treasury_bps,
        protocol_bps,
        burn_bps,
    );
    let action_data = bcs::to_bytes(&action);
    
    intent_spec::new(
        key,
        params,
        b"config_actions".to_string(),
        action_data,
        b"ConfigIntent".to_string(),
    )
}

// Additional spec builders can be added for other action types:
// - Liquidity actions
// - Operating agreement actions
// - Policy actions
// - Stream actions
// - Vault actions (Move framework compatible)/// Intent specification for storing intent data in proposals
/// This allows proposals to store intent information without creating actual Account intents
/// until the winning outcome is determined
module futarchy::intent_spec;

use std::string::String;
use account_protocol::intents::Params;

/// Specification for creating an intent later
/// Stores all the data needed to create an AccountProtocol intent
public struct IntentSpec has store {
    /// Unique key for this intent
    key: String,
    /// Parameters for the intent (timing, expiry, etc.)
    params: Params,
    /// Module that will process this intent
    /// e.g. "config_actions", "liquidity_actions", "vault_actions"
    module_name: String,
    /// Serialized action data
    /// This will be deserialized and used to create the actual actions
    action_data: vector<u8>,
    /// Type name of the witness to use when creating the intent
    /// e.g. "ConfigIntent", "LiquidityIntent", "VaultIntent"
    witness_type: String,
}

/// Create a new intent specification
public fun new(
    key: String,
    params: Params,
    module_name: String,
    action_data: vector<u8>,
    witness_type: String,
): IntentSpec {
    IntentSpec {
        key,
        params,
        module_name,
        action_data,
        witness_type,
    }
}

/// Get the key
public fun key(spec: &IntentSpec): &String {
    &spec.key
}

/// Get the params
public fun params(spec: &IntentSpec): &Params {
    &spec.params
}

/// Get the module name
public fun module_name(spec: &IntentSpec): &String {
    &spec.module_name
}

/// Get the action data
public fun action_data(spec: &IntentSpec): &vector<u8> {
    &spec.action_data
}

/// Get the witness type
public fun witness_type(spec: &IntentSpec): &String {
    &spec.witness_type
}/// Handles the complete lifecycle of proposals from queue activation to intent execution
module futarchy::proposal_lifecycle;

// === Imports ===
use std::{
    string::String,
    option,
    vector,
};
use sui::{
    clock::{Self, Clock},
    coin::{Self, Coin},
    balance::{Self, Balance},
    event,
    object,
};
use account_protocol::{
    account::{Self, Account},
    executable::{Self, Executable},
    intents::{Self, Intent},
};
use futarchy::{
    futarchy_config::{Self, FutarchyConfig, FutarchyOutcome},
    proposal::{Self, Proposal},
    market_state::{Self, MarketState},
    priority_queue::{Self, ProposalQueue, QueuedProposal},
    proposal_fee_manager::ProposalFeeManager,
    governance_actions::{Self, ProposalReservationRegistry},
    action_dispatcher,
    version,
    spot_amm::{Self, SpotAMM},
    conditional_amm,
};
use futarchy::{
    futarchy_vault,
    intent_janitor,
    gc_janitor,
    execute,
    strategy,
    events,
};

// === Errors ===
const EProposalNotActive: u64 = 1;
const EMarketNotFinalized: u64 = 2;
const EProposalNotApproved: u64 = 3;
const ENoIntentKey: u64 = 4;
const EInvalidWinningOutcome: u64 = 5;
const EIntentExpiryTooLong: u64 = 6;

// === Constants ===
const OUTCOME_ACCEPTED: u64 = 0;
const OUTCOME_REJECTED: u64 = 1;

// === Events ===

/// Emitted when a proposal is activated from the queue
public struct ProposalActivated has copy, drop {
    proposal_id: ID,
    dao_id: ID,
    intent_key: Option<String>,
    timestamp: u64,
}

/// Emitted when a proposal's market is finalized
public struct ProposalMarketFinalized has copy, drop {
    proposal_id: ID,
    dao_id: ID,
    winning_outcome: u64,
    approved: bool,
    timestamp: u64,
}

/// Emitted when a proposal's intent is executed
public struct ProposalIntentExecuted has copy, drop {
    proposal_id: ID,
    dao_id: ID,
    intent_key: String,
    timestamp: u64,
}

/// Execute approved proposal with fee coin for second-order proposals
public entry fun execute_approved_proposal_with_fee<AssetType, StableType, IW: copy + drop>(
    account: &mut Account<FutarchyConfig>,
    proposal: &Proposal<AssetType, StableType>,
    market: &MarketState,
    intent_witness: IW,
    queue: &mut priority_queue::ProposalQueue<FutarchyConfig>,
    fee_manager: &mut ProposalFeeManager,
    registry: &mut governance_actions::ProposalReservationRegistry,
    fee_coin: Coin<sui::sui::SUI>,
    clock: &Clock,
    ctx: &mut TxContext,
) {
    // Verify market is finalized
    assert!(market_state::is_finalized(market), EMarketNotFinalized);
    
    // Verify proposal was approved (YES outcome won)
    let winning_outcome = market_state::get_winning_outcome(market);
    assert!(winning_outcome == OUTCOME_ACCEPTED, EProposalNotApproved);
    
    // Get the intent key for the winning outcome (YES = 0)  
    let intent_key_opt = proposal::get_intent_key_for_outcome(proposal, OUTCOME_ACCEPTED);
    assert!(intent_key_opt.is_some(), ENoIntentKey);
    let intent_key = *intent_key_opt.borrow();
    
    // Execute the proposal intent using FutarchyOutcome
    let executable = futarchy_config::execute_proposal_intent<AssetType, StableType, FutarchyOutcome>(
        account,
        proposal,
        market,
        winning_outcome,
        clock,
        ctx
    );
    
    // Get the parent proposal ID for second-order proposals
    let parent_proposal_id = proposal::get_id(proposal);
    
    execute::run_all_with_governance(
        executable,
        account,
        strategy::and(),
        true,
        true,
        intent_witness,
        queue,
        fee_manager,
        registry,
        parent_proposal_id,
        option::some(fee_coin),
        clock,
        ctx
    );
    
    // Cleanup all expired intents after execution
    intent_janitor::cleanup_all_expired_intents(account, clock, ctx);
    
    // Emit execution event
    event::emit(ProposalIntentExecuted {
        proposal_id: proposal::get_id(proposal),
        dao_id: proposal::get_dao_id(proposal),
        intent_key,
        timestamp: clock.timestamp_ms(),
    });
}

/// Emitted when the next proposal is reserved (locked) into PREMARKET
public struct ProposalReserved has copy, drop {
    queued_proposal_id: ID,
    premarket_proposal_id: ID,
    dao_id: ID,
    timestamp: u64,
}


// === Public Functions ===

/// Activates a proposal from the queue and initializes its market
/// This is called when there's an available slot and a proposal can be activated
public fun activate_proposal_from_queue<AssetType, StableType>(
    account: &mut Account<FutarchyConfig>,
    queue: &mut ProposalQueue<StableType>,
    proposal_fee_manager: &mut ProposalFeeManager,
    spot_pool: &mut SpotAMM<AssetType, StableType>, // Added: For marking liquidity movement
    asset_liquidity: Coin<AssetType>,
    stable_liquidity: Coin<StableType>,
    clock: &Clock,
    ctx: &mut TxContext,
): (ID, ID) {
    // Try to activate the next proposal from the queue
    let mut queued_proposal_opt = priority_queue::try_activate_next(queue);
    assert!(queued_proposal_opt.is_some(), EProposalNotActive);
    
    let mut queued_proposal = queued_proposal_opt.extract();
    queued_proposal_opt.destroy_none();
    
    // Extract fields using getter functions
    let proposal_id = priority_queue::get_proposal_id(&queued_proposal);
    let dao_id = priority_queue::dao_id(queue);
    let uses_dao_liquidity = priority_queue::uses_dao_liquidity(&queued_proposal);
    let proposer = priority_queue::get_proposer(&queued_proposal);
    let data = *priority_queue::get_proposal_data(&queued_proposal);
    let intent_key = *priority_queue::get_intent_key(&queued_proposal);
    
    // Extract bond (mutable borrow needed)
    let mut bond = priority_queue::extract_bond(&mut queued_proposal);
    
    // Get config values from account
    let config = account.config();
    
    // Extract proposal data fields
    let title = *priority_queue::get_title(&data);
    let metadata = *priority_queue::get_metadata(&data);
    let outcome_messages = *priority_queue::get_outcome_messages(&data);
    let details = *priority_queue::get_outcome_details(&data);
    
    // Create fee escrow (bond or empty)
    let fee_escrow = if (bond.is_some()) {
        bond.extract().into_balance()
    } else {
        balance::zero<StableType>()
    };
    
    // If a YES intent key was provided, enforce a strict TTL bound now.
    // This avoids long-lived stale intents bloating the account.
    if (intent_key.is_some()) {
        let key = *intent_key.borrow();
        // Check if the account actually has this intent
        let intents_store = account::intents(account);
        if (intents::contains(intents_store, key)) {
            // We standardize Futarchy proposal intents to FutarchyOutcome for typed access
            let intent_ref = intents::get<FutarchyOutcome>(intents_store, key);
            let max_expiry = clock.timestamp_ms() + futarchy_config::proposal_intent_expiry_ms(config);
            assert!(
                intents::expiration_time(intent_ref) <= max_expiry, 
                EIntentExpiryTooLong
            );
        };
    };
    
    // If this proposal uses DAO liquidity, mark the spot pool
    if (uses_dao_liquidity) {
        spot_amm::mark_liquidity_to_proposal(spot_pool, clock);
    };
    
    // Initialize the market
    let (_proposal_id, market_state_id, _state) = proposal::initialize_market<AssetType, StableType>(
        proposal_id,  // Pass the proposal_id from the queue
        dao_id,
        futarchy_config::review_period_ms(config),
        futarchy_config::trading_period_ms(config),
        futarchy_config::min_asset_amount(config),
        futarchy_config::min_stable_amount(config),
        futarchy_config::amm_twap_start_delay(config),
        futarchy_config::amm_twap_initial_observation(config),
        futarchy_config::amm_twap_step_max(config),
        futarchy_config::twap_threshold(config),
        futarchy_config::amm_total_fee_bps(config),
        object::id_address(account), // treasury address
        title,
        metadata,
        outcome_messages,
        details,
        asset_liquidity,
        stable_liquidity,
        proposer,
        uses_dao_liquidity,
        fee_escrow,
        intent_key, // Pass the intent key for YES outcome
        clock,
        ctx,
    );
    
    // Initialize intent keys vector and set YES outcome intent if provided
    // Note: We'll need to add a function to update the proposal's intent keys
    // For now, store the intent key in futarchy config if provided
    if (intent_key.is_some()) {
        let key = *intent_key.borrow();
        futarchy_config::register_proposal(
            account,
            proposal_id,
            key,
            ctx
        );
    };
    
    // Destroy the remaining bond option (should be none after extraction)
    bond.destroy_none();
    
    // Destroy the queued proposal (we've extracted everything we need)
    priority_queue::destroy_proposal(queued_proposal);
    
    // Emit activation event
    event::emit(ProposalActivated {
        proposal_id,
        dao_id,
        intent_key,
        timestamp: clock.timestamp_ms(),
    });
    
    // Return the proposal_id that was passed in
    // Note: proposal_id_returned is the on-chain object ID, which differs from the queued proposal_id
    (proposal_id, market_state_id)
}

/// Finalizes a proposal's market and determines the winning outcome
/// This should be called after trading has ended and TWAP prices are calculated
public fun finalize_proposal_market<AssetType, StableType>(
    account: &mut Account<FutarchyConfig>, // Added: Account needed for intent cleanup
    registry: &mut ProposalReservationRegistry, // Added: Registry for pruning
    proposal: &mut Proposal<AssetType, StableType>,
    market_state: &mut MarketState,
    spot_pool: &mut SpotAMM<AssetType, StableType>, // Added: For TWAP integration
    clock: &Clock,
    ctx: &mut TxContext, // Now needed for auth
) {
    // Critical fix: Calculate the winning outcome on-chain instead of accepting it from caller
    let winning_outcome = calculate_winning_outcome(proposal, clock);
    
    // Set the winning outcome on the proposal
    proposal::set_winning_outcome(proposal, winning_outcome);
    
    // Finalize the market state
    market_state::finalize(market_state, winning_outcome, clock);
    
    // If this proposal used DAO liquidity, integrate the winning conditional TWAP
    if (proposal::uses_dao_liquidity(proposal)) {
        // Get proposal timing info before borrowing the pool
        let proposal_start = proposal::get_market_initialized_at(proposal);
        let proposal_end = clock.timestamp_ms();
        
        // Get the winning pool's TWAP
        let winning_pool = proposal::get_pool_mut_by_outcome(proposal, winning_outcome as u8);
        let conditional_twap = conditional_amm::get_twap(winning_pool, clock);
        
        // Fill the TWAP gap with the winning conditional's TWAP (for futarchy oracle)
        spot_amm::fill_twap_gap_from_proposal(
            spot_pool, 
            conditional_twap,
            conditional_twap, // Use same value for both TWAP and final price
            clock
        );
        
        // Merge the winning conditional's ring buffer observations into spot (for lending oracle)
        spot_amm::merge_winning_conditional_oracle(
            spot_pool,
            winning_pool,
            proposal_start,
            proposal_end
        );
    };
    
    // NEW: Cancel losing outcome intents in the hot path using a scoped witness.
    // This ensures per-proposal isolation and prevents cross-proposal cancellation
    let num_outcomes = proposal::get_num_outcomes(proposal);
    let mut i = 0u64;
    while (i < num_outcomes) {
        if (i != winning_outcome) {
            // Mint a scoped cancel witness for this specific proposal/outcome
            let mut cw_opt = proposal::make_cancel_witness(proposal, i);
            if (option::is_some(&cw_opt)) {
                let cw = option::extract(&mut cw_opt);
                // Cancel with the scoped witness (emits a keyed-hash event)
                let mut expired = futarchy_config::cancel_losing_intent_scoped(
                    account,
                    cw,
                    clock
                );
                // Drain all actions immediately to prevent state bloat
                gc_janitor::drain_all_public(account, &mut expired);
                account_protocol::intents::destroy_empty_expired(expired);
            }
        };
        i = i + 1;
    };
    
    // Also cleanup any other expired intents during finalization
    intent_janitor::cleanup_all_expired_intents(account, clock, ctx);
    
    // --- BEGIN REGISTRY PRUNING ---
    // Prune expired proposal reservations from the registry to prevent state bloat.
    // This is done at the end of finalization when we have time to do cleanup.
    let config = account::config(account);
    governance_actions::prune_oldest_expired_bucket(registry, config, clock, ctx);
    // --- END REGISTRY PRUNING ---
    
    // Emit finalization event
    event::emit(ProposalMarketFinalized {
        proposal_id: proposal::get_id(proposal),
        dao_id: proposal::get_dao_id(proposal),
        winning_outcome,
        approved: winning_outcome == OUTCOME_ACCEPTED,
        timestamp: clock.timestamp_ms(),
    });
}

/// Executes an approved proposal's intent (generic version)
/// This should be called after the market is finalized and the proposal was approved
/// Note: This version may not handle all action types that require specific coin types
public fun execute_approved_proposal<AssetType, StableType, IW: copy + drop>(
    account: &mut Account<FutarchyConfig>,
    proposal: &Proposal<AssetType, StableType>,
    market: &MarketState,
    intent_witness: IW,
    queue: &mut priority_queue::ProposalQueue<FutarchyConfig>,
    fee_manager: &mut ProposalFeeManager,
    registry: &mut governance_actions::ProposalReservationRegistry,
    clock: &Clock,
    ctx: &mut TxContext,
) {
    // Verify market is finalized
    assert!(market_state::is_finalized(market), EMarketNotFinalized);
    
    // Verify proposal was approved (YES outcome won)
    let winning_outcome = market_state::get_winning_outcome(market);
    assert!(winning_outcome == OUTCOME_ACCEPTED, EProposalNotApproved);
    
    // Get the intent key for the winning outcome (YES = 0)
    let intent_key_opt = proposal::get_intent_key_for_outcome(proposal, OUTCOME_ACCEPTED);
    assert!(intent_key_opt.is_some(), ENoIntentKey);
    let intent_key = *intent_key_opt.borrow();
    
    // Execute the proposal intent using FutarchyOutcome
    let executable = futarchy_config::execute_proposal_intent<AssetType, StableType, FutarchyOutcome>(
        account,
        proposal,
        market,
        winning_outcome,  // Pass the actual winning outcome
        clock,
        ctx
    );
    
    // NEW: Use the centralized execute::run_all with strategy gates
    // For approved proposals, both futarchy (ok_a) and any council requirements (ok_b) are satisfied
    // execute::run_all handles confirmation internally - consumes executable
    // Get the parent proposal ID for second-order proposals
    let parent_proposal_id = proposal::get_id(proposal);
    
    execute::run_all_with_governance(
        executable,
        account,
        strategy::and(),
        true,
        true,
        intent_witness,
        queue,
        fee_manager,
        registry,
        parent_proposal_id,
        option::none(), // No fee coin - caller must provide if needed
        clock,
        ctx
    );
    
    // Cleanup all expired intents after execution
    intent_janitor::cleanup_all_expired_intents(account, clock, ctx);
    
    // Emit execution event
    event::emit(ProposalIntentExecuted {
        proposal_id: proposal::get_id(proposal),
        dao_id: proposal::get_dao_id(proposal),
        intent_key,
        timestamp: clock.timestamp_ms(),
    });
}

/// Executes an approved proposal's intent with known asset types
/// This version can handle all action types including those requiring specific coin types
public fun execute_approved_proposal_typed<AssetType: drop + store, StableType: drop + store, IW: copy + drop>(
    account: &mut Account<FutarchyConfig>,
    proposal: &Proposal<AssetType, StableType>,
    market: &MarketState,
    intent_witness: IW,
    queue: &mut priority_queue::ProposalQueue<FutarchyConfig>,
    fee_manager: &mut ProposalFeeManager,
    registry: &mut governance_actions::ProposalReservationRegistry,
    clock: &Clock,
    ctx: &mut TxContext,
) {
    // Verify market is finalized
    assert!(market_state::is_finalized(market), EMarketNotFinalized);
    
    // Verify proposal was approved (YES outcome won)
    let winning_outcome = market_state::get_winning_outcome(market);
    assert!(winning_outcome == OUTCOME_ACCEPTED, EProposalNotApproved);
    
    // Get the intent key for the winning outcome (YES = 0)  
    let intent_key_opt = proposal::get_intent_key_for_outcome(proposal, OUTCOME_ACCEPTED);
    assert!(intent_key_opt.is_some(), ENoIntentKey);
    let intent_key = *intent_key_opt.borrow();
    
    // Execute using FutarchyOutcome
    let executable = futarchy_config::execute_proposal_intent<AssetType, StableType, FutarchyOutcome>(
        account,
        proposal,
        market,
        winning_outcome,  // Pass the actual winning outcome
        clock,
        ctx
    );
    
    execute::run_typed<AssetType, StableType, IW>(
        executable,
        account,
        strategy::and(),
        true,
        true,
        intent_witness,
        clock,
        ctx
    );
    
    // Cleanup all expired intents after execution
    intent_janitor::cleanup_all_expired_intents(account, clock, ctx);
    
    // Emit execution event
    event::emit(ProposalIntentExecuted {
        proposal_id: proposal::get_id(proposal),
        dao_id: proposal::get_dao_id(proposal),
        intent_key,
        timestamp: clock.timestamp_ms(),
    });
}

/// Reserve the next proposal into PREMARKET (no liquidity), only if the current
/// proposal's trading end is within the premarket threshold.
public entry fun reserve_next_proposal_for_premarket<AssetType, StableType>(
    account: &mut Account<FutarchyConfig>,
    queue: &mut ProposalQueue<StableType>,
    proposal_fee_manager: &mut ProposalFeeManager,
    current_market: &MarketState,
    premarket_threshold_ms: u64,
    clock: &Clock,
    ctx: &mut TxContext,
) {
    use futarchy::proposal as proposal_mod;
    
    // Prevent double reservation
    assert!(!priority_queue::has_reserved(queue), EProposalNotActive);
    
    // Compute time remaining for the active trading market
    let end_opt = market_state::get_trading_end_time(current_market);
    assert!(end_opt.is_some(), EMarketNotFinalized);
    let end_ts = *end_opt.borrow();
    let now = clock.timestamp_ms();
    assert!(now <= end_ts, EMarketNotFinalized);
    let remaining = end_ts - now;
    assert!(remaining <= premarket_threshold_ms, EInvalidWinningOutcome);
    
    // Pop top of queue
    let mut qp_opt = priority_queue::try_activate_next(queue);
    assert!(qp_opt.is_some(), EProposalNotActive);
    let mut qp = qp_opt.extract();
    qp_opt.destroy_none();
    
    let dao_id = priority_queue::dao_id(queue);
    let queued_id = priority_queue::get_proposal_id(&qp);
    let proposer = priority_queue::get_proposer(&qp);
    let uses_dao_liquidity = priority_queue::uses_dao_liquidity(&qp);
    let data = *priority_queue::get_proposal_data(&qp);
    let intent_key = *priority_queue::get_intent_key(&qp);
    
    // Extract optional bond -> becomes fee_escrow in proposal
    let mut bond = priority_queue::extract_bond(&mut qp);
    let fee_escrow = if (bond.is_some()) {
        bond.extract().into_balance()
    } else {
        balance::zero<StableType>()
    };
    bond.destroy_none();
    
    // Config from account
    let cfg = account.config();
    
    // Build PREMARKET proposal (no liquidity)
    let premarket_id = proposal_mod::new_premarket<AssetType, StableType>(
        queued_id,
        dao_id,
        futarchy_config::review_period_ms(cfg),
        futarchy_config::trading_period_ms(cfg),
        futarchy_config::min_asset_amount(cfg),
        futarchy_config::min_stable_amount(cfg),
        futarchy_config::amm_twap_start_delay(cfg),
        futarchy_config::amm_twap_initial_observation(cfg),
        futarchy_config::amm_twap_step_max(cfg),
        futarchy_config::twap_threshold(cfg),
        futarchy_config::amm_total_fee_bps(cfg),
        object::id_address(account),
        *priority_queue::get_title(&data),
        *priority_queue::get_metadata(&data),
        *priority_queue::get_outcome_messages(&data),
        *priority_queue::get_outcome_details(&data),
        proposer,
        uses_dao_liquidity,
        fee_escrow,
        intent_key,
        clock,
        ctx
    );
    
    // Mark queue reserved and emit
    priority_queue::set_reserved(queue, premarket_id);
    priority_queue::destroy_proposal(qp);
    
    event::emit(ProposalReserved {
        queued_proposal_id: queued_id,
        premarket_proposal_id: premarket_id,
        dao_id,
        timestamp: clock.timestamp_ms(),
    });
}

/// Initialize the reserved PREMARKET proposal into REVIEW by injecting liquidity now.
public entry fun initialize_reserved_premarket_to_review<AssetType, StableType>(
    account: &mut Account<FutarchyConfig>,
    queue: &mut ProposalQueue<StableType>,
    proposal: &mut Proposal<AssetType, StableType>,
    asset_liquidity: Coin<AssetType>,
    stable_liquidity: Coin<StableType>,
    clock: &Clock,
    ctx: &mut TxContext,
) {
    use futarchy::proposal as proposal_mod;
    
    // Must have a reservation, and it must match this proposal's ID
    assert!(priority_queue::has_reserved(queue), EProposalNotActive);
    let reserved = priority_queue::reserved_proposal_id(queue);
    assert!(reserved.is_some(), EProposalNotActive);
    let reserved_id = *reserved.borrow();
    assert!(reserved_id == object::id(proposal), EInvalidWinningOutcome);
    
    // Initialize market now (PREMARKET -> REVIEW)
    let _market_state_id = proposal_mod::initialize_market_from_premarket<AssetType, StableType>(
        proposal,
        asset_liquidity,
        stable_liquidity,
        clock,
        ctx
    );
    
    // Clear reservation
    priority_queue::clear_reserved(queue);
}

/// Complete lifecycle: Activate proposal, run market, finalize, and execute if approved
/// This is a convenience function for testing - in production these steps happen at different times
#[test_only]
public fun run_complete_proposal_lifecycle<AssetType, StableType>(
    account: &mut Account<FutarchyConfig>,
    queue: &mut ProposalQueue<StableType>,
    proposal_fee_manager: &mut ProposalFeeManager,
    spot_pool: &mut SpotAMM<AssetType, StableType>,
    asset_liquidity: Coin<AssetType>,
    stable_liquidity: Coin<StableType>,
    winning_outcome: u64,
    clock: &mut Clock,
    ctx: &mut TxContext,
) {
    // Step 1: Activate proposal
    let (proposal_id, market_state_id) = activate_proposal_from_queue(
        account,
        queue,
        proposal_fee_manager,
        spot_pool,
        asset_liquidity,
        stable_liquidity,
        clock,
        ctx
    );
    
    // Step 2: Fast forward through review and trading periods
    let config = account.config();
    sui::clock::increment_for_testing(clock, futarchy_config::review_period_ms(config) + futarchy_config::trading_period_ms(config) + 1000);
    
    // Step 3: Get proposal and market state (would be shared objects in production)
    // For testing, we'll assume they're available
    
    // Step 4: Finalize market
    // This would normally be done through the proper market finalization flow
    // Note: Updated to pass account parameter for intent cleanup
    
    // Step 5: Execute if approved
    // This would normally check the winning outcome and execute if YES
}

// === Helper Functions ===

/// Checks if a proposal can be executed
public fun can_execute_proposal<AssetType, StableType>(
    proposal: &Proposal<AssetType, StableType>,
    market: &MarketState,
): bool {
    // Market must be finalized
    if (!market_state::is_finalized(market)) {
        return false
    };
    
    // Proposal must have been approved (YES outcome)
    let winning_outcome = market_state::get_winning_outcome(market);
    if (winning_outcome != OUTCOME_ACCEPTED) {
        return false
    };
    
    // Proposal must have an intent key for YES outcome
    let intent_key = proposal::get_intent_key_for_outcome(proposal, OUTCOME_ACCEPTED);
    if (!intent_key.is_some()) {
        return false
    };
    
    true
}


/// Calculates the winning outcome based on TWAP prices
/// Returns OUTCOME_ACCEPTED if the YES price exceeds the threshold, OUTCOME_REJECTED otherwise
public fun calculate_winning_outcome<AssetType, StableType>(
    proposal: &mut Proposal<AssetType, StableType>,
    clock: &Clock,
): u64 {
    // Get TWAP prices from all pools
    let twap_prices = proposal::get_twaps_for_proposal(proposal, clock);
    
    // For a simple YES/NO proposal, compare the YES TWAP to the threshold
    if (twap_prices.length() >= 2) {
        let yes_twap = *twap_prices.borrow(OUTCOME_ACCEPTED);
        let threshold = proposal::get_twap_threshold(proposal);
        
        // If YES TWAP exceeds threshold, YES wins
        if (yes_twap > (threshold as u128)) {
            OUTCOME_ACCEPTED
        } else {
            OUTCOME_REJECTED
        }
    } else {
        // Default to NO if we can't determine
        OUTCOME_REJECTED
    }
}module futarchy::proposal;

use futarchy::conditional_amm::{Self, LiquidityPool};
use futarchy::coin_escrow::{Self, TokenEscrow};
use futarchy::liquidity_initialize;
use futarchy::market_state;
use std::ascii::String as AsciiString;
use std::string::String;
use std::type_name;
use std::option;
use std::vector;
use sui::balance::{Balance};
use sui::clock::Clock;
use sui::coin::{Coin};
use sui::event;

// === Introduction ===
// This defines the core proposal logic and details

// === Errors ===

const EInvalidAmount: u64 = 1;
const EInvalidState: u64 = 2;
const EAssetLiquidityTooLow: u64 = 4;
const EStableLiquidityTooLow: u64 = 5;
const EPoolNotFound: u64 = 6;
const EOutcomeOutOfBounds: u64 = 7;
const EInvalidOutcomeVectors: u64 = 8;
const ESpotTwapNotReady: u64 = 9;

// === Constants ===

const STATE_PREMARKET: u8 = 0; // Proposal exists, outcomes can be added/mutated. No market yet.
const STATE_REVIEW: u8 = 1;    // Market is initialized and locked for review. Not yet trading.
const STATE_TRADING: u8 = 2;   // Market is live and trading.
const STATE_FINALIZED: u8 = 3; // Market has resolved.

// Outcome constants for TWAP calculation
const OUTCOME_ACCEPTED: u64 = 0;
const OUTCOME_REJECTED: u64 = 1;

// === Structs ===

/// Core proposal object that owns AMM pools
public struct Proposal<phantom AssetType, phantom StableType> has key, store {
    id: UID,
    /// The logical ID of the proposal from the priority queue.
    queued_proposal_id: ID,
    created_at: u64,
    market_initialized_at: Option<u64>,
    state: u8,
    outcome_count: u64,
    dao_id: ID,
    proposer: address, // The original proposer.
    liquidity_provider: Option<address>, // The user who provides liquidity (gets liquidity back).
    supply_ids: Option<vector<ID>>,
    amm_pools: Option<vector<LiquidityPool>>,
    // LP tokens are now handled as conditional tokens with asset_type = 2
    escrow_id: Option<ID>,
    market_state_id: Option<ID>,
    title: String,
    details: vector<String>,
    metadata: String,
    outcome_messages: vector<String>,
    // The creator of each specific outcome's text/parameters (gets fee rebate if outcome wins).
    outcome_creators: vector<address>,
    // Liquidity targets for each outcome, defined during premarket.
    asset_amounts: vector<u64>,
    stable_amounts: vector<u64>,
    twap_prices: vector<u128>, // Historical TWAP prices
    last_twap_update: u64,
    review_period_ms: u64,
    trading_period_ms: u64,
    min_asset_liquidity: u64,
    min_stable_liquidity: u64,
    twap_start_delay: u64,
    // A flag to indicate if this proposal's liquidity comes from the DAO pool.
    uses_dao_liquidity: bool,
    twap_initial_observation: u128,
    twap_step_max: u64,
    twap_threshold: u64,
    amm_total_fee_bps: u64,
    winning_outcome: Option<u64>,
    fee_escrow: Balance<StableType>,
    treasury_address: address,
    /// Intent keys for each outcome - when outcome i wins, create and execute intent with this key
    /// Intents are NOT created in Account until the outcome wins
    intent_keys: vector<option::Option<String>>,
}

/// A scoped witness proving that a particular (proposal, outcome) owned the intent key.
/// Only mintable by the module that has &mut Proposal and consumes the slot.
/// This prevents cross-proposal cancellation attacks.
public struct CancelWitness has drop {
    proposal: address,
    outcome_index: u64,
    key: String,
}

// Getter functions for CancelWitness (for use in cancel_losing_intent_scoped)
public fun cancel_witness_proposal(witness: &CancelWitness): address {
    witness.proposal
}

public fun cancel_witness_outcome_index(witness: &CancelWitness): u64 {
    witness.outcome_index
}

public fun cancel_witness_key(witness: &CancelWitness): String {
    witness.key
}

// === Events ===

public struct ProposalCreated has copy, drop {
    proposal_id: ID,
    dao_id: ID,
    proposer: address,
    outcome_count: u64,
    outcome_messages: vector<String>,
    created_at: u64,
    asset_type: AsciiString,
    stable_type: AsciiString,
    review_period_ms: u64,
    trading_period_ms: u64,
    title: String,
    metadata: String,
}

public struct ProposalMarketInitialized has copy, drop {
    proposal_id: ID,
    dao_id: ID,
    market_state_id: ID,
    escrow_id: ID,
    timestamp: u64,
}

public struct ProposalOutcomeMutated has copy, drop {
    proposal_id: ID,
    dao_id: ID,
    outcome_idx: u64,
    old_creator: address,
    new_creator: address,
    timestamp: u64,
}

public struct ProposalOutcomeAdded has copy, drop {
    proposal_id: ID,
    dao_id: ID,
    new_outcome_idx: u64,
    creator: address,
    timestamp: u64,
}

// === Public Functions ===

/// Creates all on-chain objects for a futarchy market when a proposal is activated from the queue.
/// This is the main entry point for creating a full proposal with market infrastructure.
#[allow(lint(share_owned))]
public(package) fun initialize_market<AssetType, StableType>(
    // Proposal ID (generated when adding to queue)
    proposal_id: ID,
    // Market parameters from DAO
    dao_id: ID,
    review_period_ms: u64,
    trading_period_ms: u64,
    min_asset_liquidity: u64,
    min_stable_liquidity: u64,
    twap_start_delay: u64,
    twap_initial_observation: u128,
    twap_step_max: u64,
    twap_threshold: u64,
    amm_total_fee_bps: u64,
    treasury_address: address,
    // Proposal specific parameters
    title: String,
    metadata: String,
    initial_outcome_messages: vector<String>,
    initial_outcome_details: vector<String>,
    asset_coin: Coin<AssetType>,
    stable_coin: Coin<StableType>,
    proposer: address, // The original proposer from the queue
    uses_dao_liquidity: bool,
    fee_escrow: Balance<StableType>, // DAO fees if any
    intent_key_for_yes: Option<String>, // Intent key for YES outcome
    clock: &Clock,
    ctx: &mut TxContext,
): (ID, ID, u8) {

    // Create a new proposal UID
    let id = object::new(ctx);
    let actual_proposal_id = object::uid_to_inner(&id);
    let outcome_count = initial_outcome_messages.length();

    // Validate outcome count
    assert!(outcome_count == initial_outcome_details.length(), EInvalidOutcomeVectors);

    // Liquidity is split evenly among all outcomes
    let total_asset_liquidity = asset_coin.value();
    let total_stable_liquidity = stable_coin.value();
    assert!(total_asset_liquidity > 0 && total_stable_liquidity > 0, EInvalidAmount);
    
    let asset_per_outcome = total_asset_liquidity / outcome_count;
    let stable_per_outcome = total_stable_liquidity / outcome_count;
    
    // Calculate remainders from integer division
    let asset_remainder = total_asset_liquidity % outcome_count;
    let stable_remainder = total_stable_liquidity % outcome_count;
    
    // Distribute liquidity evenly, with remainder going to first outcomes
    let mut initial_asset_amounts = vector::empty<u64>();
    let mut initial_stable_amounts = vector::empty<u64>();
    let mut i = 0;
    while (i < outcome_count) {
        // Add 1 extra token to first 'remainder' outcomes
        let asset_amount = if (i < asset_remainder) { asset_per_outcome + 1 } else { asset_per_outcome };
        let stable_amount = if (i < stable_remainder) { stable_per_outcome + 1 } else { stable_per_outcome };
        
        vector::push_back(&mut initial_asset_amounts, asset_amount);
        vector::push_back(&mut initial_stable_amounts, stable_amount);
        i = i + 1;
    };

    // Validate minimum liquidity requirements
    assert!(asset_per_outcome >= min_asset_liquidity, EAssetLiquidityTooLow);
    assert!(stable_per_outcome >= min_stable_liquidity, EStableLiquidityTooLow);

    // Initialize outcome creators to the original proposer
    let outcome_creators = vector::tabulate!(outcome_count, |_| proposer);

    // Create market state
    let market_state = market_state::new(
        actual_proposal_id,  // Use the actual proposal ID, not the parameter
        dao_id, 
        outcome_count, 
        initial_outcome_messages, 
        clock, 
        ctx
    );
    let market_state_id = object::id(&market_state);

    // Create escrow
    let mut escrow = coin_escrow::new<AssetType, StableType>(market_state, ctx);
    let escrow_id = object::id(&escrow);

    // Create AMM pools and initialize liquidity
    let mut asset_balance = asset_coin.into_balance();
    let mut stable_balance = stable_coin.into_balance();
    
    // Quantum liquidity: the same liquidity backs all outcomes conditionally
    // We only need the MAX amount across outcomes since they share the same underlying liquidity
    let mut max_asset = 0u64;
    let mut max_stable = 0u64;
    let mut j = 0;
    while (j < outcome_count) {
        let asset_amt = *initial_asset_amounts.borrow(j);
        let stable_amt = *initial_stable_amounts.borrow(j);
        if (asset_amt > max_asset) { max_asset = asset_amt };
        if (stable_amt > max_stable) { max_stable = stable_amt };
        j = j + 1;
    };
    
    // Extract the exact amount needed for quantum liquidity
    let asset_total = asset_balance.value();
    let stable_total = stable_balance.value();
    
    let asset_for_pool = if (asset_total > max_asset) {
        asset_balance.split(max_asset)
    } else {
        asset_balance.split(asset_total)
    };
    
    let stable_for_pool = if (stable_total > max_stable) {
        stable_balance.split(max_stable)
    } else {
        stable_balance.split(stable_total)
    };
    
    // Return excess to proposer if any
    if (asset_balance.value() > 0) {
        transfer::public_transfer(asset_balance.into_coin(ctx), proposer);
    } else {
        asset_balance.destroy_zero();
    };
    
    if (stable_balance.value() > 0) {
        transfer::public_transfer(stable_balance.into_coin(ctx), proposer);
    } else {
        stable_balance.destroy_zero();
    };
    
    let (_, amm_pools) = liquidity_initialize::create_outcome_markets(
        &mut escrow, 
        outcome_count, 
        initial_asset_amounts, 
        initial_stable_amounts,
        twap_start_delay, 
        twap_initial_observation, 
        twap_step_max,
        amm_total_fee_bps,
        asset_for_pool, 
        stable_for_pool, 
        clock, 
        ctx
    );

    // Create proposal object
    let proposal = Proposal<AssetType, StableType> {
        id,
        queued_proposal_id: proposal_id,
        created_at: clock.timestamp_ms(),
        market_initialized_at: option::some(clock.timestamp_ms()),
        state: STATE_REVIEW, // Start in REVIEW state since market is initialized
        outcome_count,
        dao_id,
        proposer,
        liquidity_provider: option::some(ctx.sender()), // The activator provides liquidity
        supply_ids: option::none(), // Will be set when escrow mints tokens
        amm_pools: option::some(amm_pools),
        // lp_caps no longer needed - using conditional tokens
        escrow_id: option::some(escrow_id),
        market_state_id: option::some(market_state_id),
        title,
        details: initial_outcome_details,
        metadata,
        outcome_messages: initial_outcome_messages,
        outcome_creators,
        asset_amounts: initial_asset_amounts,
        stable_amounts: initial_stable_amounts,
        min_asset_liquidity,
        min_stable_liquidity,
        twap_start_delay,
        uses_dao_liquidity,
        twap_initial_observation,
        twap_step_max,
        twap_threshold,
        amm_total_fee_bps,
        winning_outcome: option::none(),
        fee_escrow,
        treasury_address,
        // Initialize with no intent keys for each outcome
        // Intent keys will be set separately if needed
        intent_keys: vector::tabulate!(outcome_count, |_| option::none()),
        review_period_ms,
        trading_period_ms,
        twap_prices: vector::empty(),
        last_twap_update: 0,
    };

    event::emit(ProposalCreated {
        proposal_id: actual_proposal_id,
        dao_id,
        proposer,
        outcome_count,
        outcome_messages: initial_outcome_messages,
        created_at: clock.timestamp_ms(),
        asset_type: type_name::get<AssetType>().into_string(),
        stable_type: type_name::get<StableType>().into_string(),
        review_period_ms,
        trading_period_ms,
        title,
        metadata,
    });

    transfer::public_share_object(proposal);
    transfer::public_share_object(escrow);

    // Return the actual on-chain proposal ID, not the queue ID
    (actual_proposal_id, market_state_id, STATE_REVIEW)
}

// The create function has been removed as it's not used in production.
// All proposals are created through initialize_market which properly handles proposal IDs
// generated from the priority queue.

/// Create a PREMARKET proposal without market/escrow/liquidity.
/// This reserves the proposal "as next" without consuming DAO/proposer liquidity.
#[allow(lint(share_owned))]
public(package) fun new_premarket<AssetType, StableType>(
    // Proposal ID originating from queue
    proposal_id_from_queue: ID,
    dao_id: ID,
    review_period_ms: u64,
    trading_period_ms: u64,
    min_asset_liquidity: u64,
    min_stable_liquidity: u64,
    twap_start_delay: u64,
    twap_initial_observation: u128,
    twap_step_max: u64,
    twap_threshold: u64,
    amm_total_fee_bps: u64,
    treasury_address: address,
    title: String,
    metadata: String,
    outcome_messages: vector<String>,
    outcome_details: vector<String>,
    proposer: address,
    uses_dao_liquidity: bool,
    fee_escrow: Balance<StableType>,
    intent_key_for_yes: Option<String>,
    clock: &Clock,
    ctx: &mut TxContext,
): ID {
    let id = object::new(ctx);
    let actual_proposal_id = object::uid_to_inner(&id);
    let outcome_count = outcome_messages.length();
    
    let proposal = Proposal<AssetType, StableType> {
        id,
        queued_proposal_id: proposal_id_from_queue,
        created_at: clock.timestamp_ms(),
        market_initialized_at: option::none(),
        state: STATE_PREMARKET,
        outcome_count,
        dao_id,
        proposer,
        liquidity_provider: option::none(),
        supply_ids: option::none(),
        amm_pools: option::none(),
        escrow_id: option::none(),
        market_state_id: option::none(),
        title,
        details: outcome_details,
        metadata,
        outcome_messages,
        outcome_creators: vector::tabulate!(outcome_count, |_| proposer),
        // Will be computed at market initialization from coin inputs
        asset_amounts: vector::empty(),
        stable_amounts: vector::empty(),
        min_asset_liquidity,
        min_stable_liquidity,
        twap_start_delay,
        uses_dao_liquidity,
        twap_initial_observation,
        twap_step_max,
        twap_threshold,
        amm_total_fee_bps,
        winning_outcome: option::none(),
        fee_escrow,
        treasury_address,
        intent_keys: vector::tabulate!(outcome_count, |_| option::none()),
        review_period_ms,
        trading_period_ms,
        twap_prices: vector::empty(),
        last_twap_update: 0,
    };
    
    transfer::public_share_object(proposal);
    actual_proposal_id
}

/// Initialize market/escrow/AMMs for a PREMARKET proposal.
/// Consumes provided coins, sets state to REVIEW, and readies the market for the review timer.
#[allow(lint(share_owned, self_transfer))]
public(package) fun initialize_market_from_premarket<AssetType, StableType>(
    proposal: &mut Proposal<AssetType, StableType>,
    asset_coin: Coin<AssetType>,
    stable_coin: Coin<StableType>,
    clock: &Clock,
    ctx: &mut TxContext,
): ID {
    assert!(proposal.state == STATE_PREMARKET, EInvalidState);
    
    // Evenly split liquidity across outcomes (same convention as initialize_market)
    let outcome_count = proposal.outcome_count;
    let total_asset_liquidity = asset_coin.value();
    let total_stable_liquidity = stable_coin.value();
    assert!(total_asset_liquidity > 0 && total_stable_liquidity > 0, EInvalidAmount);
    
    let asset_per = total_asset_liquidity / outcome_count;
    let stable_per = total_stable_liquidity / outcome_count;
    assert!(asset_per >= proposal.min_asset_liquidity, EAssetLiquidityTooLow);
    assert!(stable_per >= proposal.min_stable_liquidity, EStableLiquidityTooLow);
    
    let asset_remainder = total_asset_liquidity % outcome_count;
    let stable_remainder = total_stable_liquidity % outcome_count;
    
    let mut initial_asset_amounts = vector::empty<u64>();
    let mut initial_stable_amounts = vector::empty<u64>();
    let mut i = 0;
    while (i < outcome_count) {
        let a = if (i < asset_remainder) { asset_per + 1 } else { asset_per };
        let s = if (i < stable_remainder) { stable_per + 1 } else { stable_per };
        vector::push_back(&mut initial_asset_amounts, a);
        vector::push_back(&mut initial_stable_amounts, s);
        i = i + 1;
    };
    
    // Market state
    let ms = market_state::new(
        object::id(proposal),
        proposal.dao_id,
        proposal.outcome_count,
        proposal.outcome_messages,
        clock,
        ctx
    );
    let market_state_id = object::id(&ms);
    
    // Escrow
    let mut escrow = coin_escrow::new<AssetType, StableType>(ms, ctx);
    let escrow_id = object::id(&escrow);
    
    // Determine quantum liquidity amounts
    let mut asset_balance = asset_coin.into_balance();
    let mut stable_balance = stable_coin.into_balance();
    
    let mut max_asset = 0u64;
    let mut max_stable = 0u64;
    i = 0;
    while (i < outcome_count) {
        let a = *initial_asset_amounts.borrow(i);
        let s = *initial_stable_amounts.borrow(i);
        if (a > max_asset) { max_asset = a };
        if (s > max_stable) { max_stable = s };
        i = i + 1;
    };
    
    let asset_total = asset_balance.value();
    let stable_total = stable_balance.value();
    
    let asset_for_pool = if (asset_total > max_asset) {
        asset_balance.split(max_asset)
    } else {
        asset_balance.split(asset_total)
    };
    
    let stable_for_pool = if (stable_total > max_stable) {
        stable_balance.split(max_stable)
    } else {
        stable_balance.split(stable_total)
    };
    
    // Return any excess to liquidity provider (the activator who supplied coins)
    let sender = ctx.sender();
    if (asset_balance.value() > 0) {
        transfer::public_transfer(asset_balance.into_coin(ctx), sender);
    } else {
        asset_balance.destroy_zero();
    };
    
    if (stable_balance.value() > 0) {
        transfer::public_transfer(stable_balance.into_coin(ctx), sender);
    } else {
        stable_balance.destroy_zero();
    };
    
    // Create outcome markets
    let (_supply_ids, amm_pools) = liquidity_initialize::create_outcome_markets(
        &mut escrow,
        proposal.outcome_count,
        initial_asset_amounts,
        initial_stable_amounts,
        proposal.twap_start_delay,
        proposal.twap_initial_observation,
        proposal.twap_step_max,
        proposal.amm_total_fee_bps,
        asset_for_pool,
        stable_for_pool,
        clock,
        ctx
    );
    
    // Update proposal's liquidity amounts
    proposal.asset_amounts = initial_asset_amounts;
    proposal.stable_amounts = initial_stable_amounts;
    
    // Initialize market fields: PREMARKET → REVIEW
    initialize_market_fields(
        proposal,
        market_state_id,
        escrow_id,
        amm_pools,
        clock.timestamp_ms(),
        sender
    );
    
    transfer::public_share_object(escrow);
    market_state_id
}

/// Adds a new outcome during the premarket phase.
public(package) fun add_outcome<AssetType, StableType>(
    proposal: &mut Proposal<AssetType, StableType>,
    message: String,
    detail: String,
    asset_amount: u64,
    stable_amount: u64,
    creator: address,
    clock: &Clock,
) {
    proposal.outcome_messages.push_back(message);
    proposal.details.push_back(detail);
    proposal.asset_amounts.push_back(asset_amount);
    proposal.stable_amounts.push_back(stable_amount);
    proposal.outcome_creators.push_back(creator);

    let new_idx = proposal.outcome_count;
    proposal.outcome_count = new_idx + 1;

    event::emit(ProposalOutcomeAdded {
        proposal_id: get_id(proposal),
        dao_id: get_dao_id(proposal),
        new_outcome_idx: new_idx,
        creator,
        timestamp: clock.timestamp_ms(),
    });
}

/// Initializes the market-related fields of the proposal.
public(package) fun initialize_market_fields<AssetType, StableType>(
    proposal: &mut Proposal<AssetType, StableType>,
    market_state_id: ID,
    escrow_id: ID,
    amm_pools: vector<LiquidityPool>,
    // LP tracking moved to conditional tokens
    initialized_at: u64,
    liquidity_provider: address,
) {
    assert!(proposal.state == STATE_PREMARKET, EInvalidState);

    // Use option::fill to replace None with Some value
    option::fill(&mut proposal.market_state_id, market_state_id);
    option::fill(&mut proposal.escrow_id, escrow_id);
    option::fill(&mut proposal.amm_pools, amm_pools);
    // LP caps no longer needed - using conditional tokens
    option::fill(&mut proposal.market_initialized_at, initialized_at);
    option::fill(&mut proposal.liquidity_provider, liquidity_provider);
    proposal.state = STATE_REVIEW; // Advance state to REVIEW
}

/// Emits the ProposalMarketInitialized event
public(package) fun emit_market_initialized(
    proposal_id: ID,
    dao_id: ID,
    market_state_id: ID,
    escrow_id: ID,
    timestamp: u64,
) {
    event::emit(ProposalMarketInitialized {
        proposal_id,
        dao_id,
        market_state_id,
        escrow_id,
        timestamp,
    });
}

/// Takes the escrowed fee balance out of the proposal, leaving a zero balance behind.
public(package) fun take_fee_escrow<AssetType, StableType>(
    proposal: &mut Proposal<AssetType, StableType>,
): Balance<StableType> {
    let fee_balance = &mut proposal.fee_escrow;
    let amount = fee_balance.value();
    sui::balance::split(fee_balance, amount)
}

/// Searches the proposal's liquidity pools for an oracle matching the target ID.
/// Returns a reference to that oracle; aborts if not found.
public fun get_twaps_for_proposal<AssetType, StableType>(
    proposal: &mut Proposal<AssetType, StableType>,
    clock: &Clock,
): vector<u128> {
    let pools = proposal.amm_pools.borrow_mut();
    let mut twaps = vector[];
    let mut i = 0;
    while (i < pools.length()) {
        let pool = &mut pools[i];
        let twap = pool.get_twap(clock);
        twaps.push_back(twap);
        i = i + 1;
    };
    twaps
}

// === Private Functions ===

fun get_pool_mut(pools: &mut vector<LiquidityPool>, outcome_idx: u8): &mut LiquidityPool {
    let mut i = 0;
    let len = pools.length();
    while (i < len) {
        let pool = &mut pools[i];
        if (pool.get_outcome_idx() == outcome_idx) {
            return pool
        };
        i = i + 1;
    };
    abort EPoolNotFound
}

// === View Functions ===

public fun is_finalized<AssetType, StableType>(proposal: &Proposal<AssetType, StableType>): bool {
    proposal.state == STATE_FINALIZED
}

public fun get_twap_prices<AssetType, StableType>(
    proposal: &Proposal<AssetType, StableType>,
): &vector<u128> {
    &proposal.twap_prices
}

public fun get_last_twap_update<AssetType, StableType>(
    proposal: &Proposal<AssetType, StableType>,
): u64 {
    proposal.last_twap_update
}

public fun state<AssetType, StableType>(proposal: &Proposal<AssetType, StableType>): u8 {
    proposal.state
}

public fun get_winning_outcome<AssetType, StableType>(
    proposal: &Proposal<AssetType, StableType>,
): u64 {
    assert!(proposal.winning_outcome.is_some(), EInvalidState);
    *proposal.winning_outcome.borrow()
}

/// Checks if winning outcome has been set
public fun is_winning_outcome_set<AssetType, StableType>(
    proposal: &Proposal<AssetType, StableType>,
): bool {
    proposal.winning_outcome.is_some()
}

/// Returns the treasury address where fees for failed proposals are sent.
public(package) fun treasury_address<AssetType, StableType>(
    proposal: &Proposal<AssetType, StableType>,
): address {
    proposal.treasury_address
}

public fun get_id<AssetType, StableType>(proposal: &Proposal<AssetType, StableType>): ID {
    proposal.id.to_inner()
}

public fun escrow_id<AssetType, StableType>(proposal: &Proposal<AssetType, StableType>): ID {
    assert!(proposal.escrow_id.is_some(), EInvalidState);
    *proposal.escrow_id.borrow()
}

public fun market_state_id<AssetType, StableType>(proposal: &Proposal<AssetType, StableType>): ID {
    assert!(proposal.market_state_id.is_some(), EInvalidState);
    *proposal.market_state_id.borrow()
}

public fun get_market_initialized_at<AssetType, StableType>(proposal: &Proposal<AssetType, StableType>): u64 {
    assert!(proposal.market_initialized_at.is_some(), EInvalidState);
    *proposal.market_initialized_at.borrow()
}

public fun outcome_count<AssetType, StableType>(proposal: &Proposal<AssetType, StableType>): u64 {
    proposal.outcome_count
}

/// Alias for outcome_count for better readability
public fun get_num_outcomes<AssetType, StableType>(proposal: &Proposal<AssetType, StableType>): u64 {
    proposal.outcome_count
}

public fun proposer<AssetType, StableType>(proposal: &Proposal<AssetType, StableType>): address {
    proposal.proposer
}

public fun created_at<AssetType, StableType>(proposal: &Proposal<AssetType, StableType>): u64 {
    proposal.created_at
}

public fun get_details<AssetType, StableType>(proposal: &Proposal<AssetType, StableType>): &vector<String> {
    &proposal.details
}

public fun get_metadata<AssetType, StableType>(
    proposal: &Proposal<AssetType, StableType>,
): &String {
    &proposal.metadata
}

public fun get_amm_pool_ids<AssetType, StableType>(
    proposal: &Proposal<AssetType, StableType>,
): vector<ID> {
    let mut ids = vector[];
    let mut i = 0;
    let pools = proposal.amm_pools.borrow();
    let len = pools.length();
    while (i < len) {
        let pool = &pools[i];
        ids.push_back(pool.get_id());
        i = i + 1;
    };
    ids
}

public(package) fun get_pool_mut_by_outcome<AssetType, StableType>(
    proposal: &mut Proposal<AssetType, StableType>,
    outcome_idx: u8,
): &mut LiquidityPool {
    assert!((outcome_idx as u64) < proposal.outcome_count, EOutcomeOutOfBounds);
    let pools_mut = proposal.amm_pools.borrow_mut();
    get_pool_mut(pools_mut, outcome_idx)
}

public fun get_pool_by_outcome<AssetType, StableType>(
    proposal: &Proposal<AssetType, StableType>,
    outcome_idx: u8,
): &LiquidityPool {
    assert!((outcome_idx as u64) < proposal.outcome_count, EOutcomeOutOfBounds);
    let pools = proposal.amm_pools.borrow();
    let mut i = 0;
    let len = pools.length();
    while (i < len) {
        let pool = &pools[i];
        if (pool.get_outcome_idx() == outcome_idx) {
            return pool
        };
        i = i + 1;
    };
    abort EPoolNotFound
}

// LP caps no longer needed - using conditional tokens for LP

// Pool and LP cap getter no longer needed - using conditional tokens for LP

public fun get_state<AssetType, StableType>(proposal: &Proposal<AssetType, StableType>): u8 {
    proposal.state
}

public fun get_dao_id<AssetType, StableType>(proposal: &Proposal<AssetType, StableType>): ID {
    proposal.dao_id
}

public fun proposal_id<AssetType, StableType>(proposal: &Proposal<AssetType, StableType>): ID {
    proposal.id.to_inner()
}

public fun get_amm_pools<AssetType, StableType>(
    proposal: &Proposal<AssetType, StableType>,
): &vector<LiquidityPool> {
    proposal.amm_pools.borrow()
}

public(package) fun get_amm_pools_mut<AssetType, StableType>(
    proposal: &mut Proposal<AssetType, StableType>,
): &mut vector<LiquidityPool> {
    proposal.amm_pools.borrow_mut()
}

public fun get_created_at<AssetType, StableType>(proposal: &Proposal<AssetType, StableType>): u64 {
    proposal.created_at
}

public fun get_review_period_ms<AssetType, StableType>(
    proposal: &Proposal<AssetType, StableType>,
): u64 {
    proposal.review_period_ms
}

public fun get_trading_period_ms<AssetType, StableType>(
    proposal: &Proposal<AssetType, StableType>,
): u64 {
    proposal.trading_period_ms
}

public fun get_twap_threshold<AssetType, StableType>(
    proposal: &Proposal<AssetType, StableType>,
): u64 {
    proposal.twap_threshold
}

public fun get_twap_start_delay<AssetType, StableType>(proposal: &Proposal<AssetType, StableType>): u64 {
    proposal.twap_start_delay
}

public fun get_twap_initial_observation<AssetType, StableType>(proposal: &Proposal<AssetType, StableType>): u128 {
    proposal.twap_initial_observation
}

public fun get_twap_step_max<AssetType, StableType>(proposal: &Proposal<AssetType, StableType>): u64 {
    proposal.twap_step_max
}

public fun uses_dao_liquidity<AssetType, StableType>(proposal: &Proposal<AssetType, StableType>): bool {
    proposal.uses_dao_liquidity
}

public fun get_amm_total_fee_bps<AssetType, StableType>(
    proposal: &Proposal<AssetType, StableType>,
): u64 {
    proposal.amm_total_fee_bps
}


/// Returns the parameters needed to initialize the market after the premarket phase.
public(package) fun get_market_init_params<AssetType, StableType>(proposal: &Proposal<AssetType, StableType>): (u64, &vector<String>, &vector<u64>, &vector<u64>) {
    (
        proposal.outcome_count,
        &proposal.outcome_messages,
        &proposal.asset_amounts,
        &proposal.stable_amounts,
    )
}

// === Package Functions ===

/// Advances the proposal state based on elapsed time
/// Transitions from REVIEW to TRADING when review period ends
/// Returns true if state was changed
public fun advance_state<AssetType, StableType>(
    proposal: &mut Proposal<AssetType, StableType>,
    escrow: &mut TokenEscrow<AssetType, StableType>,
    clock: &Clock,
): bool {
    let current_time = clock.timestamp_ms();
    // Use market_initialized_at for timing calculations instead of created_at
    // This ensures premarket proposals get proper review/trading periods after initialization
    let base_timestamp = if (proposal.market_initialized_at.is_some()) {
        *proposal.market_initialized_at.borrow()
    } else {
        // Fallback to created_at if market not initialized (shouldn't happen in normal flow)
        proposal.created_at
    };
    
    // Check if we should transition from REVIEW to TRADING
    if (proposal.state == STATE_REVIEW) {
        let review_end = base_timestamp + proposal.review_period_ms;
        if (current_time >= review_end) {
            proposal.state = STATE_TRADING;
            
            // Start trading in the market state
            let market = coin_escrow::get_market_state_mut(escrow);
            market_state::start_trading(market, proposal.trading_period_ms, clock);
            
            // Set oracle start time for all pools when trading begins
            let pools = proposal.amm_pools.borrow_mut();
            let mut i = 0;
            while (i < pools.length()) {
                let pool = &mut pools[i];
                conditional_amm::set_oracle_start_time(pool, market);
                i = i + 1;
            };
            
            return true
        };
    };
    
    // Check if we should transition from TRADING to ended
    if (proposal.state == STATE_TRADING) {
        let trading_end = base_timestamp + proposal.review_period_ms + proposal.trading_period_ms;
        if (current_time >= trading_end) {
            // End trading in the market state
            let market = coin_escrow::get_market_state_mut(escrow);
            if (market_state::is_trading_active(market)) {
                market_state::end_trading(market, clock);
            };
            // Note: Full finalization requires calculating winner and is done separately
            return true
        };
    };
    
    false
}

public(package) fun set_state<AssetType, StableType>(
    proposal: &mut Proposal<AssetType, StableType>,
    new_state: u8,
) {
    proposal.state = new_state;
}

public(package) fun set_twap_prices<AssetType, StableType>(
    proposal: &mut Proposal<AssetType, StableType>,
    twap_prices: vector<u128>,
) {
    proposal.twap_prices = twap_prices;
}

public(package) fun set_last_twap_update<AssetType, StableType>(
    proposal: &mut Proposal<AssetType, StableType>,
    timestamp: u64,
) {
    proposal.last_twap_update = timestamp;
}

public(package) fun set_winning_outcome<AssetType, StableType>(
    proposal: &mut Proposal<AssetType, StableType>,
    outcome: u64,
) {
    proposal.winning_outcome = option::some(outcome);
}

/// Finalize the proposal with the winning outcome computed on-chain
/// This combines computing the winner from TWAP, setting the winning outcome and updating state atomically
/// @deprecated Use proposal_lifecycle::finalize_proposal_market instead - this version lacks critical intent cleanup
#[test_only]
public fun finalize_proposal<AssetType, StableType>(
    proposal: &mut Proposal<AssetType, StableType>,
    escrow: &mut TokenEscrow<AssetType, StableType>,
    clock: &Clock,
) {
    // Ensure we're in a state that can be finalized
    assert!(proposal.state == STATE_TRADING || proposal.state == STATE_REVIEW, EInvalidState);
    
    // If still in trading, end trading first
    if (proposal.state == STATE_TRADING) {
        let market = coin_escrow::get_market_state_mut(escrow);
        if (market_state::is_trading_active(market)) {
            market_state::end_trading(market, clock);
        };
    };
    
    // Critical fix: Compute the winning outcome on-chain from TWAP prices
    // Get TWAP prices from all pools
    let twap_prices = get_twaps_for_proposal(proposal, clock);
    
    // For a simple YES/NO proposal, compare the YES TWAP to the threshold
    let winning_outcome = if (twap_prices.length() >= 2) {
        let yes_twap = *twap_prices.borrow(OUTCOME_ACCEPTED);
        let threshold = get_twap_threshold(proposal);
        
        // If YES TWAP exceeds threshold, YES wins
        if (yes_twap > (threshold as u128)) {
            OUTCOME_ACCEPTED
        } else {
            OUTCOME_REJECTED
        }
    } else {
        // For single-outcome or other configs, default to first outcome
        // This should be revisited based on your specific requirements
        0
    };
    
    // Set the winning outcome
    proposal.winning_outcome = option::some(winning_outcome);
    
    // Update state to finalized
    proposal.state = STATE_FINALIZED;
    
    // Finalize the market state
    let market = coin_escrow::get_market_state_mut(escrow);
    market_state::finalize(market, winning_outcome, clock);
}

public fun get_outcome_creators<AssetType, StableType>(proposal: &Proposal<AssetType, StableType>): &vector<address> {
    &proposal.outcome_creators
}

public fun get_liquidity_provider<AssetType, StableType>(proposal: &Proposal<AssetType, StableType>): Option<address> {
    proposal.liquidity_provider
}

public fun get_proposer<AssetType, StableType>(proposal: &Proposal<AssetType, StableType>): address {
    proposal.proposer
}

public fun get_outcome_messages<AssetType, StableType>(proposal: &Proposal<AssetType, StableType>): &vector<String> {
    &proposal.outcome_messages
}

/// Get the intent key for a specific outcome
public fun get_intent_key_for_outcome<AssetType, StableType>(
    proposal: &Proposal<AssetType, StableType>,
    outcome_index: u64
): &option::Option<String> {
    vector::borrow(&proposal.intent_keys, outcome_index)
}

/// Clear the intent key for a specific outcome (used after cancellation)
public(package) fun clear_intent_key_for_outcome<AssetType, StableType>(
    proposal: &mut Proposal<AssetType, StableType>,
    outcome_index: u64
) {
    assert!(outcome_index < proposal.outcome_count, EOutcomeOutOfBounds);
    let intent_key_ref = vector::borrow_mut(&mut proposal.intent_keys, outcome_index);
    *intent_key_ref = option::none();
}

/// Take (move out) the intent key for a specific outcome and clear the slot.
public(package) fun take_intent_key_for_outcome<AssetType, StableType>(
    proposal: &mut Proposal<AssetType, StableType>,
    outcome_index: u64
): option::Option<String> {
    assert!(outcome_index < proposal.outcome_count, EOutcomeOutOfBounds);
    let slot = vector::borrow_mut(&mut proposal.intent_keys, outcome_index);
    let old_value = *slot;
    *slot = option::none();
    old_value
}

/// Mint a scoped cancel witness by taking (moving) the key out of the slot.
/// Returns None if no key was set for that outcome.
/// This witness can only be created once per (proposal, outcome) pair.
public(package) fun make_cancel_witness<AssetType, StableType>(
    proposal: &mut Proposal<AssetType, StableType>,
    outcome_index: u64
): option::Option<CancelWitness> {
    assert!(outcome_index < proposal.outcome_count, EOutcomeOutOfBounds);
    let addr = object::uid_to_address(&proposal.id);
    let mut key_opt = take_intent_key_for_outcome(proposal, outcome_index);
    if (option::is_some(&key_opt)) {
        let key = option::extract(&mut key_opt);
        option::some(CancelWitness { proposal: addr, outcome_index, key })
    } else {
        option::none<CancelWitness>()
    }
}

/// Set the intent key for a specific outcome
public fun set_intent_key_for_outcome<AssetType, StableType>(
    proposal: &mut Proposal<AssetType, StableType>,
    outcome_index: u64,
    intent_key: String,
) {
    // Allow intents for any outcome - each outcome may need different actions
    assert!(outcome_index < proposal.outcome_count, EOutcomeOutOfBounds);
    
    let key_slot = vector::borrow_mut(&mut proposal.intent_keys, outcome_index);
    *key_slot = option::some(intent_key);
}


/// Check if an outcome has an intent key
public fun has_intent_key<AssetType, StableType>(
    proposal: &Proposal<AssetType, StableType>,
    outcome_index: u64
): bool {
    assert!(outcome_index < proposal.outcome_count, EOutcomeOutOfBounds);
    option::is_some(vector::borrow(&proposal.intent_keys, outcome_index))
}

/// Emits the ProposalOutcomeMutated event
public(package) fun emit_outcome_mutated(
    proposal_id: ID,
    dao_id: ID,
    outcome_idx: u64,
    old_creator: address,
    new_creator: address,
    timestamp: u64,
) {
    event::emit(ProposalOutcomeMutated {
        proposal_id,
        dao_id,
        outcome_idx,
        old_creator,
        new_creator,
        timestamp,
    });
}

public(package) fun set_outcome_creator<AssetType, StableType>(
    proposal: &mut Proposal<AssetType, StableType>,
    outcome_idx: u64,
    creator: address,
) {
    assert!(outcome_idx < proposal.outcome_count, EOutcomeOutOfBounds);
    let creator_ref = vector::borrow_mut(&mut proposal.outcome_creators, outcome_idx);
    *creator_ref = creator;
}

public(package) fun get_details_mut<AssetType, StableType>(proposal: &mut Proposal<AssetType, StableType>): &mut vector<String> {
    &mut proposal.details
}


// === Test Functions ===

#[test_only]
/// Create a minimal proposal for testing
public fun new_for_testing<AssetType, StableType>(
    dao_id: address,
    proposer: address,
    liquidity_provider: Option<address>,
    title: String,
    metadata: String,
    outcome_messages: vector<String>,
    outcome_details: vector<String>,
    outcome_creators: vector<address>,
    outcome_count: u8,
    review_period_ms: u64,
    trading_period_ms: u64,
    min_asset_liquidity: u64,
    min_stable_liquidity: u64,
    twap_start_delay: u64,
    twap_initial_observation: u128,
    twap_step_max: u64,
    twap_threshold: u64,
    amm_total_fee_bps: u64,
    winning_outcome: Option<u64>,
    fee_escrow: Balance<StableType>,
    treasury_address: address,
    intent_keys: vector<option::Option<String>>,
    ctx: &mut TxContext
): Proposal<AssetType, StableType> {
    Proposal {
        id: object::new(ctx),
        dao_id: object::id_from_address(dao_id),
        queued_proposal_id: object::id_from_address(@0x0),
        created_at: 0,
        market_initialized_at: option::none(),
        state: STATE_PREMARKET,
        outcome_count: outcome_count as u64,
        proposer,
        liquidity_provider,
        supply_ids: option::none(),
        amm_pools: option::none(),
        escrow_id: option::none(),
        market_state_id: option::none(),
        title,
        details: outcome_details,
        metadata,
        outcome_messages,
        outcome_creators,
        asset_amounts: vector::empty(),
        stable_amounts: vector::empty(),
        twap_prices: vector::empty(),
        last_twap_update: 0,
        review_period_ms,
        trading_period_ms,
        min_asset_liquidity,
        min_stable_liquidity,
        twap_start_delay,
        uses_dao_liquidity: false,
        twap_initial_observation,
        twap_step_max,
        twap_threshold,
        amm_total_fee_bps,
        winning_outcome,
        fee_escrow,
        treasury_address,
        intent_keys,
    }
}

#[test_only]
/// Gets a mutable reference to the token escrow of the proposal
public fun test_get_coin_escrow<AssetType, StableType>(
    escrow: &mut coin_escrow::TokenEscrow<AssetType, StableType>,
): &mut coin_escrow::TokenEscrow<AssetType, StableType> {
    escrow
}

#[test_only]
/// Gets the market state through the token escrow
public fun test_get_market_state<AssetType, StableType>(
    escrow: &coin_escrow::TokenEscrow<AssetType, StableType>,
): &market_state::MarketState {
    escrow.get_market_state()
}


// === Additional View Functions ===

/// Get proposal ID
public fun id<AssetType, StableType>(proposal: &Proposal<AssetType, StableType>): ID {
    object::id(proposal)
}

/// Get proposal address (for testing)
public fun id_address<AssetType, StableType>(proposal: &Proposal<AssetType, StableType>): address {
    object::uid_to_address(&proposal.id)
}

/// Get market ID (already defined earlier in the file)
/// Commitment Actions Module
/// Defines actions for creating and managing commitment proposals
module futarchy::commitment_actions;

use std::string::{Self, String};
use std::vector;
use std::option::{Self, Option};
use sui::coin::{Self, Coin};
use sui::clock::{Self, Clock};
use sui::transfer;
use sui::tx_context::{Self, TxContext};
use sui::object::{Self, ID};
use sui::event;
use account_protocol::{
    executable::{Self, Executable},
    account::{Self, Account},
    version_witness::VersionWitness,
};
use futarchy::{
    futarchy_config::FutarchyConfig,
    version,
    commitment_proposal::{Self, CommitmentProposal, PriceTier},
    spot_amm::SpotAMM,
    resource_requests::{Self, ResourceRequest, ResourceReceipt},
    proposal::Proposal,
};

// === Errors ===
const EInvalidProposalId: u64 = 0;
const EProposalNotFound: u64 = 1;
const ECommitmentAlreadyExists: u64 = 2;
const ECommitmentNotFound: u64 = 3;
const EInvalidRecipient: u64 = 4;
const ECannotExecuteWithoutPool: u64 = 5;
const ECannotExecuteWithoutProposal: u64 = 6;
const ECommitmentIdMismatch: u64 = 7;
const EInsufficientCommittedAmount: u64 = 8;

// === Action Structs ===

/// Action to create a commitment proposal
public struct CreateCommitmentProposalAction<phantom AssetType> has store, copy, drop {
    /// Amount of tokens to commit
    committed_amount: u64,
    /// Price tiers for locking
    tiers: vector<PriceTier>,
    /// Associated proposal ID
    proposal_id: ID,
    /// Trading start time
    trading_start: u64,
    /// Trading end time
    trading_end: u64,
    /// Description of the commitment
    description: String,
}

/// Action to execute a commitment after proposal passes
public struct ExecuteCommitmentAction has store, copy, drop {
    /// ID of the commitment proposal to execute
    commitment_id: ID,
}

/// Action to update withdrawal recipient
public struct UpdateCommitmentRecipientAction has store, copy, drop {
    /// ID of the commitment proposal
    commitment_id: ID,
    /// New recipient address
    new_recipient: address,
}

/// Action to withdraw unlocked tokens
public struct WithdrawUnlockedTokensAction has store, copy, drop {
    /// ID of the commitment proposal
    commitment_id: ID,
}

// === Do Functions (Action Execution) ===

/// Create a commitment proposal directly with coins
public fun do_create_commitment_proposal<AssetType, StableType, Outcome: store, IW: drop>(
    executable: &mut Executable<Outcome>,
    _account: &mut Account<FutarchyConfig>,
    _version: VersionWitness,
    witness: IW,
    committed_coins: Coin<AssetType>,
    clock: &Clock,
    ctx: &mut TxContext,
): CommitmentProposal<AssetType, StableType> {
    let action = executable::next_action<Outcome, CreateCommitmentProposalAction<AssetType>, IW>(
        executable,
        witness,
    );
    
    // Verify coin amount matches exactly
    assert!(coin::value(&committed_coins) >= action.committed_amount, EInsufficientCommittedAmount);
    
    // Create the commitment proposal directly
    commitment_proposal::create_commitment_proposal(
        tx_context::sender(ctx),
        committed_coins,
        action.tiers,
        action.proposal_id,
        action.trading_start,
        action.trading_end,
        action.description,
        clock,
        ctx,
    )
}

/// Execute a commitment proposal directly
public fun do_execute_commitment<AssetType, StableType, Outcome: store, IW: drop>(
    executable: &mut Executable<Outcome>,
    _account: &mut Account<FutarchyConfig>,
    _version: VersionWitness,
    witness: IW,
    commitment: &mut CommitmentProposal<AssetType, StableType>,
    proposal: &Proposal<AssetType, StableType>,
    clock: &Clock,
    ctx: &mut TxContext,
) {
    let action = executable::next_action<Outcome, ExecuteCommitmentAction, IW>(
        executable,
        witness,
    );
    
    // Verify commitment ID matches the action's target
    assert!(object::id(commitment) == action.commitment_id, ECommitmentIdMismatch);
    
    // Execute the commitment directly
    commitment_proposal::execute_commitment(
        commitment,
        proposal,
        clock,
        ctx,
    );
}

/// Update withdrawal recipient
public fun do_update_commitment_recipient<AssetType, StableType, Outcome: store, IW: drop>(
    executable: &mut Executable<Outcome>,
    _account: &mut Account<FutarchyConfig>,
    _version: VersionWitness,
    witness: IW,
    commitment: &mut CommitmentProposal<AssetType, StableType>,
    ctx: &mut TxContext,
) {
    let action = executable::next_action<Outcome, UpdateCommitmentRecipientAction, IW>(
        executable,
        witness,
    );
    
    // Verify commitment ID matches the action's target
    assert!(object::id(commitment) == action.commitment_id, ECommitmentIdMismatch);
    
    // Update the recipient
    commitment_proposal::update_withdrawal_recipient(
        commitment,
        action.new_recipient,
        ctx,
    );
}

/// Withdraw unlocked tokens
public fun do_withdraw_unlocked_tokens<AssetType, StableType, Outcome: store, IW: drop>(
    executable: &mut Executable<Outcome>,
    _account: &mut Account<FutarchyConfig>,
    _version: VersionWitness,
    witness: IW,
    commitment: &mut CommitmentProposal<AssetType, StableType>,
    clock: &Clock,
    ctx: &mut TxContext,
) {
    let action = executable::next_action<Outcome, WithdrawUnlockedTokensAction, IW>(
        executable,
        witness,
    );
    
    // Verify commitment ID matches the action's target
    assert!(object::id(commitment) == action.commitment_id, ECommitmentIdMismatch);
    
    // Withdraw the tokens
    commitment_proposal::withdraw_unlocked_tokens(
        commitment,
        clock,
        ctx,
    );
}

// === Constructor Functions ===

/// Create a new CreateCommitmentProposalAction
public fun new_create_commitment_proposal_action<AssetType>(
    committed_amount: u64,
    tiers: vector<PriceTier>,
    proposal_id: ID,
    trading_start: u64,
    trading_end: u64,
    description: String,
): CreateCommitmentProposalAction<AssetType> {
    CreateCommitmentProposalAction {
        committed_amount,
        tiers,
        proposal_id,
        trading_start,
        trading_end,
        description,
    }
}

/// Create a new ExecuteCommitmentAction
public fun new_execute_commitment_action(
    commitment_id: ID,
): ExecuteCommitmentAction {
    ExecuteCommitmentAction {
        commitment_id,
    }
}

/// Create a new UpdateCommitmentRecipientAction
public fun new_update_commitment_recipient_action(
    commitment_id: ID,
    new_recipient: address,
): UpdateCommitmentRecipientAction {
    UpdateCommitmentRecipientAction {
        commitment_id,
        new_recipient,
    }
}

/// Create a new WithdrawUnlockedTokensAction
public fun new_withdraw_unlocked_tokens_action(
    commitment_id: ID,
): WithdrawUnlockedTokensAction {
    WithdrawUnlockedTokensAction {
        commitment_id,
    }
}/// Optimistic Proposal System
/// Proposals execute automatically after a delay unless challenged
/// Challenges trigger futarchy markets using standard proposal fees
module futarchy::optimistic_proposal;

use std::string::{Self, String};
use std::vector;
use std::option::{Self, Option};
use sui::balance::{Self, Balance};
use sui::coin::{Self, Coin};
use sui::clock::{Self, Clock};
use sui::tx_context::{Self, TxContext};
use sui::object::{Self, ID, UID};
use sui::event;
use sui::transfer;
use account_protocol::{
    executable::{Self, Executable},
    account::{Self, Account},
    intents::{Intent},
};
use futarchy::{
    futarchy_config::{Self, FutarchyConfig},
    dao_config,
    proposal::{Self, Proposal},
};

// === Errors ===
const ENotOptimistic: u64 = 0;
const EAlreadyChallenged: u64 = 1;
const EChallengePeriodEnded: u64 = 2;
const EChallengePeriodNotEnded: u64 = 3;
const EAlreadyExecuted: u64 = 4;
const ENotProposer: u64 = 5;
const EInvalidFeeAmount: u64 = 6;
const EChallengeAlreadyResolved: u64 = 7;
const EProposalNotFinalized: u64 = 8;

// === Constants ===
// Challenge period is now configured in DAO config
// const DEFAULT_CHALLENGE_PERIOD_MS: u64 = 259_200_000; // 3 days
// const MIN_CHALLENGE_PERIOD_MS: u64 = 86_400_000; // 1 day
// const MAX_CHALLENGE_PERIOD_MS: u64 = 604_800_000; // 7 days

// === Events ===

/// Emitted when an optimistic proposal is created
public struct OptimisticProposalCreated has copy, drop {
    proposal_id: ID,
    proposer: address,
    challenge_period_end: u64,
    description: String,
}

/// Emitted when a proposal is challenged
public struct ProposalChallenged has copy, drop {
    proposal_id: ID,
    challenger: address,
    futarchy_proposal_id: ID,
    timestamp: u64,
}

/// Emitted when an optimistic proposal executes (no challenge)
public struct OptimisticProposalExecuted has copy, drop {
    proposal_id: ID,
    timestamp: u64,
}

/// Emitted when a challenge is resolved
public struct ChallengeResolved has copy, drop {
    proposal_id: ID,
    challenge_succeeded: bool,
    challenger_refunded: bool,
}

// === Structs ===

/// An optimistic proposal that executes unless challenged
public struct OptimisticProposal has key, store {
    id: UID,
    
    // Core proposal data
    proposer: address,
    intent: Intent<String>, // The action to execute
    description: String,
    
    // Challenge mechanics
    challenge_period_end: u64,
    is_challenged: bool,
    challenger: Option<address>,
    
    // If challenged, links to futarchy proposal
    futarchy_proposal_id: Option<ID>,
    challenge_succeeded: Option<bool>,
    
    // Execution state
    executed: bool,
    created_at: u64,
    
    // Metadata
    metadata: String,
}

/// Action to create an optimistic proposal
public struct CreateOptimisticProposalAction has store {
    intent: Intent<String>,
    description: String,
    challenge_period_ms: u64,  // If 0, uses DAO config default
    metadata: String,
}

/// Action to challenge an optimistic proposal
public struct ChallengeOptimisticProposalAction has store, drop {
    optimistic_proposal_id: ID,
    challenge_description: String,
}

/// Action to execute an unchallenged optimistic proposal
public struct ExecuteOptimisticProposalAction has store, drop {
    optimistic_proposal_id: ID,
}

/// Action to resolve a challenge after futarchy markets decide
public struct ResolveChallengeAction has store, drop {
    optimistic_proposal_id: ID,
    futarchy_proposal_id: ID,
}

// === Constructor Functions ===

/// Create a new optimistic proposal
public fun create_optimistic_proposal(
    proposer: address,
    intent: Intent<String>,
    description: String,
    challenge_period_ms: u64,  // If 0, uses DAO config default
    metadata: String,
    account: &Account<FutarchyConfig>,
    clock: &Clock,
    ctx: &mut TxContext,
): OptimisticProposal {
    // Get challenge period from config if not specified
    let actual_challenge_period = if (challenge_period_ms == 0) {
        let futarchy_config = account::config(account);
        futarchy_config::optimistic_challenge_period_ms(futarchy_config)
    } else {
        // If specified, just ensure it's non-zero
        assert!(challenge_period_ms > 0, EInvalidFeeAmount);
        challenge_period_ms
    };
    
    let id = object::new(ctx);
    let proposal_id = object::uid_to_inner(&id);
    let created_at = clock::timestamp_ms(clock);
    let challenge_period_end = created_at + actual_challenge_period;
    
    event::emit(OptimisticProposalCreated {
        proposal_id,
        proposer,
        challenge_period_end,
        description: description,
    });
    
    OptimisticProposal {
        id,
        proposer,
        intent,
        description,
        challenge_period_end,
        is_challenged: false,
        challenger: option::none(),
        futarchy_proposal_id: option::none(),
        challenge_succeeded: option::none(),
        executed: false,
        created_at,
        metadata,
    }
}

// === Challenge Functions ===

/// Challenge an optimistic proposal (requires fee in DAO's native token)
public fun challenge_optimistic_proposal<AssetType>(
    optimistic: &mut OptimisticProposal,
    challenger: address,
    account: &mut Account<FutarchyConfig>,
    fee_coin: Coin<AssetType>, // Fee must be in DAO's token type
    futarchy_proposal_id: ID,
    clock: &Clock,
    ctx: &mut TxContext,
) {
    // Validate challenge timing
    let now = clock::timestamp_ms(clock);
    assert!(now < optimistic.challenge_period_end, EChallengePeriodEnded);
    assert!(!optimistic.is_challenged, EAlreadyChallenged);
    assert!(!optimistic.executed, EAlreadyExecuted);
    
    // Get the required fee amount from DAO config
    let futarchy_config = account::config(account);
    let fee_amount = futarchy_config::optimistic_challenge_fee(futarchy_config);
    assert!(coin::value(&fee_coin) >= fee_amount, EInvalidFeeAmount);
    
    // Transfer fee to DAO treasury (challenger loses this if challenge fails)
    transfer::public_transfer(fee_coin, account::addr(account));
    
    // Mark as challenged
    optimistic.is_challenged = true;
    optimistic.challenger = option::some(challenger);
    optimistic.futarchy_proposal_id = option::some(futarchy_proposal_id);
    
    event::emit(ProposalChallenged {
        proposal_id: object::id(optimistic),
        challenger,
        futarchy_proposal_id,
        timestamp: now,
    });
}

// === Execution Functions ===

/// Execute an unchallenged optimistic proposal after challenge period
public fun execute_optimistic_proposal(
    optimistic: &mut OptimisticProposal,
    clock: &Clock,
    ctx: &mut TxContext,
) {
    // Validate execution conditions
    assert!(!optimistic.executed, EAlreadyExecuted);
    assert!(!optimistic.is_challenged, EAlreadyChallenged);
    assert!(clock::timestamp_ms(clock) >= optimistic.challenge_period_end, EChallengePeriodNotEnded);
    
    optimistic.executed = true;
    
    event::emit(OptimisticProposalExecuted {
        proposal_id: object::id(optimistic),
        timestamp: clock::timestamp_ms(clock),
    });
    
    // Intent execution would be handled separately
    // The intent remains stored in the proposal for reference
}

/// Resolve a challenge after futarchy markets decide
public fun resolve_challenge<AssetType, StableType>(
    optimistic: &mut OptimisticProposal,
    futarchy_proposal: &Proposal<AssetType, StableType>,
    account: &mut Account<FutarchyConfig>,
    mut refund_coin: Option<Coin<AssetType>>, // Coin for refund if challenge succeeds
    clock: &Clock,
    ctx: &mut TxContext,
) {
    // Validate resolution conditions
    assert!(optimistic.is_challenged, ENotOptimistic);
    assert!(option::is_none(&optimistic.challenge_succeeded), EChallengeAlreadyResolved);
    assert!(proposal::is_finalized(futarchy_proposal), EProposalNotFinalized);
    
    // Check if the futarchy proposal passed (challenge failed) or failed (challenge succeeded)
    // If futarchy REJECTS the optimistic proposal, the challenge succeeded
    let challenge_succeeded = !proposal::is_winning_outcome_set(futarchy_proposal) || 
                             proposal::get_winning_outcome(futarchy_proposal) == 1; // REJECT outcome
    
    optimistic.challenge_succeeded = option::some(challenge_succeeded);
    
    // Handle fee based on challenge result
    let challenger_refunded = if (challenge_succeeded && option::is_some(&optimistic.challenger)) {
        // Challenge succeeded - refund challenger
        if (option::is_some(&refund_coin)) {
            let coin = option::extract(&mut refund_coin);
            let challenger = *option::borrow(&optimistic.challenger);
            transfer::public_transfer(coin, challenger);
        };
        true
    } else {
        // Challenge failed - DAO keeps the fee (already in treasury)
        // Destroy the refund coin if provided
        if (option::is_some(&refund_coin)) {
            let coin = option::extract(&mut refund_coin);
            transfer::public_transfer(coin, account::addr(account)); // Keep in DAO
        };
        false
    };
    
    // If challenge failed, the optimistic proposal can still execute
    if (!challenge_succeeded) {
        // Proposal was validated by markets, can execute
        optimistic.executed = false; // Still needs explicit execution
    } else {
        // Challenge succeeded, proposal is blocked
        optimistic.executed = true; // Mark as executed to prevent future execution
    };
    
    event::emit(ChallengeResolved {
        proposal_id: object::id(optimistic),
        challenge_succeeded,
        challenger_refunded,
    });
    
    // Destroy the Option if it still contains a coin (shouldn't happen in normal flow)
    if (option::is_some(&refund_coin)) {
        let leftover_coin = option::extract(&mut refund_coin);
        transfer::public_transfer(leftover_coin, account::addr(account)); // Send to DAO treasury
    };
    option::destroy_none(refund_coin);
}

// === Getter Functions ===

public fun is_challengeable(
    optimistic: &OptimisticProposal,
    clock: &Clock,
): bool {
    !optimistic.is_challenged && 
    !optimistic.executed && 
    clock::timestamp_ms(clock) < optimistic.challenge_period_end
}

public fun is_executable(
    optimistic: &OptimisticProposal,
    clock: &Clock,
): bool {
    !optimistic.executed && 
    !optimistic.is_challenged && 
    clock::timestamp_ms(clock) >= optimistic.challenge_period_end
}

public fun get_proposer(optimistic: &OptimisticProposal): address {
    optimistic.proposer
}

public fun get_challenger(optimistic: &OptimisticProposal): Option<address> {
    optimistic.challenger
}

public fun is_challenged(optimistic: &OptimisticProposal): bool {
    optimistic.is_challenged
}

public fun is_executed(optimistic: &OptimisticProposal): bool {
    optimistic.executed
}

public fun get_challenge_period_end(optimistic: &OptimisticProposal): u64 {
    optimistic.challenge_period_end
}

public fun get_futarchy_proposal_id(optimistic: &OptimisticProposal): Option<ID> {
    optimistic.futarchy_proposal_id
}

public fun get_challenge_result(optimistic: &OptimisticProposal): Option<bool> {
    optimistic.challenge_succeeded
}/// Governance module for creating and executing intents from approved proposals
/// This module provides a simplified interface for governance operations
module futarchy::governance_intents;

// === Imports ===
use std::string::String;
use sui::{
    clock::Clock,
    tx_context::TxContext,
};
use account_protocol::{
    account::Account,
    executable::Executable,
    intents::{Self, Intent, Params},
    intent_interface,
};
use futarchy::{
    futarchy_config::{Self, FutarchyConfig, FutarchyOutcome},
    proposal::Proposal,
    market_state::MarketState,
    version,
};

// === Aliases ===
use fun intent_interface::build_intent as Account.build_intent;

// === Witness ===
/// Single witness for governance intents
public struct GovernanceWitness has copy, drop {}

/// Get the governance witness
public fun witness(): GovernanceWitness {
    GovernanceWitness {}
}

// === Intent Creation Functions ===

/// Create a simple treasury transfer intent
/// For actual transfers, use vault_intents::request_spend_and_transfer directly
public fun create_transfer_intent<CoinType, Outcome: store + drop + copy>(
    account: &Account<FutarchyConfig>,
    recipient: address,
    amount: u64,
    outcome: Outcome,
    clock: &Clock,
    ctx: &mut TxContext
): Intent<Outcome> {
    // Generate intent key
    let mut intent_key = b"transfer_".to_string();
    intent_key.append(recipient.to_string());
    intent_key.append(b"_".to_string());
    intent_key.append(amount.to_string());
    
    // Create intent parameters
    let params = intents::new_params(
        intent_key,
        b"Treasury Transfer".to_string(),
        vector[clock.timestamp_ms() + 3_600_000], // 1 hour delay
        clock.timestamp_ms() + 86_400_000, // 24 hour expiry
        clock,
        ctx
    );
    
    // Create intent using account
    let intent = account.create_intent(
        params,
        outcome,
        b"TreasuryTransfer".to_string(),
        version::current(),
        witness(),
        ctx
    );
    
    // Note: Actions should be added by the caller using vault_intents
    intent
}

/// Create a config update intent
public fun create_config_intent<Outcome: store + drop + copy>(
    account: &Account<FutarchyConfig>,
    update_type: String,
    outcome: Outcome,
    clock: &Clock,
    ctx: &mut TxContext
): Intent<Outcome> {
    // Generate intent key
    let mut intent_key = b"config_".to_string();
    intent_key.append(update_type);
    intent_key.append(b"_".to_string());
    intent_key.append(clock.timestamp_ms().to_string());
    
    // Create intent parameters
    let params = intents::new_params(
        intent_key,
        b"Config Update".to_string(),
        vector[clock.timestamp_ms() + 3_600_000],
        clock.timestamp_ms() + 86_400_000,
        clock,
        ctx
    );
    
    // Create intent
    let intent = account.create_intent(
        params,
        outcome,
        b"ConfigUpdate".to_string(),
        version::current(),
        witness(),
        ctx
    );
    
    intent
}

/// Create a dissolution intent
public fun create_dissolution_intent<Outcome: store + drop + copy>(
    account: &Account<FutarchyConfig>,
    outcome: Outcome,
    clock: &Clock,
    ctx: &mut TxContext
): Intent<Outcome> {
    // Generate intent key
    let mut intent_key = b"dissolution_".to_string();
    intent_key.append(clock.timestamp_ms().to_string());
    
    // Create intent parameters
    let params = intents::new_params(
        intent_key,
        b"DAO Dissolution".to_string(),
        vector[clock.timestamp_ms() + 7_200_000], // 2 hour delay for dissolution
        clock.timestamp_ms() + 86_400_000,
        clock,
        ctx
    );
    
    // Create intent
    let intent = account.create_intent(
        params,
        outcome,
        b"Dissolution".to_string(),
        version::current(),
        witness(),
        ctx
    );
    
    intent
}

// === Execution Functions ===

/// Execute a governance intent from an approved proposal (generic version)
/// This is called after a proposal is approved and its market is finalized
/// Note: The actual execution is delegated to futarchy_config::execute_proposal_intent
public fun execute_proposal_intent<AssetType, StableType, Outcome: store + drop + copy>(
    account: &mut Account<FutarchyConfig>,
    proposal: &Proposal<AssetType, StableType>,
    market: &MarketState,
    outcome_index: u64,
    clock: &Clock,
    ctx: &mut TxContext
): Executable<Outcome> {
    // Delegate to futarchy_config which has the proper implementation
    futarchy_config::execute_proposal_intent(
        account,
        proposal,
        market,
        outcome_index,
        clock,
        ctx
    )
}

// === Helper Functions ===

/// Helper to create intent params with standard settings
public fun create_standard_params(
    key: String,
    description: String,
    delay_ms: u64,
    expiry_ms: u64,
    clock: &Clock,
    ctx: &mut TxContext
): Params {
    intents::new_params(
        key,
        description,
        vector[clock.timestamp_ms() + delay_ms],
        clock.timestamp_ms() + expiry_ms,
        clock,
        ctx
    )
}

// === Notes ===
// For actual action execution, use the appropriate modules directly:
// - Transfers: account_actions::vault_intents
// - Config: futarchy::config_intents
// - Liquidity: futarchy::liquidity_intents
// - Dissolution: futarchy::dissolution_intents
// - Streaming: futarchy::stream_intents/// Public cleanup functions for expired intents
/// Sui's storage rebate system naturally incentivizes cleanup - 
/// cleaners get the storage deposit back when deleting objects
module futarchy::intent_janitor;

use std::string::String;
use sui::{
    clock::Clock,
    event,
    table::{Self, Table},
};
use account_protocol::{
    account::{Self, Account},
    intents::{Self, Expired},
};
use futarchy::{
    futarchy_config::{Self, FutarchyConfig, FutarchyOutcome},
    config_actions,
    version,
};

// === Constants ===

/// Maximum intents that can be cleaned in one call to prevent gas exhaustion
const MAX_CLEANUP_PER_CALL: u64 = 20;

// === Errors ===

const ENoExpiredIntents: u64 = 1;
const ECleanupLimitExceeded: u64 = 2;

// === Types ===

/// Index for tracking created intents to enable cleanup
public struct IntentIndex has store {
    /// Vector of all intent keys that have been created
    keys: vector<String>,
    /// Map from intent key to expiration time for quick lookup
    expiration_times: Table<String, u64>,
    /// Current scan position for round-robin cleanup
    scan_position: u64,
}

/// Key for storing the intent index in managed data
public struct IntentIndexKey has copy, drop, store {}

// === Events ===

/// Emitted when intents are cleaned
public struct IntentsCleaned has copy, drop {
    dao_id: ID,
    cleaner: address,
    count: u64,
    timestamp: u64,
}

/// Emitted when maintenance is needed
public struct MaintenanceNeeded has copy, drop {
    dao_id: ID,
    expired_count: u64,
    timestamp: u64,
}

// === Public Functions ===

/// Clean up expired FutarchyOutcome intents
/// Sui's storage rebate naturally rewards cleaners
public fun cleanup_expired_futarchy_intents(
    account: &mut Account<FutarchyConfig>,
    max_to_clean: u64,
    clock: &Clock,
    ctx: &mut TxContext,
) {
    assert!(max_to_clean <= MAX_CLEANUP_PER_CALL, ECleanupLimitExceeded);
    
    let mut cleaned = 0u64;
    let dao_id = object::id(account);
    let cleaner = ctx.sender();
    
    // Try to clean up to max_to_clean intents
    while (cleaned < max_to_clean) {
        // Find next expired intent
        let mut intent_key_opt = find_next_expired_intent(account, clock, ctx);
        if (intent_key_opt.is_none()) {
            break // No more expired intents
        };
        
        let intent_key = intent_key_opt.extract();
        
        // Try to delete it as FutarchyOutcome type
        if (try_delete_expired_futarchy_intent(account, intent_key, clock, ctx)) {
            cleaned = cleaned + 1;
        } else {
            // Could not delete this intent (wrong type or not expired)
            // Continue to next one
        };
    };
    
    assert!(cleaned > 0, ENoExpiredIntents);
    
    // Emit event
    event::emit(IntentsCleaned {
        dao_id,
        cleaner,
        count: cleaned,
        timestamp: clock.timestamp_ms(),
    });
}

/// Clean up ALL expired intents during normal operations (no reward)
/// Called automatically during proposal finalization and execution
public(package) fun cleanup_all_expired_intents(
    account: &mut Account<FutarchyConfig>,
    clock: &Clock,
    ctx: &mut TxContext,
) {
    // Keep cleaning until no more expired intents are found
    loop {
        let mut intent_key_opt = find_next_expired_intent(account, clock, ctx);
        if (intent_key_opt.is_none()) {
            break
        };
        
        let intent_key = intent_key_opt.extract();
        
        // Try to delete it - continue even if this specific one fails
        // (might be wrong type or other issue)
        try_delete_expired_futarchy_intent(account, intent_key, clock, ctx);
    };
}

/// Clean up expired intents with a limit (for bounded operations)
/// Called automatically during proposal finalization and execution
public(package) fun cleanup_expired_intents_automatic(
    account: &mut Account<FutarchyConfig>,
    max_to_clean: u64,
    clock: &Clock,
    ctx: &mut TxContext,
) {
    let mut cleaned = 0u64;
    
    while (cleaned < max_to_clean) {
        let mut intent_key_opt = find_next_expired_intent(account, clock, ctx);
        if (intent_key_opt.is_none()) {
            break
        };
        
        let intent_key = intent_key_opt.extract();
        
        if (try_delete_expired_futarchy_intent(account, intent_key, clock, ctx)) {
            cleaned = cleaned + 1;
        };
    };
}

/// Check if maintenance is needed and emit event if so
public fun check_maintenance_needed(
    account: &Account<FutarchyConfig>,
    clock: &Clock,
) {
    let expired_count = count_expired_intents(account, clock);
    
    if (expired_count > 10) {
        event::emit(MaintenanceNeeded {
            dao_id: object::id(account),
            expired_count,
            timestamp: clock.timestamp_ms(),
        });
    }
}

// === Internal Functions ===

/// Get or initialize the intent index
fun get_or_init_intent_index(
    account: &mut Account<FutarchyConfig>,
    ctx: &mut TxContext
): &mut IntentIndex {
    // Initialize if doesn't exist
    if (!account::has_managed_data(account, IntentIndexKey {})) {
        let index = IntentIndex {
            keys: vector::empty(),
            expiration_times: table::new(ctx),
            scan_position: 0,
        };
        account::add_managed_data(
            account,
            IntentIndexKey {},
            index,
            version::current()
        );
    };
    
    account::borrow_managed_data_mut(
        account,
        IntentIndexKey {},
        version::current()
    )
}

/// Add an intent to the index when it's created
public(package) fun register_intent(
    account: &mut Account<FutarchyConfig>,
    key: String,
    expiration_time: u64,
    ctx: &mut TxContext
) {
    let index = get_or_init_intent_index(account, ctx);
    vector::push_back(&mut index.keys, key);
    table::add(&mut index.expiration_times, key, expiration_time);
}

/// Find the next expired intent key
fun find_next_expired_intent(
    account: &mut Account<FutarchyConfig>,
    clock: &Clock,
    ctx: &mut TxContext
): Option<String> {
    // Get the index
    let index = get_or_init_intent_index(account, ctx);
    
    let current_time = clock.timestamp_ms();
    let keys = &index.keys;
    let expiration_times = &index.expiration_times;
    let len = vector::length(keys);
    
    if (len == 0) {
        return option::none()
    };
    
    // Start from last scan position for round-robin
    let mut checked = 0;
    let mut pos = index.scan_position;
    
    while (checked < len) {
        if (pos >= len) {
            pos = 0; // Wrap around
        };
        
        let key = vector::borrow(keys, pos);
        
        // Check if this intent is expired
        if (table::contains(expiration_times, *key)) {
            let expiry = *table::borrow(expiration_times, *key);
            if (current_time >= expiry) {
                // Update scan position for next call
                index.scan_position = pos + 1;
                return option::some(*key)
            }
        };
        
        pos = pos + 1;
        checked = checked + 1;
    };
    
    option::none()
}

/// Try to delete an expired FutarchyOutcome intent
fun try_delete_expired_futarchy_intent(
    account: &mut Account<FutarchyConfig>,
    key: String,
    clock: &Clock,
    ctx: &mut TxContext,
): bool {
    // Check if intent exists and is expired
    let intents_store = account::intents(account);
    if (!intents::contains(intents_store, key)) {
        return false
    };
    
    // Try to delete as FutarchyOutcome type
    // This will fail if the intent has a different outcome type
    let can_delete = {
        let intent = intents::get<FutarchyOutcome>(intents_store, key);
        clock.timestamp_ms() >= intents::expiration_time(intent)
    };
    
    if (can_delete) {
        let expired = account::delete_expired_intent<FutarchyConfig, FutarchyOutcome>(
            account,
            key,
            clock
        );
        destroy_expired(expired);
        
        // Remove from index
        remove_from_index(account, key, ctx);
        
        true
    } else {
        false
    }
}

/// Destroy an expired intent after removing all actions
fun destroy_expired(expired: Expired) {
    // For now, we can't generically remove actions from Expired
    // This would require knowing all possible action types
    // Instead, we'll just destroy it if it's already empty
    // or abort if it has actions (shouldn't happen with FutarchyOutcome)
    
    // Destroy the expired intent (will abort if not empty)
    intents::destroy_empty_expired(expired);
}

/// Count expired intents
fun count_expired_intents(
    account: &Account<FutarchyConfig>,
    clock: &Clock,
): u64 {
    // Check if index exists
    if (!account::has_managed_data(account, IntentIndexKey {})) {
        return 0
    };
    
    let index: &IntentIndex = account::borrow_managed_data(
        account,
        IntentIndexKey {},
        version::current()
    );
    
    let current_time = clock.timestamp_ms();
    let mut count = 0u64;
    let keys = &index.keys;
    let expiration_times = &index.expiration_times;
    let len = vector::length(keys);
    
    let mut i = 0;
    while (i < len && i < 100) { // Limit scan to prevent gas exhaustion
        let key = vector::borrow(keys, i);
        if (table::contains(expiration_times, *key)) {
            let expiry = *table::borrow(expiration_times, *key);
            if (current_time >= expiry) {
                count = count + 1;
            }
        };
        i = i + 1;
    };
    
    count
}

/// Remove an intent from the index after deletion
fun remove_from_index(
    account: &mut Account<FutarchyConfig>,
    key: String,
    ctx: &mut TxContext
) {
    let index = get_or_init_intent_index(account, ctx);
    
    // Remove from expiration times table
    if (table::contains(&index.expiration_times, key)) {
        table::remove(&mut index.expiration_times, key);
    };
    
    // Remove from keys vector (expensive but necessary)
    let keys = &mut index.keys;
    let len = vector::length(keys);
    let mut i = 0;
    
    while (i < len) {
        if (*vector::borrow(keys, i) == key) {
            vector::swap_remove(keys, i);
            
            // Adjust scan position if needed
            if (index.scan_position > i) {
                index.scan_position = index.scan_position - 1;
            };
            break
        };
        i = i + 1;
    };
}/// Protocol admin intents for transferring admin capabilities to a futarchy DAO
/// This module enables the initial migration of protocol admin caps to be governed by a DAO
module futarchy::protocol_admin_intents;

// === Imports ===
use std::string::String;
use sui::{
    transfer::Receiving,
    object::ID,
};
use account_protocol::{
    account::{Self, Account, Auth},
    executable::Executable,
    owned,
    intents::{Self, Params},
    intent_interface,
};
use futarchy::version;
use futarchy::{
    factory::{FactoryOwnerCap, ValidatorAdminCap},
    fee::FeeAdminCap,
    futarchy_config::FutarchyConfig,
};

// === Aliases ===
use fun intent_interface::process_intent as Account.process_intent;

// === Intent Witness Types ===

/// Intent to accept the FactoryOwnerCap into the DAO's custody
public struct AcceptFactoryOwnerCapIntent() has copy, drop;

/// Intent to accept the FeeAdminCap into the DAO's custody  
public struct AcceptFeeAdminCapIntent() has copy, drop;

/// Intent to accept the ValidatorAdminCap into the DAO's custody
public struct AcceptValidatorAdminCapIntent() has copy, drop;

// === Request Functions ===

/// Request to accept the FactoryOwnerCap into the DAO's custody
public fun request_accept_factory_owner_cap<Outcome: store>(
    auth: Auth,
    account: &mut Account<FutarchyConfig>,
    params: Params,
    outcome: Outcome,
    cap_id: ID,
    ctx: &mut TxContext,
) {
    account.verify(auth);
    params.assert_single_execution();
    
    intent_interface::build_intent!(
        account,
        params,
        outcome,
        b"Accept FactoryOwnerCap into protocol DAO custody".to_string(),
        version::current(),
        AcceptFactoryOwnerCapIntent(),
        ctx,
        |intent, iw| {
            owned::new_withdraw(intent, account, cap_id, iw);
        }
    );
}

/// Request to accept the FeeAdminCap into the DAO's custody
public fun request_accept_fee_admin_cap<Outcome: store>(
    auth: Auth,
    account: &mut Account<FutarchyConfig>,
    params: Params,
    outcome: Outcome,
    cap_id: ID,
    ctx: &mut TxContext,
) {
    account.verify(auth);
    params.assert_single_execution();
    
    intent_interface::build_intent!(
        account,
        params,
        outcome,
        b"Accept FeeAdminCap into protocol DAO custody".to_string(),
        version::current(),
        AcceptFeeAdminCapIntent(),
        ctx,
        |intent, iw| {
            owned::new_withdraw(intent, account, cap_id, iw);
        }
    );
}

/// Request to accept the ValidatorAdminCap into the DAO's custody
public fun request_accept_validator_admin_cap<Outcome: store>(
    auth: Auth,
    account: &mut Account<FutarchyConfig>,
    params: Params,
    outcome: Outcome,
    cap_id: ID,
    ctx: &mut TxContext,
) {
    account.verify(auth);
    params.assert_single_execution();
    
    intent_interface::build_intent!(
        account,
        params,
        outcome,
        b"Accept ValidatorAdminCap into protocol DAO custody".to_string(),
        version::current(),
        AcceptValidatorAdminCapIntent(),
        ctx,
        |intent, iw| {
            owned::new_withdraw(intent, account, cap_id, iw);
        }
    );
}

// === Execution Functions ===

/// Execute the intent to accept FactoryOwnerCap
public fun execute_accept_factory_owner_cap<Outcome: store>(
    executable: &mut Executable<Outcome>,
    account: &mut Account<FutarchyConfig>,
    receiving: Receiving<FactoryOwnerCap>,
) {
    account.process_intent!(
        executable,
        version::current(),
        AcceptFactoryOwnerCapIntent(),
        |executable, iw| {
            let cap = owned::do_withdraw(executable, account, receiving, iw);
            
            // Store the cap in the account's managed assets
            account::add_managed_asset(
                account,
                b"protocol:factory_owner_cap".to_string(),
                cap,
                version::current()
            );
        }
    );
}

/// Execute the intent to accept FeeAdminCap
public fun execute_accept_fee_admin_cap<Outcome: store>(
    executable: &mut Executable<Outcome>,
    account: &mut Account<FutarchyConfig>,
    receiving: Receiving<FeeAdminCap>,
) {
    account.process_intent!(
        executable,
        version::current(),
        AcceptFeeAdminCapIntent(),
        |executable, iw| {
            let cap = owned::do_withdraw(executable, account, receiving, iw);
            
            // Store the cap in the account's managed assets
            account::add_managed_asset(
                account,
                b"protocol:fee_admin_cap".to_string(),
                cap,
                version::current()
            );
        }
    );
}

/// Execute the intent to accept ValidatorAdminCap
public fun execute_accept_validator_admin_cap<Outcome: store>(
    executable: &mut Executable<Outcome>,
    account: &mut Account<FutarchyConfig>,
    receiving: Receiving<ValidatorAdminCap>,
) {
    account.process_intent!(
        executable,
        version::current(),
        AcceptValidatorAdminCapIntent(),
        |executable, iw| {
            let cap = owned::do_withdraw(executable, account, receiving, iw);
            
            // Store the cap in the account's managed assets
            account::add_managed_asset(
                account,
                b"protocol:validator_admin_cap".to_string(),
                cap,
                version::current()
            );
        }
    );
}

// === Migration Helper Functions ===

/// One-time migration function to transfer all admin caps to the protocol DAO
/// This should be called by the current admin cap holders to transfer control
public entry fun migrate_admin_caps_to_dao(
    account: &mut Account<FutarchyConfig>,
    factory_cap: FactoryOwnerCap,
    fee_cap: FeeAdminCap,
    validator_cap: ValidatorAdminCap,
    ctx: &mut TxContext,
) {
    // Store all caps in the DAO's account
    account::add_managed_asset(
        account,
        b"protocol:factory_owner_cap".to_string(),
        factory_cap,
        version::current()
    );
    
    account::add_managed_asset(
        account,
        b"protocol:fee_admin_cap".to_string(),
        fee_cap,
        version::current()
    );
    
    account::add_managed_asset(
        account,
        b"protocol:validator_admin_cap".to_string(),
        validator_cap,
        version::current()
    );
}

/// Transfer a specific admin cap to the protocol DAO (for gradual migration)
public entry fun migrate_factory_cap_to_dao(
    account: &mut Account<FutarchyConfig>,
    cap: FactoryOwnerCap,
    ctx: &mut TxContext,
) {
    account::add_managed_asset(
        account,
        b"protocol:factory_owner_cap".to_string(),
        cap,
        version::current()
    );
}

public entry fun migrate_fee_cap_to_dao(
    account: &mut Account<FutarchyConfig>,
    cap: FeeAdminCap,
    ctx: &mut TxContext,
) {
    account::add_managed_asset(
        account,
        b"protocol:fee_admin_cap".to_string(),
        cap,
        version::current()
    );
}

public entry fun migrate_validator_cap_to_dao(
    account: &mut Account<FutarchyConfig>,
    cap: ValidatorAdminCap,
    ctx: &mut TxContext,
) {
    account::add_managed_asset(
        account,
        b"protocol:validator_admin_cap".to_string(),
        cap,
        version::current()
    );
}/// Governance-related actions for futarchy DAOs
/// This module defines action structs and execution logic for creating second-order proposals
module futarchy::governance_actions;

// === Imports ===
use std::string::{Self, String};
use std::option::{Self, Option};
use std::vector::{Self};
use sui::{
    clock::{Self, Clock},
    coin::{Self, Coin},
    object::{Self, ID, UID},
    sui::SUI,
    table::{Self, Table},
    transfer,
    tx_context::{Self, TxContext},
};
use account_protocol::{
    account::{Self, Account},
    executable::{Self, Executable},
    version_witness::VersionWitness,
};
use futarchy::{
    futarchy_config::{Self, FutarchyConfig},
    priority_queue,
    proposal_fee_manager::{Self, ProposalFeeManager},
    resource_requests::{Self, ResourceRequest, ResourceReceipt},
};

// === Errors ===
const EInvalidProposalType: u64 = 1;
const EReservationExpired: u64 = 2;
const EReservationNotFound: u64 = 3;
const EInvalidReservationPeriod: u64 = 4;
const EProposalAlreadyExists: u64 = 5;
const EInsufficientFee: u64 = 6;
const EMaxDepthExceeded: u64 = 7;
const EInvalidTitle: u64 = 8;
const ENoOutcomes: u64 = 9;
const EOutcomeMismatch: u64 = 10;
const EInvalidBucketDuration: u64 = 11;

// === Constants ===
// These are now just fallbacks - actual values come from DAO config
/// Default reservation period (30 days in milliseconds)
const DEFAULT_RESERVATION_PERIOD_MS: u64 = 2_592_000_000; // 30 days
/// Maximum reservation period (90 days in milliseconds)
const MAX_RESERVATION_PERIOD_MS: u64 = 7_776_000_000; // 90 days

// === Structs ===

/// Action to create a new proposal (second-order proposal)
public struct CreateProposalAction has store, copy, drop {
    /// Type of proposal to create
    proposal_type: String,
    /// Serialized proposal data
    proposal_data: vector<u8>,
    /// Initial asset amount for the new proposal
    initial_asset_amount: u64,
    /// Initial stable amount for the new proposal
    initial_stable_amount: u64,
    /// Whether to use DAO liquidity
    use_dao_liquidity: bool,
    /// Fee for the new proposal
    proposal_fee: u64,
    /// Optional: Override reservation period (if not set, uses DAO config)
    reservation_period_ms_override: Option<u64>,
    /// The title of the proposal to be created
    title: String,
    /// The human-readable messages for each outcome
    outcome_messages: vector<String>,
    /// The detailed descriptions for each outcome
    outcome_details: vector<String>,
}

/// Reservation for an nth-order proposal that was evicted
/// This allows the proposal to be recreated within a time window
/// Each recreation requires full fees - no special privileges
public struct ProposalReservation has store {
    /// Original parent proposal that created this reservation
    parent_proposal_id: ID,
    /// Root proposal ID (the original first-order proposal in the chain)
    root_proposal_id: ID,
    /// Depth in the proposal chain (1 = second-order, 2 = third-order, etc.)
    chain_depth: u64,
    /// Which outcome this proposal is created for (0 = YES, 1 = NO, etc.)
    parent_outcome: u8,
    /// Whether parent has already been executed
    parent_executed: bool,
    /// The proposal data that was evicted
    proposal_type: String,
    proposal_data: vector<u8>,
    initial_asset_amount: u64,
    initial_stable_amount: u64,
    use_dao_liquidity: bool,
    /// The title of the proposal to be created
    title: String,
    /// The human-readable messages for each outcome
    outcome_messages: vector<String>,
    /// The detailed descriptions for each outcome
    outcome_details: vector<String>,
    /// Original fee amount (for reference)
    original_fee: u64,
    /// Original proposer (from parent proposal)
    original_proposer: address,
    /// Expiration timestamp for recreation rights
    recreation_expires_at: u64,
    /// Number of times this has been recreated (for tracking only)
    recreation_count: u64,
    /// Child proposals this would create (for nth-order chains)
    /// Each child can be for different outcomes
    child_proposals: vector<CreateProposalAction>,
}

/// A "bucket" that holds all reservations expiring within the same time window (e.g., a day).
public struct ReservationBucket has store {
    /// The start timestamp of this bucket's time window (e.g., midnight UTC).
    timestamp_ms: u64,
    /// The keys of all reservations that expire within this bucket's window.
    reservation_ids: vector<ID>,
    /// Pointers for the doubly-linked list (bucket timestamps).
    prev_bucket_timestamp: Option<u64>,
    next_bucket_timestamp: Option<u64>,
}

/// Storage for proposal reservations
public struct ProposalReservationRegistry has key {
    id: UID,
    /// Map from parent proposal ID to reservation
    reservations: Table<ID, ProposalReservation>,
    /// Map from bucket timestamp to bucket
    buckets: Table<u64, ReservationBucket>,
    /// Head of the linked list (points to the OLDEST bucket timestamp).
    head_bucket_timestamp: Option<u64>,
    /// Tail of the linked list (points to the NEWEST bucket timestamp).
    tail_bucket_timestamp: Option<u64>,
    /// How large each time window is in milliseconds. A DAO-configurable value.
    /// Example: 1 day = 86,400,000 ms.
    bucket_duration_ms: u64,
}

// === Getter Functions ===

/// Get the proposal fee from a CreateProposalAction
public fun get_proposal_fee(action: &CreateProposalAction): u64 {
    action.proposal_fee
}

// === Constructor Functions ===

/// Create a new CreateProposalAction with validation
public fun new_create_proposal_action(
    proposal_type: String,
    proposal_data: vector<u8>,
    initial_asset_amount: u64,
    initial_stable_amount: u64,
    use_dao_liquidity: bool,
    proposal_fee: u64,
    reservation_period_ms_override: Option<u64>,
    title: String,
    outcome_messages: vector<String>,
    outcome_details: vector<String>,
): CreateProposalAction {
    use std::string;
    
    // Basic validation
    assert!(string::length(&title) > 0, EInvalidTitle);
    assert!(!vector::is_empty(&outcome_messages), ENoOutcomes);
    assert!(vector::length(&outcome_messages) == vector::length(&outcome_details), EOutcomeMismatch);

    CreateProposalAction {
        proposal_type,
        proposal_data,
        initial_asset_amount,
        initial_stable_amount,
        use_dao_liquidity,
        proposal_fee,
        reservation_period_ms_override,
        title,
        outcome_messages,
        outcome_details,
    }
}

// === Action Execution ===

/// Execute the create proposal action - creates a resource request
/// Returns a hot potato that must be fulfilled with governance resources
public fun do_create_proposal<Outcome: store, IW: copy + drop>(
    executable: &mut Executable<Outcome>,
    account: &mut Account<FutarchyConfig>,
    version_witness: VersionWitness,
    witness: IW,
    parent_proposal_id: ID,
    clock: &Clock,
    ctx: &mut TxContext,
): ResourceRequest<CreateProposalAction> {
    let action = executable.next_action<Outcome, CreateProposalAction, IW>(witness);
    
    // Get reservation period from DAO config or use override
    let config = account::config(account);
    let reservation_period = if (option::is_some(&action.reservation_period_ms_override)) {
        let override_period = *option::borrow(&action.reservation_period_ms_override);
        // Still validate against max
        assert!(override_period <= MAX_RESERVATION_PERIOD_MS, EInvalidReservationPeriod);
        override_period
    } else {
        futarchy_config::proposal_recreation_window_ms(config)
    };
    
    // Check chain depth (we'll need to pass registry to fulfill function)
    let max_depth = futarchy_config::max_proposal_chain_depth(config);
    
    // Create resource request with all needed context
    let mut request = resource_requests::new_request<CreateProposalAction>(ctx);
    
    // Add all the context data needed for fulfillment
    resource_requests::add_context(&mut request, string::utf8(b"action"), *action);
    resource_requests::add_context(&mut request, string::utf8(b"parent_proposal_id"), parent_proposal_id);
    resource_requests::add_context(&mut request, string::utf8(b"reservation_period"), reservation_period);
    resource_requests::add_context(&mut request, string::utf8(b"max_depth"), max_depth);
    resource_requests::add_context(&mut request, string::utf8(b"account_id"), object::id(account));
    
    let _ = version_witness;
    
    request
}

/// Fulfill the resource request by providing the governance resources
/// This completes the proposal creation with all required resources
public fun fulfill_create_proposal(
    request: ResourceRequest<CreateProposalAction>,
    queue: &mut priority_queue::ProposalQueue<FutarchyConfig>,
    fee_manager: &mut ProposalFeeManager,
    registry: &mut ProposalReservationRegistry,
    fee_coin: Coin<SUI>,
    clock: &Clock,
    ctx: &mut TxContext,
): ResourceReceipt<CreateProposalAction> {
    // Extract context from the request
    let action: CreateProposalAction = resource_requests::get_context(&request, string::utf8(b"action"));
    let parent_proposal_id: ID = resource_requests::get_context(&request, string::utf8(b"parent_proposal_id"));
    let reservation_period: u64 = resource_requests::get_context(&request, string::utf8(b"reservation_period"));
    let max_depth: u64 = resource_requests::get_context(&request, string::utf8(b"max_depth"));
    
    // Check chain depth using registry
    let parent_depth = if (table::contains(&registry.reservations, parent_proposal_id)) {
        table::borrow(&registry.reservations, parent_proposal_id).chain_depth
    } else {
        0
    };
    
    // Enforce the chain depth limit
    assert!(parent_depth < max_depth, EMaxDepthExceeded);
    
    // Verify the fee coin matches the required fee amount
    assert!(coin::value(&fee_coin) >= action.proposal_fee, EInsufficientFee);
    
    // Generate a unique proposal ID for the new proposal
    let proposal_uid = object::new(ctx);
    let proposal_id = object::uid_to_inner(&proposal_uid);
    object::delete(proposal_uid);
    
    // Deposit the fee first (required for potential refunds)
    proposal_fee_manager::deposit_proposal_fee(
        fee_manager,
        proposal_id,
        fee_coin
    );
    
    // Create the proposal with the generated ID
    let new_proposal = create_queued_proposal_with_id(
        &action,
        proposal_id,
        parent_proposal_id,
        reservation_period,
        clock,
        ctx
    );
    
    // Try to insert into queue
    let eviction_info = priority_queue::insert(
        queue,
        new_proposal,
        clock,
        ctx
    );
    
    // Handle eviction - refund fee if a proposal was evicted
    if (option::is_some(&eviction_info)) {
        let eviction = option::borrow(&eviction_info);
        let evicted_proposal_id = priority_queue::eviction_proposal_id(eviction);
        let evicted_proposer = priority_queue::eviction_proposer(eviction);
        
        // Refund the evicted proposal's fee
        let refund_coin = proposal_fee_manager::refund_proposal_fee(
            fee_manager,
            evicted_proposal_id,
            ctx
        );
        transfer::public_transfer(refund_coin, evicted_proposer);
        
        // Create a reservation for the current proposal since it caused an eviction
        create_reservation(
            registry,
            parent_proposal_id,
            action,
            reservation_period,
            clock,
            ctx
        );
    } else if (should_create_reservation(&action)) {
        // Create reservation if needed even without eviction
        create_reservation(
            registry,
            parent_proposal_id,
            action,
            reservation_period,
            clock,
            ctx
        );
    };
    
    // Consume the request and return receipt
    resource_requests::fulfill(request)
}

/// Execute recreation of an evicted second-order proposal
/// Requires full fee payment - no special privileges or priority
public entry fun recreate_evicted_proposal(
    parent_proposal_id: ID,
    registry: &mut ProposalReservationRegistry,
    queue: &mut priority_queue::ProposalQueue<FutarchyConfig>,
    fee_manager: &mut ProposalFeeManager,
    fee_coin: Coin<sui::sui::SUI>, // Must pay full fee for recreation in SUI
    clock: &Clock,
    ctx: &mut TxContext,
) {
    // Get the reservation
    assert!(
        table::contains(&registry.reservations, parent_proposal_id),
        EReservationNotFound
    );
    
    let reservation = table::borrow_mut(&mut registry.reservations, parent_proposal_id);
    
    // Check if reservation is still valid (time window only)
    assert!(
        clock::timestamp_ms(clock) < reservation.recreation_expires_at,
        EReservationExpired
    );
    
    // Verify fee is sufficient (same as any new proposal)
    let fee_amount = coin::value(&fee_coin);
    // Validate that fee meets the original requirement
    // The fee should be at least the original fee that was paid
    assert!(fee_amount >= reservation.original_fee, EInsufficientFee);
    
    // Pay the fee to the fee manager
    let fee_amount = coin::value(&fee_coin);
    proposal_fee_manager::deposit_proposal_fee(fee_manager, parent_proposal_id, fee_coin);
    
    // Create the proposal from reservation data
    // Uses current timestamp and fee for priority calculation - no special treatment
    let new_proposal = create_queued_proposal_from_reservation(
        reservation,
        fee_amount,
        clock,
        ctx
    );
    
    // Try to insert into queue - competes like any other proposal
    let eviction_info = priority_queue::insert(
        queue,
        new_proposal,
        clock,
        ctx
    );
    
    // If a proposal was evicted, refund its fee to prevent orphaned funds
    if (option::is_some(&eviction_info)) {
        let eviction = option::borrow(&eviction_info);
        let evicted_proposal_id = priority_queue::eviction_proposal_id(eviction);
        let evicted_proposer = priority_queue::eviction_proposer(eviction);
        
        // Refund the evicted proposal's fee from the fee manager
        let refund_coin = proposal_fee_manager::refund_proposal_fee(
            fee_manager,
            evicted_proposal_id,
            ctx
        );
        
        // Transfer the refunded fee to the evicted proposer
        transfer::public_transfer(refund_coin, evicted_proposer);
    };
    
    // Update recreation count (just for tracking)
    reservation.recreation_count = reservation.recreation_count + 1;
    
    // Reservation stays valid until expiry - can be recreated unlimited times
    // as long as someone pays the fee each time
}

// === Helper Functions ===

fun create_reservation(
    registry: &mut ProposalReservationRegistry,
    parent_proposal_id: ID,
    action: CreateProposalAction,
    reservation_period: u64,
    clock: &Clock,
    ctx: &TxContext,
) {

    // Check if parent is also a reserved proposal to get chain info
    let (root_id, depth) = if (table::contains(&registry.reservations, parent_proposal_id)) {
        let parent_reservation = table::borrow(&registry.reservations, parent_proposal_id);
        (parent_reservation.root_proposal_id, parent_reservation.chain_depth + 1)
    } else {
        // This is a direct child of a first-order proposal
        (parent_proposal_id, 1)
    };
    
    // Extract child proposals if this proposal contains any
    let child_proposals = extract_child_proposals(&action.proposal_data);
    
    // Calculate the expiration time for the new reservation
    let expires_at = clock::timestamp_ms(clock) + reservation_period;
    
    let reservation = ProposalReservation {
        parent_proposal_id,
        root_proposal_id: root_id,
        chain_depth: depth,
        parent_outcome: 0, // Default to outcome 0 (YES) for now, will be set when parent resolves
        parent_executed: false, // Defaults to false, will be updated when parent executes
        proposal_type: action.proposal_type,
        proposal_data: action.proposal_data,
        initial_asset_amount: action.initial_asset_amount,
        initial_stable_amount: action.initial_stable_amount,
        use_dao_liquidity: action.use_dao_liquidity,
        title: action.title,
        outcome_messages: action.outcome_messages,
        outcome_details: action.outcome_details,
        original_fee: action.proposal_fee,
        original_proposer: tx_context::sender(ctx),
        recreation_expires_at: expires_at,
        recreation_count: 0,
        child_proposals,
    };
    
    // Add the reservation to the main table
    table::add(&mut registry.reservations, parent_proposal_id, reservation);
    
    // --- Add the reservation ID to the correct time bucket ---
    let bucket_duration = registry.bucket_duration_ms;
    assert!(bucket_duration > 0, EInvalidBucketDuration);
    
    // Calculate the timestamp for the bucket this reservation belongs to
    let bucket_timestamp = expires_at - (expires_at % bucket_duration);
    
    if (table::contains(&registry.buckets, bucket_timestamp)) {
        // Bucket already exists, just add the ID
        let bucket = table::borrow_mut(&mut registry.buckets, bucket_timestamp);
        vector::push_back(&mut bucket.reservation_ids, parent_proposal_id);
    } else {
        // Need to create a new bucket
        let prev_timestamp = registry.tail_bucket_timestamp;
        
        let new_bucket = ReservationBucket {
            timestamp_ms: bucket_timestamp,
            reservation_ids: vector[parent_proposal_id],
            prev_bucket_timestamp: prev_timestamp,
            next_bucket_timestamp: option::none(),
        };
        
        // Add the new bucket to the table
        table::add(&mut registry.buckets, bucket_timestamp, new_bucket);
        
        // Update linked list pointers
        if (option::is_some(&prev_timestamp)) {
            // Update the old tail's next pointer
            let old_tail_timestamp = *option::borrow(&prev_timestamp);
            let old_tail = table::borrow_mut(&mut registry.buckets, old_tail_timestamp);
            old_tail.next_bucket_timestamp = option::some(bucket_timestamp);
        } else {
            // This is the first bucket
            registry.head_bucket_timestamp = option::some(bucket_timestamp);
        };
        
        // Update the tail pointer
        registry.tail_bucket_timestamp = option::some(bucket_timestamp);
    }
}

/// Extract any CreateProposalActions from proposal data
fun extract_child_proposals(proposal_data: &vector<u8>): vector<CreateProposalAction> {
    // Child proposals are tracked separately in the ProposalReservation
    // They are not embedded in the raw proposal data bytes
    // Return empty vector as child proposals are managed through reservations
    let _ = proposal_data;
    vector::empty<CreateProposalAction>()
}

fun should_create_reservation(action: &CreateProposalAction): bool {
    // Create reservation if a reservation period override is specified
    // or if the proposal has a high fee (indicating importance)
    option::is_some(&action.reservation_period_ms_override) || 
    action.proposal_fee >= 1000000000 // High-value proposals get reservations
}

fun create_queued_proposal_with_id(
    action: &CreateProposalAction,
    proposal_id: ID,
    parent_proposal_id: ID,
    _reservation_period: u64,
    clock: &Clock,
    ctx: &TxContext,
): priority_queue::QueuedProposal<FutarchyConfig> {
    // Create proposal data from action
    let proposal_data = priority_queue::new_proposal_data(
        action.title,
        action.proposal_type,
        action.outcome_messages,
        action.outcome_details,
        vector[action.initial_asset_amount, action.initial_asset_amount],
        vector[action.initial_stable_amount, action.initial_stable_amount]
    );
    
    // Create the queued proposal with the specific ID
    priority_queue::new_queued_proposal_with_id(
        proposal_id,
        parent_proposal_id, // Using parent as DAO ID for now
        action.proposal_fee,
        action.use_dao_liquidity,
        tx_context::sender(ctx),
        proposal_data,
        option::none(), // No bond for now
        option::none(), // No intent key
        clock
    )
}

fun create_queued_proposal_from_reservation(
    reservation: &ProposalReservation,
    fee_amount: u64,
    clock: &Clock,
    ctx: &TxContext,
): priority_queue::QueuedProposal<FutarchyConfig> {
    // Create proposal data from reservation
    let proposal_data = priority_queue::new_proposal_data(
        reservation.title,
        reservation.proposal_type,
        reservation.outcome_messages,
        reservation.outcome_details,
        vector[reservation.initial_asset_amount, reservation.initial_asset_amount],
        vector[reservation.initial_stable_amount, reservation.initial_stable_amount]
    );
    
    // Create the queued proposal with new fee
    priority_queue::new_queued_proposal(
        reservation.parent_proposal_id,
        fee_amount,
        reservation.use_dao_liquidity,
        tx_context::sender(ctx), // Current recreator becomes proposer
        proposal_data,
        option::none(), // No bond
        option::none(), // No intent key
        clock
    )
}

// === Public Registry Functions ===

/// Initialize the registry (should be called once during deployment)
public fun init_registry(ctx: &mut TxContext): ProposalReservationRegistry {
    ProposalReservationRegistry {
        id: object::new(ctx),
        reservations: table::new(ctx),
        buckets: table::new(ctx),
        head_bucket_timestamp: option::none(),
        tail_bucket_timestamp: option::none(),
        // Default to 1 day buckets. Can be made configurable per-DAO.
        bucket_duration_ms: 86_400_000,
    }
}

/// Share the registry for global access
public fun share_registry(registry: ProposalReservationRegistry) {
    transfer::share_object(registry);
}

/// Check if a reservation exists and is valid
public fun has_valid_reservation(
    registry: &ProposalReservationRegistry,
    parent_proposal_id: ID,
    clock: &Clock,
): bool {
    if (!table::contains(&registry.reservations, parent_proposal_id)) {
        return false
    };
    
    let reservation = table::borrow(&registry.reservations, parent_proposal_id);
    // Only time window matters - no recreation limit
    clock::timestamp_ms(clock) < reservation.recreation_expires_at
}

/// Get reservation details (for viewing)
public fun get_reservation(
    registry: &ProposalReservationRegistry,
    parent_proposal_id: ID,
): &ProposalReservation {
    table::borrow(&registry.reservations, parent_proposal_id)
}

/// Recreate an entire proposal chain starting from a specific proposal
/// This handles nth-order proposals by recreating the whole subtree
public entry fun recreate_proposal_chain(
    parent_proposal_id: ID,
    registry: &mut ProposalReservationRegistry,
    queue: &mut priority_queue::ProposalQueue<FutarchyConfig>,
    fee_manager: &mut ProposalFeeManager,
    mut fee_coins: vector<Coin<sui::sui::SUI>>, // Fees for each proposal in the chain
    clock: &Clock,
    ctx: &mut TxContext,
) {
    // Get the reservation
    assert!(
        table::contains(&registry.reservations, parent_proposal_id),
        EReservationNotFound
    );
    
    // First check the chain size
    let chain_size = {
        let reservation = table::borrow(&registry.reservations, parent_proposal_id);
        1 + vector::length(&reservation.child_proposals)
    };
    
    assert!(
        vector::length(&fee_coins) == chain_size,
        EInsufficientFee
    );
    
    // Recreate this proposal first
    let fee_coin = vector::pop_back(&mut fee_coins);
    recreate_evicted_proposal(
        parent_proposal_id,
        registry,
        queue,
        fee_manager,
        fee_coin,
        clock,
        ctx
    );
    
    // Then recreate all child proposals
    let child_proposals_count = {
        let reservation = table::borrow(&registry.reservations, parent_proposal_id);
        vector::length(&reservation.child_proposals)
    };
    
    let mut i = 0;
    while (i < child_proposals_count) {
        // Get child action (need to borrow inside loop to avoid lifetime issues)
        let child_action = {
            let reservation = table::borrow(&registry.reservations, parent_proposal_id);
            *vector::borrow(&reservation.child_proposals, i)
        };
        let child_fee = vector::pop_back(&mut fee_coins);
        
        // Create child proposal with a new ID
        let child_id = object::new(ctx);
        let child_proposal_id = object::uid_to_inner(&child_id);
        object::delete(child_id);
        
        // Create the child proposal with the specific ID
        let child_proposal = create_queued_proposal_with_id(
            &child_action,
            child_proposal_id,
            parent_proposal_id, // Use parent as the dao_id
            0, // No additional reservation period for children in batch
            clock,
            ctx
        );
        
        // Deposit the fee for the child proposal
        proposal_fee_manager::deposit_proposal_fee(
            fee_manager,
            child_proposal_id,
            child_fee
        );
        
        // Insert child proposal into queue
        let eviction_info = priority_queue::insert(
            queue,
            child_proposal,
            clock,
            ctx
        );
        
        // If a proposal was evicted, refund its fee to prevent orphaned funds
        if (option::is_some(&eviction_info)) {
            let eviction = option::borrow(&eviction_info);
            let evicted_proposal_id = priority_queue::eviction_proposal_id(eviction);
            let evicted_proposer = priority_queue::eviction_proposer(eviction);
            
            // Refund the evicted proposal's fee from the fee manager
            let refund_coin = proposal_fee_manager::refund_proposal_fee(
                fee_manager,
                evicted_proposal_id,
                ctx
            );
            
            // Transfer the refunded fee to the evicted proposer
            transfer::public_transfer(refund_coin, evicted_proposer);
        };
        
        i = i + 1;
    };
    
    vector::destroy_empty(fee_coins);
}

/// Get all proposals in a chain (for viewing/planning recreation)
public fun get_proposal_chain(
    registry: &ProposalReservationRegistry,
    root_proposal_id: ID,
): vector<ID> {
    // Returns the root proposal ID
    // Full chain tracking is handled via events for off-chain indexing
    let _ = registry;
    let mut chain = vector::empty<ID>();
    vector::push_back(&mut chain, root_proposal_id);
    chain
}

/// Prune the oldest expired bucket from the registry.
/// This function is O(1) if there are no expired reservations, and O(k) where k is the number
/// of reservations in a single bucket to prune.
/// Called from proposal_lifecycle during finalization to clean up old reservations.
public fun prune_oldest_expired_bucket(
    registry: &mut ProposalReservationRegistry,
    config: &futarchy_config::FutarchyConfig,
    clock: &Clock,
    _ctx: &TxContext,
) {
    // Check if we have any buckets to prune
    if (option::is_none(&registry.head_bucket_timestamp)) {
        return // No buckets at all
    };
    
    let head_timestamp = *option::borrow(&registry.head_bucket_timestamp);
    let current_time = clock::timestamp_ms(clock);
    
    // Add a safety buffer based on DAO configuration
    let safety_buffer = futarchy_config::proposal_recreation_window_ms(config);
    let prune_before = if (current_time > safety_buffer) {
        current_time - safety_buffer
    } else {
        0
    };
    
    // Check if the oldest bucket has expired
    if (head_timestamp >= prune_before) {
        return // Oldest bucket hasn't expired yet
    };
    
    // Remove the head bucket
    let bucket = table::remove(&mut registry.buckets, head_timestamp);
    
    // Update the head pointer
    registry.head_bucket_timestamp = bucket.next_bucket_timestamp;
    
    // If there's a new head, update its prev pointer to none
    if (option::is_some(&bucket.next_bucket_timestamp)) {
        let next_timestamp = *option::borrow(&bucket.next_bucket_timestamp);
        let next_bucket = table::borrow_mut(&mut registry.buckets, next_timestamp);
        next_bucket.prev_bucket_timestamp = option::none();
    } else {
        // This was the last bucket, so tail should also be none
        registry.tail_bucket_timestamp = option::none();
    };
    
    // Clean up the expired reservations
    let mut i = 0;
    while (i < vector::length(&bucket.reservation_ids)) {
        let reservation_id = *vector::borrow(&bucket.reservation_ids, i);
        if (table::contains(&registry.reservations, reservation_id)) {
            // Remove and properly destroy the reservation
            let reservation = table::remove(&mut registry.reservations, reservation_id);
            
            // Destructure the reservation to avoid "value has drop ability" error
            let ProposalReservation { 
                parent_proposal_id: _,
                root_proposal_id: _,
                chain_depth: _,
                parent_outcome: _,
                parent_executed: _,
                proposal_type: _,
                proposal_data: _,
                initial_asset_amount: _,
                initial_stable_amount: _,
                use_dao_liquidity: _,
                title: _,
                outcome_messages: _,
                outcome_details: _,
                original_fee: _,
                original_proposer: _,
                recreation_expires_at: _,
                recreation_count: _,
                child_proposals: _,
            } = reservation;
        };
        i = i + 1;
    };
    
    // Destructure the bucket to avoid "value has drop ability" error
    let ReservationBucket {
        timestamp_ms: _,
        reservation_ids: _,
        prev_bucket_timestamp: _,
        next_bucket_timestamp: _,
    } = bucket;
}/// Protocol admin actions for managing the futarchy protocol through its own DAO (dogfooding).
/// This module allows the protocol's owner DAO and its security council to control:
/// - Factory admin functions (FactoryOwnerCap)
/// - Fee management (FeeAdminCap) 
/// - Validator functions (ValidatorAdminCap)
module futarchy::protocol_admin_actions;

// === Imports ===
use std::{
    string::{String as UTF8String, String},
    type_name::{Self, TypeName},
};
use sui::{
    clock::Clock,
    coin::{Self, Coin},
    sui::SUI,
    vec_set::VecSet,
};
use account_protocol::{
    account::{Self, Account},
    executable::{Self, Executable},
    version_witness::VersionWitness,
};
use futarchy::{
    factory::{Self, Factory, FactoryOwnerCap},
    fee::{Self, FeeManager, FeeAdminCap},
    factory::{ValidatorAdminCap},
    futarchy_config::FutarchyConfig,
    version,
};

// === Errors ===
const EInvalidAdminCap: u64 = 1;
const ECapNotFound: u64 = 2;
const EInvalidFeeAmount: u64 = 3;

// === Action Structs ===

// Factory Admin Actions

/// Pause or unpause the factory
public struct SetFactoryPausedAction has store {
    paused: bool,
}

/// Add a stable coin type to the factory whitelist
public struct AddStableTypeAction has store {
    stable_type: TypeName,
}

/// Remove a stable coin type from the factory whitelist
public struct RemoveStableTypeAction has store {
    stable_type: TypeName,
}

// Fee Admin Actions

/// Update the DAO creation fee
public struct UpdateDaoCreationFeeAction has store {
    new_fee: u64,
}

/// Update the proposal creation fee per outcome
public struct UpdateProposalFeeAction has store {
    new_fee_per_outcome: u64,
}

/// Update the monthly DAO fee
public struct UpdateMonthlyDaoFeeAction has store {
    new_fee: u64,
}

/// Update verification fee for a specific level
public struct UpdateVerificationFeeAction has store {
    level: u8,
    new_fee: u64,
}

/// Add a new verification level with fee
public struct AddVerificationLevelAction has store {
    level: u8,
    fee: u64,
}

/// Remove a verification level
public struct RemoveVerificationLevelAction has store {
    level: u8,
}

/// Update the recovery fee
public struct UpdateRecoveryFeeAction has store {
    new_fee: u64,
}

/// Withdraw accumulated fees to treasury
public struct WithdrawFeesToTreasuryAction has store {
    amount: u64,
}

/// Apply discount to a DAO's monthly fees
public struct ApplyDaoFeeDiscountAction has store {
    dao_id: ID,
    discount_amount: u64,
}


// === Public Functions ===

// Factory Actions

public fun new_set_factory_paused(paused: bool): SetFactoryPausedAction {
    SetFactoryPausedAction { paused }
}

public fun new_add_stable_type(stable_type: TypeName): AddStableTypeAction {
    AddStableTypeAction { stable_type }
}

public fun new_remove_stable_type(stable_type: TypeName): RemoveStableTypeAction {
    RemoveStableTypeAction { stable_type }
}

// Fee Actions

public fun new_update_dao_creation_fee(new_fee: u64): UpdateDaoCreationFeeAction {
    UpdateDaoCreationFeeAction { new_fee }
}

public fun new_update_proposal_fee(new_fee_per_outcome: u64): UpdateProposalFeeAction {
    UpdateProposalFeeAction { new_fee_per_outcome }
}

public fun new_update_monthly_dao_fee(new_fee: u64): UpdateMonthlyDaoFeeAction {
    UpdateMonthlyDaoFeeAction { new_fee }
}

public fun new_update_verification_fee(level: u8, new_fee: u64): UpdateVerificationFeeAction {
    UpdateVerificationFeeAction { level, new_fee }
}

public fun new_add_verification_level(level: u8, fee: u64): AddVerificationLevelAction {
    AddVerificationLevelAction { level, fee }
}

public fun new_remove_verification_level(level: u8): RemoveVerificationLevelAction {
    RemoveVerificationLevelAction { level }
}

public fun new_update_recovery_fee(new_fee: u64): UpdateRecoveryFeeAction {
    UpdateRecoveryFeeAction { new_fee }
}

public fun new_apply_dao_fee_discount(dao_id: ID, discount_amount: u64): ApplyDaoFeeDiscountAction {
    ApplyDaoFeeDiscountAction { dao_id, discount_amount }
}

public fun new_withdraw_fees_to_treasury(amount: u64): WithdrawFeesToTreasuryAction {
    WithdrawFeesToTreasuryAction { amount }
}


// === Execution Functions ===

/// Execute factory pause/unpause action
public fun do_set_factory_paused<Outcome: store, IW: drop>(
    executable: &mut Executable<Outcome>,
    account: &mut Account<FutarchyConfig>,
    version: VersionWitness,
    witness: IW,
    factory: &mut Factory,
    ctx: &mut TxContext,
) {
    let action = executable::next_action<Outcome, SetFactoryPausedAction, IW>(executable, witness);
    let _ = ctx;
    
    let cap = account::borrow_managed_asset<FutarchyConfig, String, FactoryOwnerCap>(
        account,
        b"protocol:factory_owner_cap".to_string(),
        version
    );
    
    // Toggle pause state if action says to pause and factory is unpaused, or vice versa
    if ((action.paused && !factory::is_paused(factory)) || 
        (!action.paused && factory::is_paused(factory))) {
        factory::toggle_pause(factory, cap);
    }
}

/// Execute add stable type action
public fun do_add_stable_type<Outcome: store, IW: drop, StableType>(
    executable: &mut Executable<Outcome>,
    account: &mut Account<FutarchyConfig>,
    version: VersionWitness,
    witness: IW,
    factory: &mut Factory,
    clock: &Clock,
    ctx: &mut TxContext,
) {
    let action = executable::next_action<Outcome, AddStableTypeAction, IW>(executable, witness);
    let _ = action; // Just consume it
    
    let cap = account::borrow_managed_asset<FutarchyConfig, String, FactoryOwnerCap>(
        account,
        b"protocol:factory_owner_cap".to_string(),
        version
    );
    
    factory::add_allowed_stable_type<StableType>(factory, cap, clock, ctx);
}

/// Execute remove stable type action
public fun do_remove_stable_type<Outcome: store, IW: drop, StableType>(
    executable: &mut Executable<Outcome>,
    account: &mut Account<FutarchyConfig>,
    version: VersionWitness,
    witness: IW,
    factory: &mut Factory,
    clock: &Clock,
    ctx: &mut TxContext,
) {
    let action = executable::next_action<Outcome, RemoveStableTypeAction, IW>(executable, witness);
    let _ = action; // Just consume it
    
    let cap = account::borrow_managed_asset<FutarchyConfig, String, FactoryOwnerCap>(
        account,
        b"protocol:factory_owner_cap".to_string(),
        version
    );
    
    factory::remove_allowed_stable_type<StableType>(factory, cap, clock, ctx);
}

/// Execute update DAO creation fee action
public fun do_update_dao_creation_fee<Outcome: store, IW: drop>(
    executable: &mut Executable<Outcome>,
    account: &mut Account<FutarchyConfig>,
    version: VersionWitness,
    witness: IW,
    fee_manager: &mut FeeManager,
    clock: &Clock,
    ctx: &mut TxContext,
) {
    let action = executable::next_action<Outcome, UpdateDaoCreationFeeAction, IW>(executable, witness);
    
    let cap = account::borrow_managed_asset<FutarchyConfig, String, FeeAdminCap>(
        account,
        b"protocol:fee_admin_cap".to_string(),
        version
    );
    
    fee::update_dao_creation_fee(fee_manager, cap, action.new_fee, clock, ctx);
}

/// Execute update proposal fee action
public fun do_update_proposal_fee<Outcome: store, IW: drop>(
    executable: &mut Executable<Outcome>,
    account: &mut Account<FutarchyConfig>,
    version: VersionWitness,
    witness: IW,
    fee_manager: &mut FeeManager,
    clock: &Clock,
    ctx: &mut TxContext,
) {
    let action = executable::next_action<Outcome, UpdateProposalFeeAction, IW>(executable, witness);
    
    let cap = account::borrow_managed_asset<FutarchyConfig, String, FeeAdminCap>(
        account,
        b"protocol:fee_admin_cap".to_string(),
        version
    );
    
    fee::update_proposal_creation_fee(
        fee_manager,
        cap,
        action.new_fee_per_outcome,
        clock,
        ctx
    );
}

/// Execute update monthly DAO fee action
public fun do_update_monthly_dao_fee<Outcome: store, IW: drop>(
    executable: &mut Executable<Outcome>,
    account: &mut Account<FutarchyConfig>,
    version: VersionWitness,
    witness: IW,
    fee_manager: &mut FeeManager,
    clock: &Clock,
    ctx: &mut TxContext,
) {
    let action = executable::next_action<Outcome, UpdateMonthlyDaoFeeAction, IW>(executable, witness);
    
    let cap = account::borrow_managed_asset<FutarchyConfig, String, FeeAdminCap>(
        account,
        b"protocol:fee_admin_cap".to_string(),
        version
    );
    
    // Update the monthly fee (it will have a built-in delay)
    fee::update_dao_monthly_fee(
        fee_manager,
        cap,
        action.new_fee,
        clock,
        ctx
    );
}

/// Execute update verification fee action
public fun do_update_verification_fee<Outcome: store, IW: drop>(
    executable: &mut Executable<Outcome>,
    account: &mut Account<FutarchyConfig>,
    version: VersionWitness,
    witness: IW,
    fee_manager: &mut FeeManager,
    clock: &Clock,
    ctx: &mut TxContext,
) {
    let action = executable::next_action<Outcome, UpdateVerificationFeeAction, IW>(executable, witness);
    
    let cap = account::borrow_managed_asset<FutarchyConfig, String, FeeAdminCap>(
        account,
        b"protocol:fee_admin_cap".to_string(),
        version
    );
    
    fee::update_verification_fee(
        fee_manager,
        cap,
        action.level,
        action.new_fee,
        clock,
        ctx
    );
}

/// Execute add verification level action
public fun do_add_verification_level<Outcome: store, IW: drop>(
    executable: &mut Executable<Outcome>,
    account: &mut Account<FutarchyConfig>,
    version: VersionWitness,
    witness: IW,
    fee_manager: &mut FeeManager,
    clock: &Clock,
    ctx: &mut TxContext,
) {
    let action = executable::next_action<Outcome, AddVerificationLevelAction, IW>(executable, witness);
    
    let cap = account::borrow_managed_asset<FutarchyConfig, String, FeeAdminCap>(
        account,
        b"protocol:fee_admin_cap".to_string(),
        version
    );
    
    fee::add_verification_level(fee_manager, cap, action.level, action.fee, clock, ctx);
}

/// Execute remove verification level action
public fun do_remove_verification_level<Outcome: store, IW: drop>(
    executable: &mut Executable<Outcome>,
    account: &mut Account<FutarchyConfig>,
    version: VersionWitness,
    witness: IW,
    fee_manager: &mut FeeManager,
    clock: &Clock,
    ctx: &mut TxContext,
) {
    let action = executable::next_action<Outcome, RemoveVerificationLevelAction, IW>(executable, witness);
    
    let cap = account::borrow_managed_asset<FutarchyConfig, String, FeeAdminCap>(
        account,
        b"protocol:fee_admin_cap".to_string(),
        version
    );
    
    fee::remove_verification_level(fee_manager, cap, action.level, clock, ctx);
}

/// Execute update recovery fee action
public fun do_update_recovery_fee<Outcome: store, IW: drop>(
    executable: &mut Executable<Outcome>,
    account: &mut Account<FutarchyConfig>,
    version: VersionWitness,
    witness: IW,
    fee_manager: &mut FeeManager,
    clock: &Clock,
    ctx: &mut TxContext,
) {
    let action = executable::next_action<Outcome, UpdateRecoveryFeeAction, IW>(executable, witness);
    
    let cap = account::borrow_managed_asset<FutarchyConfig, String, FeeAdminCap>(
        account,
        b"protocol:fee_admin_cap".to_string(),
        version
    );
    
    fee::update_recovery_fee(fee_manager, cap, action.new_fee, clock, ctx);
}

/// Execute apply DAO fee discount action
public fun do_apply_dao_fee_discount<Outcome: store, IW: drop>(
    executable: &mut Executable<Outcome>,
    account: &mut Account<FutarchyConfig>,
    version: VersionWitness,
    witness: IW,
    fee_manager: &mut FeeManager,
    clock: &Clock,
    ctx: &mut TxContext,
) {
    let action = executable::next_action<Outcome, ApplyDaoFeeDiscountAction, IW>(executable, witness);
    
    let cap = account::borrow_managed_asset<FutarchyConfig, String, FeeAdminCap>(
        account,
        b"protocol:fee_admin_cap".to_string(),
        version
    );
    
    // Note: There's no direct apply_dao_fee_discount function.
    // Discounts are applied at collection time via collect_dao_platform_fee_with_discount
    // This action would need to store the discount for later use, which isn't implemented
    let _ = fee_manager;
    let _ = cap;
    let _ = action;
    let _ = clock;
    let _ = ctx;
}

/// Execute withdraw fees to treasury action
public fun do_withdraw_fees_to_treasury<Outcome: store, IW: drop>(
    executable: &mut Executable<Outcome>,
    account: &mut Account<FutarchyConfig>,
    version: VersionWitness,
    witness: IW,
    fee_manager: &mut FeeManager,
    clock: &Clock,
    ctx: &mut TxContext,
) {
    let action = executable::next_action<Outcome, WithdrawFeesToTreasuryAction, IW>(executable, witness);
    let _ = action; // Just consume it
    
    let cap = account::borrow_managed_asset<FutarchyConfig, String, FeeAdminCap>(
        account,
        b"protocol:fee_admin_cap".to_string(),
        version
    );
    
    // Withdraw all fees from the fee manager
    fee::withdraw_all_fees(fee_manager, cap, clock, ctx);
    // Note: The withdraw_all_fees function transfers directly to sender
    // In a proper implementation, we would need a function that returns the coin
    // for deposit into the DAO treasury
}


// === Helper Functions for Security Council ===

// This function is commented out because it has incorrect assumptions about
// how account::borrow_managed_asset works. The FactoryOwnerCap would need to be
// stored in the account first, but it's actually a separate object.
// /// Allow security council to execute factory operations 
// public fun council_set_factory_paused<Outcome: store>(
//     council: &mut Account<FutarchyConfig>,
//     executable: &mut Executable<Outcome>,
//     factory: &mut Factory,
//     paused: bool,
//     version: VersionWitness,
//     ctx: &mut TxContext,
// ) {
//     // Security council must have been granted access to the cap
//     let cap = account::borrow_managed_asset<FactoryOwnerCap>(
//         council,
//         b"protocol:factory_owner_cap".to_string(),
//         version
//     );
//     
//     // Toggle pause state if needed
//     let current_paused = factory::is_paused(factory);
//     if (current_paused != paused) {
//         factory::toggle_pause(factory, cap);
//     };
// }

// This function is commented out because it has incorrect assumptions about
// how account::borrow_managed_asset works. The FeeAdminCap would need to be
// stored in the account first, but it's actually a separate object.
// /// Allow security council to execute fee operations
// public fun council_withdraw_emergency_fees<Outcome: store>(
//     council: &mut Account<FutarchyConfig>,
//     executable: &mut Executable<Outcome>,
//     fee_manager: &mut FeeManager,
//     amount: u64,
//     version: VersionWitness,
//     clock: &Clock,
//     ctx: &mut TxContext,
// ) {
//     let cap = account::borrow_managed_asset<FeeAdminCap>(
//         council,
//         b"protocol:fee_admin_cap".to_string(),
//         version
//     );
//     
//     // Withdraw all fees (there's no partial withdraw function)
//     // Note: This withdraws ALL fees, not just the specified amount
//     fee::withdraw_all_fees(fee_manager, cap, clock, ctx);
//     // The fees are sent to tx sender, not to the council account
//     // This is a limitation of the current fee module
//     let _ = amount;
//     let _ = council;
//     let _ = version;
// }/// Common witness types for intents
/// This module provides reusable witness types for various intent operations
module futarchy::intent_witnesses;

// === Witness Types ===

/// Witness for governance-related intents
public struct GovernanceWitness has copy, drop {}

/// Witness for treasury operations
public struct TreasuryWitness has copy, drop {}

/// Witness for config changes
public struct ConfigWitness has copy, drop {}

/// Witness for liquidity operations
public struct LiquidityWitness has copy, drop {}

/// Witness for dissolution operations
public struct DissolutionWitness has copy, drop {}

/// Generic witness for proposals
public struct ProposalWitness has copy, drop {}

// === Constructor Functions ===

/// Create a governance witness
public fun governance(): GovernanceWitness {
    GovernanceWitness {}
}

/// Create a treasury witness
public fun treasury(): TreasuryWitness {
    TreasuryWitness {}
}

/// Create a config witness
public fun config(): ConfigWitness {
    ConfigWitness {}
}

/// Create a liquidity witness
public fun liquidity(): LiquidityWitness {
    LiquidityWitness {}
}

/// Create a dissolution witness
public fun dissolution(): DissolutionWitness {
    DissolutionWitness {}
}

/// Create a proposal witness
public fun proposal(): ProposalWitness {
    ProposalWitness {}
}/// Dispatcher for governance actions
module futarchy::governance_dispatcher;

// === Imports ===
use sui::{
    clock::Clock,
    tx_context::TxContext,
};
use account_protocol::{
    account::Account,
    executable::Executable,
};
use futarchy::{
    futarchy_config::FutarchyConfig,
};

// === Public(friend) Functions ===

/// Try to execute governance actions
/// These actions require special resources (queue, fee_manager, etc.)
/// and should be handled via specialized entry functions
public(package) fun try_execute_governance_actions<IW: drop, Outcome: store + drop + copy>(
    _executable: &mut Executable<Outcome>,
    _account: &mut Account<FutarchyConfig>,
    _witness: IW,
    _clock: &Clock,
    _ctx: &mut TxContext,
): bool {
    // Governance actions require special resources (queue, fee_manager, etc.)
    // These should be handled via specialized entry functions
    // For now, return false to indicate not handled
    false
}/// Commitment Proposal Module
/// Allows founders/whales to propose burning or locking their tokens to reduce centralization risk.
/// Markets decide if this decentralization would increase the DAO's value.
module futarchy::commitment_proposal;

use std::string::{Self, String};
use std::vector;
use std::option::{Self, Option};
use sui::balance::{Self, Balance};
use sui::coin::{Self, Coin};
use sui::clock::{Self, Clock};
use sui::transfer;
use sui::tx_context::{Self, TxContext};
use sui::object::{Self, ID, UID};
use sui::event;
use account_protocol::{
    intents::{Expired},
    executable::{Self, Executable},
    account::{Self, Account},
    version_witness::VersionWitness,
};
use futarchy::{
    futarchy_config::FutarchyConfig,
    proposal::{Self, Proposal},
    version,
    spot_amm::{Self, SpotAMM},
    spot_conditional_quoter,
    conditional_amm,
};

// === Errors ===
const EInvalidTiers: u64 = 0;
const ETiersNotSorted: u64 = 1;
const ETierAmountsExceedDeposit: u64 = 2;
const EProposalNotPassed: u64 = 3;
const EProposalNotExecuted: u64 = 4;
const ENotProposer: u64 = 5;
const ENotRecipient: u64 = 6;
const EStillLocked: u64 = 7;
const ENotLocked: u64 = 8;
const EAlreadyExecuted: u64 = 9;
const EInsufficientDeposit: u64 = 10;
const ETwapNotReady: u64 = 11;
const ENoTiersProvided: u64 = 12;
const EInvalidProposalId: u64 = 13;
const EInvalidLockDuration: u64 = 14;
const EAlreadyWithdrawn: u64 = 15;

// === Constants ===
const MAX_TIERS: u64 = 10;
const MIN_LOCK_DURATION_MS: u64 = 86_400_000; // 1 day
const MAX_LOCK_DURATION_MS: u64 = 63_072_000_000; // 2 years
const TWAP_MEASUREMENT_PERIOD_MS: u64 = 604_800_000; // 7 days
const MIN_COMMITMENT_AMOUNT: u64 = 1_000_000_000; // 1 token (assuming 9 decimals)

// === Events ===

/// Emitted when a commitment proposal is created
public struct CommitmentProposalCreated has copy, drop {
    proposal_id: ID,
    proposer: address,
    committed_amount: u64,
    tier_count: u64,
}

/// Emitted when commitment is executed
public struct CommitmentExecuted has copy, drop {
    proposal_id: ID,
    tier_reached: u64,
    twap_price: u128,
    locked_amount: u64,
    unlock_time: u64,
}

/// Emitted when locked tokens are withdrawn
public struct CommitmentWithdrawn has copy, drop {
    proposal_id: ID,
    recipient: address,
    amount: u64,
}

/// Emitted when withdrawal recipient is updated
public struct RecipientUpdated has copy, drop {
    proposal_id: ID,
    old_recipient: address,
    new_recipient: address,
}

/// Emitted when tokens are returned (proposal rejected)
public struct CommitmentReturned has copy, drop {
    proposal_id: ID,
    proposer: address,
    amount: u64,
}

// === Structs ===

/// A price tier defining lock conditions
public struct PriceTier has store, copy, drop {
    /// TWAP price threshold to trigger this tier (scaled by 1e12)
    twap_threshold: u128,
    /// Amount to lock at this price
    lock_amount: u64,
    /// How long to lock tokens (milliseconds)
    lock_duration_ms: u64,
}

/// Commitment proposal for token locking/burning
public struct CommitmentProposal<phantom AssetType, phantom StableType> has key, store {
    id: UID,
    
    // Proposer info
    proposer: address,
    withdrawal_recipient: address,
    
    // Commitment details
    committed_amount: u64,
    committed_coins: Balance<AssetType>,
    
    // Price-based lock tiers (ordered by price)
    tiers: vector<PriceTier>,
    
    // Execution results
    locked_amount: u64,
    unlock_time: Option<u64>,
    tier_reached: Option<u64>,
    
    // Proposal state
    proposal_id: ID, // ID of the associated Proposal object
    executed: bool,
    withdrawn: bool,
    
    // Timestamps
    created_at: u64,
    trading_start: u64,
    trading_end: u64,
    
    // Metadata
    description: String,
}

// === Constructor Functions ===

/// Create a new commitment proposal
public fun create_commitment_proposal<AssetType, StableType>(
    proposer: address,
    committed_coins: Coin<AssetType>,
    tiers: vector<PriceTier>,
    proposal_id: ID,
    trading_start: u64,
    trading_end: u64,
    description: String,
    clock: &Clock,
    ctx: &mut TxContext,
): CommitmentProposal<AssetType, StableType> {
    let committed_amount = coin::value(&committed_coins);
    assert!(committed_amount >= MIN_COMMITMENT_AMOUNT, EInsufficientDeposit);
    assert!(vector::length(&tiers) > 0, ENoTiersProvided);
    assert!(vector::length(&tiers) <= MAX_TIERS, EInvalidTiers);
    
    // Validate tiers are sorted by price and amounts don't exceed deposit
    validate_tiers(&tiers, committed_amount);
    
    let id = object::new(ctx);
    let created_at = clock::timestamp_ms(clock);
    
    event::emit(CommitmentProposalCreated {
        proposal_id: object::uid_to_inner(&id),
        proposer,
        committed_amount,
        tier_count: vector::length(&tiers),
    });
    
    CommitmentProposal {
        id,
        proposer,
        withdrawal_recipient: proposer,
        committed_amount,
        committed_coins: coin::into_balance(committed_coins),
        tiers,
        locked_amount: 0,
        unlock_time: option::none(),
        tier_reached: option::none(),
        proposal_id,
        executed: false,
        withdrawn: false,
        created_at,
        trading_start,
        trading_end,
        description,
    }
}

// === Validation Functions ===

fun validate_tiers(tiers: &vector<PriceTier>, max_amount: u64) {
    let len = vector::length(tiers);
    let mut i = 0;
    let mut prev_threshold = 0u128;
    
    while (i < len) {
        let tier = vector::borrow(tiers, i);
        
        // Check tiers are sorted by price
        assert!(tier.twap_threshold > prev_threshold, ETiersNotSorted);
        prev_threshold = tier.twap_threshold;
        
        // Check lock amount doesn't exceed deposit
        assert!(tier.lock_amount <= max_amount, ETierAmountsExceedDeposit);
        
        // Check lock duration is valid
        assert!(tier.lock_duration_ms >= MIN_LOCK_DURATION_MS, EInvalidLockDuration);
        assert!(tier.lock_duration_ms <= MAX_LOCK_DURATION_MS, EInvalidLockDuration);
        
        i = i + 1;
    }
}

// === Execution Functions ===

/// Execute commitment after proposal passes
public fun execute_commitment<AssetType, StableType>(
    commitment: &mut CommitmentProposal<AssetType, StableType>,
    proposal: &Proposal<AssetType, StableType>,
    clock: &Clock,
    ctx: &mut TxContext,
) {
    // Validate commitment state
    assert!(!commitment.executed, EAlreadyExecuted);
    assert!(clock::timestamp_ms(clock) >= commitment.trading_end, EProposalNotExecuted);
    
    // Validate proposal state - must be finalized with a winning outcome
    assert!(proposal::is_finalized(proposal), EProposalNotExecuted);
    assert!(proposal::is_winning_outcome_set(proposal), EProposalNotExecuted);
    
    // Validate proposal matches commitment
    assert!(object::id(proposal) == commitment.proposal_id, EInvalidProposalId);
    
    // Get TWAP from the winning outcome
    let outcome_idx = proposal::get_winning_outcome(proposal);
    
    // Get stored TWAP prices (indexed by outcome)
    let twap_prices = proposal::get_twap_prices(proposal);
    assert!(vector::length(twap_prices) > outcome_idx, ETwapNotReady);
    
    // Get the TWAP for the winning outcome
    let current_twap = *vector::borrow(twap_prices, outcome_idx);
    
    // Find highest tier where TWAP >= threshold
    let tier_index = find_highest_tier(&commitment.tiers, current_twap);
    
    if (option::is_some(&tier_index)) {
        // Lock tokens based on tier
        let index = *option::borrow(&tier_index);
        let tier = vector::borrow(&commitment.tiers, index);
        
        commitment.locked_amount = tier.lock_amount;
        commitment.unlock_time = option::some(
            clock::timestamp_ms(clock) + tier.lock_duration_ms
        );
        commitment.tier_reached = option::some(index);
        
        // Return excess tokens if any
        let excess_amount = commitment.committed_amount - tier.lock_amount;
        if (excess_amount > 0) {
            let excess_coins = coin::from_balance(
                balance::split(&mut commitment.committed_coins, excess_amount),
                ctx
            );
            transfer::public_transfer(excess_coins, commitment.proposer);
        };
        
        event::emit(CommitmentExecuted {
            proposal_id: object::uid_to_inner(&commitment.id),
            tier_reached: index,
            twap_price: current_twap,
            locked_amount: tier.lock_amount,
            unlock_time: *option::borrow(&commitment.unlock_time),
        });
    } else {
        // No tier reached, return all tokens
        let all_coins = coin::from_balance(
            balance::withdraw_all(&mut commitment.committed_coins),
            ctx
        );
        transfer::public_transfer(all_coins, commitment.proposer);
        
        event::emit(CommitmentReturned {
            proposal_id: object::uid_to_inner(&commitment.id),
            proposer: commitment.proposer,
            amount: commitment.committed_amount,
        });
    };
    
    commitment.executed = true;
}

/// Find the highest tier where TWAP meets threshold
fun find_highest_tier(tiers: &vector<PriceTier>, twap: u128): Option<u64> {
    let len = vector::length(tiers);
    let mut highest_index = option::none<u64>();
    let mut i = 0;
    
    while (i < len) {
        let tier = vector::borrow(tiers, i);
        if (twap >= tier.twap_threshold) {
            highest_index = option::some(i);
        };
        i = i + 1;
    };
    
    highest_index
}

// === Withdrawal Functions ===

/// Withdraw unlocked tokens
public entry fun withdraw_unlocked_tokens<AssetType, StableType>(
    commitment: &mut CommitmentProposal<AssetType, StableType>,
    clock: &Clock,
    ctx: &mut TxContext,
) {
    assert!(commitment.executed, EProposalNotExecuted);
    assert!(!commitment.withdrawn, EAlreadyWithdrawn);
    assert!(option::is_some(&commitment.unlock_time), ENotLocked);
    
    let unlock_time = *option::borrow(&commitment.unlock_time);
    assert!(clock::timestamp_ms(clock) >= unlock_time, EStillLocked);
    
    let sender = tx_context::sender(ctx);
    assert!(sender == commitment.withdrawal_recipient, ENotRecipient);
    
    let withdrawal_coins = coin::from_balance(
        balance::withdraw_all(&mut commitment.committed_coins),
        ctx
    );
    
    transfer::public_transfer(withdrawal_coins, commitment.withdrawal_recipient);
    
    commitment.withdrawn = true;
    
    event::emit(CommitmentWithdrawn {
        proposal_id: object::uid_to_inner(&commitment.id),
        recipient: commitment.withdrawal_recipient,
        amount: commitment.locked_amount,
    });
}

/// Update withdrawal recipient
public entry fun update_withdrawal_recipient<AssetType, StableType>(
    commitment: &mut CommitmentProposal<AssetType, StableType>,
    new_recipient: address,
    ctx: &mut TxContext,
) {
    let sender = tx_context::sender(ctx);
    assert!(sender == commitment.proposer, ENotProposer);
    
    // Only allow recipient updates before tokens are withdrawn
    assert!(!commitment.withdrawn, EAlreadyWithdrawn);
    
    let old_recipient = commitment.withdrawal_recipient;
    commitment.withdrawal_recipient = new_recipient;
    
    event::emit(RecipientUpdated {
        proposal_id: object::uid_to_inner(&commitment.id),
        old_recipient,
        new_recipient,
    });
}

// === Getter Functions ===

public fun get_proposer<AssetType, StableType>(
    commitment: &CommitmentProposal<AssetType, StableType>
): address {
    commitment.proposer
}

public fun get_withdrawal_recipient<AssetType, StableType>(
    commitment: &CommitmentProposal<AssetType, StableType>
): address {
    commitment.withdrawal_recipient
}

public fun get_committed_amount<AssetType, StableType>(
    commitment: &CommitmentProposal<AssetType, StableType>
): u64 {
    commitment.committed_amount
}

public fun get_locked_amount<AssetType, StableType>(
    commitment: &CommitmentProposal<AssetType, StableType>
): u64 {
    commitment.locked_amount
}

public fun get_unlock_time<AssetType, StableType>(
    commitment: &CommitmentProposal<AssetType, StableType>
): Option<u64> {
    commitment.unlock_time
}

public fun is_executed<AssetType, StableType>(
    commitment: &CommitmentProposal<AssetType, StableType>
): bool {
    commitment.executed
}

public fun is_withdrawn<AssetType, StableType>(
    commitment: &CommitmentProposal<AssetType, StableType>
): bool {
    commitment.withdrawn
}

public fun get_tier_count<AssetType, StableType>(
    commitment: &CommitmentProposal<AssetType, StableType>
): u64 {
    vector::length(&commitment.tiers)
}

public fun get_tier_at<AssetType, StableType>(
    commitment: &CommitmentProposal<AssetType, StableType>,
    index: u64
): &PriceTier {
    vector::borrow(&commitment.tiers, index)
}module futarchy::gc_janitor;

use std::string::String;
use std::vector;
use account_protocol::{
    account::{Self, Account},
    intents::{Self, Expired},
};
use sui::clock::Clock;
use futarchy::futarchy_config::{FutarchyConfig, FutarchyOutcome};

/// Drain an `Expired` bag by invoking all futarchy delete hooks, then destroy.
/// Internal version without Account parameter for non-owned actions
fun drain_all(expired: &mut Expired) {
    // Call every delete_* you registered. Add more as you introduce actions.
    
    // Operating Agreement
    futarchy::gc_registry::delete_operating_agreement_update(expired);
    futarchy::gc_registry::delete_operating_agreement_insert(expired);
    futarchy::gc_registry::delete_operating_agreement_remove(expired);
    futarchy::gc_registry::delete_operating_agreement_batch(expired);
    
    // Config
    futarchy::gc_registry::delete_config_update(expired);
    futarchy::gc_registry::delete_trading_params(expired);
    futarchy::gc_registry::delete_metadata_update(expired);
    futarchy::gc_registry::delete_governance_update(expired);
    futarchy::gc_registry::delete_slash_distribution(expired);
    
    // Security Council
    futarchy::gc_registry::delete_create_council(expired);
    futarchy::gc_registry::delete_approve_oa_change(expired);
    futarchy::gc_registry::delete_update_council_membership(expired);
    futarchy::gc_registry::delete_approve_policy_change(expired);
    
    // Note: Generic type parameters need to be handled specially
    // For now we skip them - they'll be handled in Phase 3 with proper type resolution
    // futarchy::gc_registry::delete_approve_custody<R>(expired);
    // futarchy::gc_registry::delete_add_coin_type<CoinType>(expired);
    // futarchy::gc_registry::delete_add_liquidity<AssetType, StableType>(expired);
    
    // Liquidity (non-generic)
    futarchy::gc_registry::delete_update_pool_params(expired);
    
    // Policy
    futarchy::gc_registry::delete_set_policy(expired);
    futarchy::gc_registry::delete_remove_policy(expired);
    
    // Dissolution
    futarchy::gc_registry::delete_initiate_dissolution(expired);
    futarchy::gc_registry::delete_batch_distribute(expired);
    futarchy::gc_registry::delete_finalize_dissolution(expired);
    futarchy::gc_registry::delete_cancel_dissolution(expired);
    
    // Package upgrade actions
    futarchy::gc_registry::delete_upgrade_commit(expired);
    
    // Note: owned::delete_withdraw is handled separately in drain_all_with_account
    // since it requires the Account parameter to unlock objects
}

/// Delete a specific expired intent by key (one-shot flow).
public fun delete_expired_by_key(
    account: &mut Account<FutarchyConfig>,
    key: String,
    clock: &Clock
) {
    let mut expired = account::delete_expired_intent<FutarchyConfig, FutarchyOutcome>(
        account, key, clock
    );
    drain_all_with_account(account, &mut expired);
    intents::destroy_empty_expired(expired);
}

// TODO: Implement sweep_some when we have a way to check intent expiration
// /// Bounded sweeper (iterate over your own key index if you maintain one).
// public fun sweep_some(
//     account: &mut Account<FutarchyConfig>,
//     keys: &vector<String>,
//     max_n: u64,
//     clock: &Clock
// ) {
//     let mut i = 0u64;
//     let len = vector::length(keys);
//     while (i < max_n && i < len) {
//         let k = *vector::borrow(keys, i);
//         // Need to check if intent is expired - not currently exposed by protocol
//         // if (account::is_expired<FutarchyConfig, FutarchyOutcome>(account, k, clock)) {
//         //     delete_expired_by_key(account, k, clock);
//         // };
//         i = i + 1;
//     }
// }

/// Drain with Account context for actions that need unlocking
fun drain_all_with_account(account: &mut Account<FutarchyConfig>, expired: &mut Expired) {
    // First drain all non-owned actions
    drain_all(expired);
    
    // Then handle owned withdrawals which need Account for unlocking
    // We need to check if there are owned withdrawals in the expired bag
    // Since we can't inspect the bag directly, we try to delete and handle any errors
    futarchy::gc_registry::delete_owned_withdraw(account, expired);
    
    // Handle vault spending actions that might need Account
    futarchy::gc_registry::delete_vault_spend(account, expired);
}

/// Public export of drain_all for use in other modules
/// This works on any Expired object, not just time-expired ones
/// Accepts &mut Account for actions that need unlocking
public fun drain_all_public(account: &mut Account<FutarchyConfig>, expired: &mut Expired) {
    drain_all_with_account(account, expired);
}module futarchy::gc_registry;

use account_protocol::{
    intents::Expired,
    account::Account,
    owned,
};
use account_actions::{
    package_upgrade,
    vault,
};
use futarchy::futarchy_config::FutarchyConfig;

/// Register one delete_* per action you actually use in futarchy.
/// This module serves as a central registry for all delete functions.
/// Each function delegates to the appropriate module's delete function.

// === Operating Agreement Actions ===
public fun delete_operating_agreement_update(expired: &mut Expired) {
    futarchy::operating_agreement_actions::delete_update_line(expired);
}

public fun delete_operating_agreement_insert(expired: &mut Expired) {
    futarchy::operating_agreement_actions::delete_insert_line_after(expired);
}

public fun delete_operating_agreement_remove(expired: &mut Expired) {
    futarchy::operating_agreement_actions::delete_remove_line(expired);
}

public fun delete_operating_agreement_batch(expired: &mut Expired) {
    futarchy::operating_agreement_actions::delete_batch_operating_agreement(expired);
}

// === Config Actions ===
public fun delete_config_update(expired: &mut Expired) {
    futarchy::config_actions::delete_config_action(expired);
}

public fun delete_trading_params(expired: &mut Expired) {
    futarchy::config_actions::delete_trading_params_update(expired);
}

public fun delete_metadata_update(expired: &mut Expired) {
    futarchy::config_actions::delete_metadata_update(expired);
}

public fun delete_governance_update(expired: &mut Expired) {
    futarchy::config_actions::delete_governance_update(expired);
}

public fun delete_slash_distribution(expired: &mut Expired) {
    futarchy::config_actions::delete_slash_distribution_update(expired);
}

// === Security Council Actions ===
public fun delete_create_council(expired: &mut Expired) {
    futarchy::security_council_actions::delete_create_council(expired);
}

public fun delete_approve_oa_change(expired: &mut Expired) {
    futarchy::security_council_actions::delete_approve_oa_change(expired);
}

public fun delete_update_council_membership(expired: &mut Expired) {
    futarchy::security_council_actions::delete_update_council_membership(expired);
}

public fun delete_approve_policy_change(expired: &mut Expired) {
    futarchy::security_council_actions::delete_approve_generic(expired);
}

// === Vault/Custody Actions ===
public fun delete_approve_custody<R>(expired: &mut Expired) {
    futarchy::custody_actions::delete_approve_custody<R>(expired);
}

public fun delete_accept_into_custody<R>(expired: &mut Expired) {
    futarchy::custody_actions::delete_accept_into_custody<R>(expired);
}

public fun delete_add_coin_type<CoinType>(expired: &mut Expired) {
    futarchy::futarchy_vault::delete_add_coin_type<CoinType>(expired);
}

public fun delete_remove_coin_type<CoinType>(expired: &mut Expired) {
    futarchy::futarchy_vault::delete_remove_coin_type<CoinType>(expired);
}

// === Liquidity Actions ===
public fun delete_add_liquidity<AssetType, StableType>(expired: &mut Expired) {
    futarchy::liquidity_actions::delete_add_liquidity<AssetType, StableType>(expired);
}

public fun delete_remove_liquidity<AssetType, StableType>(expired: &mut Expired) {
    futarchy::liquidity_actions::delete_remove_liquidity<AssetType, StableType>(expired);
}

public fun delete_create_pool<AssetType, StableType>(expired: &mut Expired) {
    futarchy::liquidity_actions::delete_create_pool<AssetType, StableType>(expired);
}

public fun delete_update_pool_params(expired: &mut Expired) {
    futarchy::liquidity_actions::delete_update_pool_params(expired);
}

// === Policy Actions ===
public fun delete_set_policy(expired: &mut Expired) {
    futarchy::policy_actions::delete_set_policy(expired);
}

public fun delete_remove_policy(expired: &mut Expired) {
    futarchy::policy_actions::delete_remove_policy(expired);
}

// === Dissolution Actions ===
public fun delete_initiate_dissolution(expired: &mut Expired) {
    futarchy::dissolution_actions::delete_initiate_dissolution(expired);
}


public fun delete_batch_distribute(expired: &mut Expired) {
    futarchy::dissolution_actions::delete_batch_distribute(expired);
}

public fun delete_finalize_dissolution(expired: &mut Expired) {
    futarchy::dissolution_actions::delete_finalize_dissolution(expired);
}

public fun delete_cancel_dissolution(expired: &mut Expired) {
    futarchy::dissolution_actions::delete_cancel_dissolution(expired);
}

// === Package Upgrade Actions ===
public fun delete_upgrade_commit(expired: &mut Expired) {
    // Handle upgrade commit actions from account_actions
    // These don't need Account parameter
    if (expired.actions().length() > 0) {
        account_actions::package_upgrade::delete_upgrade(expired);
    }
}

// === Owned Object Actions ===
public fun delete_owned_withdraw(account: &mut Account<FutarchyConfig>, expired: &mut Expired) {
    // Handle owned withdrawals - this unlocks the object
    // We need to check if there's actually a withdraw action before calling
    // For now we'll handle this carefully to avoid errors
    if (expired.actions().length() > 0) {
        // Try to delete owned withdraw if it exists
        // The account_protocol::owned module handles the unlocking
        account_protocol::owned::delete_withdraw(expired, account);
    }
}

// === Vault Spending Actions ===
public fun delete_vault_spend(account: &mut Account<FutarchyConfig>, expired: &mut Expired) {
    // Handle vault spending which might involve locked coins
    // Check with vault module if this needs special handling
    let _ = account;
    if (expired.actions().length() > 0) {
        // account_actions::vault::delete_spend(expired);
        // For now, just drain without special handling
        let _ = expired;
    }
}/// Dispatcher for operating agreement actions
module futarchy::operating_agreement_dispatcher;

// === Imports ===
use sui::{
    clock::Clock,
    tx_context::TxContext,
};
use account_protocol::{
    account::Account,
    executable::{Self, Executable},
};
use futarchy::{
    futarchy_config::FutarchyConfig,
    version,
    operating_agreement,
    operating_agreement_actions,
};

// === Public(friend) Functions ===

/// Try to execute operating agreement actions
public(package) fun try_execute_operating_agreement_action<IW: drop, Outcome: store + drop + copy>(
    executable: &mut Executable<Outcome>,
    account: &mut Account<FutarchyConfig>,
    witness: IW,
    clock: &Clock,
    ctx: &mut TxContext,
): bool {
    // Create OA if it doesn't exist yet
    if (executable::contains_action<Outcome, operating_agreement_actions::CreateOperatingAgreementAction>(executable)) {
        operating_agreement::execute_create_agreement<IW, FutarchyConfig, Outcome>(
            executable,
            account,
            witness,
            clock,
            ctx
        );
        return true
    };
    
    if (executable::contains_action<Outcome, operating_agreement_actions::UpdateLineAction>(executable)) {
        let agreement = operating_agreement::get_agreement_mut(account, version::current());
        operating_agreement::execute_update_line<IW, Outcome>(
            executable,
            agreement,
            witness,
            clock,
            ctx
        );
        return true
    };
    
    if (executable::contains_action<Outcome, operating_agreement_actions::InsertLineAfterAction>(executable)) {
        let agreement = operating_agreement::get_agreement_mut(account, version::current());
        operating_agreement::execute_insert_line_after<IW, Outcome>(
            executable,
            agreement,
            witness,
            clock,
            ctx
        );
        return true
    };
    
    if (executable::contains_action<Outcome, operating_agreement_actions::InsertLineAtBeginningAction>(executable)) {
        let agreement = operating_agreement::get_agreement_mut(account, version::current());
        operating_agreement::execute_insert_line_at_beginning<IW, Outcome>(
            executable,
            agreement,
            witness,
            clock,
            ctx
        );
        return true
    };
    
    if (executable::contains_action<Outcome, operating_agreement_actions::RemoveLineAction>(executable)) {
        let agreement = operating_agreement::get_agreement_mut(account, version::current());
        operating_agreement::execute_remove_line<IW, Outcome>(
            executable,
            agreement,
            witness,
            clock,
            ctx
        );
        return true
    };
    
    if (executable::contains_action<Outcome, operating_agreement_actions::BatchOperatingAgreementAction>(executable)) {
        let agreement = operating_agreement::get_agreement_mut(account, version::current());
        operating_agreement::execute_batch_operating_agreement<IW, Outcome>(
            executable,
            agreement,
            witness,
            clock,
            ctx
        );
        return true
    };
    
    if (executable::contains_action<Outcome, operating_agreement_actions::SetLineImmutableAction>(executable)) {
        let agreement = operating_agreement::get_agreement_mut(account, version::current());
        operating_agreement::execute_set_line_immutable<IW, Outcome>(
            executable,
            agreement,
            witness,
            clock,
            ctx
        );
        return true
    };
    
    if (executable::contains_action<Outcome, operating_agreement_actions::SetInsertAllowedAction>(executable)) {
        let agreement = operating_agreement::get_agreement_mut(account, version::current());
        operating_agreement::execute_set_insert_allowed<IW, Outcome>(
            executable,
            agreement,
            witness,
            clock,
            ctx
        );
        return true
    };
    
    if (executable::contains_action<Outcome, operating_agreement_actions::SetRemoveAllowedAction>(executable)) {
        let agreement = operating_agreement::get_agreement_mut(account, version::current());
        operating_agreement::execute_set_remove_allowed<IW, Outcome>(
            executable,
            agreement,
            witness,
            clock,
            ctx
        );
        return true
    };
    
    false
}/// Operating agreement module for futarchy DAOs
/// This module manages the on-chain operating agreement with amendment capabilities
module futarchy::operating_agreement;

// === Imports ===
use std::{
    string::String,
    option::{Self, Option},
    vector,
};
use sui::{
    clock::{Self, Clock},
    event,
    dynamic_field as df,
    object::{Self, ID, UID},
    tx_context::TxContext,
};
use account_protocol::{
    account::{Self, Account},
    executable::Executable,
    version_witness::VersionWitness,
};
use futarchy::{
    policy_registry,
    version,
};
use futarchy::operating_agreement_actions::{
    UpdateLineAction,
    InsertLineAfterAction,
    InsertLineAtBeginningAction,
    RemoveLineAction,
    SetLineImmutableAction,
    SetInsertAllowedAction,
    SetRemoveAllowedAction,
    BatchOperatingAgreementAction,
    OperatingAgreementAction,
    CreateOperatingAgreementAction,
    get_update_line_params,
    get_insert_line_after_params,
    get_insert_line_at_beginning_params,
    get_remove_line_id,
    get_set_line_immutable_id,
    get_set_insert_allowed,
    get_set_remove_allowed,
    get_batch_actions,
    get_operating_agreement_action_params,
    get_create_operating_agreement_params,
    action_update,
    action_insert_after,
    action_insert_at_beginning,
    action_remove,
};

// === Type Keys for Dynamic Fields ===
/// Type key for storing the operating agreement in the Account
public struct AgreementKey has copy, drop, store {}

/// Type key for individual lines in the agreement
public struct LineKey has copy, drop, store {
    id: ID,
}

// === Errors ===
const ELineNotFound: u64 = 0;
const EIncorrectLengths: u64 = 1;
const ETooManyLines: u64 = 2;
const EInvalidActionType: u64 = 3;
const EAgreementNotFound: u64 = 4;
const EAgreementAlreadyExists: u64 = 5;
const ELineIsImmutable: u64 = 6;
const EInsertNotAllowed: u64 = 7;
const ERemoveNotAllowed: u64 = 8;
const ECannotReEnableInsert: u64 = 9;
const ECannotReEnableRemove: u64 = 10;
const EAlreadyImmutable: u64 = 11;
const EUnauthorizedCustodian: u64 = 12;
const ELineHasNoExpiry: u64 = 13;
const ELineNotExpired: u64 = 14;
const EInvalidTimeOrder: u64 = 15;
const EAgreementIsImmutable: u64 = 16;
const EAlreadyGloballyImmutable: u64 = 17;

// === Constants ===
const MAX_LINES_PER_AGREEMENT: u64 = 1000;
const MAX_TRAVERSAL_LIMIT: u64 = 1000;

// Line type constants
const LINE_TYPE_PERMANENT: u8 = 0;
const LINE_TYPE_SUNSET: u8 = 1;     // Auto-deactivates after expiry
const LINE_TYPE_SUNRISE: u8 = 2;    // Activates after effective_from
const LINE_TYPE_TEMPORARY: u8 = 3;  // Active only between effective_from and expires_at

// === Structs ===

/// Individual line in the operating agreement
public struct AgreementLine has store, drop {
    text: String,
    /// Difficulty required to change this line (in basis points)
    difficulty: u64,
    /// Whether this line is immutable (one-way lock: false -> true only)
    immutable: bool,
    /// Previous line in the linked list
    prev: Option<ID>,
    /// Next line in the linked list
    next: Option<ID>,
    /// Type of time-based provision
    line_type: u8,
    /// Timestamp when line becomes inactive (milliseconds)
    expires_at: Option<u64>,
    /// Timestamp when line becomes active (milliseconds)
    effective_from: Option<u64>,
}

/// The main operating agreement object - a shared object on chain
public struct OperatingAgreement has key, store {
    id: UID,
    /// DAO/Account ID this agreement belongs to
    dao_id: ID,
    /// Head of the linked list
    head: Option<ID>,
    /// Tail of the linked list  
    tail: Option<ID>,
    /// Whether new lines can be inserted (one-way lock: true -> false only)
    allow_insert: bool,
    /// Whether lines can be removed (one-way lock: true -> false only)
    allow_remove: bool,
    /// Number of lines in the agreement for O(1) counting
    line_count: u64,
    /// Global immutable flag - when true, entire agreement is frozen (one-way lock: false -> true only)
    immutable: bool,
}

// === Creation and Management Functions ===

/// Store the operating agreement in the Account using managed assets
public fun store_in_account<Config: store>(
    account: &mut Account<Config>,
    agreement: OperatingAgreement,
    version_witness: account_protocol::version_witness::VersionWitness,
) {
    account::add_managed_asset(account, AgreementKey {}, agreement, version_witness);
}

/// Get a mutable reference to the operating agreement from the Account
public fun get_agreement_mut<Config: store>(
    account: &mut Account<Config>,
    version_witness: account_protocol::version_witness::VersionWitness,
): &mut OperatingAgreement {
    account::borrow_managed_asset_mut(account, AgreementKey {}, version_witness)
}

/// Get a reference to the operating agreement from the Account
public fun get_agreement<Config: store>(
    account: &Account<Config>,
    version_witness: VersionWitness,
): &OperatingAgreement {
    account::borrow_managed_asset<Config, AgreementKey, OperatingAgreement>(account, AgreementKey {}, version_witness)
}

/// Check if an account has an operating agreement
public fun has_agreement<Config: store>(
    account: &Account<Config>,
): bool {
    account::has_managed_asset<Config, AgreementKey>(account, AgreementKey {})
}

// === Events ===

/// Emitted when the agreement is read or modified
public struct AgreementRead has copy, drop {
    dao_id: ID,
    line_ids: vector<ID>,
    texts: vector<String>,
    difficulties: vector<u64>,
    immutables: vector<bool>,
    allow_insert: bool,
    allow_remove: bool,
    global_immutable: bool,
    timestamp_ms: u64,
}

/// Enhanced event with time-based status
public struct AgreementReadWithStatus has copy, drop {
    dao_id: ID,
    line_ids: vector<ID>,
    texts: vector<String>,
    difficulties: vector<u64>,
    immutables: vector<bool>,
    active_statuses: vector<bool>,      // Whether each line is currently active
    line_types: vector<u8>,             // Type of each line
    expires_at: vector<Option<u64>>,    // Expiry times
    effective_from: vector<Option<u64>>, // Effective times
    allow_insert: bool,
    allow_remove: bool,
    global_immutable: bool,
    timestamp_ms: u64,
}

/// Emitted when a line is updated
public struct LineUpdated has copy, drop {
    dao_id: ID,
    line_id: ID,
    new_text: String,
    timestamp_ms: u64,
}

/// Emitted when a line is inserted
public struct LineInserted has copy, drop {
    dao_id: ID,
    line_id: ID,
    text: String,
    difficulty: u64,
    position_after: Option<ID>,
    timestamp_ms: u64,
    line_type: u8,
    expires_at: Option<u64>,
    effective_from: Option<u64>,
}

/// Emitted when a line is removed
public struct LineRemoved has copy, drop {
    dao_id: ID,
    line_id: ID,
    timestamp_ms: u64,
}

/// Emitted when a line's immutability status changes (one-way: false -> true only)
public struct LineImmutabilityChanged has copy, drop {
    dao_id: ID,
    line_id: ID,
    immutable: bool,
    timestamp_ms: u64,
}

/// Emitted when OA's insert permission changes (one-way: true -> false only)
public struct OAInsertAllowedChanged has copy, drop {
    dao_id: ID,
    allow_insert: bool,
    timestamp_ms: u64,
}

/// Emitted when OA's remove permission changes (one-way: true -> false only)  
public struct OARemoveAllowedChanged has copy, drop {
    dao_id: ID,
    allow_remove: bool,
    timestamp_ms: u64,
}

/// Emitted when OA becomes globally immutable (one-way: false -> true only)
public struct OAGlobalImmutabilityChanged has copy, drop {
    dao_id: ID,
    immutable: bool,
    timestamp_ms: u64,
}

// === Witness ===
/// Witness for accessing the operating agreement
public struct OperatingAgreementWitness has drop {}

// === Initialization Functions ===

/// Create a new operating agreement for a DAO
/// Returns the created agreement (to be stored in Account)
public fun new(
    dao_id: ID,
    initial_lines: vector<String>,
    initial_difficulties: vector<u64>,
    ctx: &mut TxContext
): OperatingAgreement {
    assert!(initial_lines.length() == initial_difficulties.length(), EIncorrectLengths);
    
    let mut agreement = OperatingAgreement {
        id: object::new(ctx),
        dao_id,
        head: option::none(),
        tail: option::none(),
        allow_insert: true,  // Initially allow insertions
        allow_remove: true,  // Initially allow removals
        line_count: 0,
        immutable: false,  // Initially mutable
    };
    
    // Initialize with the provided lines
    let mut i = 0;
    let mut prev_id: Option<ID> = option::none();
    
    assert!(initial_lines.length() <= MAX_LINES_PER_AGREEMENT, ETooManyLines);
    
    while (i < initial_lines.length()) {
        let text = *initial_lines.borrow(i);
        let difficulty = *initial_difficulties.borrow(i);
        let line_uid = object::new(ctx);
        let line_id = object::uid_to_inner(&line_uid);
        
        let line = AgreementLine {
            text,
            difficulty,
            immutable: false,  // Lines start as mutable
            prev: prev_id,
            next: option::none(),
            line_type: LINE_TYPE_PERMANENT,  // Default to permanent
            expires_at: option::none(),
            effective_from: option::none(),
        };
        
        // Store line as dynamic field on the agreement
        df::add(&mut agreement.id, LineKey { id: line_id }, line);
        
        // Update previous line's next pointer
        if (prev_id.is_some()) {
            let prev_line = df::borrow_mut<LineKey, AgreementLine>(
                &mut agreement.id, 
                LineKey { id: *prev_id.borrow() }
            );
            prev_line.next = option::some(line_id);
        } else {
            // This is the first line
            agreement.head = option::some(line_id);
        };
        
        prev_id = option::some(line_id);
        object::delete(line_uid);
        agreement.line_count = agreement.line_count + 1;
        i = i + 1;
    };
    
    // Set tail to the last line
    if (prev_id.is_some()) {
        agreement.tail = prev_id;
    };
    
    agreement
}

// === Execution Functions (Called by action_dispatcher) ===

/// Execute creation of a fresh OperatingAgreement and store it in the Account
/// This creates an empty OA (no lines), with the allow_insert/remove flags set as requested.
/// Abort if an agreement already exists.
public(package) fun execute_create_agreement<IW: drop, Config: store, Outcome: store + drop + copy>(
    executable: &mut Executable<Outcome>,
    account: &mut Account<Config>,
    witness: IW,
    clock: &Clock,
    ctx: &mut TxContext,
) {
    if (has_agreement(account)) {
        abort EAgreementAlreadyExists
    };

    let action: &CreateOperatingAgreementAction = executable.next_action(witness);
    let (allow_insert, allow_remove) = get_create_operating_agreement_params(action);

    // Create an empty OA for this DAO ID
    let dao_id = object::id(account);
    let initial_lines: vector<String> = vector[];
    let initial_difficulties: vector<u64> = vector[];
    let mut agreement = new(dao_id, initial_lines, initial_difficulties, ctx);

    // Apply policy flags as requested
    set_insert_allowed(&mut agreement, allow_insert, clock);
    set_remove_allowed(&mut agreement, allow_remove, clock);

    // Store in account managed assets
    store_in_account(account, agreement, version::current());
}

/// Execute an update line action
public(package) fun execute_update_line<IW: drop, Outcome: store + drop + copy>(
    executable: &mut Executable<Outcome>,
    agreement: &mut OperatingAgreement,
    witness: IW,
    clock: &Clock,
    _ctx: &mut TxContext,
) {
    let action: &UpdateLineAction = executable.next_action(witness);
    let (line_id, new_text) = get_update_line_params(action);
    
    update_line_internal(agreement, line_id, new_text, clock);
}

/// Execute an insert line after action
public(package) fun execute_insert_line_after<IW: drop, Outcome: store + drop + copy>(
    executable: &mut Executable<Outcome>,
    agreement: &mut OperatingAgreement,
    witness: IW,
    clock: &Clock,
    ctx: &mut TxContext,
) {
    let action: &InsertLineAfterAction = executable.next_action(witness);
    let (prev_line_id, text, difficulty) = get_insert_line_after_params(action);
    
    insert_line_after_internal(agreement, prev_line_id, text, difficulty, clock, ctx);
}

/// Execute an insert line at beginning action
public(package) fun execute_insert_line_at_beginning<IW: drop, Outcome: store + drop + copy>(
    executable: &mut Executable<Outcome>,
    agreement: &mut OperatingAgreement,
    witness: IW,
    clock: &Clock,
    ctx: &mut TxContext,
) {
    let action: &InsertLineAtBeginningAction = executable.next_action(witness);
    let (text, difficulty) = get_insert_line_at_beginning_params(action);
    
    insert_line_at_beginning_internal(agreement, text, difficulty, clock, ctx);
}

/// Execute a remove line action
public(package) fun execute_remove_line<IW: drop, Outcome: store + drop + copy>(
    executable: &mut Executable<Outcome>,
    agreement: &mut OperatingAgreement,
    witness: IW,
    clock: &Clock,
    _ctx: &mut TxContext,
) {
    let action: &RemoveLineAction = executable.next_action(witness);
    let line_id = get_remove_line_id(action);
    
    remove_line_internal(agreement, line_id, clock);
}

/// Execute a batch operating agreement action
public(package) fun execute_batch_operating_agreement<IW: drop, Outcome: store + drop + copy>(
    executable: &mut Executable<Outcome>,
    agreement: &mut OperatingAgreement,
    witness: IW,
    clock: &Clock,
    ctx: &mut TxContext,
) {
    let action: &BatchOperatingAgreementAction = executable.next_action(witness);
    let actions = get_batch_actions(action);
    
    // Process each action in the batch
    let mut i = 0;
    while (i < actions.length()) {
        let act = actions.borrow(i);
        let (action_type, line_id_opt, text_opt, difficulty_opt) = get_operating_agreement_action_params(act);
        
        if (action_type == action_update()) {
            assert!(line_id_opt.is_some() && text_opt.is_some(), EInvalidActionType);
            update_line_internal(agreement, *line_id_opt.borrow(), *text_opt.borrow(), clock);
        } else if (action_type == action_insert_after()) {
            assert!(line_id_opt.is_some() && text_opt.is_some() && difficulty_opt.is_some(), EInvalidActionType);
            insert_line_after_internal(
                agreement, 
                *line_id_opt.borrow(), 
                *text_opt.borrow(), 
                *difficulty_opt.borrow(), 
                clock, 
                ctx
            );
        } else if (action_type == action_insert_at_beginning()) {
            assert!(text_opt.is_some() && difficulty_opt.is_some(), EInvalidActionType);
            insert_line_at_beginning_internal(
                agreement, 
                *text_opt.borrow(), 
                *difficulty_opt.borrow(), 
                clock, 
                ctx
            );
        } else if (action_type == action_remove()) {
            assert!(line_id_opt.is_some(), EInvalidActionType);
            remove_line_internal(agreement, *line_id_opt.borrow(), clock);
        } else {
            abort EInvalidActionType
        };
        
        i = i + 1;
    };
    
    // Emit the full state after batch update
    emit_current_state_event(agreement, clock);
}

/// Execute a set line immutable action
public(package) fun execute_set_line_immutable<IW: drop, Outcome: store + drop + copy>(
    executable: &mut Executable<Outcome>,
    agreement: &mut OperatingAgreement,
    witness: IW,
    clock: &Clock,
    _ctx: &mut TxContext,
) {
    let action: &SetLineImmutableAction = executable.next_action(witness);
    let line_id = get_set_line_immutable_id(action);
    set_line_immutable(agreement, line_id, clock);
}

/// Execute a set insert allowed action
public(package) fun execute_set_insert_allowed<IW: drop, Outcome: store + drop + copy>(
    executable: &mut Executable<Outcome>,
    agreement: &mut OperatingAgreement,
    witness: IW,
    clock: &Clock,
    _ctx: &mut TxContext,
) {
    let action: &SetInsertAllowedAction = executable.next_action(witness);
    let allowed = get_set_insert_allowed(action);
    set_insert_allowed(agreement, allowed, clock);
}

/// Execute a set remove allowed action
public(package) fun execute_set_remove_allowed<IW: drop, Outcome: store + drop + copy>(
    executable: &mut Executable<Outcome>,
    agreement: &mut OperatingAgreement,
    witness: IW,
    clock: &Clock,
    _ctx: &mut TxContext,
) {
    let action: &SetRemoveAllowedAction = executable.next_action(witness);
    let allowed = get_set_remove_allowed(action);
    set_remove_allowed(agreement, allowed, clock);
}

// === Internal Functions ===

fun update_line_internal(
    agreement: &mut OperatingAgreement,
    line_id: ID,
    new_text: String,
    clock: &Clock,
) {
    // Check if agreement is globally immutable
    assert!(!agreement.immutable, EAgreementIsImmutable);
    
    assert!(df::exists_<LineKey>(&agreement.id, LineKey { id: line_id }), ELineNotFound);
    let line = df::borrow_mut<LineKey, AgreementLine>(&mut agreement.id, LineKey { id: line_id });
    
    // Check if line is immutable
    assert!(!line.immutable, ELineIsImmutable);
    
    line.text = new_text;
    
    event::emit(LineUpdated {
        dao_id: agreement.dao_id,
        line_id,
        new_text,
        timestamp_ms: clock::timestamp_ms(clock),
    });
}

fun insert_line_after_internal(
    agreement: &mut OperatingAgreement,
    prev_line_id: ID,
    new_text: String,
    new_difficulty: u64,
    clock: &Clock,
    ctx: &mut TxContext,
): ID {
    // Check if agreement is globally immutable
    assert!(!agreement.immutable, EAgreementIsImmutable);
    
    // Check if insertions are allowed
    assert!(agreement.allow_insert, EInsertNotAllowed);
    
    assert!(df::exists_<LineKey>(&agreement.id, LineKey { id: prev_line_id }), ELineNotFound);
    
    assert!(agreement.line_count < MAX_LINES_PER_AGREEMENT, ETooManyLines);
    
    let line_uid = object::new(ctx);
    let new_line_id = object::uid_to_inner(&line_uid);
    
    // Get the next pointer from the previous line
    let prev_line_next;
    {
        let prev_line = df::borrow<LineKey, AgreementLine>(&agreement.id, LineKey { id: prev_line_id });
        prev_line_next = prev_line.next;
    };
    
    let new_line = AgreementLine {
        text: new_text,
        difficulty: new_difficulty,
        immutable: false,  // New lines start as mutable
        prev: option::some(prev_line_id),
        next: prev_line_next,
        line_type: LINE_TYPE_PERMANENT,  // Default to permanent
        expires_at: option::none(),
        effective_from: option::none(),
    };
    
    // Update the next line's prev pointer if it exists
    if (prev_line_next.is_some()) {
        let next_line_id = *prev_line_next.borrow();
        let next_line = df::borrow_mut<LineKey, AgreementLine>(&mut agreement.id, LineKey { id: next_line_id });
        next_line.prev = option::some(new_line_id);
    };
    
    // Update the previous line's next pointer
    let prev_line = df::borrow_mut<LineKey, AgreementLine>(&mut agreement.id, LineKey { id: prev_line_id });
    prev_line.next = option::some(new_line_id);
    
    // If we inserted after the tail, update tail
    if (agreement.tail.is_some() && *agreement.tail.borrow() == prev_line_id) {
        agreement.tail = option::some(new_line_id);
    };
    
    df::add(&mut agreement.id, LineKey { id: new_line_id }, new_line);
    object::delete(line_uid);
    agreement.line_count = agreement.line_count + 1;
    
    event::emit(LineInserted {
        dao_id: agreement.dao_id,
        line_id: new_line_id,
        text: new_text,
        difficulty: new_difficulty,
        position_after: option::some(prev_line_id),
        timestamp_ms: clock::timestamp_ms(clock),
        line_type: LINE_TYPE_PERMANENT,
        expires_at: option::none(),
        effective_from: option::none(),
    });
    
    new_line_id
}

fun insert_line_at_beginning_internal(
    agreement: &mut OperatingAgreement,
    new_text: String,
    new_difficulty: u64,
    clock: &Clock,
    ctx: &mut TxContext,
): ID {
    // Check if agreement is globally immutable
    assert!(!agreement.immutable, EAgreementIsImmutable);
    
    // Check if insertions are allowed
    assert!(agreement.allow_insert, EInsertNotAllowed);
    
    assert!(agreement.line_count < MAX_LINES_PER_AGREEMENT, ETooManyLines);
    
    let line_uid = object::new(ctx);
    let new_line_id = object::uid_to_inner(&line_uid);
    
    let new_line = AgreementLine {
        text: new_text,
        difficulty: new_difficulty,
        immutable: false,  // New lines start as mutable
        prev: option::none(),
        next: agreement.head,
        line_type: LINE_TYPE_PERMANENT,  // Default to permanent
        expires_at: option::none(),
        effective_from: option::none(),
    };
    
    // Update the current head's prev pointer if it exists
    if (agreement.head.is_some()) {
        let current_head_id = *agreement.head.borrow();
        let current_head = df::borrow_mut<LineKey, AgreementLine>(&mut agreement.id, LineKey { id: current_head_id });
        current_head.prev = option::some(new_line_id);
    } else {
        // This is the first line, so it's also the tail
        agreement.tail = option::some(new_line_id);
    };
    
    agreement.head = option::some(new_line_id);
    df::add(&mut agreement.id, LineKey { id: new_line_id }, new_line);
    object::delete(line_uid);
    agreement.line_count = agreement.line_count + 1;
    
    event::emit(LineInserted {
        dao_id: agreement.dao_id,
        line_id: new_line_id,
        text: new_text,
        difficulty: new_difficulty,
        position_after: option::none(),
        timestamp_ms: clock::timestamp_ms(clock),
        line_type: LINE_TYPE_PERMANENT,
        expires_at: option::none(),
        effective_from: option::none(),
    });
    
    new_line_id
}

/// Internal function to remove expired lines (bypasses immutability check since expired lines can be removed)
fun remove_expired_line_internal(
    agreement: &mut OperatingAgreement,
    line_id: ID,
    clock: &Clock,
) {
    // Note: allow_remove check is done by the caller
    assert!(df::exists_<LineKey>(&agreement.id, LineKey { id: line_id }), ELineNotFound);
    
    // For expired lines, we don't check immutability - expiry overrides immutability
    let line_to_remove = df::remove<LineKey, AgreementLine>(&mut agreement.id, LineKey { id: line_id });
    
    // Update the previous line's next pointer
    if (line_to_remove.prev.is_some()) {
        let prev_id = *line_to_remove.prev.borrow();
        let prev_line = df::borrow_mut<LineKey, AgreementLine>(&mut agreement.id, LineKey { id: prev_id });
        prev_line.next = line_to_remove.next;
    } else {
        // This was the head
        agreement.head = line_to_remove.next;
    };
    
    // Update the next line's prev pointer
    if (line_to_remove.next.is_some()) {
        let next_id = *line_to_remove.next.borrow();
        let next_line = df::borrow_mut<LineKey, AgreementLine>(&mut agreement.id, LineKey { id: next_id });
        next_line.prev = line_to_remove.prev;
    } else {
        // This was the tail
        agreement.tail = line_to_remove.prev;
    };
    
    let AgreementLine { 
        text: _, 
        difficulty: _, 
        immutable: _, 
        prev: _, 
        next: _,
        line_type: _,
        expires_at: _,
        effective_from: _,
    } = line_to_remove;
    agreement.line_count = agreement.line_count - 1;
    
    event::emit(LineRemoved {
        dao_id: agreement.dao_id,
        line_id,
        timestamp_ms: clock::timestamp_ms(clock),
    });
}

fun remove_line_internal(
    agreement: &mut OperatingAgreement,
    line_id: ID,
    clock: &Clock,
) {
    // Check if agreement is globally immutable
    assert!(!agreement.immutable, EAgreementIsImmutable);
    
    // Check if removals are allowed
    assert!(agreement.allow_remove, ERemoveNotAllowed);
    
    assert!(df::exists_<LineKey>(&agreement.id, LineKey { id: line_id }), ELineNotFound);
    
    // Check if the line is immutable before removing
    let line_immutable = df::borrow<LineKey, AgreementLine>(&agreement.id, LineKey { id: line_id }).immutable;
    assert!(!line_immutable, ELineIsImmutable);
    
    let line_to_remove = df::remove<LineKey, AgreementLine>(&mut agreement.id, LineKey { id: line_id });
    
    // Update the previous line's next pointer
    if (line_to_remove.prev.is_some()) {
        let prev_id = *line_to_remove.prev.borrow();
        let prev_line = df::borrow_mut<LineKey, AgreementLine>(&mut agreement.id, LineKey { id: prev_id });
        prev_line.next = line_to_remove.next;
    } else {
        // This was the head
        agreement.head = line_to_remove.next;
    };
    
    // Update the next line's prev pointer
    if (line_to_remove.next.is_some()) {
        let next_id = *line_to_remove.next.borrow();
        let next_line = df::borrow_mut<LineKey, AgreementLine>(&mut agreement.id, LineKey { id: next_id });
        next_line.prev = line_to_remove.prev;
    } else {
        // This was the tail
        agreement.tail = line_to_remove.prev;
    };
    
    let AgreementLine { 
        text: _, 
        difficulty: _, 
        immutable: _, 
        prev: _, 
        next: _,
        line_type: _,
        expires_at: _,
        effective_from: _,
    } = line_to_remove;
    agreement.line_count = agreement.line_count - 1;
    
    event::emit(LineRemoved {
        dao_id: agreement.dao_id,
        line_id,
        timestamp_ms: clock::timestamp_ms(clock),
    });
}

// === Immutability Control Functions ===

/// Set a line as immutable (one-way: can only go from false to true)
public fun set_line_immutable(
    agreement: &mut OperatingAgreement,
    line_id: ID,
    clock: &Clock,
) {
    // Check if agreement is globally immutable
    assert!(!agreement.immutable, EAgreementIsImmutable);
    
    assert!(df::exists_<LineKey>(&agreement.id, LineKey { id: line_id }), ELineNotFound);
    
    let line = df::borrow_mut<LineKey, AgreementLine>(&mut agreement.id, LineKey { id: line_id });
    
    // One-way lock: can only go from false to true
    assert!(!line.immutable, EAlreadyImmutable);
    
    line.immutable = true;
    
    event::emit(LineImmutabilityChanged {
        dao_id: agreement.dao_id,
        line_id,
        immutable: true,
        timestamp_ms: clock::timestamp_ms(clock),
    });
}

/// Set whether insertions are allowed (one-way: can only go from true to false)
public fun set_insert_allowed(
    agreement: &mut OperatingAgreement,
    allowed: bool,
    clock: &Clock,
) {
    // Check if agreement is globally immutable
    assert!(!agreement.immutable, EAgreementIsImmutable);
    
    // One-way lock: can only go from true to false
    if (!allowed) {
        agreement.allow_insert = false;
    } else {
        assert!(agreement.allow_insert, ECannotReEnableInsert);
    };
    
    event::emit(OAInsertAllowedChanged {
        dao_id: agreement.dao_id,
        allow_insert: agreement.allow_insert,
        timestamp_ms: clock::timestamp_ms(clock),
    });
}

/// Set whether removals are allowed (one-way: can only go from true to false)
public fun set_remove_allowed(
    agreement: &mut OperatingAgreement,
    allowed: bool,
    clock: &Clock,
) {
    // Check if agreement is globally immutable
    assert!(!agreement.immutable, EAgreementIsImmutable);
    
    // One-way lock: can only go from true to false
    if (!allowed) {
        agreement.allow_remove = false;
    } else {
        assert!(agreement.allow_remove, ECannotReEnableRemove);
    };
    
    event::emit(OARemoveAllowedChanged {
        dao_id: agreement.dao_id,
        allow_remove: agreement.allow_remove,
        timestamp_ms: clock::timestamp_ms(clock),
    });
}

/// Set the entire agreement as globally immutable (one-way: can only go from false to true)
/// This is the ultimate lock - once set, NO changes can be made to the agreement
public fun set_global_immutable(
    agreement: &mut OperatingAgreement,
    clock: &Clock,
) {
    // One-way lock: can only go from false to true
    assert!(!agreement.immutable, EAlreadyGloballyImmutable);
    
    agreement.immutable = true;
    
    event::emit(OAGlobalImmutabilityChanged {
        dao_id: agreement.dao_id,
        immutable: true,
        timestamp_ms: clock::timestamp_ms(clock),
    });
}

// === View Functions ===

/// Get the difficulty for a specific line
public fun get_difficulty(agreement: &OperatingAgreement, line_id: ID): u64 {
    assert!(df::exists_<LineKey>(&agreement.id, LineKey { id: line_id }), ELineNotFound);
    df::borrow<LineKey, AgreementLine>(&agreement.id, LineKey { id: line_id }).difficulty
}

/// Get the text for a specific line
public fun get_line_text(agreement: &OperatingAgreement, line_id: ID): String {
    assert!(df::exists_<LineKey>(&agreement.id, LineKey { id: line_id }), ELineNotFound);
    df::borrow<LineKey, AgreementLine>(&agreement.id, LineKey { id: line_id }).text
}

/// Check if a specific line is immutable
public fun is_line_immutable(agreement: &OperatingAgreement, line_id: ID): bool {
    assert!(df::exists_<LineKey>(&agreement.id, LineKey { id: line_id }), ELineNotFound);
    df::borrow<LineKey, AgreementLine>(&agreement.id, LineKey { id: line_id }).immutable
}

/// Check if insertions are allowed
public fun is_insert_allowed(agreement: &OperatingAgreement): bool {
    agreement.allow_insert
}

/// Check if removals are allowed
public fun is_remove_allowed(agreement: &OperatingAgreement): bool {
    agreement.allow_remove
}

/// Get OA policy flags in one call (allow_insert, allow_remove)
public fun get_oa_policy(agreement: &OperatingAgreement): (bool, bool) {
    (agreement.allow_insert, agreement.allow_remove)
}

/// Check if the agreement is globally immutable
public fun is_global_immutable(agreement: &OperatingAgreement): bool {
    agreement.immutable
}

/// Get all OA lock status in one call (allow_insert, allow_remove, global_immutable)
public fun get_oa_full_policy(agreement: &OperatingAgreement): (bool, bool, bool) {
    (agreement.allow_insert, agreement.allow_remove, agreement.immutable)
}

/// Get the number of lines in the agreement (O(1) operation)
public fun line_count(agreement: &OperatingAgreement): u64 {
    agreement.line_count
}

/// Get all line IDs in order
public fun get_all_line_ids_ordered(agreement: &OperatingAgreement): vector<ID> {
    let mut lines = vector[];
    let mut current_id_opt = agreement.head;
    let mut iterations = 0;
    
    while (current_id_opt.is_some() && iterations < MAX_TRAVERSAL_LIMIT) {
        let current_id = *current_id_opt.borrow();
        lines.push_back(current_id);
        let current_line = df::borrow<LineKey, AgreementLine>(&agreement.id, LineKey { id: current_id });
        current_id_opt = current_line.next;
        iterations = iterations + 1;
    };
    
    assert!(iterations < MAX_TRAVERSAL_LIMIT, ETooManyLines);
    lines
}

/// Read and emit the full operating agreement
public entry fun read_agreement(agreement: &OperatingAgreement, clock: &Clock) {
    emit_current_state_event(agreement, clock);
    emit_current_state_event_with_status(agreement, clock);
}



/// Apply a batch of OA actions directly (co-exec calls this after validation).
/// Note: caller must have already enforced any policy/authorization checks.
public(package) fun apply_actions(
    agreement: &mut OperatingAgreement,
    actions: &vector<OperatingAgreementAction>,
    clock: &Clock,
    ctx: &mut TxContext,
) {
    let mut i = 0;
    while (i < actions.length()) {
        let act = actions.borrow(i);
        let (t, lid_opt, text_opt, diff_opt) = get_operating_agreement_action_params(act);
        if (t == action_update()) {
            assert!(lid_opt.is_some() && text_opt.is_some(), EInvalidActionType);
            update_line_internal(agreement, *lid_opt.borrow(), *text_opt.borrow(), clock);
        } else if (t == action_insert_after()) {
            assert!(lid_opt.is_some() && text_opt.is_some() && diff_opt.is_some(), EInvalidActionType);
            insert_line_after_internal(
                agreement,
                *lid_opt.borrow(),
                *text_opt.borrow(),
                *diff_opt.borrow(),
                clock,
                ctx
            );
        } else if (t == action_insert_at_beginning()) {
            assert!(text_opt.is_some() && diff_opt.is_some(), EInvalidActionType);
            insert_line_at_beginning_internal(
                agreement,
                *text_opt.borrow(),
                *diff_opt.borrow(),
                clock,
                ctx
            );
        } else if (t == action_remove()) {
            assert!(lid_opt.is_some(), EInvalidActionType);
            remove_line_internal(agreement, *lid_opt.borrow(), clock);
        } else {
            abort EInvalidActionType
        };
        i = i + 1;
    };
    emit_current_state_event(agreement, clock);
}

public(package) fun emit_current_state_event(agreement: &OperatingAgreement, clock: &Clock) {
    let ordered_ids = get_all_line_ids_ordered(agreement);
    
    let mut texts = vector[];
    let mut difficulties = vector[];
    let mut immutables = vector[];
    
    let mut i = 0;
    while (i < ordered_ids.length()) {
        let line_id = *ordered_ids.borrow(i);
        let line = df::borrow<LineKey, AgreementLine>(&agreement.id, LineKey { id: line_id });
        texts.push_back(line.text);
        difficulties.push_back(line.difficulty);
        immutables.push_back(line.immutable);
        i = i + 1;
    };
    
    event::emit(AgreementRead {
        dao_id: agreement.dao_id,
        line_ids: ordered_ids,
        texts,
        difficulties,
        immutables,
        allow_insert: agreement.allow_insert,
        allow_remove: agreement.allow_remove,
        global_immutable: agreement.immutable,
        timestamp_ms: clock::timestamp_ms(clock),
    });
}
// === Time-Based Line Functions ===

/// Check if a line is currently active based on time
/// NOTE: Immutability is separate from time-based activity. An immutable line
/// can still have a sunset date (becomes inactive but remains unchangeable)
public fun is_line_active(line: &AgreementLine, current_time_ms: u64): bool {
    // Check effective_from
    if (line.effective_from.is_some()) {
        if (current_time_ms < *line.effective_from.borrow()) {
            return false
        }
    };
    
    // Check expires_at
    if (line.expires_at.is_some()) {
        if (current_time_ms >= *line.expires_at.borrow()) {
            return false
        }
    };
    
    true
}

/// Public entry point for anyone to remove a specific expired line
/// This is a cleanup function that can be called by anyone to remove expired sunset lines
/// The line must actually be expired (expires_at < current_time) for this to succeed
/// Respects allow_remove: if removals are disabled, even expired lines cannot be removed
public entry fun remove_expired_line(
    agreement: &mut OperatingAgreement,
    line_id: ID,
    clock: &Clock,
) {
    // Check if removals are allowed - if not, even expired lines can't be removed
    assert!(agreement.allow_remove, ERemoveNotAllowed);
    
    // Check line exists
    assert!(df::exists_<LineKey>(&agreement.id, LineKey { id: line_id }), ELineNotFound);
    
    // Get the line and check if it's expired
    let line = df::borrow<LineKey, AgreementLine>(&agreement.id, LineKey { id: line_id });
    let current_time = clock::timestamp_ms(clock);
    
    // Line must have an expiry date and be past it
    assert!(line.expires_at.is_some(), ELineHasNoExpiry);
    assert!(current_time >= *line.expires_at.borrow(), ELineNotExpired);
    
    // For expired lines, we bypass the immutability check in remove_line_internal
    // by calling a special version that allows removing expired immutable lines
    remove_expired_line_internal(agreement, line_id, clock);
}

/// Insert a line with sunset provision (auto-deactivates after expiry)
/// The line can optionally be immutable - it will still sunset but cannot be changed before then
public fun insert_sunset_line_after(
    agreement: &mut OperatingAgreement,
    prev_line_id: ID,
    text: String,
    difficulty: u64,
    expires_at_ms: u64,
    immutable: bool,  // Can be immutable AND have sunset
    clock: &Clock,
    ctx: &mut TxContext,
): ID {
    // Check if agreement is globally immutable
    assert!(!agreement.immutable, EAgreementIsImmutable);
    assert!(agreement.allow_insert, EInsertNotAllowed);
    // Cannot add sunset lines if removals are disabled (since they can't be cleaned up)
    assert!(agreement.allow_remove, ERemoveNotAllowed);
    assert!(df::exists_<LineKey>(&agreement.id, LineKey { id: prev_line_id }), ELineNotFound);
    assert!(agreement.line_count < MAX_LINES_PER_AGREEMENT, ETooManyLines);
    
    // Validate sunset time is in the future
    let now = clock::timestamp_ms(clock);
    assert!(expires_at_ms > now, EInvalidTimeOrder);
    
    let line_uid = object::new(ctx);
    let new_line_id = object::uid_to_inner(&line_uid);
    
    let prev_line_next;
    {
        let prev_line = df::borrow<LineKey, AgreementLine>(&agreement.id, LineKey { id: prev_line_id });
        prev_line_next = prev_line.next;
    };
    
    let new_line = AgreementLine {
        text,
        difficulty,
        immutable,  // Can be immutable with sunset
        prev: option::some(prev_line_id),
        next: prev_line_next,
        line_type: LINE_TYPE_SUNSET,
        expires_at: option::some(expires_at_ms),
        effective_from: option::none(),
    };
    
    // Update the next line's prev pointer if it exists
    if (prev_line_next.is_some()) {
        let next_line_id = *prev_line_next.borrow();
        let next_line = df::borrow_mut<LineKey, AgreementLine>(&mut agreement.id, LineKey { id: next_line_id });
        next_line.prev = option::some(new_line_id);
    };
    
    // Update the previous line's next pointer
    let prev_line = df::borrow_mut<LineKey, AgreementLine>(&mut agreement.id, LineKey { id: prev_line_id });
    prev_line.next = option::some(new_line_id);
    
    // If we inserted after the tail, update tail
    if (agreement.tail.is_some() && *agreement.tail.borrow() == prev_line_id) {
        agreement.tail = option::some(new_line_id);
    };
    
    df::add(&mut agreement.id, LineKey { id: new_line_id }, new_line);
    object::delete(line_uid);
    agreement.line_count = agreement.line_count + 1;
    
    event::emit(LineInserted {
        dao_id: agreement.dao_id,
        line_id: new_line_id,
        text,
        difficulty,
        position_after: option::some(prev_line_id),
        timestamp_ms: clock::timestamp_ms(clock),
        line_type: LINE_TYPE_SUNSET,
        expires_at: option::some(expires_at_ms),
        effective_from: option::none(),
    });
    
    new_line_id
}

/// Insert a line that becomes active only after `effective_from`
public fun insert_sunrise_line_after(
    agreement: &mut OperatingAgreement,
    prev_line_id: ID,
    text: String,
    difficulty: u64,
    effective_from_ms: u64,
    immutable: bool,
    clock: &Clock,
    ctx: &mut TxContext,
): ID {
    // Check if agreement is globally immutable
    assert!(!agreement.immutable, EAgreementIsImmutable);
    assert!(agreement.allow_insert, EInsertNotAllowed);
    assert!(df::exists_<LineKey>(&agreement.id, LineKey { id: prev_line_id }), ELineNotFound);
    assert!(agreement.line_count < MAX_LINES_PER_AGREEMENT, ETooManyLines);

    let line_uid = object::new(ctx);
    let new_line_id = object::uid_to_inner(&line_uid);

    let prev_line_next;
    {
        let prev_line = df::borrow<LineKey, AgreementLine>(&agreement.id, LineKey { id: prev_line_id });
        prev_line_next = prev_line.next;
    };

    let new_line = AgreementLine {
        text,
        difficulty,
        immutable,
        prev: option::some(prev_line_id),
        next: prev_line_next,
        line_type: LINE_TYPE_SUNRISE,
        expires_at: option::none(),
        effective_from: option::some(effective_from_ms),
    };

    if (prev_line_next.is_some()) {
        let next_line_id = *prev_line_next.borrow();
        let next_line = df::borrow_mut<LineKey, AgreementLine>(&mut agreement.id, LineKey { id: next_line_id });
        next_line.prev = option::some(new_line_id);
    };
    
    let prev_line = df::borrow_mut<LineKey, AgreementLine>(&mut agreement.id, LineKey { id: prev_line_id });
    prev_line.next = option::some(new_line_id);
    
    if (agreement.tail.is_some() && *agreement.tail.borrow() == prev_line_id) {
        agreement.tail = option::some(new_line_id);
    };

    df::add(&mut agreement.id, LineKey { id: new_line_id }, new_line);
    object::delete(line_uid);
    agreement.line_count = agreement.line_count + 1;

    event::emit(LineInserted {
        dao_id: agreement.dao_id,
        line_id: new_line_id,
        text,
        difficulty,
        position_after: option::some(prev_line_id),
        timestamp_ms: clock::timestamp_ms(clock),
        line_type: LINE_TYPE_SUNRISE,
        expires_at: option::none(),
        effective_from: option::some(effective_from_ms),
    });

    new_line_id
}

/// Insert a line that is active only between [effective_from, expires_at)
public fun insert_temporary_line_after(
    agreement: &mut OperatingAgreement,
    prev_line_id: ID,
    text: String,
    difficulty: u64,
    effective_from_ms: u64,
    expires_at_ms: u64,
    immutable: bool,
    clock: &Clock,
    ctx: &mut TxContext,
): ID {
    // Check if agreement is globally immutable
    assert!(!agreement.immutable, EAgreementIsImmutable);
    assert!(agreement.allow_insert, EInsertNotAllowed);
    assert!(agreement.allow_remove, ERemoveNotAllowed); // must allow later cleanup
    assert!(df::exists_<LineKey>(&agreement.id, LineKey { id: prev_line_id }), ELineNotFound);
    assert!(agreement.line_count < MAX_LINES_PER_AGREEMENT, ETooManyLines);
    assert!(effective_from_ms < expires_at_ms, EInvalidTimeOrder);

    let line_uid = object::new(ctx);
    let new_line_id = object::uid_to_inner(&line_uid);

    let prev_line_next;
    {
        let prev_line = df::borrow<LineKey, AgreementLine>(&agreement.id, LineKey { id: prev_line_id });
        prev_line_next = prev_line.next;
    };

    let new_line = AgreementLine {
        text,
        difficulty,
        immutable,
        prev: option::some(prev_line_id),
        next: prev_line_next,
        line_type: LINE_TYPE_TEMPORARY,
        expires_at: option::some(expires_at_ms),
        effective_from: option::some(effective_from_ms),
    };

    if (prev_line_next.is_some()) {
        let next_line_id = *prev_line_next.borrow();
        let next_line = df::borrow_mut<LineKey, AgreementLine>(&mut agreement.id, LineKey { id: next_line_id });
        next_line.prev = option::some(new_line_id);
    };
    
    let prev_line = df::borrow_mut<LineKey, AgreementLine>(&mut agreement.id, LineKey { id: prev_line_id });
    prev_line.next = option::some(new_line_id);
    
    if (agreement.tail.is_some() && *agreement.tail.borrow() == prev_line_id) {
        agreement.tail = option::some(new_line_id);
    };

    df::add(&mut agreement.id, LineKey { id: new_line_id }, new_line);
    object::delete(line_uid);
    agreement.line_count = agreement.line_count + 1;

    event::emit(LineInserted {
        dao_id: agreement.dao_id,
        line_id: new_line_id,
        text,
        difficulty,
        position_after: option::some(prev_line_id),
        timestamp_ms: clock::timestamp_ms(clock),
        line_type: LINE_TYPE_TEMPORARY,
        expires_at: option::some(expires_at_ms),
        effective_from: option::some(effective_from_ms),
    });

    new_line_id
}

/// Emit the full state including activity and schedule
public fun emit_current_state_event_with_status(agreement: &OperatingAgreement, clock: &Clock) {
    let ordered_ids = get_all_line_ids_ordered(agreement);
    let now = clock::timestamp_ms(clock);

    let mut texts = vector[];
    let mut difficulties = vector[];
    let mut immutables = vector[];
    let mut active_statuses = vector[];
    let mut line_types = vector[];
    let mut expires_vec = vector[];
    let mut effective_vec = vector[];

    let mut i = 0;
    while (i < ordered_ids.length()) {
        let line_id = *ordered_ids.borrow(i);
        let line = df::borrow<LineKey, AgreementLine>(&agreement.id, LineKey { id: line_id });
        texts.push_back(line.text);
        difficulties.push_back(line.difficulty);
        immutables.push_back(line.immutable);
        active_statuses.push_back(is_line_active(line, now));
        line_types.push_back(line.line_type);
        expires_vec.push_back(line.expires_at);
        effective_vec.push_back(line.effective_from);
        i = i + 1;
    };

    event::emit(AgreementReadWithStatus {
        dao_id: agreement.dao_id,
        line_ids: ordered_ids,
        texts,
        difficulties,
        immutables,
        active_statuses,
        line_types,
        expires_at: expires_vec,
        effective_from: effective_vec,
        allow_insert: agreement.allow_insert,
        allow_remove: agreement.allow_remove,
        global_immutable: agreement.immutable,
        timestamp_ms: now,
    });
}

/// Operating agreement actions for futarchy DAOs
/// This module defines action structs and execution logic for operating agreement changes
module futarchy::operating_agreement_actions;

// === Imports ===
use std::{
    string::String,
    option::{Self, Option},
};
use sui::{
    object::ID,
    clock::Clock,
};
use account_protocol::{
    account::{Self, Account},
    executable::Executable,
    intents::{Intent, Expired},
    version_witness::VersionWitness,
};
use futarchy::futarchy_config::FutarchyConfig;

// === Errors ===
const EInvalidLineId: u64 = 1;
const EEmptyText: u64 = 2;
const EInvalidDifficulty: u64 = 3;
const EInvalidActionType: u64 = 4;

// === Constants ===
const ACTION_UPDATE: u8 = 0;
const ACTION_INSERT_AFTER: u8 = 1;
const ACTION_INSERT_AT_BEGINNING: u8 = 2;
const ACTION_REMOVE: u8 = 3;

// === Action Structs ===


/// Create a new (empty) Operating Agreement and store it in the Account
/// Lines can be inserted subsequently via Insert* actions.
public struct CreateOperatingAgreementAction has store {
    /// Optional policy flags to set immediately (defaults are true in OA::new)
    allow_insert: bool,
    allow_remove: bool,
}

/// Represents a single atomic change to the operating agreement
/// NOTE: This is used as part of BatchOperatingAgreementAction for batch operations.
/// Individual actions (UpdateLineAction, InsertLineAfterAction, etc.) are handled
/// directly in the dispatcher. This wrapper is only used within batch operations.
public struct OperatingAgreementAction has store, drop {
    action_type: u8, // 0 for Update, 1 for Insert After, 2 for Insert At Beginning, 3 for Remove
    // Only fields relevant to the action_type will be populated
    line_id: Option<ID>, // Used for Update, Remove, and as the *previous* line for Insert After
    text: Option<String>, // Used for Update and Insert operations
    difficulty: Option<u64>, // Used for Insert operations
}

/// Action to update a line in the operating agreement
public struct UpdateLineAction has store {
    line_id: ID,
    new_text: String,
}

/// Action to insert a line after another line
public struct InsertLineAfterAction has store {
    prev_line_id: ID,
    text: String,
    difficulty: u64,
}

/// Action to insert a line at the beginning
public struct InsertLineAtBeginningAction has store {
    text: String,
    difficulty: u64,
}

/// Action to remove a line
public struct RemoveLineAction has store {
    line_id: ID,
}

/// Action to set a line as immutable (one-way lock)
public struct SetLineImmutableAction has store {
    line_id: ID,
}

/// Action to control whether insertions are allowed (one-way lock)
public struct SetInsertAllowedAction has store {
    allowed: bool,
}

/// Action to control whether removals are allowed (one-way lock)
public struct SetRemoveAllowedAction has store {
    allowed: bool,
}

/// Batch action for multiple operating agreement changes
public struct BatchOperatingAgreementAction has store {
    batch_id: ID,  // Unique ID for this batch
    actions: vector<OperatingAgreementAction>,
}

// === Execution Functions ===
// Note: These do_* functions are not used. The action_dispatcher directly calls
// operating_agreement module functions. Keeping struct definitions only.

// === Cleanup Functions ===

/// Delete a create OA action from an expired intent
public fun delete_create_operating_agreement(expired: &mut Expired) {
    let CreateOperatingAgreementAction { allow_insert: _, allow_remove: _ } = expired.remove_action();
}

/// Delete an update line action from an expired intent
public fun delete_update_line(expired: &mut Expired) {
    let UpdateLineAction { line_id: _, new_text: _ } = expired.remove_action();
}

/// Delete an insert line after action from an expired intent
public fun delete_insert_line_after(expired: &mut Expired) {
    let InsertLineAfterAction { prev_line_id: _, text: _, difficulty: _ } = expired.remove_action();
}

/// Delete an insert line at beginning action from an expired intent
public fun delete_insert_line_at_beginning(expired: &mut Expired) {
    let InsertLineAtBeginningAction { text: _, difficulty: _ } = expired.remove_action();
}

/// Delete a remove line action from an expired intent
public fun delete_remove_line(expired: &mut Expired) {
    let RemoveLineAction { line_id: _ } = expired.remove_action();
}

/// Delete a set line immutable action from an expired intent
public fun delete_set_line_immutable(expired: &mut Expired) {
    let SetLineImmutableAction { line_id: _ } = expired.remove_action();
}

/// Delete a set insert allowed action from an expired intent
public fun delete_set_insert_allowed(expired: &mut Expired) {
    let SetInsertAllowedAction { allowed: _ } = expired.remove_action();
}

/// Delete a set remove allowed action from an expired intent
public fun delete_set_remove_allowed(expired: &mut Expired) {
    let SetRemoveAllowedAction { allowed: _ } = expired.remove_action();
}

/// Delete a batch operating agreement action from an expired intent
public fun delete_batch_operating_agreement(expired: &mut Expired) {
    let BatchOperatingAgreementAction { batch_id: _, actions: _ } = expired.remove_action();
}

/// Delete an operating agreement action from an expired intent
public fun delete_operating_agreement_action(expired: &mut Expired) {
    let OperatingAgreementAction { action_type: _, line_id: _, text: _, difficulty: _ } = expired.remove_action();
}

// === Intent Helper Functions ===

/// Create a new update line action for intents
public fun new_update_line<Outcome: store, IW: drop>(
    intent: &mut Intent<Outcome>,
    line_id: ID,
    new_text: String,
    intent_witness: IW,
) {
    let action = new_update_line_action(line_id, new_text);
    intent.add_action(action, intent_witness);
}

/// Create a new insert line after action for intents
public fun new_insert_line_after<Outcome: store, IW: drop>(
    intent: &mut Intent<Outcome>,
    prev_line_id: ID,
    text: String,
    difficulty: u64,
    intent_witness: IW,
) {
    let action = new_insert_line_after_action(prev_line_id, text, difficulty);
    intent.add_action(action, intent_witness);
}

/// Create a new insert line at beginning action for intents
public fun new_insert_line_at_beginning<Outcome: store, IW: drop>(
    intent: &mut Intent<Outcome>,
    text: String,
    difficulty: u64,
    intent_witness: IW,
) {
    let action = new_insert_line_at_beginning_action(text, difficulty);
    intent.add_action(action, intent_witness);
}

/// Create a new remove line action for intents
public fun new_remove_line<Outcome: store, IW: drop>(
    intent: &mut Intent<Outcome>,
    line_id: ID,
    intent_witness: IW,
) {
    let action = new_remove_line_action(line_id);
    intent.add_action(action, intent_witness);
}

/// Create a new batch operating agreement action for intents
public fun new_batch_operating_agreement<Outcome: store, IW: drop>(
    intent: &mut Intent<Outcome>,
    batch_id: ID,
    actions: vector<OperatingAgreementAction>,
    intent_witness: IW,
) {
    let action = new_batch_operating_agreement_action(batch_id, actions);
    intent.add_action(action, intent_witness);
}

// === Helper Functions ===

/// Get the batch ID from a BatchOperatingAgreementAction
public fun get_batch_id(batch: &BatchOperatingAgreementAction): ID {
    batch.batch_id
}

/// Create a new create OA action
public fun new_create_operating_agreement_action(
    allow_insert: bool,
    allow_remove: bool
): CreateOperatingAgreementAction {
    CreateOperatingAgreementAction { allow_insert, allow_remove }
}

/// Create a new update line action
public fun new_update_line_action(line_id: ID, new_text: String): UpdateLineAction {
    assert!(new_text.length() > 0, EEmptyText);
    UpdateLineAction { line_id, new_text }
}

/// Create a new insert line after action
public fun new_insert_line_after_action(
    prev_line_id: ID,
    text: String,
    difficulty: u64,
): InsertLineAfterAction {
    assert!(text.length() > 0, EEmptyText);
    assert!(difficulty > 0, EInvalidDifficulty);
    InsertLineAfterAction { prev_line_id, text, difficulty }
}

/// Create a new insert line at beginning action
public fun new_insert_line_at_beginning_action(
    text: String,
    difficulty: u64,
): InsertLineAtBeginningAction {
    assert!(text.length() > 0, EEmptyText);
    assert!(difficulty > 0, EInvalidDifficulty);
    InsertLineAtBeginningAction { text, difficulty }
}

/// Create a new remove line action
public fun new_remove_line_action(line_id: ID): RemoveLineAction {
    RemoveLineAction { line_id }
}

/// Create a new set line immutable action
public fun new_set_line_immutable_action(line_id: ID): SetLineImmutableAction {
    SetLineImmutableAction { line_id }
}

/// Create a new set insert allowed action
public fun new_set_insert_allowed_action(allowed: bool): SetInsertAllowedAction {
    SetInsertAllowedAction { allowed }
}

/// Create a new set remove allowed action
public fun new_set_remove_allowed_action(allowed: bool): SetRemoveAllowedAction {
    SetRemoveAllowedAction { allowed }
}

/// Create a new batch operating agreement action
public fun new_batch_operating_agreement_action(
    batch_id: ID,
    actions: vector<OperatingAgreementAction>
): BatchOperatingAgreementAction {
    BatchOperatingAgreementAction { batch_id, actions }
}

/// Create a new operating agreement action (flexible type)
public fun new_operating_agreement_action(
    action_type: u8,
    line_id: Option<ID>,
    text: Option<String>,
    difficulty: Option<u64>,
): OperatingAgreementAction {
    assert!(action_type <= ACTION_REMOVE, EInvalidActionType);
    
    // Validate based on action type
    if (action_type == ACTION_UPDATE) {
        assert!(line_id.is_some(), EInvalidLineId);
        assert!(text.is_some() && text.borrow().length() > 0, EEmptyText);
    } else if (action_type == ACTION_INSERT_AFTER) {
        assert!(line_id.is_some(), EInvalidLineId);
        assert!(text.is_some() && text.borrow().length() > 0, EEmptyText);
        assert!(difficulty.is_some() && *difficulty.borrow() > 0, EInvalidDifficulty);
    } else if (action_type == ACTION_INSERT_AT_BEGINNING) {
        assert!(text.is_some() && text.borrow().length() > 0, EEmptyText);
        assert!(difficulty.is_some() && *difficulty.borrow() > 0, EInvalidDifficulty);
    } else if (action_type == ACTION_REMOVE) {
        assert!(line_id.is_some(), EInvalidLineId);
    };
    
    OperatingAgreementAction {
        action_type,
        line_id,
        text,
        difficulty,
    }
}

/// Create a new update action using the flexible format
public fun new_update_action(line_id: ID, new_text: String): OperatingAgreementAction {
    new_operating_agreement_action(
        ACTION_UPDATE,
        option::some(line_id),
        option::some(new_text),
        option::none(),
    )
}

/// Create a new insert after action using the flexible format
public fun new_insert_after_action(prev_line_id: ID, text: String, difficulty: u64): OperatingAgreementAction {
    new_operating_agreement_action(
        ACTION_INSERT_AFTER,
        option::some(prev_line_id),
        option::some(text),
        option::some(difficulty),
    )
}

/// Create a new insert at beginning action using the flexible format
public fun new_insert_at_beginning_action(text: String, difficulty: u64): OperatingAgreementAction {
    new_operating_agreement_action(
        ACTION_INSERT_AT_BEGINNING,
        option::none(),
        option::some(text),
        option::some(difficulty),
    )
}

/// Create a new remove action using the flexible format
public fun new_remove_action(line_id: ID): OperatingAgreementAction {
    new_operating_agreement_action(
        ACTION_REMOVE,
        option::some(line_id),
        option::none(),
        option::none(),
    )
}

// === Getter Functions ===

/// Get line ID and new text from UpdateLineAction
public fun get_update_line_params(action: &UpdateLineAction): (ID, String) {
    (action.line_id, action.new_text)
}

/// Get parameters from InsertLineAfterAction
public fun get_insert_line_after_params(action: &InsertLineAfterAction): (ID, String, u64) {
    (action.prev_line_id, action.text, action.difficulty)
}

/// Get parameters from InsertLineAtBeginningAction
public fun get_insert_line_at_beginning_params(action: &InsertLineAtBeginningAction): (String, u64) {
    (action.text, action.difficulty)
}

/// Get line ID from RemoveLineAction
public fun get_remove_line_id(action: &RemoveLineAction): ID {
    action.line_id
}

/// Get line ID from SetLineImmutableAction
public fun get_set_line_immutable_id(action: &SetLineImmutableAction): ID {
    action.line_id
}

/// Get allowed flag from SetInsertAllowedAction
public fun get_set_insert_allowed(action: &SetInsertAllowedAction): bool {
    action.allowed
}

/// Get allowed flag from SetRemoveAllowedAction
public fun get_set_remove_allowed(action: &SetRemoveAllowedAction): bool {
    action.allowed
}

/// Get actions from BatchOperatingAgreementAction
public fun get_batch_actions(action: &BatchOperatingAgreementAction): &vector<OperatingAgreementAction> {
    &action.actions
}

/// Get parameters from OperatingAgreementAction
public fun get_operating_agreement_action_params(action: &OperatingAgreementAction): (
    u8,
    &Option<ID>,
    &Option<String>,
    &Option<u64>,
) {
    (action.action_type, &action.line_id, &action.text, &action.difficulty)
}


/// Get parameters from CreateOperatingAgreementAction
public fun get_create_operating_agreement_params(action: &CreateOperatingAgreementAction): (bool, bool) {
    (action.allow_insert, action.allow_remove)
}

/// Get action type constants for external use
public fun action_update(): u8 { ACTION_UPDATE }
public fun action_insert_after(): u8 { ACTION_INSERT_AFTER }
public fun action_insert_at_beginning(): u8 { ACTION_INSERT_AT_BEGINNING }
public fun action_remove(): u8 { ACTION_REMOVE }

// === Internal Functions ===

/// Validate an operating agreement action
fun validate_operating_agreement_action(action: &OperatingAgreementAction) {
    assert!(action.action_type <= ACTION_REMOVE, EInvalidActionType);
    
    if (action.action_type == ACTION_UPDATE) {
        assert!(action.line_id.is_some(), EInvalidLineId);
        assert!(action.text.is_some() && action.text.borrow().length() > 0, EEmptyText);
    } else if (action.action_type == ACTION_INSERT_AFTER) {
        assert!(action.line_id.is_some(), EInvalidLineId);
        assert!(action.text.is_some() && action.text.borrow().length() > 0, EEmptyText);
        assert!(action.difficulty.is_some() && *action.difficulty.borrow() > 0, EInvalidDifficulty);
    } else if (action.action_type == ACTION_INSERT_AT_BEGINNING) {
        assert!(action.text.is_some() && action.text.borrow().length() > 0, EEmptyText);
        assert!(action.difficulty.is_some() && *action.difficulty.borrow() > 0, EInvalidDifficulty);
    } else if (action.action_type == ACTION_REMOVE) {
        assert!(action.line_id.is_some(), EInvalidLineId);
    };
}/// Operating agreement intent creation using the CORRECT pattern with build_intent! macro
module futarchy::operating_agreement_intents;

// === Imports ===
use std::string::String;
use sui::{
    clock::Clock,
    object::ID,
    tx_context::TxContext,
};
use account_protocol::{
    account::Account,
    executable::Executable,
    intents::{Intent, Params},
    intent_interface,
};
use futarchy::{
    operating_agreement_actions,
    version,
};

// === Aliases ===
use fun intent_interface::build_intent as Account.build_intent;
use fun intent_interface::process_intent as Account.process_intent;

// === Single Witness ===
public struct OperatingAgreementIntent has copy, drop {}

// === Intent Creation Functions ===

/// Create intent to update a line in the operating agreement
public fun create_update_line_intent<Config, Outcome: store>(
    account: &mut Account<Config>,
    params: Params,
    outcome: Outcome,
    line_id: ID,
    new_text: String,
    ctx: &mut TxContext
) {
    account.build_intent!(
        params,
        outcome,
        b"operating_agreement_update_line".to_string(),
        version::current(),
        OperatingAgreementIntent {},
        ctx,
        |intent, iw| {
            operating_agreement_actions::new_update_line<Outcome, OperatingAgreementIntent>(
                intent,
                line_id,
                new_text,
                iw
            );
        }
    );
}

/// Create intent to insert a line after another line
public fun create_insert_line_after_intent<Config, Outcome: store>(
    account: &mut Account<Config>,
    params: Params,
    outcome: Outcome,
    prev_line_id: ID,
    text: String,
    difficulty: u64,
    ctx: &mut TxContext
) {
    account.build_intent!(
        params,
        outcome,
        b"operating_agreement_insert_after".to_string(),
        version::current(),
        OperatingAgreementIntent {},
        ctx,
        |intent, iw| {
            operating_agreement_actions::new_insert_line_after<Outcome, OperatingAgreementIntent>(
                intent,
                prev_line_id,
                text,
                difficulty,
                iw
            );
        }
    );
}

/// Create intent to insert a line at the beginning
public fun create_insert_line_at_beginning_intent<Config, Outcome: store>(
    account: &mut Account<Config>,
    params: Params,
    outcome: Outcome,
    text: String,
    difficulty: u64,
    ctx: &mut TxContext
) {
    account.build_intent!(
        params,
        outcome,
        b"operating_agreement_insert_beginning".to_string(),
        version::current(),
        OperatingAgreementIntent {},
        ctx,
        |intent, iw| {
            operating_agreement_actions::new_insert_line_at_beginning<Outcome, OperatingAgreementIntent>(
                intent,
                text,
                difficulty,
                iw
            );
        }
    );
}

/// Create intent to remove a line from the operating agreement
public fun create_remove_line_intent<Config, Outcome: store>(
    account: &mut Account<Config>,
    params: Params,
    outcome: Outcome,
    line_id: ID,
    ctx: &mut TxContext
) {
    account.build_intent!(
        params,
        outcome,
        b"operating_agreement_remove_line".to_string(),
        version::current(),
        OperatingAgreementIntent {},
        ctx,
        |intent, iw| {
            operating_agreement_actions::new_remove_line<Outcome, OperatingAgreementIntent>(
                intent,
                line_id,
                iw
            );
        }
    );
}

/// Create intent for batch operating agreement changes
public fun create_batch_operating_agreement_intent<Config, Outcome: store>(
    account: &mut Account<Config>,
    params: Params,
    outcome: Outcome,
    actions: vector<operating_agreement_actions::OperatingAgreementAction>,
    ctx: &mut TxContext
) {
    account.build_intent!(
        params,
        outcome,
        b"operating_agreement_batch".to_string(),
        version::current(),
        OperatingAgreementIntent {},
        ctx,
        |intent, iw| {
            // Generate a unique batch ID for this set of operations  
            let batch_uid = object::new(ctx);
            let batch_id = object::uid_to_inner(&batch_uid);
            object::delete(batch_uid);
            operating_agreement_actions::new_batch_operating_agreement<Outcome, OperatingAgreementIntent>(
                intent,
                batch_id,
                actions,
                iw
            );
        }
    );
}

/// Create intent to initialize a brand-new Operating Agreement in the Account
/// Creates an empty OA (no lines). Use insert actions afterwards.
public fun create_create_agreement_intent<Config, Outcome: store>(
    account: &mut Account<Config>,
    params: Params,
    outcome: Outcome,
    allow_insert: bool,
    allow_remove: bool,
    ctx: &mut TxContext
) {
    account.build_intent!(
        params,
        outcome,
        b"operating_agreement_create".to_string(),
        version::current(),
        OperatingAgreementIntent {},
        ctx,
        |intent, iw| {
            let action = operating_agreement_actions::new_create_operating_agreement_action(
                allow_insert,
                allow_remove
            );
            intent.add_action(action, iw);
        }
    );
}

// Note: Execution of intents should be done through the account protocol's
// process_intent! macro in the calling module, not here. This module only
// provides intent creation functions.module futarchy::coexec_custody;

use std::string::String;
use sui::{
    clock::Clock,
    object::{Self, ID},
    transfer::Receiving,
    tx_context::TxContext,
};
use account_protocol::{
    account::{Self, Account},
    executable::Executable,
    owned,
};
use futarchy::{
    version,
    coexec_common,
    futarchy_config::{Self, FutarchyConfig},
    weighted_multisig::{Self, WeightedMultisig, Approvals},
    custody_actions,
};

// Error codes
const EObjectIdMismatch: u64 = 5;
const EResourceKeyMismatch: u64 = 6;
const EWithdrawnObjectIdMismatch: u64 = 7;

/// Generic 2-of-2 custody accept:
/// - DAO executable must contain ApproveCustodyAction<R>
/// - Council executable must contain AcceptIntoCustodyAction<R> and a Receiving<R>
/// - Enforces policy_key on DAO ("Custody:*" or domain-specific like "UpgradeCap:Custodian")
/// Stores the object under council custody with a standard key.
public fun execute_accept_with_council<FutarchyOutcome: store + drop + copy, R: key + store, W: copy + drop>(
    dao: &mut Account<FutarchyConfig>,
    council: &mut Account<WeightedMultisig>,
    mut futarchy_exec: Executable<FutarchyOutcome>,
    mut council_exec: Executable<Approvals>,
    receipt: Receiving<R>,
    policy_key: String,
    intent_witness: W,
    clock: &Clock,
    ctx: &mut TxContext,
) {
    // DAO approves
    let approve: &custody_actions::ApproveCustodyAction<R> =
        coexec_common::extract_action(&mut futarchy_exec, version::current());
    let (dao_id_expected, obj_id_expected, res_key_ref, _ctx_ref, expires_at) =
        custody_actions::get_approve_custody_params(approve);
    
    // Council accepts
    let accept: &custody_actions::AcceptIntoCustodyAction<R> =
        coexec_common::extract_action(&mut council_exec, intent_witness);
    let (obj_id_council, res_key_council_ref, _ctx2_ref) =
        custody_actions::get_accept_params(accept);
    
    // Policy/expiry checks
    coexec_common::enforce_custodian_policy(dao, council, policy_key);
    coexec_common::validate_dao_id(dao_id_expected, object::id(dao));
    coexec_common::validate_expiry(clock, expires_at);
    
    assert!(obj_id_expected == obj_id_council, EObjectIdMismatch);
    assert!(*res_key_ref == *res_key_council_ref, EResourceKeyMismatch);
    
    // Withdraw the object (must match the withdraw action witness used when building the intent)
    let obj = owned::do_withdraw(&mut council_exec, council, receipt, intent_witness);
    assert!(object::id(&obj) == obj_id_expected, EWithdrawnObjectIdMismatch);
    
    // Store under council custody using a standard key
    let mut key = b"custody:".to_string();
    key.append(*res_key_ref);
    account_protocol::account::add_managed_asset(council, key, obj, version::current());
    
    // Confirm both executables atomically
    coexec_common::confirm_both_executables(dao, council, futarchy_exec, council_exec);
}/// 2-of-2 co-execution for accepting and locking UpgradeCaps (DAO + Security Council).
/// Enforced when DAO sets policy "UpgradeCap:Custodian" -> council_id in policy_registry.
module futarchy::upgrade_cap_coexec;

use std::{string::{Self, String}, hash, vector};
use sui::{
    clock::Clock,
    object::{Self, ID},
    package::UpgradeCap,
    transfer::Receiving,
    tx_context::TxContext,
};
use account_protocol::{
    account::{Self, Account},
    executable::{Self, Executable},
    owned, // withdraw helper
};
use futarchy::{
    version,
    coexec_common,
    futarchy_config::{Self, FutarchyConfig, GenericApproval},
    security_council,
    custody_actions,
    security_council_intents,
    security_council_actions,
    weighted_multisig::{Self, WeightedMultisig, Approvals},
};
use account_actions::package_upgrade;

// Error codes
const ECapIdMismatch: u64 = 1001;
const EPackageNameMismatch: u64 = 1002;
const EWrongCapObject: u64 = 1003;

/// Require 2-of-2 for accepting/locking an UpgradeCap:
/// - DAO must have policy "UpgradeCap:Custodian" pointing to Security Council
/// - DAO executable contains custody action or DAO's approval
/// - Council executable contains ApproveUpgradeCapAction with matching params
/// If checks pass, withdraw and lock the cap into the council via package_upgrade,
/// and confirm both executables atomically.
public fun execute_accept_and_lock_with_council<FutarchyOutcome: store + drop + copy>(
    dao: &mut Account<FutarchyConfig>,
    council: &mut Account<WeightedMultisig>,
    mut futarchy_exec: Executable<FutarchyOutcome>,
    mut council_exec: Executable<Approvals>,
    cap_receipt: Receiving<UpgradeCap>,
    clock: &Clock,
    ctx: &mut TxContext,
) {
    // Extract Council's generic approval for the UpgradeCap
    let approval: &security_council_actions::ApproveGenericAction =
        coexec_common::extract_action(&mut council_exec, version::current());
    let (dao_id, action_type, resource_key, metadata, expires_at) =
        security_council_actions::get_approve_generic_params(approval);
    
    // Validate action type
    assert!(*action_type == b"custody_accept".to_string(), coexec_common::error_action_type_mismatch());
    assert!(resource_key.bytes().length() >= 11 && 
            // Check if resource_key starts with "UpgradeCap:"
            {
                let key_bytes = resource_key.bytes();
                let mut i = 0;
                let mut matches = true;
                let prefix = b"UpgradeCap:";
                while (i < 11 && i < key_bytes.length()) {
                    if (*key_bytes.borrow(i) != *prefix.borrow(i)) {
                        matches = false;
                        break
                    };
                    i = i + 1;
                };
                matches && key_bytes.length() >= 11
            }, 
            EPackageNameMismatch);
    
    // Extract package_name from metadata
    // metadata should be: ["package_name", <name>]
    assert!(metadata.length() == 2, coexec_common::error_metadata_missing());
    assert!(*metadata.borrow(0) == b"package_name".to_string(), coexec_common::error_metadata_missing());
    let pkg_name_expected = metadata.borrow(1);
    
    // Validate basic requirements
    assert!(dao_id == object::id(dao), coexec_common::error_dao_mismatch());
    assert!(clock.timestamp_ms() < expires_at, coexec_common::error_expired());
    
    // Verify council is the UpgradeCap custodian
    coexec_common::enforce_custodian_policy(dao, council, b"UpgradeCap:Custodian".to_string());
    
    // Extract the accept action to get the cap
    let accept: &custody_actions::AcceptIntoCustodyAction<UpgradeCap> =
        coexec_common::extract_action(
            &mut futarchy_exec,
            version::current()
        );
    let (cap_id_expected, pkg_name_council_ref, _) =
        custody_actions::get_accept_params(accept);
    
    // Validate package names match
    assert!(*pkg_name_expected == *pkg_name_council_ref, EPackageNameMismatch);
    
    // Withdraw the cap from the receipt and lock it into the council
    let cap = owned::do_withdraw(
        &mut futarchy_exec,
        dao,
        cap_receipt,
        version::current()
    );
    
    // Strong object identity check
    assert!(object::id(&cap) == cap_id_expected, EWrongCapObject);
    
    // Lock the cap under council management
    let auth = security_council::authenticate(council, ctx);
    package_upgrade::lock_cap(auth, council, cap, *pkg_name_expected, 0);
    
    // Record the council approval for this intent
    let intent_key = executable::intent(&futarchy_exec).key();
    let generic_approval = futarchy_config::new_custody_approval(
        object::id(dao),
        *resource_key,
        cap_id_expected,
        expires_at,
        ctx
    );
    futarchy_config::record_council_approval_generic(
        dao,
        intent_key,
        generic_approval,
        ctx
    );
    
    // Confirm both executables atomically
    coexec_common::confirm_both_executables(dao, council, futarchy_exec, council_exec);
}/// Bilateral approval mechanism for critical policy changes.
/// Requires both DAO and Security Council approval for modifying critical policies.
module futarchy::policy_registry_coexec;

use std::{string::String, option};
use sui::{clock::Clock, object::{Self, ID}};
use account_protocol::{
    account::{Self, Account},
    executable::{Self, Executable},
};
use sui::tx_context::TxContext;
use futarchy::{
    version,
    policy_registry,
    policy_actions,
    coexec_common,
    futarchy_config::{Self, FutarchyConfig, GenericApproval},
    weighted_multisig::{WeightedMultisig, Approvals},
    security_council_actions,
};

// === Errors ===
const EPolicyActionMissing: u64 = 1;
const EApprovalActionMissing: u64 = 2;
const EKeyMismatch: u64 = 4;
const EActionTypeMismatch: u64 = 5;
const EPolicyMismatch: u64 = 8;
const ENotCriticalPolicy: u64 = 9;

/// Critical policies that require bilateral approval to modify
public fun is_critical_policy(resource_key: &String): bool {
    let key_bytes = resource_key.bytes();
    
    // UpgradeCap:* - protects package upgrades
    if (key_bytes.length() >= 11) {
        let prefix = vector[85, 112, 103, 114, 97, 100, 101, 67, 97, 112, 58]; // "UpgradeCap:"
        let mut i = 0;
        let mut matches = true;
        while (i < 11) {
            if (*key_bytes.borrow(i) != *prefix.borrow(i)) {
                matches = false;
                break
            };
            i = i + 1;
        };
        if (matches) return true;
    };
    
    // Vault:AllowedCoinTypes - protects treasury asset types
    if (key_bytes == b"Vault:AllowedCoinTypes") return true;
    
    // PolicyRegistry:Admin - protects the policy registry itself
    if (key_bytes == b"PolicyRegistry:Admin") return true;
    
    false
}

/// Execute policy changes requiring 2-of-2: futarchy + council.
/// For removing a critical policy:
/// - DAO must have the policy currently set
/// - Futarchy executable must contain RemovePolicyAction
/// - Council executable must contain ApprovePolicyChangeAction with matching params
/// Both executables are confirmed atomically.
public fun execute_remove_policy_with_council<FutarchyOutcome: store + drop + copy>(
    dao: &mut Account<FutarchyConfig>,
    council: &mut Account<WeightedMultisig>,
    mut futarchy_exec: Executable<FutarchyOutcome>,
    mut council_exec: Executable<Approvals>,
    clock: &Clock,
    ctx: &mut TxContext,
) {
    // Extract futarchy RemovePolicyAction
    let remove_action: &policy_actions::RemovePolicyAction = 
        coexec_common::extract_action_with_check(&mut futarchy_exec, version::current(), EPolicyActionMissing);
    let resource_key = policy_actions::get_remove_policy_key(remove_action);
    
    // Verify this is a critical policy
    assert!(is_critical_policy(resource_key), ENotCriticalPolicy);
    
    // Extract council ApproveGenericAction
    let approval: &security_council_actions::ApproveGenericAction = 
        coexec_common::extract_action_with_check(&mut council_exec, version::current(), EApprovalActionMissing);
    
    let (dao_id, action_type, approved_key, metadata, expires_at) = 
        security_council_actions::get_approve_generic_params(approval);
    
    // Validate approval matches the remove action
    assert!(dao_id == object::id(dao), coexec_common::error_dao_mismatch());
    assert!(*approved_key == *resource_key, EKeyMismatch);
    assert!(*action_type == b"policy_remove".to_string(), EActionTypeMismatch);
    assert!(clock.timestamp_ms() < expires_at, coexec_common::error_expired());
    
    // Verify the policy exists and is for this council
    let registry = policy_registry::borrow_registry(dao, version::current());
    assert!(policy_registry::has_policy(registry, *resource_key), coexec_common::error_no_policy());
    let policy = policy_registry::get_policy(registry, *resource_key);
    assert!(policy_registry::policy_account_id(policy) == object::id(council), EPolicyMismatch);
    
    // Execute the removal
    let dao_id = object::id(dao);
    let registry_mut = policy_registry::borrow_registry_mut(dao, version::current());
    policy_registry::remove_policy(registry_mut, dao_id, *resource_key);
    
    // Record the council approval for this intent
    let intent_key = executable::intent(&futarchy_exec).key();
    let generic_approval = futarchy_config::new_policy_removal_approval(
        object::id(dao),
        *resource_key,
        expires_at,
        ctx
    );
    futarchy_config::record_council_approval_generic(
        dao,
        intent_key,
        generic_approval,
        ctx
    );
    
    // Confirm both executables atomically
    coexec_common::confirm_both_executables(dao, council, futarchy_exec, council_exec);
}

/// Execute policy set/update requiring 2-of-2: futarchy + council.
/// For setting a critical policy:
/// - Futarchy executable must contain SetPolicyAction
/// - Council executable must contain ApprovePolicyChangeAction with matching params
/// Both executables are confirmed atomically.
public fun execute_set_policy_with_council<FutarchyOutcome: store + drop + copy>(
    dao: &mut Account<FutarchyConfig>,
    council: &mut Account<WeightedMultisig>,
    mut futarchy_exec: Executable<FutarchyOutcome>,
    mut council_exec: Executable<Approvals>,
    clock: &Clock,
    ctx: &mut TxContext,
) {
    // Optional immutability check for OA:Custodian updates
    let cfg = account::config(dao);
    
    // Extract futarchy SetPolicyAction
    let set_action: &policy_actions::SetPolicyAction = 
        coexec_common::extract_action_with_check(&mut futarchy_exec, version::current(), EPolicyActionMissing);
    let (resource_key, policy_account_id, intent_key_prefix) = 
        policy_actions::get_set_policy_params(set_action);
    
    // Verify this is a critical policy
    assert!(is_critical_policy(resource_key), ENotCriticalPolicy);
    
    // Extract council ApproveGenericAction
    let approval: &security_council_actions::ApproveGenericAction = 
        coexec_common::extract_action_with_check(&mut council_exec, version::current(), EApprovalActionMissing);
    
    let (dao_id, action_type, approved_key, metadata, expires_at) = 
        security_council_actions::get_approve_generic_params(approval);
    
    // Validate approval matches the set action
    assert!(dao_id == object::id(dao), coexec_common::error_dao_mismatch());
    assert!(*approved_key == *resource_key, EKeyMismatch);
    assert!(*action_type == b"policy_set".to_string(), EActionTypeMismatch);
    
    // Verify metadata contains the correct policy_account_id and intent_key_prefix
    assert!(metadata.length() == 4, EActionTypeMismatch); // Exactly 2 key-value pairs
    assert!(*metadata.borrow(0) == b"policy_account_id".to_string(), EActionTypeMismatch);
    // Note: We can't easily parse the ID back from hex string in Move
    // So we'll just verify the metadata structure is correct
    // The actual policy_account_id validation happens when setting the policy
    
    assert!(*metadata.borrow(2) == b"intent_key_prefix".to_string(), EActionTypeMismatch);
    assert!(*metadata.borrow(3) == *intent_key_prefix, EActionTypeMismatch);
    
    assert!(clock.timestamp_ms() < expires_at, coexec_common::error_expired());
    
    // Execute the set operation
    let dao_id = object::id(dao);
    let registry_mut = policy_registry::borrow_registry_mut(dao, version::current());
    policy_registry::set_policy(
        registry_mut,
        dao_id,
        *resource_key,
        policy_account_id,
        *intent_key_prefix
    );
    
    // Record the council approval for this intent
    let intent_key = executable::intent(&futarchy_exec).key();
    let generic_approval = futarchy_config::new_policy_set_approval(
        object::id(dao),
        *resource_key,
        policy_account_id,
        *intent_key_prefix,
        expires_at,
        ctx
    );
    futarchy_config::record_council_approval_generic(
        dao,
        intent_key,
        generic_approval,
        ctx
    );
    
    // Confirm both executables atomically
    coexec_common::confirm_both_executables(dao, council, futarchy_exec, council_exec);
}/// Common utilities and patterns for 2-of-2 co-execution between DAO and Security Council
module futarchy::coexec_common;

use std::string::String;
use sui::{
    clock::Clock,
    object::{Self, ID},
};
use account_protocol::{
    account::Account,
    executable::Executable,
};
use futarchy::{
    version,
    policy_registry,
    futarchy_config::FutarchyConfig,
    weighted_multisig::WeightedMultisig,
};

// === Common Error Codes ===
const ENoPolicy: u64 = 1;
const EWrongCouncil: u64 = 2;
const EWrongDao: u64 = 3;
const EExpired: u64 = 4;
const EDigestMismatch: u64 = 5;
const EActionTypeMismatch: u64 = 6;
const EMetadataMissing: u64 = 7;
const EDAOMismatch: u64 = 8;

// === Policy Validation ===

/// Verify that a DAO has a specific custodian policy set to the given council
/// Returns true if policy exists and points to the council, false otherwise
public fun verify_custodian_policy(
    dao: &Account<FutarchyConfig>,
    council: &Account<WeightedMultisig>,
    policy_key: String,
): bool {
    let reg = policy_registry::borrow_registry(dao, version::current());
    if (!policy_registry::has_policy(reg, policy_key)) {
        return false
    };
    let pol = policy_registry::get_policy(reg, policy_key);
    policy_registry::policy_account_id(pol) == object::id(council)
}

/// Assert that a DAO has a specific custodian policy set to the given council
/// Aborts with ENoPolicy if policy doesn't exist or EWrongCouncil if it points elsewhere
public fun enforce_custodian_policy(
    dao: &Account<FutarchyConfig>,
    council: &Account<WeightedMultisig>,
    policy_key: String,
) {
    let reg = policy_registry::borrow_registry(dao, version::current());
    assert!(policy_registry::has_policy(reg, policy_key), ENoPolicy);
    let pol = policy_registry::get_policy(reg, policy_key);
    assert!(policy_registry::policy_account_id(pol) == object::id(council), EWrongCouncil);
}

// === Common Validation Helpers ===

/// Validate that the DAO ID matches expected
public fun validate_dao_id(expected: ID, actual: ID) {
    assert!(expected == actual, EWrongDao);
}

/// Validate that current time hasn't exceeded expiry
public fun validate_expiry(clock: &Clock, expires_at: u64) {
    assert!(clock.timestamp_ms() < expires_at, EExpired);
}

/// Validate that two digests match
public fun validate_digest(expected: &vector<u8>, actual: &vector<u8>) {
    assert!(*expected == *actual, EDigestMismatch);
}

// === Executable Confirmation ===

/// Confirm both DAO and council executables atomically
/// This ensures both sides of the co-execution are committed together
public fun confirm_both_executables<DaoOutcome: store + drop, CouncilOutcome: store + drop>(
    dao: &mut Account<FutarchyConfig>,
    council: &mut Account<WeightedMultisig>,
    dao_exec: Executable<DaoOutcome>,
    council_exec: Executable<CouncilOutcome>,
) {
    account_protocol::account::confirm_execution(dao, dao_exec);
    account_protocol::account::confirm_execution(council, council_exec);
}

// === Action Extraction Helpers ===

/// Generic helper to check if an action exists and extract it
/// This pattern is common across all co-exec modules
public fun extract_action_with_check<Outcome: store, Action: store, W: drop>(
    executable: &mut account_protocol::executable::Executable<Outcome>,
    witness: W,
    error_code: u64,
): &Action {
    use account_protocol::executable;
    assert!(executable::contains_action<Outcome, Action>(executable), error_code);
    executable::next_action(executable, witness)
}

/// Extract an action without checking if it exists first
/// Use when you're certain the action is present
public fun extract_action<Outcome: store, Action: store, W: drop>(
    executable: &mut account_protocol::executable::Executable<Outcome>,
    witness: W,
): &Action {
    account_protocol::executable::next_action(executable, witness)
}

// === Common Co-Execution Pattern ===

/// Standard validation flow for co-execution:
/// 1. Enforce policy
/// 2. Extract and validate actions
/// 3. Check DAO ID, expiry, and digest
/// This encapsulates the common pattern used across all co-exec modules
public fun validate_coexec_standard(
    dao: &Account<FutarchyConfig>,
    council: &Account<WeightedMultisig>,
    policy_key: String,
    dao_id_from_action: ID,
    expires_at: u64,
    expected_digest: &vector<u8>,
    actual_digest: &vector<u8>,
    clock: &Clock,
) {
    // Enforce the policy
    enforce_custodian_policy(dao, council, policy_key);
    
    // Validate all standard requirements
    validate_dao_id(dao_id_from_action, object::id(dao));
    validate_expiry(clock, expires_at);
    validate_digest(expected_digest, actual_digest);
}

// === Getters for Error Codes (for external modules) ===

public fun error_no_policy(): u64 { ENoPolicy }
public fun error_wrong_council(): u64 { EWrongCouncil }
public fun error_wrong_dao(): u64 { EWrongDao }
public fun error_expired(): u64 { EExpired }
public fun error_digest_mismatch(): u64 { EDigestMismatch }
public fun error_action_type_mismatch(): u64 { EActionTypeMismatch }
public fun error_metadata_missing(): u64 { EMetadataMissing }
public fun error_dao_mismatch(): u64 { EDAOMismatch }/// Factory for creating futarchy DAOs using account_protocol
/// This is the main entry point for creating DAOs in the Futarchy protocol
module futarchy::factory;

// === Imports ===
use std::{
    string::{String as UTF8String},
    ascii::String as AsciiString,
    type_name::{Self, TypeName},
    option::{Self, Option},
};
use sui::{
    clock::Clock,
    coin::{Self, Coin, TreasuryCap},
    event,
    object::{Self, ID, UID},
    sui::SUI,
    vec_set::{Self, VecSet},
    transfer,
    url,
};
use account_protocol::{
    account::{Self, Account},
};
use account_extensions::extensions::Extensions;
use account_actions::currency;
use futarchy::{
    futarchy_config::{Self, FutarchyConfig, ConfigParams},
    dao_config,
    futarchy_vault_init,
    fee::{Self, FeeManager},
    priority_queue::{Self, ProposalQueue},
    account_spot_pool::{Self, AccountSpotPool},
    version,
    policy_registry,
};

// === Errors ===
const EPaused: u64 = 1;
const EStableTypeNotAllowed: u64 = 2;
const EBadWitness: u64 = 3;
const EHighTwapThreshold: u64 = 4;
const ELowTwapWindowCap: u64 = 5;
const ELongTradingTime: u64 = 6;
const ELongReviewTime: u64 = 7;
const ELongTwapDelayTime: u64 = 8;
const ETwapInitialTooLarge: u64 = 9;
const EDelayNearTotalTrading: u64 = 10;

// === Constants ===
const TWAP_MINIMUM_WINDOW_CAP: u64 = 1;
const MAX_TRADING_TIME: u64 = 604_800_000; // 7 days in ms
const MAX_REVIEW_TIME: u64 = 604_800_000; // 7 days in ms
const MAX_TWAP_START_DELAY: u64 = 86_400_000; // 1 day in ms
const MAX_TWAP_THRESHOLD: u64 = 1_000_000; // 10x increase required to pass

// === Structs ===

/// One-time witness for factory initialization
public struct FACTORY has drop {}

/// Factory for creating futarchy DAOs
public struct Factory has key, store {
    id: UID,
    dao_count: u64,
    paused: bool,
    owner_cap_id: ID,
    allowed_stable_types: VecSet<TypeName>,
}

/// Admin capability for factory operations
public struct FactoryOwnerCap has key, store {
    id: UID,
}

/// Validator capability for DAO verification
public struct ValidatorAdminCap has key, store {
    id: UID,
}

// === Events ===

public struct DAOCreated has copy, drop {
    account_id: address,
    dao_name: AsciiString,
    asset_type: UTF8String,
    stable_type: UTF8String,
    creator: address,
    timestamp: u64,
}

public struct StableCoinTypeAdded has copy, drop {
    type_str: UTF8String,
    admin: address,
    timestamp: u64,
}

public struct StableCoinTypeRemoved has copy, drop {
    type_str: UTF8String,
    admin: address,
    timestamp: u64,
}

// === Internal Helper Functions ===
// Note: Action registry removed - using statically-typed pattern like move-framework

// Test helpers removed - no longer needed without action registry

// === Public Functions ===

fun init(witness: FACTORY, ctx: &mut TxContext) {
    assert!(sui::types::is_one_time_witness(&witness), EBadWitness);
    
    let owner_cap = FactoryOwnerCap {
        id: object::new(ctx),
    };
    
    let factory = Factory {
        id: object::new(ctx),
        dao_count: 0,
        paused: false,
        owner_cap_id: object::id(&owner_cap),
        allowed_stable_types: vec_set::empty<TypeName>(),
    };
    
    let validator_cap = ValidatorAdminCap {
        id: object::new(ctx),
    };
    
    transfer::share_object(factory);
    transfer::public_transfer(owner_cap, ctx.sender());
    transfer::public_transfer(validator_cap, ctx.sender());
}

/// Create a new futarchy DAO with Extensions
public entry fun create_dao<AssetType: drop, StableType>(
    factory: &mut Factory,
    extensions: &Extensions,
    fee_manager: &mut FeeManager,
    payment: Coin<SUI>,
    min_asset_amount: u64,
    min_stable_amount: u64,
    dao_name: AsciiString,
    icon_url_string: AsciiString,
    review_period_ms: u64,
    trading_period_ms: u64,
    twap_start_delay: u64,
    twap_step_max: u64,
    twap_initial_observation: u128,
    twap_threshold: u64,
    amm_total_fee_bps: u64,
    description: UTF8String,
    max_outcomes: u64,
    _agreement_lines: vector<UTF8String>,
    _agreement_difficulties: vector<u64>,
    clock: &Clock,
    ctx: &mut TxContext,
) {
    create_dao_internal_with_extensions<AssetType, StableType>(
        factory,
        extensions,
        fee_manager,
        payment,
        min_asset_amount,
        min_stable_amount,
        dao_name,
        icon_url_string,
        review_period_ms,
        trading_period_ms,
        twap_start_delay,
        twap_step_max,
        twap_initial_observation,
        twap_threshold,
        amm_total_fee_bps,
        description,
        max_outcomes,
        _agreement_lines,
        _agreement_difficulties,
        option::none(),
        clock,
        ctx,
    );
}

/// Internal function to create a DAO with Extensions and optional TreasuryCap
#[allow(lint(share_owned))]
public(package) fun create_dao_internal_with_extensions<AssetType: drop, StableType>(
    factory: &mut Factory,
    extensions: &Extensions,
    fee_manager: &mut FeeManager,
    payment: Coin<SUI>,
    min_asset_amount: u64,
    min_stable_amount: u64,
    dao_name: AsciiString,
    icon_url_string: AsciiString,
    review_period_ms: u64,
    trading_period_ms: u64,
    twap_start_delay: u64,
    twap_step_max: u64,
    twap_initial_observation: u128,
    twap_threshold: u64,
    amm_total_fee_bps: u64,
    description: UTF8String,
    max_outcomes: u64,
    _agreement_lines: vector<UTF8String>,
    _agreement_difficulties: vector<u64>,
    mut treasury_cap: Option<TreasuryCap<AssetType>>,
    clock: &Clock,
    ctx: &mut TxContext,
) {
    // Check factory is active
    assert!(!factory.paused, EPaused);
    
    // Check if StableType is allowed
    let stable_type_name = type_name::get<StableType>();
    assert!(factory.allowed_stable_types.contains(&stable_type_name), EStableTypeNotAllowed);
    
    // Process payment
    fee::deposit_dao_creation_payment(fee_manager, payment, clock, ctx);
    
    // Validate parameters
    assert!(twap_step_max >= TWAP_MINIMUM_WINDOW_CAP, ELowTwapWindowCap);
    assert!(review_period_ms <= MAX_REVIEW_TIME, ELongReviewTime);
    assert!(trading_period_ms <= MAX_TRADING_TIME, ELongTradingTime);
    assert!(twap_start_delay <= MAX_TWAP_START_DELAY, ELongTwapDelayTime);
    assert!((twap_start_delay + 60_000) < trading_period_ms, EDelayNearTotalTrading);
    assert!(twap_threshold <= MAX_TWAP_THRESHOLD, EHighTwapThreshold);
    assert!(
        twap_initial_observation <= (18446744073709551615u128) * 1_000_000_000_000,
        ETwapInitialTooLarge,
    );
    
    // Create config parameters using the new structured approach
    let config_params = futarchy_config::new_config_params_from_values(
        min_asset_amount,
        min_stable_amount,
        review_period_ms,
        trading_period_ms,
        twap_start_delay,
        twap_step_max,
        twap_initial_observation,
        twap_threshold,
        amm_total_fee_bps,
        max_outcomes,
        1000000, // proposal_fee_per_outcome (1 token per outcome)
        50, // max_concurrent_proposals
        100_000_000, // required_bond_amount
        2_592_000_000, // proposal_recreation_window_ms (30 days default)
        5, // max_proposal_chain_depth
        100, // fee_escalation_basis_points
        dao_name,
        url::new_unsafe(icon_url_string),
        description,
    );
    
    // --- Phase 1: Create all objects in memory (no sharing) ---

    // Create fee manager for this DAO
    let _dao_fee_manager_id = object::id(fee_manager); // Use factory fee manager for now
    
    // Create the spot pool but do not share it yet.
    let spot_pool = account_spot_pool::new<AssetType, StableType>(
        amm_total_fee_bps,
        ctx
    );
    let spot_pool_id = object::id(&spot_pool);
    
    // Create the futarchy configuration
    let mut config = futarchy_config::new<AssetType, StableType>(
        config_params,
        ctx
    );
    
    // Set additional fields that aren't in the constructor
    futarchy_config::set_proposal_queue_id(&mut config, option::none());
    futarchy_config::set_spot_pool_id(&mut config, spot_pool_id);
    futarchy_config::set_dao_pool_id(&mut config, spot_pool_id);
    
    // Create the account with Extensions registry validation for security
    let mut account = futarchy_config::new_account_with_extensions(extensions, config, ctx);
    
    // Get eviction grace period from config for the queue
    let eviction_grace_period_ms = futarchy_config::eviction_grace_period_ms(account::config(&account));
    
    // Now create the priority queue but do not share it yet.
    let queue = priority_queue::new<StableType>(
        object::id(&account), // dao_id
        30, // max_proposer_funded
        50, // max_concurrent_proposals
        eviction_grace_period_ms,
        ctx
    );
    let priority_queue_id = object::id(&queue);
    
    // --- Phase 2: Configure the objects and link them together ---

    // Note: DAO liquidity pool is not used in the new architecture
    // The spot pool handles all liquidity needs
    
    // Update the config with the actual priority queue ID
    let config_mut = futarchy_config::internal_config_mut(&mut account);
    futarchy_config::set_proposal_queue_id(config_mut, option::some(priority_queue_id));
    
    // Action registry removed - using statically-typed pattern
    
    // Initialize the policy registry
    policy_registry::initialize(&mut account, version::current(), ctx);
    
    // Initialize the vault
    futarchy_vault_init::initialize(&mut account, version::current(), ctx);
    
    // If treasury cap provided, lock it using Move framework's currency module
    if (treasury_cap.is_some()) {
        let cap = treasury_cap.extract();
        // Use Move framework's currency::lock_cap for proper treasury cap storage
        // This ensures atomic borrowing and proper permissions management
        let auth = futarchy_config::authenticate(&account, ctx);
        currency::lock_cap(
            auth,
            &mut account,
            cap,
            option::none() // No max supply limit for now
        );
    };
    // Destroy the empty option
    treasury_cap.destroy_none();
    
    // Get account ID before sharing
    let account_id = object::id_address(&account);
    
    // --- Phase 3: Final Atomic Sharing ---
    // All objects are shared at the end of the function. If any step above failed,
    // the transaction would abort and no objects would be created.
    transfer::public_share_object(account);
    account_spot_pool::share(spot_pool);
    transfer::public_share_object(queue);
    
    // --- Phase 4: Update Factory State and Emit Event ---

    // Update factory state
    factory.dao_count = factory.dao_count + 1;
    
    // Emit event
    event::emit(DAOCreated {
        account_id,
        dao_name,
        asset_type: get_type_string<AssetType>(),
        stable_type: get_type_string<StableType>(),
        creator: ctx.sender(),
        timestamp: clock.timestamp_ms(),
    });
}

#[test_only]
/// Internal function to create a DAO for testing without Extensions
fun create_dao_internal_test<AssetType: drop, StableType>(
    factory: &mut Factory,
    fee_manager: &mut FeeManager,
    payment: Coin<SUI>,
    min_asset_amount: u64,
    min_stable_amount: u64,
    dao_name: AsciiString,
    icon_url_string: AsciiString,
    review_period_ms: u64,
    trading_period_ms: u64,
    twap_start_delay: u64,
    twap_step_max: u64,
    twap_initial_observation: u128,
    twap_threshold: u64,
    amm_total_fee_bps: u64,
    description: UTF8String,
    max_outcomes: u64,
    _agreement_lines: vector<UTF8String>,
    _agreement_difficulties: vector<u64>,
    mut treasury_cap: Option<TreasuryCap<AssetType>>,
    clock: &Clock,
    ctx: &mut TxContext,
) {
    // Check factory is active
    assert!(!factory.paused, EPaused);
    
    // Check if StableType is allowed
    let stable_type_name = type_name::get<StableType>();
    assert!(factory.allowed_stable_types.contains(&stable_type_name), EStableTypeNotAllowed);
    
    // Process payment
    fee::deposit_dao_creation_payment(fee_manager, payment, clock, ctx);
    
    // Validate parameters
    assert!(twap_step_max >= TWAP_MINIMUM_WINDOW_CAP, ELowTwapWindowCap);
    assert!(review_period_ms <= MAX_REVIEW_TIME, ELongReviewTime);
    assert!(trading_period_ms <= MAX_TRADING_TIME, ELongTradingTime);
    assert!(twap_start_delay <= MAX_TWAP_START_DELAY, ELongTwapDelayTime);
    assert!((twap_start_delay + 60_000) < trading_period_ms, EDelayNearTotalTrading);
    assert!(twap_threshold <= MAX_TWAP_THRESHOLD, EHighTwapThreshold);
    assert!(
        twap_initial_observation <= (18446744073709551615u128) * 1_000_000_000_000,
        ETwapInitialTooLarge,
    );
    
    // Create config parameters using the new structured approach
    let config_params = futarchy_config::new_config_params_from_values(
        min_asset_amount,
        min_stable_amount,
        review_period_ms,
        trading_period_ms,
        twap_start_delay,
        twap_step_max,
        twap_initial_observation,
        twap_threshold,
        amm_total_fee_bps,
        max_outcomes,
        1000000, // proposal_fee_per_outcome (1 token per outcome)
        50, // max_concurrent_proposals
        100_000_000, // required_bond_amount
        2_592_000_000, // proposal_recreation_window_ms (30 days default)
        5, // max_proposal_chain_depth
        100, // fee_escalation_basis_points
        dao_name,
        url::new_unsafe(icon_url_string),
        description,
    );
    
    // --- Phase 1: Create all objects in memory (no sharing) ---

    // Create fee manager for this DAO
    let _dao_fee_manager_id = object::id(fee_manager); // Use factory fee manager for now
    
    // Create the spot pool but do not share it yet.
    let spot_pool = account_spot_pool::new<AssetType, StableType>(
        amm_total_fee_bps,
        ctx
    );
    let spot_pool_id = object::id(&spot_pool);
    
    // Create the futarchy configuration
    let mut config = futarchy_config::new<AssetType, StableType>(
        config_params,
        ctx
    );
    
    // Set additional fields that aren't in the constructor
    futarchy_config::set_proposal_queue_id(&mut config, option::none());
    futarchy_config::set_spot_pool_id(&mut config, spot_pool_id);
    futarchy_config::set_dao_pool_id(&mut config, spot_pool_id);
    
    // Create the account using test function
    let mut account = futarchy_config::new_account_test(config, ctx);
    
    // Get eviction grace period from config for the queue
    let eviction_grace_period_ms = futarchy_config::eviction_grace_period_ms(account::config(&account));
    
    // Now create the priority queue but do not share it yet.
    let queue = priority_queue::new<StableType>(
        object::id(&account), // dao_id
        30, // max_proposer_funded
        50, // max_concurrent_proposals
        eviction_grace_period_ms,
        ctx
    );
    let priority_queue_id = object::id(&queue);
    
    // --- Phase 2: Configure the objects and link them together ---

    // Update the config with the actual priority queue ID
    let config_mut = futarchy_config::internal_config_mut_test(&mut account);
    futarchy_config::set_proposal_queue_id(config_mut, option::some(priority_queue_id));
    
    // Action registry removed - using statically-typed pattern
    
    // Initialize the vault (test version uses @account_protocol witness)
    {
        use account_protocol::version_witness;
        futarchy_vault_init::initialize(
            &mut account, 
            version_witness::new_for_testing(@account_protocol), 
            ctx
        );
    };
    
    // If treasury cap provided, lock it using Move framework's currency module
    if (treasury_cap.is_some()) {
        let cap = treasury_cap.extract();
        // Use Move framework's currency::lock_cap for proper treasury cap storage
        // This ensures atomic borrowing and proper permissions management
        let auth = futarchy_config::authenticate(&account, ctx);
        currency::lock_cap(
            auth,
            &mut account,
            cap,
            option::none() // No max supply limit for now
        );
    };
    // Destroy the empty option
    treasury_cap.destroy_none();
    
    // Get account ID before sharing
    let account_id = object::id_address(&account);
    
    // --- Phase 3: Final Atomic Sharing ---
    // All objects are shared at the end of the function. If any step above failed,
    // the transaction would abort and no objects would be created.
    transfer::public_share_object(account);
    account_spot_pool::share(spot_pool);
    transfer::public_share_object(queue);
    
    // --- Phase 4: Update Factory State and Emit Event ---

    // Update factory state
    factory.dao_count = factory.dao_count + 1;
    
    // Emit event
    event::emit(DAOCreated {
        account_id,
        dao_name,
        asset_type: get_type_string<AssetType>(),
        stable_type: get_type_string<StableType>(),
        creator: ctx.sender(),
        timestamp: clock.timestamp_ms(),
    });
}

// === Admin Functions ===

/// Toggle factory pause state
public entry fun toggle_pause(factory: &mut Factory, cap: &FactoryOwnerCap) {
    assert!(object::id(cap) == factory.owner_cap_id, EBadWitness);
    factory.paused = !factory.paused;
}

/// Add an allowed stable coin type
public entry fun add_allowed_stable_type<StableType>(
    factory: &mut Factory,
    owner_cap: &FactoryOwnerCap,
    clock: &Clock,
    ctx: &mut TxContext,
) {
    assert!(object::id(owner_cap) == factory.owner_cap_id, EBadWitness);
    let type_name_val = type_name::get<StableType>();
    
    if (!factory.allowed_stable_types.contains(&type_name_val)) {
        factory.allowed_stable_types.insert(type_name_val);
        
        event::emit(StableCoinTypeAdded {
            type_str: get_type_string<StableType>(),
            admin: ctx.sender(),
            timestamp: clock.timestamp_ms(),
        });
    }
}

/// Remove an allowed stable coin type
public entry fun remove_allowed_stable_type<StableType>(
    factory: &mut Factory,
    owner_cap: &FactoryOwnerCap,
    clock: &Clock,
    ctx: &mut TxContext,
) {
    assert!(object::id(owner_cap) == factory.owner_cap_id, EBadWitness);
    let type_name_val = type_name::get<StableType>();
    if (factory.allowed_stable_types.contains(&type_name_val)) {
        factory.allowed_stable_types.remove(&type_name_val);
        
        event::emit(StableCoinTypeRemoved {
            type_str: get_type_string<StableType>(),
            admin: ctx.sender(),
            timestamp: clock.timestamp_ms(),
        });
    }
}

/// Burn the factory owner cap
public entry fun burn_factory_owner_cap(factory: &Factory, cap: FactoryOwnerCap) {
    // It is good practice to check ownership one last time before burning,
    // even though only the owner can call this.
    assert!(object::id(&cap) == factory.owner_cap_id, EBadWitness);
    let FactoryOwnerCap { id } = cap;
    id.delete();
}

// === View Functions ===

/// Get DAO count
public fun dao_count(factory: &Factory): u64 {
    factory.dao_count
}

/// Check if factory is paused
public fun is_paused(factory: &Factory): bool {
    factory.paused
}

/// Check if a stable type is allowed
public fun is_stable_type_allowed<StableType>(factory: &Factory): bool {
    let type_name_val = type_name::get<StableType>();
    factory.allowed_stable_types.contains(&type_name_val)
}

// === Private Functions ===

fun get_type_string<T>(): UTF8String {
    let type_name_obj = type_name::get_with_original_ids<T>();
    let type_str = type_name_obj.into_string().into_bytes();
    type_str.to_string()
}

// === Test Functions ===

#[test_only]
public fun create_factory(ctx: &mut TxContext) {
    let owner_cap = FactoryOwnerCap {
        id: object::new(ctx),
    };
    
    let factory = Factory {
        id: object::new(ctx),
        dao_count: 0,
        paused: false,
        owner_cap_id: object::id(&owner_cap),
        allowed_stable_types: vec_set::empty<TypeName>(),
    };
    
    let validator_cap = ValidatorAdminCap {
        id: object::new(ctx),
    };
    
    transfer::share_object(factory);
    transfer::public_transfer(owner_cap, ctx.sender());
    transfer::public_transfer(validator_cap, ctx.sender());
}

#[test_only]
/// Create a DAO for testing without Extensions
public entry fun create_dao_test<AssetType: drop, StableType>(
    factory: &mut Factory,
    fee_manager: &mut FeeManager,
    payment: Coin<SUI>,
    min_asset_amount: u64,
    min_stable_amount: u64,
    dao_name: AsciiString,
    icon_url_string: AsciiString,
    review_period_ms: u64,
    trading_period_ms: u64,
    twap_start_delay: u64,
    twap_step_max: u64,
    twap_initial_observation: u128,
    twap_threshold: u64,
    amm_total_fee_bps: u64,
    description: UTF8String,
    max_outcomes: u64,
    _agreement_lines: vector<UTF8String>,
    _agreement_difficulties: vector<u64>,
    clock: &Clock,
    ctx: &mut TxContext,
) {
    // For testing, we bypass the Extensions requirement
    // by directly calling the test internal function
    create_dao_internal_test<AssetType, StableType>(
        factory,
        fee_manager,
        payment,
        min_asset_amount,
        min_stable_amount,
        dao_name,
        icon_url_string,
        review_period_ms,
        trading_period_ms,
        twap_start_delay,
        twap_step_max,
        twap_initial_observation,
        twap_threshold,
        amm_total_fee_bps,
        description,
        max_outcomes,
        _agreement_lines,
        _agreement_difficulties,
        option::none(),
        clock,
        ctx,
    );
}/// Module to handle founder rewards setup during launchpad DAO creation
module futarchy::launchpad_rewards;

use std::string::{Self, String};
use std::vector;
use std::option::{Self, Option};
use sui::coin::TreasuryCap;
use sui::clock::Clock;
use sui::tx_context::TxContext;
use futarchy::{
    oracle_actions::{Self, TieredMintAction},
};

// === Errors ===
const EInvalidFounderAllocation: u64 = 1;
const EInvalidPriceRatio: u64 = 2;

// === Constants ===
const MAX_FOUNDER_ALLOCATION_BPS: u64 = 2000; // Max 20% for founders

/// Set up founder rewards as pre-approved oracle actions on the newly created DAO
/// This is called automatically during launchpad DAO creation
public fun setup_founder_rewards<AssetType>(
    treasury_cap: &TreasuryCap<AssetType>,
    founder_address: address,
    founder_allocation_bps: u64,
    min_price_ratio: u64, // e.g., 2e9 = 2x
    max_price_ratio: u64, // e.g., 10e9 = 10x  
    unlock_delay_ms: u64,
    linear_vesting: bool,
    clock: &Clock,
    ctx: &mut TxContext,
): TieredMintAction<AssetType> {
    // Validate parameters
    assert!(founder_allocation_bps <= MAX_FOUNDER_ALLOCATION_BPS, EInvalidFounderAllocation);
    assert!(min_price_ratio > 0 && max_price_ratio >= min_price_ratio, EInvalidPriceRatio);
    
    let total_supply = treasury_cap.total_supply();
    let founder_allocation = (total_supply * founder_allocation_bps) / 10000;
    
    // Always use tiered mints (simpler, more flexible)
    setup_tiered_founder_rewards<AssetType>(
        founder_address,
        founder_allocation,
        min_price_ratio,
        max_price_ratio,
        unlock_delay_ms,
        linear_vesting,
        clock,
        ctx
    )
}

/// Set up tiered founder rewards
fun setup_tiered_founder_rewards<AssetType>(
    founder_address: address,
    total_allocation: u64,
    min_price_ratio: u64,
    max_price_ratio: u64,
    unlock_delay_ms: u64,
    linear_vesting: bool,
    clock: &Clock,
    ctx: &mut TxContext,
): TieredMintAction<AssetType> {
    // Create either multiple tiers (linear) or single tier (cliff)
    let num_tiers = if (linear_vesting) { 5u64 } else { 1u64 };
    let mut price_thresholds = vector::empty<u128>();
    let mut recipients_per_tier = vector::empty<vector<address>>();
    let mut amounts_per_tier = vector::empty<vector<u64>>();
    let mut descriptions = vector::empty<String>();
    let mut is_above_thresholds = vector::empty<bool>();
    
    let price_step = (max_price_ratio - min_price_ratio) / (num_tiers - 1);
    let amount_per_tier = total_allocation / num_tiers;
    
    let mut i = 0;
    while (i < num_tiers) {
        // Calculate price threshold for this tier
        let price_ratio = min_price_ratio + (price_step * i);
        // Convert from 1e9 to 1e12 scale for oracle
        let threshold = (price_ratio as u128) * 1000;
        price_thresholds.push_back(threshold);
        
        // Single recipient per tier
        let mut recipients = vector::empty<address>();
        recipients.push_back(founder_address);
        recipients_per_tier.push_back(recipients);
        
        // Equal amount per tier
        let mut amounts = vector::empty<u64>();
        amounts.push_back(amount_per_tier);
        amounts_per_tier.push_back(amounts);
        
        // Description
        let tier_name = if (i == 0) {
            string::utf8(b"Initial milestone")
        } else if (i == num_tiers - 1) {
            string::utf8(b"Final milestone")  
        } else {
            string::utf8(b"Progress milestone")
        };
        descriptions.push_back(tier_name);
        
        // All tiers are "above" thresholds
        is_above_thresholds.push_back(true);
        
        i = i + 1;
    };
    
    let current_time = clock.timestamp_ms();
    let earliest_time = current_time + unlock_delay_ms;
    let latest_time = earliest_time + (5 * 365 * 24 * 60 * 60 * 1000); // 5 years
    
    // Build PriceTier objects
    let mut tiers = vector::empty<oracle_actions::PriceTier>();
    let mut i = 0;
    while (i < vector::length(&price_thresholds)) {
        let mut recipients = vector::empty<oracle_actions::RecipientMint>();
        let tier_recipients = vector::borrow(&recipients_per_tier, i);
        let tier_amounts = vector::borrow(&amounts_per_tier, i);
        
        let mut j = 0;
        while (j < vector::length(tier_recipients)) {
            vector::push_back(&mut recipients, oracle_actions::new_recipient_mint(
                *vector::borrow(tier_recipients, j),
                *vector::borrow(tier_amounts, j)
            ));
            j = j + 1;
        };
        
        vector::push_back(&mut tiers, oracle_actions::new_price_tier(
            *vector::borrow(&price_thresholds, i),
            *vector::borrow(&is_above_thresholds, i),
            recipients,
            *vector::borrow(&descriptions, i)
        ));
        i = i + 1;
    };
    
    // Create the tiered mint action
    let tiered_action = oracle_actions::new_tiered_mint<AssetType>(
        tiers,
        earliest_time,
        latest_time,
        string::utf8(b"Founder vesting rewards"),
        option::none(), // No security council ID
    );
    
    // Return the action to be added to the DAO's initial intents
    tiered_action
}module futarchy::launchpad;

use std::ascii;
use std::string::{String};
use std::type_name;
use std::option::{Self as option, Option};
use std::vector;
use sui::balance::{Self, Balance};
use sui::coin::{Self, Coin, TreasuryCap};
use sui::clock::{Clock};
use sui::event;
use sui::dynamic_field as df;
use sui::object::{Self, UID, ID};
use sui::tx_context::TxContext;
use futarchy::factory;
use futarchy::fee;
use futarchy::math;
use account_extensions::extensions::Extensions;

// === Errors ===
const ERaiseStillActive: u64 = 0;
const ERaiseNotActive: u64 = 1;
const EDeadlineNotReached: u64 = 2;
const EMinRaiseNotMet: u64 = 3;
const EMinRaiseAlreadyMet: u64 = 4;
const ENotAContributor: u64 = 6;
const EInvalidStateForAction: u64 = 7;
const EWrongTotalSupply: u64 = 9;
const EReentrancy: u64 = 10;
const EArithmeticOverflow: u64 = 11;
const ENotUSDC: u64 = 12;
const EZeroContribution: u64 = 13;
const EStableTypeNotAllowed: u64 = 14;
const ENotTheCreator: u64 = 15;
const ESettlementNotStarted: u64 = 101;
const ESettlementInProgress: u64 = 102;
const ESettlementAlreadyDone: u64 = 103;
const ENotEligibleForTokens: u64 = 104;
const ECapChangeAfterDeadline: u64 = 105;
const ECapHeapInvariant: u64 = 106;
const ESettlementAlreadyStarted: u64 = 107;
const EInvalidSettlementState: u64 = 108;

// === Constants ===
/// The duration for every raise is fixed. 14 days in milliseconds.
const LAUNCHPAD_DURATION_MS: u64 = 1_209_600_000;
/// A fixed period after a successful raise for contributors to claim tokens
/// before the creator can sweep any remaining dust. 14 days in milliseconds.
const CLAIM_PERIOD_DURATION_MS: u64 = 1_209_600_000;

const STATE_FUNDING: u8 = 0;
const STATE_SUCCESSFUL: u8 = 1;
const STATE_FAILED: u8 = 2;

const DEFAULT_AMM_TOTAL_FEE_BPS: u64 = 30; // 0.3% default AMM fee

// === Structs ===

/// A one-time witness for module initialization
public struct LAUNCHPAD has drop {}

// === IMPORTANT: Stable Coin Integration ===
// This module supports any stable coin that has been allowed by the factory.
// The creator of a raise sets the minimum raise amount for that specific launchpad.
// 
// Common stable coins and their addresses:
// - USDC Mainnet: 0xdba34672e30cb065b1f93e3ab55318768fd6fef66c15942c9f7cb846e2f900e7::usdc::USDC
// - USDC Testnet: 0xa1ec7fc00a6f40db9693ad1415d0c193ad3906494428cf252621037bd7117e29::usdc::USDC
// 
// To add a new stable coin type that can be used in launchpads, use factory::add_allowed_stable_type.

// === Scalability Design ===
// This launchpad uses dynamic fields instead of tables for contributor storage.
// Benefits:
// - No hard limits on number of contributors (can handle 100,000+ easily)
// - Each contributor's data is stored separately, improving gas efficiency
// - Supports large raises ($10M+) with many small contributors
// - Only the accessed contributor data is loaded during operations

/// Key type for storing contributor data as dynamic fields
/// This approach allows unlimited contributors without table size constraints
public struct ContributorKey has copy, drop, store {
    contributor: address,
}

/// Per-contributor record with amount and cap
public struct Contribution has store, drop, copy {
    amount: u64,
    max_total: u64, // cap; u64::MAX means "no cap"
}

/// Cap-bin dynamic fields for aggregating contributions by cap
public struct ThresholdKey has copy, drop, store { 
    cap: u64 
}

public struct ThresholdBin has store, drop {
    total: u64,  // sum of amounts for this cap
    count: u64,  // number of contributors with this cap
}

/// Settlement crank state for processing caps
public struct CapSettlement has key, store {
    id: UID,
    raise_id: ID,
    heap: vector<u64>,   // max-heap of caps
    size: u64,           // heap size
    running_sum: u64,    // C_k as we walk from high cap to low
    final_total: u64,    // T* once found
    done: bool,
}


/// Main object for a DAO fundraising launchpad.
/// RaiseToken is the governance token being sold.
/// StableCoin is the currency used for contributions (must be allowed by factory).
public struct Raise<phantom RaiseToken, phantom StableCoin> has key, store {
    id: UID,
    creator: address,
    state: u8,
    total_raised: u64,
    min_raise_amount: u64,
    deadline_ms: u64,
    /// Balance of the token being sold to contributors.
    raise_token_vault: Balance<RaiseToken>,
    /// Amount of tokens being sold.
    tokens_for_sale_amount: u64,
    /// Vault for the stable coins contributed by users.
    stable_coin_vault: Balance<StableCoin>,
    /// Number of unique contributors (contributions stored as dynamic fields)
    contributor_count: u64,
    description: String,
    // All parameters required to create the DAO are stored here.
    dao_params: DAOParameters,
    /// TreasuryCap stored until DAO creation
    treasury_cap: Option<TreasuryCap<RaiseToken>>,
    /// Reentrancy guard flag
    claiming: bool,
    /// Cap-aware accounting
    thresholds: vector<u64>,       // unique caps we've seen
    settlement_done: bool,
    settlement_in_progress: bool,  // Track if settlement has started
    final_total_eligible: u64,     // T* after enforcing caps
}

/// Stores all parameters needed for DAO creation to keep the Raise object clean.
public struct DAOParameters has store, drop, copy {
    dao_name: ascii::String,
    dao_description: String,
    icon_url_string: ascii::String,
    review_period_ms: u64,
    trading_period_ms: u64,
    amm_twap_start_delay: u64,
    amm_twap_step_max: u64,
    amm_twap_initial_observation: u128,
    twap_threshold: u64,
    max_outcomes: u64,
    agreement_lines: vector<String>,
    agreement_difficulties: vector<u64>,
    // Founder reward parameters
    founder_reward_params: Option<FounderRewardParams>,
}

/// Parameters for founder rewards based on price performance
public struct FounderRewardParams has store, drop, copy {
    /// Address to receive founder rewards
    founder_address: address,
    /// Percentage of tokens reserved for founder (in basis points, max 2000 = 20%)
    founder_allocation_bps: u64,
    /// Minimum price ratio to unlock rewards (scaled by 1e9, e.g., 2e9 = 2x)
    min_price_ratio: u64,
    /// Time after which rewards can be claimed (milliseconds from DAO creation)
    unlock_delay_ms: u64,
    /// Whether rewards vest linearly based on price performance
    linear_vesting: bool,
    /// Maximum price ratio for full vesting (if linear_vesting)
    max_price_ratio: u64,
}

// === Events ===

public struct RaiseCreated has copy, drop {
    raise_id: ID,
    creator: address,
    raise_token_type: String,
    stable_coin_type: String,
    min_raise_amount: u64,
    tokens_for_sale: u64,
    deadline_ms: u64,
    description: String,
}

public struct ContributionAdded has copy, drop {
    raise_id: ID,
    contributor: address,
    amount: u64,
    new_total_raised: u64,
}

public struct ContributionAddedCapped has copy, drop {
    raise_id: ID,
    contributor: address,
    amount: u64,
    cap: u64,                // max_total specified
    new_naive_total: u64,    // naive running sum (pre-cap settlement)
}

public struct SettlementStarted has copy, drop {
    raise_id: ID,
    caps_count: u64,
}

public struct SettlementStep has copy, drop {
    raise_id: ID,
    processed_cap: u64,
    added_amount: u64,
    running_sum: u64,
    next_cap: u64,
}

public struct SettlementFinalized has copy, drop {
    raise_id: ID,
    final_total: u64,
}

public struct RaiseSuccessful has copy, drop {
    raise_id: ID,
    total_raised: u64,
}

public struct RaiseFailed has copy, drop {
    raise_id: ID,
    total_raised: u64,
    min_raise_amount: u64,
}

public struct TokensClaimed has copy, drop {
    raise_id: ID,
    contributor: address,
    contribution_amount: u64,
    tokens_claimed: u64,
}

public struct RefundClaimed has copy, drop {
    raise_id: ID,
    contributor: address,
    refund_amount: u64,
}

public struct FounderRewardsConfigured has copy, drop {
    raise_id: ID,
    founder_address: address,
    allocation_bps: u64,
    tiers: u64,
}

// === Init ===

fun init(_witness: LAUNCHPAD, _ctx: &mut TxContext) {
    // No initialization needed for simplified version
}

// === Public Functions ===

/// Create a raise that sells tokens with optional founder rewards.
/// `StableCoin` must be an allowed type in the factory.
public entry fun create_raise_with_founder_rewards<RaiseToken: drop, StableCoin: drop>(
    factory: &factory::Factory,
    treasury_cap: TreasuryCap<RaiseToken>,
    tokens_for_raise: Coin<RaiseToken>,
    min_raise_amount: u64,
    description: String,
    // DAOParameters passed as individual fields for entry function compatibility
    dao_name: ascii::String,
    dao_description: String,
    icon_url_string: ascii::String,
    review_period_ms: u64,
    trading_period_ms: u64,
    amm_twap_start_delay: u64,
    amm_twap_step_max: u64,
    amm_twap_initial_observation: u128,
    twap_threshold: u64,
    max_outcomes: u64,
    agreement_lines: vector<String>,
    agreement_difficulties: vector<u64>,
    // Founder reward parameters
    with_founder_rewards: bool,
    founder_address: address,
    founder_allocation_bps: u64,
    min_price_ratio: u64,
    unlock_delay_ms: u64,
    linear_vesting: bool,
    max_price_ratio: u64,
    clock: &Clock,
    ctx: &mut TxContext,
) {
    // Validate founder reward parameters if enabled
    let founder_params = if (with_founder_rewards) {
        assert!(founder_allocation_bps <= 2000, EInvalidStateForAction); // Max 20%
        assert!(min_price_ratio >= 1_000_000_000, EInvalidStateForAction); // At least 1x
        assert!(max_price_ratio >= min_price_ratio, EInvalidStateForAction);
        
        option::some(FounderRewardParams {
            founder_address,
            founder_allocation_bps,
            min_price_ratio,
            unlock_delay_ms,
            linear_vesting,
            max_price_ratio,
        })
    } else {
        option::none()
    };
    
    // Calculate actual tokens for sale (excluding founder allocation)
    let total_supply = treasury_cap.total_supply();
    let tokens_for_sale_amount = if (with_founder_rewards) {
        // Reserve founder allocation
        let founder_reserve = total_supply * founder_allocation_bps / 10000;
        assert!(tokens_for_raise.value() == total_supply - founder_reserve, EWrongTotalSupply);
        tokens_for_raise.value()
    } else {
        // Full supply for sale
        assert!(tokens_for_raise.value() == total_supply, EWrongTotalSupply);
        tokens_for_raise.value()
    };
    
    // Check that StableCoin is allowed
    assert!(factory::is_stable_type_allowed<StableCoin>(factory), EStableTypeNotAllowed);
    
    let dao_params = DAOParameters {
        dao_name, dao_description, icon_url_string, review_period_ms, trading_period_ms,
        amm_twap_start_delay, amm_twap_step_max, amm_twap_initial_observation,
        twap_threshold, max_outcomes, agreement_lines, agreement_difficulties,
        founder_reward_params: founder_params,
    };
    
    init_raise_with_founder<RaiseToken, StableCoin>(
        treasury_cap, tokens_for_raise, min_raise_amount, description, dao_params, clock, ctx
    );
}

/// Create a raise that sells 100% of the token supply (backward compatibility).
public entry fun create_raise<RaiseToken: drop, StableCoin: drop>(
    factory: &factory::Factory,
    treasury_cap: TreasuryCap<RaiseToken>,
    tokens_for_raise: Coin<RaiseToken>,
    min_raise_amount: u64,
    description: String,
    dao_name: ascii::String,
    dao_description: String,
    icon_url_string: ascii::String,
    review_period_ms: u64,
    trading_period_ms: u64,
    amm_twap_start_delay: u64,
    amm_twap_step_max: u64,
    amm_twap_initial_observation: u128,
    twap_threshold: u64,
    max_outcomes: u64,
    agreement_lines: vector<String>,
    agreement_difficulties: vector<u64>,
    clock: &Clock,
    ctx: &mut TxContext,
) {
    // CRITICAL: Ensure we're selling 100% of the total supply
    assert!(tokens_for_raise.value() == treasury_cap.total_supply(), EWrongTotalSupply);
    
    // Check that StableCoin is allowed
    assert!(factory::is_stable_type_allowed<StableCoin>(factory), EStableTypeNotAllowed);
    
    let dao_params = DAOParameters {
        dao_name, dao_description, icon_url_string, review_period_ms, trading_period_ms,
        amm_twap_start_delay, amm_twap_step_max, amm_twap_initial_observation,
        twap_threshold, max_outcomes, agreement_lines, agreement_difficulties,
        founder_reward_params: option::none(),
    };
    
    init_raise<RaiseToken, StableCoin>(
        treasury_cap, tokens_for_raise, min_raise_amount, description, dao_params, clock, ctx
    );
}

/// Contribute with a cap: max final total raise you accept.
/// cap = u64::max_value() means "no cap".
public entry fun contribute_with_cap<RaiseToken, StableCoin>(
    raise: &mut Raise<RaiseToken, StableCoin>,
    contribution: Coin<StableCoin>,
    cap: u64,
    clock: &Clock,
    ctx: &mut TxContext,
) {
    assert!(raise.state == STATE_FUNDING, ERaiseNotActive);
    assert!(clock.timestamp_ms() < raise.deadline_ms, ERaiseStillActive);

    let contributor = ctx.sender();
    let amount = contribution.value();
    assert!(amount > 0, EZeroContribution);
    
    // SECURITY: Cap must be reasonable (at least the contribution amount)
    assert!(cap >= amount, EInvalidStateForAction);

    // Deposit coins into vault + naive total accounting
    raise.stable_coin_vault.join(contribution.into_balance());
    assert!(raise.total_raised <= std::u64::max_value!() - amount, EArithmeticOverflow);
    raise.total_raised = raise.total_raised + amount;

    // Contributor DF: (amount, max_total)
    let key = ContributorKey { contributor };

    if (df::exists_(&raise.id, key)) {
        let rec: &mut Contribution = df::borrow_mut(&mut raise.id, key);
        // SECURITY: For existing contributors, cap must match or use update_cap
        assert!(rec.max_total == cap, ECapChangeAfterDeadline);
        assert!(rec.amount <= std::u64::max_value!() - amount, EArithmeticOverflow);
        rec.amount = rec.amount + amount;
        
        // SECURITY: Updated total cap must still be reasonable
        assert!(rec.max_total >= rec.amount, EInvalidStateForAction);
    } else {
        df::add(&mut raise.id, key, Contribution { amount, max_total: cap });
        raise.contributor_count = raise.contributor_count + 1;

        // Ensure a cap-bin exists and index it if first time seen
        let tkey = ThresholdKey { cap };
        if (!df::exists_(&raise.id, tkey)) {
            df::add(&mut raise.id, tkey, ThresholdBin { total: 0, count: 0 });
            vector::push_back(&mut raise.thresholds, cap);
        };
    };

    // Update the cap-bin aggregate
    {
        let bin: &mut ThresholdBin = df::borrow_mut(&mut raise.id, ThresholdKey { cap });
        assert!(bin.total <= std::u64::max_value!() - amount, EArithmeticOverflow);
        bin.total = bin.total + amount;
        bin.count = bin.count + 1;
    };

    event::emit(ContributionAddedCapped {
        raise_id: object::id(raise),
        contributor,
        amount,
        cap,
        new_naive_total: raise.total_raised,
    });
}

/// Backward compatibility: no-cap contribution just forwards with cap = MAX
public entry fun contribute<RaiseToken, StableCoin>(
    raise: &mut Raise<RaiseToken, StableCoin>,
    contribution: Coin<StableCoin>,
    clock: &Clock,
    ctx: &mut TxContext,
) {
    contribute_with_cap<RaiseToken, StableCoin>(
        raise, contribution, std::u64::max_value!(), clock, ctx
    )
}

/// Optional: explicit cap update before deadline (moves contributor's amount across bins)
public entry fun update_cap<RaiseToken, StableCoin>(
    raise: &mut Raise<RaiseToken, StableCoin>,
    new_cap: u64,
    clock: &Clock,
    ctx: &mut TxContext,
) {
    assert!(clock.timestamp_ms() < raise.deadline_ms, ECapChangeAfterDeadline);
    // SECURITY: Cannot update caps after settlement started
    assert!(!raise.settlement_in_progress && !raise.settlement_done, ESettlementAlreadyStarted);
    
    let who = ctx.sender();
    let key = ContributorKey { contributor: who };
    assert!(df::exists_(&raise.id, key), ENotAContributor);

    // Get the existing contribution
    let rec: &Contribution = df::borrow(&raise.id, key);
    let old_cap = rec.max_total;
    let amount = rec.amount;
    
    if (old_cap == new_cap) return;
    
    // SECURITY: New cap must be at least the contribution amount
    assert!(new_cap >= amount, EInvalidStateForAction);

    // create bin for new cap if needed
    let new_tk = ThresholdKey { cap: new_cap };
    if (!df::exists_(&raise.id, new_tk)) {
        df::add(&mut raise.id, new_tk, ThresholdBin { total: 0, count: 0 });
        vector::push_back(&mut raise.thresholds, new_cap);
    };

    // move amount across bins
    {
        let old_bin: &mut ThresholdBin = df::borrow_mut(&mut raise.id, ThresholdKey { cap: old_cap });
        assert!(old_bin.total >= amount, EArithmeticOverflow);
        old_bin.total = old_bin.total - amount;
        assert!(old_bin.count > 0, EArithmeticOverflow);
        old_bin.count = old_bin.count - 1;
    };
    {
        let new_bin: &mut ThresholdBin = df::borrow_mut(&mut raise.id, new_tk);
        assert!(new_bin.total <= std::u64::max_value!() - amount, EArithmeticOverflow);
        new_bin.total = new_bin.total + amount;
        new_bin.count = new_bin.count + 1;
    };

    // Update the contributor's record
    let rec_mut: &mut Contribution = df::borrow_mut(&mut raise.id, key);
    rec_mut.max_total = new_cap;
}

// === Max-heap helpers over vector<u64> ===
fun parent(i: u64): u64 { if (i == 0) 0 else (i - 1) / 2 }
fun left(i: u64): u64 { 2 * i + 1 }
fun right(i: u64): u64 { 2 * i + 2 }

fun heapify_down(v: &mut vector<u64>, mut i: u64, size: u64) {
    loop {
        let l = left(i);
        let r = right(i);
        let mut largest = i;

        if (l < size && *vector::borrow(v, l) > *vector::borrow(v, largest)) {
            largest = l;
        };
        if (r < size && *vector::borrow(v, r) > *vector::borrow(v, largest)) {
            largest = r;
        };
        if (largest == i) break;
        vector::swap(v, i, largest);
        i = largest;
    }
}

fun build_max_heap(v: &mut vector<u64>) {
    let sz = vector::length(v);
    let mut i = if (sz == 0) { 0 } else { (sz - 1) / 2 };
    loop {
        heapify_down(v, i, sz);
        if (i == 0) break;
        i = i - 1;
    };
}

fun heap_peek(v: &vector<u64>, size: u64): u64 {
    if (size == 0) 0 else *vector::borrow(v, 0)
}

fun heap_pop(v: &mut vector<u64>, size_ref: &mut u64): u64 {
    assert!(*size_ref > 0, ECapHeapInvariant);
    let last = *size_ref - 1;
    let top = *vector::borrow(v, 0);
    if (last != 0) {
        vector::swap(v, 0, last);
    };
    let _ = vector::pop_back(v);
    *size_ref = last;
    if (last > 0) {
        heapify_down(v, 0, last);
    };
    top
}

/// Start settlement: snapshot caps into a heap
public fun begin_settlement<RT, SC>(
    raise: &mut Raise<RT, SC>,
    clock: &Clock,
    ctx: &mut TxContext,
): CapSettlement {
    assert!(clock.timestamp_ms() >= raise.deadline_ms, EDeadlineNotReached);
    assert!(!raise.settlement_done && !raise.settlement_in_progress, ESettlementAlreadyDone);
    assert!(raise.state == STATE_FUNDING, EInvalidStateForAction);
    
    // SECURITY: Mark that settlement has started to prevent bin/cap manipulation
    raise.settlement_in_progress = true;

    // Copy caps vector into heap
    let mut heap = raise.thresholds; // copy
    build_max_heap(&mut heap);
    let size = vector::length(&heap);

    let s = CapSettlement {
        id: object::new(ctx),
        raise_id: object::id(raise),
        heap,
        size,
        running_sum: 0,
        final_total: 0,
        done: false,
    };

    event::emit(SettlementStarted { raise_id: object::id(raise), caps_count: size });
    s
}

/// Crank up to `steps` caps. Once done is true, final_total is T*.
public entry fun crank_settlement<RT, SC>(
    raise: &mut Raise<RT, SC>,
    s: &mut CapSettlement,
    steps: u64,
) {
    assert!(object::id(raise) == s.raise_id, EInvalidStateForAction);
    assert!(!s.done, ESettlementInProgress);
    assert!(raise.state == STATE_FUNDING, EInvalidStateForAction);
    assert!(raise.settlement_in_progress, EInvalidSettlementState);
    
    // SECURITY: Limit steps to prevent DOS
    let actual_steps = if (steps > 100) { 100 } else { steps };

    let mut i = 0;
    while (i < actual_steps && s.size > 0 && !s.done) {
        // Pop the highest cap
        let cap = heap_pop(&mut s.heap, &mut s.size);

        // Pull bin total; remove bin to avoid double counting
        let bin: ThresholdBin = df::remove(&mut raise.id, ThresholdKey { cap });
        let added = bin.total;

        // Update running sum
        assert!(s.running_sum <= std::u64::max_value!() - added, EArithmeticOverflow);
        s.running_sum = s.running_sum + added;

        // Peek next cap (0 if none)
        let next_cap = heap_peek(&s.heap, s.size);

        // Check fixed-point window: M_{k+1} < C_k <= M_k
        if (s.running_sum > next_cap && s.running_sum <= cap) {
            s.final_total = s.running_sum;
            s.done = true;
        };

        event::emit(SettlementStep {
            raise_id: s.raise_id,
            processed_cap: cap,
            added_amount: added,
            running_sum: s.running_sum,
            next_cap,
        });

        i = i + 1;
    };

    // If heap exhausted but not done, no fixed point > 0 exists -> T* = 0
    if (s.size == 0 && !s.done) {
        s.final_total = 0;
        s.done = true;
    };
}

/// Finalize: record T* and lock settlement
public fun finalize_settlement<RT, SC>(
    raise: &mut Raise<RT, SC>,
    s: CapSettlement,
) {
    assert!(object::id(raise) == s.raise_id, EInvalidStateForAction);
    assert!(s.done, ESettlementNotStarted);
    assert!(!raise.settlement_done, ESettlementAlreadyDone);
    assert!(raise.settlement_in_progress, EInvalidSettlementState);
    assert!(raise.state == STATE_FUNDING, EInvalidStateForAction);
    
    // SECURITY: Validate final total is reasonable
    assert!(s.final_total <= raise.total_raised, EInvalidSettlementState);

    raise.final_total_eligible = s.final_total;
    raise.settlement_done = true;
    raise.settlement_in_progress = false; // Settlement completed

    event::emit(SettlementFinalized { raise_id: object::id(raise), final_total: s.final_total });

    // Destroy the crank object
    let CapSettlement { id, raise_id: _, heap: _, size: _, running_sum: _, final_total: _, done: _ } = s;
    object::delete(id);
}

/// Entry function to start settlement and share the settlement object
public entry fun start_settlement<RT, SC>(
    raise: &mut Raise<RT, SC>,
    clock: &Clock,
    ctx: &mut TxContext,
) {
    let settlement = begin_settlement(raise, clock, ctx);
    transfer::public_share_object(settlement);
}

/// Entry function to finalize settlement
public entry fun complete_settlement<RT, SC>(
    raise: &mut Raise<RT, SC>,
    s: CapSettlement,
) {
    finalize_settlement(raise, s);
}

/// If the raise was successful, this function creates the DAO and transfers funds to the creator.
/// This must be called before contributors can claim their tokens.
public entry fun claim_success_and_create_dao<RaiseToken: drop, StableCoin: drop>(
    raise: &mut Raise<RaiseToken, StableCoin>,
    factory: &mut factory::Factory,
    extensions: &Extensions,
    fee_manager: &mut fee::FeeManager,
    payment: Coin<sui::sui::SUI>,
    clock: &Clock,
    ctx: &mut TxContext,
) {
    assert!(raise.state == STATE_FUNDING, EInvalidStateForAction);
    assert!(clock.timestamp_ms() >= raise.deadline_ms, EDeadlineNotReached);
    assert!(raise.settlement_done, ESettlementNotStarted);

    // Use FINAL eligible total, not naive total_raised
    let final_total = raise.final_total_eligible;

    assert!(final_total >= raise.min_raise_amount, EMinRaiseNotMet);
    assert!(final_total > 0, EMinRaiseNotMet);
    
    // SECURITY: Final total cannot exceed total raised
    assert!(final_total <= raise.total_raised, EInvalidSettlementState);

    raise.state = STATE_SUCCESSFUL;

    // Extract the TreasuryCap if available
    let treasury_cap = if (raise.treasury_cap.is_some()) {
        option::some(raise.treasury_cap.extract())
    } else {
        option::none()
    };

    // Create the DAO using the stored parameters. The DAO's Asset is the new governance
    // token, and its Stable is the coin used in the raise.
    let params = &raise.dao_params;
    
    // Set up founder rewards if configured
    if (params.founder_reward_params.is_some()) {
        let founder_params = params.founder_reward_params.borrow();
        
        // Emit event with founder rewards configuration
        // The actual action creation will be done when processing the DAO creation
        if (treasury_cap.is_some()) {
            // Calculate tiers based on vesting type
            let num_tiers = if (founder_params.linear_vesting) { 5u64 } else { 1u64 };
            
            event::emit(FounderRewardsConfigured {
                raise_id: object::id(raise),
                founder_address: founder_params.founder_address,
                allocation_bps: founder_params.founder_allocation_bps,
                tiers: num_tiers,
            });
        };
    };
    
    factory::create_dao_internal_with_extensions<RaiseToken, StableCoin>(
        factory,
        extensions,
        fee_manager,
        payment,
        1, // min_asset_amount must be > 0. Set to a minimal value.
        1, // min_stable_amount must be > 0. Set to a minimal value.
        params.dao_name,
        params.icon_url_string,
        params.review_period_ms,
        params.trading_period_ms,
        params.amm_twap_start_delay,
        params.amm_twap_step_max,
        params.amm_twap_initial_observation,
        params.twap_threshold,
        DEFAULT_AMM_TOTAL_FEE_BPS,
        params.dao_description, // DAO description
        params.max_outcomes,
        params.agreement_lines,
        params.agreement_difficulties,
        treasury_cap,
        clock,
        ctx
    );

    // Transfer ONLY T* to the creator; remainder stays for refunds
    let raised_funds = coin::from_balance(raise.stable_coin_vault.split(final_total), ctx);
    transfer::public_transfer(raised_funds, raise.creator);

    event::emit(RaiseSuccessful {
        raise_id: object::id(raise),
        total_raised: final_total, // interpret as final eligible
    });
}

/// If successful, contributors can call this to claim their share of the governance tokens.
public entry fun claim_tokens<RaiseToken, StableCoin>(
    raise: &mut Raise<RaiseToken, StableCoin>,
    ctx: &mut TxContext,
) {
    assert!(raise.state == STATE_SUCCESSFUL, EInvalidStateForAction);
    assert!(raise.settlement_done, ESettlementNotStarted);

    assert!(!raise.claiming, EReentrancy);
    raise.claiming = true;

    let who = ctx.sender();
    let key = ContributorKey { contributor: who };
    assert!(df::exists_(&raise.id, key), ENotAContributor);

    // SECURITY: Remove and get contribution record to prevent double-claim
    let rec: Contribution = df::remove(&mut raise.id, key);
    
    // SECURITY: Verify contribution integrity
    assert!(rec.amount > 0, EInvalidStateForAction);
    assert!(rec.max_total >= rec.amount, EInvalidStateForAction);

    // Eligibility: cap must be >= final_total
    let final_total = raise.final_total_eligible;
    if (!(rec.max_total >= final_total)) {
        raise.claiming = false;
        abort ENotEligibleForTokens
    };

    let tokens_to_claim = math::mul_div_to_64(
        rec.amount,
        raise.tokens_for_sale_amount,
        final_total
    );

    let tokens = coin::from_balance(raise.raise_token_vault.split(tokens_to_claim), ctx);
    transfer::public_transfer(tokens, who);

    event::emit(TokensClaimed {
        raise_id: object::id(raise),
        contributor: who,
        contribution_amount: rec.amount,
        tokens_claimed: tokens_to_claim,
    });

    raise.claiming = false;
}

/// Refund for contributors whose cap excluded them (after successful raise).
public entry fun claim_refund_ineligible<RaiseToken, StableCoin>(
    raise: &mut Raise<RaiseToken, StableCoin>,
    ctx: &mut TxContext,
) {
    assert!(raise.settlement_done, ESettlementNotStarted);
    assert!(raise.state == STATE_SUCCESSFUL, EInvalidStateForAction);

    let who = ctx.sender();
    let key = ContributorKey { contributor: who };
    assert!(df::exists_(&raise.id, key), ENotAContributor);

    let rec: Contribution = df::remove(&mut raise.id, key);
    
    // SECURITY: Verify contribution integrity
    assert!(rec.amount > 0, EInvalidStateForAction);
    assert!(rec.max_total >= rec.amount, EInvalidStateForAction);

    // Only for contributors who were excluded by their cap
    if (rec.max_total >= raise.final_total_eligible) {
        // They should claim tokens, not refund
        // Reinsert their record to avoid bricking them
        df::add(&mut raise.id, key, rec);
        abort EInvalidStateForAction
    };

    let refund_coin = coin::from_balance(raise.stable_coin_vault.split(rec.amount), ctx);
    transfer::public_transfer(refund_coin, who);

    event::emit(RefundClaimed {
        raise_id: object::id(raise),
        contributor: who,
        refund_amount: rec.amount,
    });
}

/// If failed, contributors can call this to get a refund.
public entry fun claim_refund<RaiseToken, StableCoin>(
    raise: &mut Raise<RaiseToken, StableCoin>,
    clock: &Clock,
    ctx: &mut TxContext,
) {
    assert!(clock.timestamp_ms() >= raise.deadline_ms, EDeadlineNotReached);
    
    // For failed raises, check if settlement is done to determine if it failed
    if (raise.settlement_done) {
        // Settlement done, check if final total met minimum
        if (raise.final_total_eligible >= raise.min_raise_amount) {
            // Successful raise - use claim_refund_ineligible instead
            abort EInvalidStateForAction
        };
    } else {
        // No settlement done, check naive total
        assert!(raise.total_raised < raise.min_raise_amount, EMinRaiseAlreadyMet);
    };

    if (raise.state == STATE_FUNDING) {
        raise.state = STATE_FAILED;
        event::emit(RaiseFailed {
            raise_id: object::id(raise),
            total_raised: raise.total_raised,
            min_raise_amount: raise.min_raise_amount,
        });
    };

    assert!(raise.state == STATE_FAILED, EInvalidStateForAction);
    let contributor = ctx.sender();
    let contributor_key = ContributorKey { contributor };
    
    // Check contributor exists
    assert!(df::exists_(&raise.id, contributor_key), ENotAContributor);
    
    // Remove and get contribution record
    let rec: Contribution = df::remove(&mut raise.id, contributor_key);
    let refund_coin = coin::from_balance(raise.stable_coin_vault.split(rec.amount), ctx);
    transfer::public_transfer(refund_coin, contributor);

    event::emit(RefundClaimed {
        raise_id: object::id(raise),
        contributor,
        refund_amount: rec.amount,
    });
}

/// After a successful raise and a claim period, the creator can sweep any remaining
/// "dust" tokens that were left over from rounding during the distribution.
public entry fun sweep_dust<RaiseToken, StableCoin>(
    raise: &mut Raise<RaiseToken, StableCoin>,
    clock: &Clock,
    ctx: &mut TxContext,
) {
    assert!(raise.state == STATE_SUCCESSFUL, EInvalidStateForAction);
    assert!(ctx.sender() == raise.creator, ENotTheCreator);

    // Ensure the claim period has passed. The claim period starts after the raise deadline.
    assert!(
        clock.timestamp_ms() >= raise.deadline_ms + CLAIM_PERIOD_DURATION_MS,
        EDeadlineNotReached // Reusing error, implies "claim deadline not reached"
    );

    let remaining_balance = raise.raise_token_vault.value();
    if (remaining_balance > 0) {
        let dust_tokens = coin::from_balance(raise.raise_token_vault.split(remaining_balance), ctx);
        transfer::public_transfer(dust_tokens, raise.creator);
    };
}

/// Internal function to initialize a raise with founder rewards.
fun init_raise_with_founder<RaiseToken: drop, StableCoin: drop>(
    treasury_cap: TreasuryCap<RaiseToken>,
    tokens_for_raise: Coin<RaiseToken>,
    min_raise_amount: u64,
    description: String,
    dao_params: DAOParameters,
    clock: &Clock,
    ctx: &mut TxContext,
) {
    let tokens_for_sale = tokens_for_raise.value();
    let raise = Raise<RaiseToken, StableCoin> {
        id: object::new(ctx),
        creator: ctx.sender(),
        state: STATE_FUNDING,
        total_raised: 0,
        min_raise_amount,
        deadline_ms: clock.timestamp_ms() + LAUNCHPAD_DURATION_MS,
        raise_token_vault: tokens_for_raise.into_balance(),
        tokens_for_sale_amount: tokens_for_sale,
        stable_coin_vault: balance::zero(),
        contributor_count: 0,
        description,
        dao_params,
        treasury_cap: option::some(treasury_cap),
        claiming: false,
        thresholds: vector::empty<u64>(),
        settlement_done: false,
        settlement_in_progress: false,
        final_total_eligible: 0,
    };

    event::emit(RaiseCreated {
        raise_id: object::id(&raise),
        creator: raise.creator,
        raise_token_type: type_name::get<RaiseToken>().into_string().to_string(),
        stable_coin_type: type_name::get<StableCoin>().into_string().to_string(),
        min_raise_amount,
        tokens_for_sale,
        deadline_ms: raise.deadline_ms,
        description: raise.description,
    });

    transfer::public_share_object(raise);
}

/// Internal function to initialize a raise (backward compatibility).
fun init_raise<RaiseToken: drop, StableCoin: drop>(
    treasury_cap: TreasuryCap<RaiseToken>,
    tokens_for_raise: Coin<RaiseToken>,
    min_raise_amount: u64,
    description: String,
    dao_params: DAOParameters,
    clock: &Clock,
    ctx: &mut TxContext,
) {
    let tokens_for_sale = tokens_for_raise.value();
    let raise = Raise<RaiseToken, StableCoin> {
        id: object::new(ctx),
        creator: ctx.sender(),
        state: STATE_FUNDING,
        total_raised: 0,
        min_raise_amount,
        deadline_ms: clock.timestamp_ms() + LAUNCHPAD_DURATION_MS,
        raise_token_vault: tokens_for_raise.into_balance(),
        tokens_for_sale_amount: tokens_for_sale,
        stable_coin_vault: balance::zero(),
        contributor_count: 0,
        description,
        dao_params,
        treasury_cap: option::some(treasury_cap),
        claiming: false,
        thresholds: vector::empty<u64>(),
        settlement_done: false,
        settlement_in_progress: false,
        final_total_eligible: 0,
    };

    event::emit(RaiseCreated {
        raise_id: object::id(&raise),
        creator: raise.creator,
        raise_token_type: type_name::get<RaiseToken>().into_string().to_string(),
        stable_coin_type: type_name::get<StableCoin>().into_string().to_string(),
        min_raise_amount,
        tokens_for_sale,
        deadline_ms: raise.deadline_ms,
        description: raise.description,
    });

    transfer::public_share_object(raise);
}

// === View Functions ===

public fun total_raised<RT, SC>(r: &Raise<RT, SC>): u64 { r.total_raised }
public fun state<RT, SC>(r: &Raise<RT, SC>): u8 { r.state }
public fun deadline<RT, SC>(r: &Raise<RT, SC>): u64 { r.deadline_ms }
public fun description<RT, SC>(r: &Raise<RT, SC>): &String { &r.description }
public fun contribution_of<RT, SC>(r: &Raise<RT, SC>, addr: address): u64 {
    let key = ContributorKey { contributor: addr };
    if (df::exists_(&r.id, key)) {
        let contribution: &Contribution = df::borrow(&r.id, key);
        contribution.amount
    } else {
        0
    }
}

public fun final_total_eligible<RT, SC>(r: &Raise<RT, SC>): u64 { r.final_total_eligible }
public fun settlement_done<RT, SC>(r: &Raise<RT, SC>): bool { r.settlement_done }
public fun settlement_in_progress<RT, SC>(r: &Raise<RT, SC>): bool { r.settlement_in_progress }
public fun contributor_count<RT, SC>(r: &Raise<RT, SC>): u64 { r.contributor_count }/// Dispatcher for liquidity actions
module futarchy::liquidity_dispatcher;

// === Imports ===
use sui::tx_context::TxContext;
use account_protocol::{
    account::Account,
    executable::{Self, Executable},
};
use futarchy::{
    futarchy_config::FutarchyConfig,
    version,
    liquidity_actions,
};

// === Public(friend) Functions ===

/// Try to execute liquidity actions (pool management actions)
public(package) fun try_execute_liquidity_action<IW: drop, Outcome: store + drop + copy>(
    executable: &mut Executable<Outcome>,
    account: &mut Account<FutarchyConfig>,
    witness: IW,
    ctx: &mut TxContext
): bool {
    // Try to execute UpdatePoolParamsAction
    if (executable::contains_action<Outcome, liquidity_actions::UpdatePoolParamsAction>(executable)) {
        liquidity_actions::do_update_pool_params<Outcome, IW>(
            executable,
            account,
            version::current(),
            witness,
            ctx
        );
        return true
    };
    
    // Try to execute SetPoolStatusAction
    if (executable::contains_action<Outcome, liquidity_actions::SetPoolStatusAction>(executable)) {
        liquidity_actions::do_set_pool_status<Outcome, IW>(
            executable,
            account,
            version::current(),
            witness,
            ctx
        );
        return true
    };
    
    // Note: AddLiquidityAction, RemoveLiquidityAction, and CreatePoolAction require specific coin types
    // and are handled in try_execute_typed_liquidity_action
    
    false
}

/// Execute liquidity actions with known types
/// Handles validation for typed liquidity operations
public(package) fun try_execute_typed_liquidity_action<AssetType: drop + store, StableType: drop + store, IW: drop, Outcome: store + drop + copy>(
    executable: &mut Executable<Outcome>,
    account: &mut Account<FutarchyConfig>,
    witness: IW,
    ctx: &mut TxContext,
): bool {
    // For add liquidity actions, validate and document execution requirements
    if (executable::contains_action<Outcome, liquidity_actions::AddLiquidityAction<AssetType, StableType>>(executable)) {
        validate_add_liquidity_action<AssetType, StableType, IW, Outcome>(
            executable,
            account,
            witness,
            ctx
        );
        return true
    };
    
    // For remove liquidity actions, validate and document execution requirements  
    if (executable::contains_action<Outcome, liquidity_actions::RemoveLiquidityAction<AssetType, StableType>>(executable)) {
        validate_remove_liquidity_action<AssetType, StableType, IW, Outcome>(
            executable,
            account,
            witness,
            ctx
        );
        return true
    };
    
    // Try to execute CreatePoolAction
    if (executable::contains_action<Outcome, liquidity_actions::CreatePoolAction<AssetType, StableType>>(executable)) {
        liquidity_actions::do_create_pool<AssetType, StableType, Outcome, IW>(
            executable,
            account,
            version::current(),
            witness,
            ctx
        );
        return true
    };
    
    false
}

// === Helper Functions ===

/// Validate add liquidity action parameters
use futarchy::{
    futarchy_config,
};
use sui::object;
use account_protocol::account;

// === Constants ===
const EInvalidAmount: u64 = 4;
const ENoSpotPool: u64 = 5;
const EInvalidPoolId: u64 = 6;

fun validate_add_liquidity_action<AssetType, StableType, IW: drop, Outcome: store + drop + copy>(
    executable: &mut Executable<Outcome>,
    account: &Account<FutarchyConfig>,
    witness: IW,
    _ctx: &mut TxContext,
) {
    // Extract and validate the action
    let action: &liquidity_actions::AddLiquidityAction<AssetType, StableType> = 
        executable::next_action(executable, witness);
    
    // Get action parameters
    let pool_id = liquidity_actions::get_pool_id(action);
    let asset_amount = liquidity_actions::get_asset_amount(action);
    let stable_amount = liquidity_actions::get_stable_amount(action);
    let _min_lp_amount = liquidity_actions::get_min_lp_amount(action);
    
    // Validate the action
    assert!(asset_amount > 0, EInvalidAmount);
    assert!(stable_amount > 0, EInvalidAmount);
    
    // Verify pool ID matches config
    let config = account::config(account);
    let stored_pool_id = futarchy_config::spot_pool_id(config);
    assert!(stored_pool_id.is_some(), ENoSpotPool);
    assert!(pool_id == *stored_pool_id.borrow(), EInvalidPoolId);
    
    // Action validated - actual execution requires execute_add_liquidity_with_pool
    // with coins obtained from vault operations using Move framework vault intents:
    //
    // Example integration pattern:
    // 1. This function validates the AddLiquidityAction
    // 2. Use vault_intents::execute_spend() to withdraw asset_amount and stable_amount
    // 3. Call execute_add_liquidity_with_pool with the withdrawn coins
    // 4. LP tokens are automatically deposited to the custody registry
}

/// Validate remove liquidity action parameters
fun validate_remove_liquidity_action<AssetType, StableType, IW: drop, Outcome: store + drop + copy>(
    executable: &mut Executable<Outcome>,
    account: &Account<FutarchyConfig>,
    witness: IW,
    _ctx: &mut TxContext,
) {
    // Extract and validate the action
    let action: &liquidity_actions::RemoveLiquidityAction<AssetType, StableType> = 
        executable::next_action(executable, witness);
    
    // Get action parameters
    let pool_id = liquidity_actions::get_remove_pool_id(action);
    let lp_amount = liquidity_actions::get_lp_amount(action);
    let _min_asset_amount = liquidity_actions::get_min_asset_amount(action);
    let _min_stable_amount = liquidity_actions::get_min_stable_amount(action);
    
    // Validate the action
    assert!(lp_amount > 0, EInvalidAmount);
    
    // Verify pool ID matches config
    let config = account::config(account);
    let stored_pool_id = futarchy_config::spot_pool_id(config);
    assert!(stored_pool_id.is_some(), ENoSpotPool);
    assert!(pool_id == *stored_pool_id.borrow(), EInvalidPoolId);
    
    // Action validated - actual execution requires execute_remove_liquidity_with_pool
    // with LP tokens obtained from the custody system using Move framework patterns:
    //
    // Example integration pattern:
    // 1. This function validates the RemoveLiquidityAction
    // 2. Retrieve LP tokens from custody using lp_token_custody::withdraw_lp_token()
    // 3. Call execute_remove_liquidity_with_pool with the LP tokens
    // 4. Resulting coins can be deposited back to vault via vault_intents::execute_deposit()
}/// Liquidity-related actions for futarchy DAOs
/// This module defines action structs and execution logic for liquidity management
module futarchy::liquidity_actions;

// === Imports ===
use std::string::String;
use sui::{
    coin::{Self, Coin},
    balance::Balance,
    object::{Self, ID},
    tx_context::TxContext,
};
use account_protocol::{
    account::{Self, Account},
    executable::{Self, Executable},
    intents::Expired,
    version_witness::VersionWitness,
};
use futarchy::futarchy_config::{Self, FutarchyConfig};

// === Errors ===
const EInvalidAmount: u64 = 1;
const EInvalidRatio: u64 = 2;
const EInvalidSlippage: u64 = 3;
const EEmptyPool: u64 = 4;

// === Note ===
// The actual pool interaction and LP token management must be
// implemented in the futarchy package where the pool types are defined

// === Action Structs ===

/// Action to add liquidity to a pool
public struct AddLiquidityAction<phantom AssetType, phantom StableType> has store {
    pool_id: ID,
    asset_amount: u64,
    stable_amount: u64,
    min_lp_amount: u64, // Slippage protection
}

/// Action to remove liquidity from a pool
public struct RemoveLiquidityAction<phantom AssetType, phantom StableType> has store {
    pool_id: ID,
    lp_amount: u64,
    min_asset_amount: u64, // Slippage protection
    min_stable_amount: u64, // Slippage protection
}

/// Action to create a new liquidity pool
public struct CreatePoolAction<phantom AssetType, phantom StableType> has store {
    initial_asset_amount: u64,
    initial_stable_amount: u64,
    fee_bps: u64,
    minimum_liquidity: u64,
}

/// Action to update pool parameters
public struct UpdatePoolParamsAction has store {
    pool_id: ID,
    new_fee_bps: u64,
    new_minimum_liquidity: u64,
}

/// Action to pause/unpause a pool
public struct SetPoolStatusAction has store {
    pool_id: ID,
    is_paused: bool,
}

// === Execution Functions ===

/// Execute a create pool action
/// Note: This validates the action. The actual pool creation requires coins
/// which should be provided by the caller (dispatcher) via vault intents
public fun do_create_pool<AssetType: drop, StableType: drop, Outcome: store, IW: drop>(
    executable: &mut Executable<Outcome>,
    _account: &mut Account<FutarchyConfig>,
    _version: VersionWitness,
    witness: IW,
    _ctx: &mut TxContext,
) {
    let action: &CreatePoolAction<AssetType, StableType> = executable.next_action(witness);
    
    // Get action parameters
    let initial_asset_amount = action.initial_asset_amount;
    let initial_stable_amount = action.initial_stable_amount;
    let fee_bps = action.fee_bps;
    let minimum_liquidity = action.minimum_liquidity;
    
    // Validate parameters
    assert!(initial_asset_amount > 0, EInvalidAmount);
    assert!(initial_stable_amount > 0, EInvalidAmount);
    assert!(fee_bps <= 10000, EInvalidRatio);
    assert!(minimum_liquidity > 0, EInvalidAmount);
    
    // Note: The actual pool creation with coins should be handled by the dispatcher
    // which has access to vault_intents for withdrawing coins and can call
    // account_spot_pool::new_pool_and_add_liquidity with the actual coins
}

/// Execute an update pool params action
/// Updates fee and minimum liquidity requirements for a pool
public fun do_update_pool_params<Outcome: store, IW: drop>(
    executable: &mut Executable<Outcome>,
    account: &mut Account<FutarchyConfig>,
    _version: VersionWitness,
    witness: IW,
    _ctx: &mut TxContext,
) {
    let action: &UpdatePoolParamsAction = executable.next_action(witness);
    
    // Get action parameters
    let pool_id = action.pool_id;
    let new_fee_bps = action.new_fee_bps;
    let new_minimum_liquidity = action.new_minimum_liquidity;
    
    // Validate parameters
    assert!(new_fee_bps <= 10000, EInvalidRatio);
    assert!(new_minimum_liquidity > 0, EInvalidAmount);
    
    // Verify this pool belongs to the DAO
    let config = account.config();
    let stored_pool_id = futarchy_config::spot_pool_id(config);
    assert!(stored_pool_id.is_some(), EEmptyPool);
    assert!(pool_id == *stored_pool_id.borrow(), EEmptyPool);
    
    // Note: The pool object must be passed by the caller since it's a shared object
    // This function just validates the action - actual update happens in dispatcher
    // which has access to the pool object
}

/// Execute a set pool status action
/// Pauses or unpauses trading in a pool
public fun do_set_pool_status<Outcome: store, IW: drop>(
    executable: &mut Executable<Outcome>,
    account: &mut Account<FutarchyConfig>,
    _version: VersionWitness,
    witness: IW,
    _ctx: &mut TxContext,
) {
    let action: &SetPoolStatusAction = executable.next_action(witness);
    
    // Get action parameters
    let pool_id = action.pool_id;
    let is_paused = action.is_paused;
    
    // Verify this pool belongs to the DAO
    let config = account.config();
    let stored_pool_id = futarchy_config::spot_pool_id(config);
    assert!(stored_pool_id.is_some(), EEmptyPool);
    assert!(pool_id == *stored_pool_id.borrow(), EEmptyPool);
    
    // Note: The pool object must be passed by the caller since it's a shared object
    // This function just validates the action - actual update happens in dispatcher
    // which has access to the pool object
    
    // Store the status for future reference
    let _ = is_paused;
}

// === Cleanup Functions ===

/// Delete an add liquidity action from an expired intent
public fun delete_add_liquidity<AssetType, StableType>(expired: &mut Expired) {
    let AddLiquidityAction<AssetType, StableType> {
        pool_id: _,
        asset_amount: _,
        stable_amount: _,
        min_lp_amount: _,
    } = expired.remove_action();
}

/// Delete a remove liquidity action from an expired intent
public fun delete_remove_liquidity<AssetType, StableType>(expired: &mut Expired) {
    let RemoveLiquidityAction<AssetType, StableType> {
        pool_id: _,
        lp_amount: _,
        min_asset_amount: _,
        min_stable_amount: _,
    } = expired.remove_action();
}

/// Delete a create pool action from an expired intent
public fun delete_create_pool<AssetType, StableType>(expired: &mut Expired) {
    let CreatePoolAction<AssetType, StableType> {
        initial_asset_amount: _,
        initial_stable_amount: _,
        fee_bps: _,
        minimum_liquidity: _,
    } = expired.remove_action();
}

/// Delete an update pool params action from an expired intent
public fun delete_update_pool_params(expired: &mut Expired) {
    let UpdatePoolParamsAction {
        pool_id: _,
        new_fee_bps: _,
        new_minimum_liquidity: _,
    } = expired.remove_action();
}

/// Delete a set pool status action from an expired intent
public fun delete_set_pool_status(expired: &mut Expired) {
    let SetPoolStatusAction {
        pool_id: _,
        is_paused: _,
    } = expired.remove_action();
}

// === Helper Functions ===

/// Create a new add liquidity action
public fun new_add_liquidity_action<AssetType, StableType>(
    pool_id: ID,
    asset_amount: u64,
    stable_amount: u64,
    min_lp_amount: u64,
): AddLiquidityAction<AssetType, StableType> {
    assert!(asset_amount > 0, EInvalidAmount);
    assert!(stable_amount > 0, EInvalidAmount);
    assert!(min_lp_amount > 0, EInvalidAmount);
    
    AddLiquidityAction {
        pool_id,
        asset_amount,
        stable_amount,
        min_lp_amount,
    }
}

/// Create a new remove liquidity action
public fun new_remove_liquidity_action<AssetType, StableType>(
    pool_id: ID,
    lp_amount: u64,
    min_asset_amount: u64,
    min_stable_amount: u64,
): RemoveLiquidityAction<AssetType, StableType> {
    assert!(lp_amount > 0, EInvalidAmount);
    
    RemoveLiquidityAction {
        pool_id,
        lp_amount,
        min_asset_amount,
        min_stable_amount,
    }
}

/// Create a new create pool action
public fun new_create_pool_action<AssetType, StableType>(
    initial_asset_amount: u64,
    initial_stable_amount: u64,
    fee_bps: u64,
    minimum_liquidity: u64,
): CreatePoolAction<AssetType, StableType> {
    assert!(initial_asset_amount > 0, EInvalidAmount);
    assert!(initial_stable_amount > 0, EInvalidAmount);
    assert!(fee_bps <= 10000, EInvalidRatio); // Max 100%
    assert!(minimum_liquidity > 0, EInvalidAmount);
    
    CreatePoolAction {
        initial_asset_amount,
        initial_stable_amount,
        fee_bps,
        minimum_liquidity,
    }
}

/// Create a new update pool params action
public fun new_update_pool_params_action(
    pool_id: ID,
    new_fee_bps: u64,
    new_minimum_liquidity: u64,
): UpdatePoolParamsAction {
    assert!(new_fee_bps <= 10000, EInvalidRatio); // Max 100%
    assert!(new_minimum_liquidity > 0, EInvalidAmount);
    
    UpdatePoolParamsAction {
        pool_id,
        new_fee_bps,
        new_minimum_liquidity,
    }
}

/// Create a new set pool status action
public fun new_set_pool_status_action(
    pool_id: ID,
    is_paused: bool,
): SetPoolStatusAction {
    SetPoolStatusAction {
        pool_id,
        is_paused,
    }
}

// === Getter Functions ===

/// Get pool ID from AddLiquidityAction
public fun get_pool_id<AssetType, StableType>(action: &AddLiquidityAction<AssetType, StableType>): ID {
    action.pool_id
}

/// Get asset amount from AddLiquidityAction
public fun get_asset_amount<AssetType, StableType>(action: &AddLiquidityAction<AssetType, StableType>): u64 {
    action.asset_amount
}

/// Get stable amount from AddLiquidityAction
public fun get_stable_amount<AssetType, StableType>(action: &AddLiquidityAction<AssetType, StableType>): u64 {
    action.stable_amount
}

/// Get minimum LP amount from AddLiquidityAction
public fun get_min_lp_amount<AssetType, StableType>(action: &AddLiquidityAction<AssetType, StableType>): u64 {
    action.min_lp_amount
}

/// Get pool ID from RemoveLiquidityAction
public fun get_remove_pool_id<AssetType, StableType>(action: &RemoveLiquidityAction<AssetType, StableType>): ID {
    action.pool_id
}

/// Get LP amount from RemoveLiquidityAction
public fun get_lp_amount<AssetType, StableType>(action: &RemoveLiquidityAction<AssetType, StableType>): u64 {
    action.lp_amount
}

/// Get minimum asset amount from RemoveLiquidityAction
public fun get_min_asset_amount<AssetType, StableType>(action: &RemoveLiquidityAction<AssetType, StableType>): u64 {
    action.min_asset_amount
}

/// Get minimum stable amount from RemoveLiquidityAction
public fun get_min_stable_amount<AssetType, StableType>(action: &RemoveLiquidityAction<AssetType, StableType>): u64 {
    action.min_stable_amount
}

/// Get initial asset amount from CreatePoolAction
public fun get_initial_asset_amount<AssetType, StableType>(action: &CreatePoolAction<AssetType, StableType>): u64 {
    action.initial_asset_amount
}

/// Get initial stable amount from CreatePoolAction
public fun get_initial_stable_amount<AssetType, StableType>(action: &CreatePoolAction<AssetType, StableType>): u64 {
    action.initial_stable_amount
}

/// Get fee basis points from CreatePoolAction
public fun get_fee_bps<AssetType, StableType>(action: &CreatePoolAction<AssetType, StableType>): u64 {
    action.fee_bps
}

/// Get minimum liquidity from CreatePoolAction
public fun get_minimum_liquidity<AssetType, StableType>(action: &CreatePoolAction<AssetType, StableType>): u64 {
    action.minimum_liquidity
}

/// Get pool ID from UpdatePoolParamsAction
public fun get_update_pool_id(action: &UpdatePoolParamsAction): ID {
    action.pool_id
}

/// Get new fee basis points from UpdatePoolParamsAction
public fun get_new_fee_bps(action: &UpdatePoolParamsAction): u64 {
    action.new_fee_bps
}

/// Get new minimum liquidity from UpdatePoolParamsAction
public fun get_new_minimum_liquidity(action: &UpdatePoolParamsAction): u64 {
    action.new_minimum_liquidity
}

/// Get pool ID from SetPoolStatusAction
public fun get_status_pool_id(action: &SetPoolStatusAction): ID {
    action.pool_id
}

/// Get is paused flag from SetPoolStatusAction
public fun get_is_paused(action: &SetPoolStatusAction): bool {
    action.is_paused
}/// User-facing API for creating liquidity-related intents
/// This module provides helper functions for creating liquidity actions
/// The actual intent creation must be done by the governance system that provides the Outcome
module futarchy::liquidity_intents;

// === Imports ===
use std::string::String;
use sui::{
    clock::Clock,
    object::ID,
};
use account_protocol::{
    intents::Intent,
};
use futarchy::liquidity_actions;

// === Witness ===

/// Witness type for liquidity intents
public struct LiquidityIntent has drop {}

/// Create a LiquidityIntent witness
public fun witness(): LiquidityIntent {
    LiquidityIntent {}
}

// === Helper Functions ===

/// Add an add liquidity action to an existing intent
public fun add_liquidity_to_intent<Outcome: store, AssetType, StableType, IW: drop>(
    intent: &mut Intent<Outcome>,
    pool_id: ID,
    asset_amount: u64,
    stable_amount: u64,
    min_lp_amount: u64,
    intent_witness: IW,
) {
    let action = liquidity_actions::new_add_liquidity_action<AssetType, StableType>(
        pool_id,
        asset_amount,
        stable_amount,
        min_lp_amount,
    );
    intent.add_action(action, intent_witness);
}

/// Add a remove liquidity action to an existing intent
public fun remove_liquidity_from_intent<Outcome: store, AssetType, StableType, IW: drop>(
    intent: &mut Intent<Outcome>,
    pool_id: ID,
    lp_amount: u64,
    min_asset_amount: u64,
    min_stable_amount: u64,
    intent_witness: IW,
) {
    let action = liquidity_actions::new_remove_liquidity_action<AssetType, StableType>(
        pool_id,
        lp_amount,
        min_asset_amount,
        min_stable_amount,
    );
    intent.add_action(action, intent_witness);
}

/// Create a unique key for a liquidity intent
public fun create_liquidity_key(
    operation: String,
    clock: &Clock,
): String {
    let mut key = b"liquidity_".to_string();
    key.append(operation);
    key.append(b"_".to_string());
    key.append(clock.timestamp_ms().to_string());
    key
}
/// Dispatcher for policy registry actions
module futarchy::policy_dispatcher;

// === Imports ===
use std::string;
use sui::{
    object,
    tx_context::TxContext,
};
use account_protocol::{
    account::Account,
    executable::{Self, Executable},
};
use futarchy::{
    futarchy_config::FutarchyConfig,
    version,
    policy_actions,
    policy_registry,
    policy_registry_coexec,
};

// === Constants ===
const ECriticalPolicyRequiresCouncil: u64 = 9;

// === Public(friend) Functions ===

/// Try to execute policy registry actions
public(package) fun try_execute_policy_action<IW: drop, Outcome: store + drop + copy>(
    executable: &mut Executable<Outcome>,
    account: &mut Account<FutarchyConfig>,
    witness: IW,
    _ctx: &mut TxContext,
): bool {
    // Check for set policy action
    if (executable::contains_action<Outcome, policy_actions::SetPolicyAction>(executable)) {
        let action: &policy_actions::SetPolicyAction = executable::next_action(executable, witness);
        let account_id = object::id(account);
        let (key, id, prefix) = policy_actions::get_set_policy_params(action);
        
        // Check if this is a critical policy that requires council co-approval
        if (policy_registry_coexec::is_critical_policy(key)) {
            // Critical policies must use policy_registry_coexec::execute_set_policy_with_council
            abort ECriticalPolicyRequiresCouncil
        };
        
        let registry = policy_registry::borrow_registry_mut(account, version::current());
        policy_registry::set_policy(registry, account_id, *key, id, *prefix);
        return true
    };

    // Check for remove policy action
    if (executable::contains_action<Outcome, policy_actions::RemovePolicyAction>(executable)) {
        let action: &policy_actions::RemovePolicyAction = executable::next_action(executable, witness);
        let account_id = object::id(account);
        let key = policy_actions::get_remove_policy_key(action);
        
        // Check if this is a critical policy that requires council co-approval
        if (policy_registry_coexec::is_critical_policy(key)) {
            // Critical policies must use policy_registry_coexec::execute_remove_policy_with_council
            abort ECriticalPolicyRequiresCouncil
        };
        
        let registry = policy_registry::borrow_registry_mut(account, version::current());
        policy_registry::remove_policy(registry, account_id, *key);
        return true
    };

    false
}/// Actions for managing the Policy Registry.
module futarchy::policy_actions;

use std::string::String;
use sui::object::ID;
use account_protocol::intents::Expired;

public struct SetPolicyAction has store {
    resource_key: String, // e.g., "UpgradeCap:futarchy"
    policy_account_id: ID,
    intent_key_prefix: String,
}

public struct RemovePolicyAction has store {
    resource_key: String,
}

// --- Constructors, Getters, Cleanup ---

public fun new_set_policy(
    resource_key: String,
    policy_account_id: ID,
    intent_key_prefix: String,
): SetPolicyAction {
    SetPolicyAction { resource_key, policy_account_id, intent_key_prefix }
}

public fun new_remove_policy(resource_key: String): RemovePolicyAction {
    RemovePolicyAction { resource_key }
}

public fun get_set_policy_params(action: &SetPolicyAction): (&String, ID, &String) {
    (&action.resource_key, action.policy_account_id, &action.intent_key_prefix)
}

public fun get_remove_policy_key(action: &RemovePolicyAction): &String {
    &action.resource_key
}

public fun delete_set_policy(expired: &mut Expired) {
    let SetPolicyAction {..} = expired.remove_action();
}

public fun delete_remove_policy(expired: &mut Expired) {
    let RemovePolicyAction {..} = expired.remove_action();
}/// Manages on-chain policies that require external account approval for critical actions.
/// This registry links a protected resource (identified by a key) to a policy-enforcing Account.
/// 
/// Uses standardized resource keys from futarchy::resources for consistency.
module futarchy::policy_registry;

use std::string::{Self, String};
use sui::object::{ID, UID};
use sui::table::{Self, Table};
use sui::event;
use sui::tx_context::TxContext;
use account_protocol::account::{Self, Account};
use account_protocol::version_witness::VersionWitness;
use futarchy::resources;

// === Errors ===
const EPolicyNotFound: u64 = 1;

// === Structs ===

/// Key for storing the registry in the Account's managed data.
public struct PolicyRegistryKey has copy, drop, store {}

/// The registry object. Maps a resource key (e.g., "UpgradeCap:futarchy") to a Policy.
public struct PolicyRegistry has store {
    policies: Table<String, Policy>,
}

/// Defines the policy for a given resource.
public struct Policy has store, copy, drop {
    /// The ID of the Account (e.g., a Security Council multisig) that enforces this policy.
    policy_account_id: ID,
    /// A unique prefix for intents sent to this policy account, to prevent key collisions.
    intent_key_prefix: String,
    /// Gating mode: 0=DAO_ONLY, 1=COUNCIL_ONLY, 2=AND (both required), 3=OR (either)
    gating_mode: u8,
    /// Optional time delay in milliseconds (0 = no delay)
    time_delay_ms: u64,
    /// Optional approval threshold (e.g., 3 for "3 of 5")
    approval_threshold: u64,
}

// === Events ===
public struct PolicySet has copy, drop {
    dao_id: ID,
    resource_key: String,
    policy_account_id: ID,
}

public struct PolicyRemoved has copy, drop {
    dao_id: ID,
    resource_key: String,
}

// === Public Functions ===

/// Initializes the policy registry for an Account.
public fun initialize<Config>(account: &mut Account<Config>, version_witness: VersionWitness, ctx: &mut TxContext) {
    if (!account::has_managed_data(account, PolicyRegistryKey {})) {
        account::add_managed_data(
            account,
            PolicyRegistryKey {},
            PolicyRegistry { policies: table::new(ctx) },
            version_witness
        );
    }
}

/// Sets or updates a policy for a specific resource.
/// Resource keys should be generated using futarchy::resources functions.
public fun set_policy(
    registry: &mut PolicyRegistry,
    dao_id: ID,
    resource_key: String,
    policy_account_id: ID,
    intent_key_prefix: String,
) {
    // Default gating_mode to 0 (DAO_ONLY) with no delay or threshold
    let policy = Policy { 
        policy_account_id, 
        intent_key_prefix, 
        gating_mode: 0,
        time_delay_ms: 0,
        approval_threshold: 0
    };
    
    // Check if policy exists and update or insert accordingly
    if (table::contains(&registry.policies, resource_key)) {
        table::remove(&mut registry.policies, resource_key);
    };
    table::add(&mut registry.policies, resource_key, policy);

    event::emit(PolicySet {
        dao_id,
        resource_key,
        policy_account_id,
    });
}

/// Removes a policy for a resource.
public fun remove_policy(registry: &mut PolicyRegistry, dao_id: ID, resource_key: String) {
    assert!(table::contains(&registry.policies, resource_key), EPolicyNotFound);
    table::remove(&mut registry.policies, resource_key);

    event::emit(PolicyRemoved {
        dao_id,
        resource_key,
    });
}

/// Gets the policy for a resource.
public fun get_policy(registry: &PolicyRegistry, resource_key: String): &Policy {
    assert!(table::contains(&registry.policies, resource_key), EPolicyNotFound);
    table::borrow(&registry.policies, resource_key)
}

/// Checks if a policy exists for a resource.
public fun has_policy(registry: &PolicyRegistry, resource_key: String): bool {
    table::contains(&registry.policies, resource_key)
}

/// Getter for policy_account_id.
public fun policy_account_id(policy: &Policy): ID {
    policy.policy_account_id
}

/// Getter for intent_key_prefix.
public fun intent_key_prefix(policy: &Policy): &String {
    &policy.intent_key_prefix
}

/// Getter for gating_mode.
public fun gating_mode(policy: &Policy): u8 {
    policy.gating_mode
}

/// Getter for time_delay_ms.
public fun time_delay_ms(policy: &Policy): u64 {
    policy.time_delay_ms
}

/// Getter for approval_threshold.
public fun approval_threshold(policy: &Policy): u64 {
    policy.approval_threshold
}

/// Gating mode constants
public fun gating_mode_dao_only(): u8 { 0 }
public fun gating_mode_council_only(): u8 { 1 }
public fun gating_mode_and(): u8 { 2 }
public fun gating_mode_or(): u8 { 3 }

/// Helper function to get a mutable reference to the PolicyRegistry from an Account
public fun borrow_registry_mut<Config>(
    account: &mut Account<Config>,
    version_witness: VersionWitness
): &mut PolicyRegistry {
    account::borrow_managed_data_mut(account, PolicyRegistryKey {}, version_witness)
}

/// Helper function to get an immutable reference to the PolicyRegistry from an Account
public fun borrow_registry<Config>(
    account: &Account<Config>,
    version_witness: VersionWitness
): &PolicyRegistry {
    account::borrow_managed_data(account, PolicyRegistryKey {}, version_witness)
}

// === Convenience Functions for Common Policy Patterns ===

/// Set a policy with time delay (e.g., for package upgrades)
public fun set_policy_with_timelock(
    registry: &mut PolicyRegistry,
    dao_id: ID,
    resource_key: String,
    policy_account_id: ID,
    intent_key_prefix: String,
    delay_ms: u64,
) {
    let policy = Policy { 
        policy_account_id, 
        intent_key_prefix, 
        gating_mode: gating_mode_and(), // Both DAO and council must approve
        time_delay_ms: delay_ms,
        approval_threshold: 0
    };
    
    if (table::contains(&registry.policies, resource_key)) {
        table::remove(&mut registry.policies, resource_key);
    };
    table::add(&mut registry.policies, resource_key, policy);

    event::emit(PolicySet {
        dao_id,
        resource_key,
        policy_account_id,
    });
}

/// Set a policy requiring threshold approvals
public fun set_policy_with_threshold(
    registry: &mut PolicyRegistry,
    dao_id: ID,
    resource_key: String,
    policy_account_id: ID,
    intent_key_prefix: String,
    threshold: u64,
) {
    let policy = Policy { 
        policy_account_id, 
        intent_key_prefix, 
        gating_mode: gating_mode_council_only(), // Council handles threshold
        time_delay_ms: 0,
        approval_threshold: threshold
    };
    
    if (table::contains(&registry.policies, resource_key)) {
        table::remove(&mut registry.policies, resource_key);
    };
    table::add(&mut registry.policies, resource_key, policy);

    event::emit(PolicySet {
        dao_id,
        resource_key,
        policy_account_id,
    });
}

/// Set an emergency policy (council only, no delay)
public fun set_emergency_policy(
    registry: &mut PolicyRegistry,
    dao_id: ID,
    resource_key: String,
    policy_account_id: ID,
    intent_key_prefix: String,
) {
    let policy = Policy { 
        policy_account_id, 
        intent_key_prefix, 
        gating_mode: gating_mode_council_only(),
        time_delay_ms: 0,
        approval_threshold: 0
    };
    
    if (table::contains(&registry.policies, resource_key)) {
        table::remove(&mut registry.policies, resource_key);
    };
    table::add(&mut registry.policies, resource_key, policy);

    event::emit(PolicySet {
        dao_id,
        resource_key,
        policy_account_id,
    });
}

/// Check if a resource requires policy approval based on the registry
public fun requires_policy_approval<Config>(
    account: &Account<Config>,
    resource_key: String,
    version_witness: VersionWitness,
): bool {
    if (!account::has_managed_data(account, PolicyRegistryKey {})) {
        return false
    };
    
    let registry = borrow_registry(account, version_witness);
    has_policy(registry, resource_key)
}/// Resource and Role Key System for Policy Engine
/// Provides standardized, type-safe keys for granular governance control
/// 
/// This module defines a hierarchical namespace for resources that can be
/// governed by policies in the DAO platform. Keys follow the pattern:
/// resource:/[category]/[action]/[specific_resource]
///
/// Categories:
/// - package: Package upgrades and code management
/// - vault: Treasury and asset management
/// - governance: Proposal and voting mechanisms
/// - operations: Operating agreement and administrative functions
/// - liquidity: AMM and liquidity pool management
/// - security: Security council and emergency actions
module futarchy::resources;

use std::{
    string::{Self, String},
    type_name::{Self, TypeName},
    ascii,
};

// === Constants for Resource Categories ===
const RESOURCE_PREFIX: vector<u8> = b"resource:/";
const RESOURCE_PREFIX_LEN: u64 = 10; // len("resource:/")
const PACKAGE_CATEGORY: vector<u8> = b"package/";
const VAULT_CATEGORY: vector<u8> = b"vault/";
const GOVERNANCE_CATEGORY: vector<u8> = b"governance/";
const OPERATIONS_CATEGORY: vector<u8> = b"operations/";
const LIQUIDITY_CATEGORY: vector<u8> = b"liquidity/";
const SECURITY_CATEGORY: vector<u8> = b"security/";
const STREAMS_CATEGORY: vector<u8> = b"streams/";
const EXT_CATEGORY: vector<u8> = b"ext/";
const OTHER_CATEGORY: vector<u8> = b"other/";

// === Errors ===
const EBadResourceKey: u64 = 1;

// === Helper Functions ===
fun prefix_str(): String { string::utf8(RESOURCE_PREFIX) }

public fun is_valid(key: &String): bool {
    key.index_of(&prefix_str()) == 0
}

fun strip_prefix_or_abort(key: &String): String {
    assert!(is_valid(key), EBadResourceKey);
    key.substring(RESOURCE_PREFIX_LEN, key.length())
}

// === Package Management Resources ===

/// Key for package upgrade permissions
/// Example: "resource:/package/upgrade/0x123::my_package"
public fun package_upgrade(package_addr: address, package_name: String): String {
    let mut key = string::utf8(RESOURCE_PREFIX);
    key.append(string::utf8(PACKAGE_CATEGORY));
    key.append(string::utf8(b"upgrade/"));
    key.append(package_addr.to_string());
    key.append(string::utf8(b"::"));
    key.append(package_name);
    key
}

/// Key for restricting package upgrades (making immutable)
/// Example: "resource:/package/restrict/0x123::my_package"
public fun package_restrict(package_addr: address, package_name: String): String {
    let mut key = string::utf8(RESOURCE_PREFIX);
    key.append(string::utf8(PACKAGE_CATEGORY));
    key.append(string::utf8(b"restrict/"));
    key.append(package_addr.to_string());
    key.append(string::utf8(b"::"));
    key.append(package_name);
    key
}

/// Key for package publication permissions
public fun package_publish(): String {
    let mut key = string::utf8(RESOURCE_PREFIX);
    key.append(string::utf8(PACKAGE_CATEGORY));
    key.append(string::utf8(b"publish"));
    key
}

// === Vault/Treasury Resources ===

/// Key for spending from a specific coin type
/// Example: "resource:/vault/spend/0x2::sui::SUI"
public fun vault_spend<CoinType>(): String {
    vault_spend_by_type(type_name::get<CoinType>())
}

public fun vault_spend_by_type(coin_type: TypeName): String {
    let mut key = string::utf8(RESOURCE_PREFIX);
    key.append(string::utf8(VAULT_CATEGORY));
    key.append(string::utf8(b"spend/"));
    let type_str = type_name::into_string(coin_type);
    key.append(string::from_ascii(type_str));
    key
}

/// Key for minting new coins (if TreasuryCap is held)
/// Example: "resource:/vault/mint/0x123::my_coin::MyCoin"
public fun vault_mint<CoinType>(): String {
    vault_mint_by_type(type_name::get<CoinType>())
}

public fun vault_mint_by_type(coin_type: TypeName): String {
    let mut key = string::utf8(RESOURCE_PREFIX);
    key.append(string::utf8(VAULT_CATEGORY));
    key.append(string::utf8(b"mint/"));
    let type_str = type_name::into_string(coin_type);
    key.append(string::from_ascii(type_str));
    key
}

/// Key for burning coins
public fun vault_burn<CoinType>(): String {
    let mut key = string::utf8(RESOURCE_PREFIX);
    key.append(string::utf8(VAULT_CATEGORY));
    key.append(string::utf8(b"burn/"));
    let type_str = type_name::into_string(type_name::get<CoinType>());
    key.append(string::from_ascii(type_str));
    key
}

/// Key for vault configuration changes
public fun vault_config(): String {
    let mut key = string::utf8(RESOURCE_PREFIX);
    key.append(string::utf8(VAULT_CATEGORY));
    key.append(string::utf8(b"config"));
    key
}

// === Governance Resources ===

/// Key for creating new proposals
public fun governance_propose(): String {
    let mut key = string::utf8(RESOURCE_PREFIX);
    key.append(string::utf8(GOVERNANCE_CATEGORY));
    key.append(string::utf8(b"propose"));
    key
}

/// Key for emergency proposal cancellation
public fun governance_cancel(): String {
    let mut key = string::utf8(RESOURCE_PREFIX);
    key.append(string::utf8(GOVERNANCE_CATEGORY));
    key.append(string::utf8(b"cancel"));
    key
}

/// Key for modifying governance parameters
public fun governance_params(): String {
    let mut key = string::utf8(RESOURCE_PREFIX);
    key.append(string::utf8(GOVERNANCE_CATEGORY));
    key.append(string::utf8(b"params"));
    key
}

/// Key for fast-track/emergency proposals
public fun governance_emergency(): String {
    let mut key = string::utf8(RESOURCE_PREFIX);
    key.append(string::utf8(GOVERNANCE_CATEGORY));
    key.append(string::utf8(b"emergency"));
    key
}

// === Operations Resources ===

/// Key for operating agreement modifications
public fun operations_agreement(): String {
    let mut key = string::utf8(RESOURCE_PREFIX);
    key.append(string::utf8(OPERATIONS_CATEGORY));
    key.append(string::utf8(b"agreement"));
    key
}

/// Key for member management (add/remove)
public fun operations_membership(): String {
    let mut key = string::utf8(RESOURCE_PREFIX);
    key.append(string::utf8(OPERATIONS_CATEGORY));
    key.append(string::utf8(b"membership"));
    key
}

/// Key for role assignments
public fun operations_roles(): String {
    let mut key = string::utf8(RESOURCE_PREFIX);
    key.append(string::utf8(OPERATIONS_CATEGORY));
    key.append(string::utf8(b"roles"));
    key
}

// === Liquidity Management Resources ===

/// Key for creating new liquidity pools
public fun liquidity_create_pool<AssetType, StableType>(): String {
    let mut key = string::utf8(RESOURCE_PREFIX);
    key.append(string::utf8(LIQUIDITY_CATEGORY));
    key.append(string::utf8(b"create/"));
    let asset_str = type_name::into_string(type_name::get<AssetType>());
    key.append(string::from_ascii(asset_str));
    key.append(string::utf8(b"/"));
    let stable_str = type_name::into_string(type_name::get<StableType>());
    key.append(string::from_ascii(stable_str));
    key
}

/// Key for adding liquidity
public fun liquidity_add<AssetType, StableType>(): String {
    let mut key = string::utf8(RESOURCE_PREFIX);
    key.append(string::utf8(LIQUIDITY_CATEGORY));
    key.append(string::utf8(b"add/"));
    let asset_str = type_name::into_string(type_name::get<AssetType>());
    key.append(string::from_ascii(asset_str));
    key.append(string::utf8(b"/"));
    let stable_str = type_name::into_string(type_name::get<StableType>());
    key.append(string::from_ascii(stable_str));
    key
}

/// Key for removing liquidity
public fun liquidity_remove<AssetType, StableType>(): String {
    let mut key = string::utf8(RESOURCE_PREFIX);
    key.append(string::utf8(LIQUIDITY_CATEGORY));
    key.append(string::utf8(b"remove/"));
    let asset_str = type_name::into_string(type_name::get<AssetType>());
    key.append(string::from_ascii(asset_str));
    key.append(string::utf8(b"/"));
    let stable_str = type_name::into_string(type_name::get<StableType>());
    key.append(string::from_ascii(stable_str));
    key
}

/// Key for modifying pool parameters
public fun liquidity_params(): String {
    let mut key = string::utf8(RESOURCE_PREFIX);
    key.append(string::utf8(LIQUIDITY_CATEGORY));
    key.append(string::utf8(b"params"));
    key
}

// === Security Council Resources ===

/// Key for security council emergency actions
public fun security_emergency_action(): String {
    let mut key = string::utf8(RESOURCE_PREFIX);
    key.append(string::utf8(SECURITY_CATEGORY));
    key.append(string::utf8(b"emergency"));
    key
}

/// Key for security council membership changes
public fun security_council_membership(): String {
    let mut key = string::utf8(RESOURCE_PREFIX);
    key.append(string::utf8(SECURITY_CATEGORY));
    key.append(string::utf8(b"membership"));
    key
}

/// Key for security council veto power
public fun security_veto(): String {
    let mut key = string::utf8(RESOURCE_PREFIX);
    key.append(string::utf8(SECURITY_CATEGORY));
    key.append(string::utf8(b"veto"));
    key
}

// === Payment Streams Resources ===

/// Key for creating payment streams
public fun streams_create<CoinType>(): String {
    let mut key = string::utf8(RESOURCE_PREFIX);
    key.append(string::utf8(STREAMS_CATEGORY));
    key.append(string::utf8(b"create/"));
    let type_str = type_name::into_string(type_name::get<CoinType>());
    key.append(string::from_ascii(type_str));
    key
}

/// Key for canceling payment streams
public fun streams_cancel(): String {
    let mut key = string::utf8(RESOURCE_PREFIX);
    key.append(string::utf8(STREAMS_CATEGORY));
    key.append(string::utf8(b"cancel"));
    key
}

// === Open Extension & Catch-All ===

/// Publisher-scoped extension key for arbitrary resources.
/// Example: "resource:/ext/0xabc/streams/create"
public fun ext(publisher: address, module_name: String, name: String): String {
    let mut key = string::utf8(RESOURCE_PREFIX);
    key.append(string::utf8(EXT_CATEGORY));
    key.append(publisher.to_string());
    key.append(string::utf8(b"/"));
    key.append(module_name);
    key.append(string::utf8(b"/"));
    key.append(name);
    key
}

/// A generic "other" bucket when you don't want publisher scoping.
/// Example: "resource:/other/my/custom/path"
public fun other(path: String): String {
    let mut key = string::utf8(RESOURCE_PREFIX);
    key.append(string::utf8(OTHER_CATEGORY));
    key.append(path);
    key
}

/// Catch-all wildcard that matches any resource key.
/// Returns "resource:/*"
public fun any(): String {
    let mut key = string::utf8(RESOURCE_PREFIX);
    key.append(string::utf8(b"*"));
    key
}

/// Prefix wildcard helper. Given a concrete resource key, produce a pattern
/// that matches "this key as a prefix". E.g. input "resource:/vault/spend/0x2::sui::SUI"
/// returns "resource:/vault/spend/0x2::sui::SUI*".
public fun wildcard_prefix(resource_key: String): String {
    assert!(is_valid(&resource_key), EBadResourceKey);
    let mut pattern = resource_key;
    pattern.append(string::utf8(b"*"));
    pattern
}

/// Simple wildcard matching:
/// - Exact match (no '*') → equality
/// - Trailing '*' only → prefix match (before the '*')
/// Any other placement of '*' is rejected (returns false).
public fun matches(pattern: &String, key: &String): bool {
    let star = pattern.index_of(&string::utf8(b"*"));
    if (star == pattern.length()) {
        // no '*': exact match
        *pattern == *key
    } else if (star + 1 == pattern.length()) {
        // trailing '*': prefix match
        let pfx = pattern.substring(0, star);
        key.index_of(&pfx) == 0
    } else {
        // embedded '*' not supported
        false
    }
}

/// Scope a resource key under a proposal. Useful to ensure one proposal
/// cannot affect another's resources unintentionally.
/// Produces: "resource:/proposal/<proposal_key>/<resource-part>"
public fun for_proposal(proposal_key: String, resource_key: String): String {
    let mut key = string::utf8(RESOURCE_PREFIX);
    key.append(string::utf8(b"proposal/"));
    key.append(proposal_key);
    key.append(string::utf8(b"/"));
    let resource_part = strip_prefix_or_abort(&resource_key);
    key.append(resource_part);
    key
}

// === Role-Based Keys ===

/// Generate a role-specific resource key
/// Example: "resource:/role/admin/vault/spend/0x2::sui::SUI"
public fun for_role(role: String, resource_key: String): String {
    let mut key = string::utf8(RESOURCE_PREFIX);
    key.append(string::utf8(b"role/"));
    key.append(role);
    key.append(string::utf8(b"/"));
    let resource_part = strip_prefix_or_abort(&resource_key);
    key.append(resource_part);
    key
}

/// Generate a time-bounded resource key
/// Example: "resource:/timelock/86400/package/upgrade/0x123::pkg"
public fun with_timelock(delay_ms: u64, resource_key: String): String {
    let mut key = string::utf8(RESOURCE_PREFIX);
    key.append(string::utf8(b"timelock/"));
    key.append(delay_ms.to_string());
    key.append(string::utf8(b"/"));
    let resource_part = strip_prefix_or_abort(&resource_key);
    key.append(resource_part);
    key
}

/// Generate a threshold-based resource key
/// Example: "resource:/threshold/3of5/vault/spend/0x2::sui::SUI"
public fun with_threshold(required: u64, total: u64, resource_key: String): String {
    let mut key = string::utf8(RESOURCE_PREFIX);
    key.append(string::utf8(b"threshold/"));
    key.append(required.to_string());
    key.append(string::utf8(b"of"));
    key.append(total.to_string());
    key.append(string::utf8(b"/"));
    let resource_part = strip_prefix_or_abort(&resource_key);
    key.append(resource_part);
    key
}

// === Utility Functions ===

/// Check if a key represents a critical resource
public fun is_critical_resource(key: &String): bool {
    key.index_of(&string::utf8(b"emergency")) != key.length() ||
    key.index_of(&string::utf8(b"restrict")) != key.length() ||
    key.index_of(&string::utf8(b"mint")) != key.length() ||
    key.index_of(&string::utf8(b"security")) != key.length()
}

/// Extract the category from a resource key
public fun get_category(key: &String): String {
    // Assumes valid "resource:/..."
    if (!is_valid(key)) return string::utf8(b"unknown");
    let start = RESOURCE_PREFIX_LEN;
    // Search for the next "/" after the prefix
    let tail = key.substring(start, key.length());
    let next = tail.index_of(&string::utf8(b"/"));
    if (next == tail.length()) {
        // no more slashes → whole tail is the category
        tail
    } else {
        // category is the substring up to the slash
        key.substring(start, start + next)
    }
}

// === Tests ===

#[test]
fun test_resource_keys() {
    use sui::test_utils::assert_eq;
    
    // Test package keys
    let pkg_key = package_upgrade(@0x123, b"my_package".to_string());
    assert_eq(pkg_key, b"resource:/package/upgrade/0000000000000000000000000000000000000000000000000000000000000123::my_package".to_string());
    
    // Test vault keys
    let vault_key = vault_spend_by_type(type_name::get<sui::sui::SUI>());
    assert!(vault_key.length() > 0);
    
    // Test role-based keys
    let admin_vault = for_role(
        b"admin".to_string(),
        b"resource:/vault/spend/0x2::sui::SUI".to_string()
    );
    assert_eq(admin_vault, b"resource:/role/admin/vault/spend/0x2::sui::SUI".to_string());
    
    // Test critical resource detection
    let emergency_key = governance_emergency();
    assert!(is_critical_resource(&emergency_key));
}

#[test]
fun test_category_extraction() {
    use sui::test_utils::assert_eq;
    
    let pkg_key = package_upgrade(@0x123, b"test".to_string());
    let category = get_category(&pkg_key);
    assert_eq(category, b"package".to_string());
    
    let vault_key = vault_config();
    let vault_cat = get_category(&vault_key);
    assert_eq(vault_cat, b"vault".to_string());
}

#[test]
fun test_wildcard_and_matches() {
    let k = vault_config();
    let all = any();
    assert!(matches(&all, &k));

    let p = wildcard_prefix(vault_config());
    assert!(matches(&p, &k));
    assert!(!matches(&p, &package_publish()));
}

#[test]
fun test_ext_and_other() {
    let k1 = ext(@0x123, b"m".to_string(), b"a".to_string());
    let k2 = other(b"my/custom/path".to_string());
    assert!(is_valid(&k1));
    assert!(is_valid(&k2));
}/// Vault management intents for futarchy DAOs
/// Provides governance-controlled coin type management with permissionless deposits for allowed types
module futarchy::vault_intents;

// === Imports ===
use std::string::String;
use sui::coin::Coin;
use account_protocol::{
    account::{Account, Auth},
    intents::Params,
    intent_interface,
};
use account_actions::vault;
use futarchy::{
    futarchy_config::{Self, FutarchyConfig, FutarchyOutcome},
    futarchy_vault,
    version,
};

// === Aliases ===
use fun intent_interface::build_intent as Account.build_intent;

// === Structs ===

/// Intent witness for adding a new coin type to the vault
public struct AddCoinTypeIntent() has copy, drop;

/// Intent witness for removing a coin type from the vault
public struct RemoveCoinTypeIntent() has copy, drop;

// === Public Functions ===

/// Request to add a new coin type to the vault (requires governance)
/// This creates an intent that must be approved through a proposal
public fun request_add_coin_type<CoinType>(
    auth: Auth,
    account: &mut Account<FutarchyConfig>,
    params: Params,
    outcome: FutarchyOutcome,
    vault_name: String,
    ctx: &mut TxContext,
) {
    account.verify(auth);
    params.assert_single_execution();
    
    // Check that coin type is not already allowed
    assert!(
        !futarchy_vault::is_coin_type_allowed<FutarchyConfig, CoinType>(account),
        0 // ECoinTypeAlreadyAllowed
    );
    
    account.build_intent!(
        params,
        outcome,
        vault_name,
        version::current(),
        AddCoinTypeIntent(),
        ctx,
        |intent, iw| new_add_coin_type<_, CoinType, _>(
            intent, 
            vault_name, 
            iw
        )
    );
}

/// Request to remove a coin type from the vault (requires governance)
public fun request_remove_coin_type<CoinType>(
    auth: Auth,
    account: &mut Account<FutarchyConfig>,
    params: Params,
    outcome: FutarchyOutcome,
    vault_name: String,
    ctx: &mut TxContext,
) {
    account.verify(auth);
    params.assert_single_execution();
    
    // Check that coin type is currently allowed
    assert!(
        futarchy_vault::is_coin_type_allowed<FutarchyConfig, CoinType>(account),
        1 // ECoinTypeNotAllowed
    );
    
    account.build_intent!(
        params,
        outcome,
        vault_name,
        version::current(),
        RemoveCoinTypeIntent(),
        ctx,
        |intent, iw| new_remove_coin_type<_, CoinType, _>(
            intent,
            vault_name,
            iw
        )
    );
}

/// Helper function to create add coin type action in an intent
public fun new_add_coin_type<Outcome, CoinType, IW: drop>(
    intent: &mut account_protocol::intents::Intent<Outcome>,
    vault_name: String,
    intent_witness: IW,
) {
    let action = futarchy_vault::new_add_coin_type_action<CoinType>(vault_name);
    intent.add_action(action, intent_witness);
}

/// Helper function to create remove coin type action in an intent
public fun new_remove_coin_type<Outcome, CoinType, IW: drop>(
    intent: &mut account_protocol::intents::Intent<Outcome>,
    vault_name: String,
    intent_witness: IW,
) {
    let action = futarchy_vault::new_remove_coin_type_action<CoinType>(vault_name);
    intent.add_action(action, intent_witness);
}/// LP Token Custody Module
/// Manages LP tokens owned by DAOs from liquidity operations
/// 
/// This module provides secure custody of LP tokens using Account's managed assets feature.
/// Benefits of using managed assets over direct transfers:
/// 1. Enforces custody under Account's policy engine
/// 2. Prevents accidental outflows or unauthorized transfers
/// 3. Makes the relationship between Account and LP tokens explicit and enforceable
/// 4. Integrates with Account's permission system for access control
/// 5. Provides better tracking and audit capabilities
module futarchy::lp_token_custody;

use std::{string::String, option};
use sui::{
    object::{Self, ID},
    table::{Self, Table},
    event,
    transfer,
};
use account_protocol::{
    account::{Self, Account, Auth},
};
use futarchy::{
    version,
    futarchy_config::FutarchyConfig,
    account_spot_pool::{Self, LPToken},
};

// === Errors ===
const ELPTokenNotFound: u64 = 1;
const EInsufficientBalance: u64 = 2;
const EUnauthorized: u64 = 3;

// === Structs ===

/// Dynamic field key for LP token custody
public struct LPCustodyKey has copy, drop, store {}

/// Managed-asset key for storing LP tokens by ID (safer schema)
public struct LPKey has copy, drop, store {
    token_id: ID,
}

/// Enhanced LP token registry with better tracking capabilities
public struct LPTokenCustody has store {
    // Pool ID -> vector of LP token IDs
    tokens_by_pool: Table<ID, vector<ID>>,
    // Token ID -> amount for quick lookup
    token_amounts: Table<ID, u64>,
    // Token ID -> pool ID mapping for reverse lookup
    token_to_pool: Table<ID, ID>,
    // Pool ID -> total LP amount for that pool
    pool_totals: Table<ID, u64>,
    // Total value locked (sum of all LP tokens)
    total_value_locked: u64,
    // Registry of all pool IDs we have tokens for
    active_pools: vector<ID>,
}

// === Events ===

public struct LPTokenDeposited has copy, drop {
    account_id: ID,
    pool_id: ID,
    token_id: ID,
    amount: u64,
    new_pool_total: u64,
    new_total_value_locked: u64,
}

public struct LPTokenWithdrawn has copy, drop {
    account_id: ID,
    pool_id: ID,
    token_id: ID,
    amount: u64,
    recipient: address,
    new_pool_total: u64,
    new_total_value_locked: u64,
}

// === Public Functions ===

/// Initialize LP token custody for an account
public(package) fun init_custody(
    account: &mut Account<FutarchyConfig>,
    ctx: &mut TxContext,
) {
    if (!has_custody(account)) {
        account::add_managed_data(
            account,
            LPCustodyKey {},
            LPTokenCustody {
                tokens_by_pool: table::new(ctx),
                token_amounts: table::new(ctx),
                token_to_pool: table::new(ctx),
                pool_totals: table::new(ctx),
                total_value_locked: 0,
                active_pools: vector::empty(),
            },
            version::current()
        );
    }
}

/// Check if account has LP custody initialized
public fun has_custody(account: &Account<FutarchyConfig>): bool {
    account::has_managed_data(account, LPCustodyKey {})
}

/// Deposit an LP token into custody
public(package) fun deposit_lp_token<AssetType, StableType>(
    auth: Auth,
    account: &mut Account<FutarchyConfig>,
    pool_id: ID,
    token: LPToken<AssetType, StableType>,
    ctx: &mut TxContext,
) {
    account::verify(account, auth);
    
    // Get account ID before mutable borrowing
    let account_id = object::id(account);
    let account_address = object::id_address(account);
    
    // Initialize custody if needed
    if (!has_custody(account)) {
        init_custody(account, ctx);
    };
    
    let custody: &mut LPTokenCustody = account::borrow_managed_data_mut(
        account,
        LPCustodyKey {},
        version::current()
    );
    
    let token_id = object::id(&token);
    let amount = account_spot_pool::lp_token_amount(&token);
    
    // Update tokens by pool
    if (!custody.tokens_by_pool.contains(pool_id)) {
        custody.tokens_by_pool.add(pool_id, vector::empty());
        custody.pool_totals.add(pool_id, 0);
        // Add to active pools if not already present
        let (found, _) = custody.active_pools.index_of(&pool_id);
        if (!found) {
            custody.active_pools.push_back(pool_id);
        };
    };
    let pool_tokens = custody.tokens_by_pool.borrow_mut(pool_id);
    pool_tokens.push_back(token_id);
    
    // Update token tracking tables
    custody.token_amounts.add(token_id, amount);
    custody.token_to_pool.add(token_id, pool_id);
    
    // Update pool total
    let pool_total = custody.pool_totals.borrow_mut(pool_id);
    *pool_total = *pool_total + amount;
    
    // Update global total
    custody.total_value_locked = custody.total_value_locked + amount;
    
    // Get values for event before transfer
    let new_pool_total = *custody.pool_totals.borrow(pool_id);
    let new_total_value_locked = custody.total_value_locked;
    
    // Store LP token as a managed asset in the Account
    // This ensures proper custody under Account's policy engine and prevents accidental outflows
    // The LPKey with token_id is used as the key for retrieval
    account::add_managed_asset(
        account,
        LPKey { token_id },
        token,
        version::current()
    );
    
    event::emit(LPTokenDeposited {
        account_id,
        pool_id,
        token_id,
        amount,
        new_pool_total,
        new_total_value_locked,
    });
}

/// Withdraw LP tokens from custody
/// The token_id identifies which LP token to withdraw from managed assets
/// The LP token is transferred to the account as a child object for safety
/// Users can then transfer it from the account in a separate transaction
public(package) fun withdraw_lp_token<AssetType, StableType>(
    auth: Auth,
    account: &mut Account<FutarchyConfig>,
    pool_id: ID,
    token_id: ID,  // Changed from passing the token to just the ID
    _ctx: &mut TxContext,
) {
    account::verify(account, auth);
    
    // Get account ID before mutable borrowing
    let account_id = object::id(account);
    
    // Retrieve the LP token from managed assets
    let token: LPToken<AssetType, StableType> = account::remove_managed_asset(
        account,
        LPKey { token_id },
        version::current()
    );
    
    let amount = account_spot_pool::lp_token_amount(&token);
    
    let custody: &mut LPTokenCustody = account::borrow_managed_data_mut(
        account,
        LPCustodyKey {},
        version::current()
    );
    
    // Verify token is in custody
    assert!(custody.token_amounts.contains(token_id), ELPTokenNotFound);
    assert!(custody.token_amounts[token_id] == amount, EInsufficientBalance);
    
    // Remove from tracking tables
    custody.token_amounts.remove(token_id);
    custody.token_to_pool.remove(token_id);
    
    // Update pool total
    let pool_total = custody.pool_totals.borrow_mut(pool_id);
    *pool_total = *pool_total - amount;
    
    // Update global total
    custody.total_value_locked = custody.total_value_locked - amount;
    
    // Remove from pool tokens list
    if (custody.tokens_by_pool.contains(pool_id)) {
        let pool_tokens = custody.tokens_by_pool.borrow_mut(pool_id);
        let (found, index) = pool_tokens.index_of(&token_id);
        if (found) {
            pool_tokens.remove(index);
            
            // If no more tokens for this pool, remove from active pools
            if (pool_tokens.is_empty()) {
                let (pool_found, pool_index) = custody.active_pools.index_of(&pool_id);
                if (pool_found) {
                    custody.active_pools.remove(pool_index);
                };
            };
        };
    };
    
    // Get values for event before transfer
    let new_pool_total = *custody.pool_totals.borrow(pool_id);
    let new_total_value_locked = custody.total_value_locked;
    
    // Transfer token to the account itself for safety
    // Users can transfer it from the account in a separate transaction
    let account_address = object::id_address(account);
    transfer::public_transfer(token, account_address);
    
    event::emit(LPTokenWithdrawn {
        account_id,
        pool_id,
        token_id,
        amount,
        recipient: account_address,
        new_pool_total,
        new_total_value_locked,
    });
}

/// Get total value locked in LP tokens
public fun get_total_value_locked(account: &Account<FutarchyConfig>): u64 {
    if (!has_custody(account)) {
        return 0
    };
    
    let custody: &LPTokenCustody = account::borrow_managed_data(
        account,
        LPCustodyKey {},
        version::current()
    );
    
    custody.total_value_locked
}

/// Get LP token IDs for a specific pool
public fun get_pool_tokens(
    account: &Account<FutarchyConfig>,
    pool_id: ID,
): vector<ID> {
    if (!has_custody(account)) {
        return vector::empty()
    };
    
    let custody: &LPTokenCustody = account::borrow_managed_data(
        account,
        LPCustodyKey {},
        version::current()
    );
    
    if (custody.tokens_by_pool.contains(pool_id)) {
        *custody.tokens_by_pool.borrow(pool_id)
    } else {
        vector::empty()
    }
}

/// Get amount for a specific LP token
public fun get_token_amount(
    account: &Account<FutarchyConfig>,
    token_id: ID,
): u64 {
    if (!has_custody(account)) {
        return 0
    };
    
    let custody: &LPTokenCustody = account::borrow_managed_data(
        account,
        LPCustodyKey {},
        version::current()
    );
    
    if (custody.token_amounts.contains(token_id)) {
        custody.token_amounts[token_id]
    } else {
        0
    }
}

/// Get the pool ID that contains a specific LP token
public fun get_token_pool(
    account: &Account<FutarchyConfig>,
    token_id: ID,
): Option<ID> {
    if (!has_custody(account)) {
        return option::none()
    };
    
    let custody: &LPTokenCustody = account::borrow_managed_data(
        account,
        LPCustodyKey {},
        version::current()
    );
    
    if (custody.token_to_pool.contains(token_id)) {
        option::some(custody.token_to_pool[token_id])
    } else {
        option::none()
    }
}

/// Get total LP token amount for a specific pool
public fun get_pool_total(
    account: &Account<FutarchyConfig>,
    pool_id: ID,
): u64 {
    if (!has_custody(account)) {
        return 0
    };
    
    let custody: &LPTokenCustody = account::borrow_managed_data(
        account,
        LPCustodyKey {},
        version::current()
    );
    
    if (custody.pool_totals.contains(pool_id)) {
        custody.pool_totals[pool_id]
    } else {
        0
    }
}

/// Get all active pool IDs (pools that have LP tokens)
public fun get_active_pools(
    account: &Account<FutarchyConfig>,
): vector<ID> {
    if (!has_custody(account)) {
        return vector::empty()
    };
    
    let custody: &LPTokenCustody = account::borrow_managed_data(
        account,
        LPCustodyKey {},
        version::current()
    );
    
    custody.active_pools
}

/// Check if account has any LP tokens for a specific pool
public fun has_tokens_for_pool(
    account: &Account<FutarchyConfig>,
    pool_id: ID,
): bool {
    if (!has_custody(account)) {
        return false
    };
    
    let custody: &LPTokenCustody = account::borrow_managed_data(
        account,
        LPCustodyKey {},
        version::current()
    );
    
    custody.tokens_by_pool.contains(pool_id) && !custody.tokens_by_pool[pool_id].is_empty()
}

/// Get summary statistics for all LP token holdings
public fun get_custody_summary(
    account: &Account<FutarchyConfig>,
): (u64, u64, vector<ID>) {
    if (!has_custody(account)) {
        return (0, 0, vector::empty())
    };
    
    let custody: &LPTokenCustody = account::borrow_managed_data(
        account,
        LPCustodyKey {},
        version::current()
    );
    
    (
        custody.total_value_locked,
        custody.active_pools.length(),
        custody.active_pools
    )
}/// Vault operations for futarchy accounts with controlled coin type access
/// Allows permissionless deposits of existing coin types but requires governance for new types
module futarchy::futarchy_vault;

// === Imports ===
use std::{
    string::String,
    type_name::{Self, TypeName},
};
use sui::{
    bag::{Self, Bag},
    coin::Coin,
    event,
    vec_set::{Self, VecSet},
};
use account_protocol::{
    account::{Self, Account, Auth},
    executable::Executable,
    version_witness::VersionWitness,
};
use account_actions::vault;
use futarchy::{
    futarchy_config::{Self, FutarchyConfig},
    version,
};

// === Errors ===
const ECoinTypeNotAllowed: u64 = 1;
const EVaultNotInitialized: u64 = 2;
const ECoinTypeDoesNotExist: u64 = 3;

// === Constants ===
const VAULT_KEY: vector<u8> = b"futarchy_vault";
const ALLOWED_COINS_KEY: vector<u8> = b"allowed_coin_types";
const DEFAULT_VAULT_NAME: vector<u8> = b"treasury";

/// Get the default vault name (treasury) - the source of truth for the DAO's main vault
public fun default_vault_name(): vector<u8> {
    DEFAULT_VAULT_NAME
}

// === Structs ===

/// Event emitted when revenue is deposited to a DAO
public struct RevenueDeposited has copy, drop {
    dao_id: ID,
    depositor: address,
    coin_type: TypeName,
    amount: u64,
    vault_name: String,
}

/// Minimal vault storage for initialization only
public struct Vault has store {
    balances: Bag,
    treasury_caps: Bag,
}

/// Tracks which coin types are allowed in the vault
public struct AllowedCoinTypes has store {
    types: VecSet<TypeName>,
}

/// Action to add a new coin type to the allowed list (requires governance)
public struct AddCoinTypeAction<phantom CoinType> has store {
    vault_name: String,
}

/// Action to remove a coin type from the allowed list (requires governance)
public struct RemoveCoinTypeAction<phantom CoinType> has store {
    vault_name: String,
}

// === Public Functions ===

/// Initialize vault for a futarchy account
public fun init_vault<Config>(
    account: &mut Account<Config>,
    version: VersionWitness,
    ctx: &mut TxContext
) {
    let vault = Vault {
        balances: bag::new(ctx),
        treasury_caps: bag::new(ctx),
    };
    
    // Store vault in account managed data
    account::add_managed_data(
        account,
        VAULT_KEY,
        vault,
        version,
    );
    
    // Initialize allowed coin types set
    let allowed = AllowedCoinTypes {
        types: vec_set::empty(),
    };
    
    account::add_managed_data(
        account,
        ALLOWED_COINS_KEY,
        allowed,
        version,
    );
    
    // Open the default treasury vault
    // Note: vault::open requires Auth, but we're initializing during DAO creation
    // The actual vault opening is handled by account_actions::vault module
    // We just initialize the allowed coin types tracking here
}

/// Check if a coin type is allowed in the vault
public fun is_coin_type_allowed<Config, CoinType>(
    account: &Account<Config>,
): bool {
    // Check if the allowed coins list exists
    if (!account::has_managed_data(account, ALLOWED_COINS_KEY)) {
        return false
    };
    
    let allowed: &AllowedCoinTypes = account::borrow_managed_data(
        account,
        ALLOWED_COINS_KEY,
        version::current()
    );
    allowed.types.contains(&type_name::get<CoinType>())
}

/// PERMISSIONLESS: Deposit coins of a type that already exists in the vault
/// Anyone can deposit if the DAO already holds this coin type
public fun deposit_existing_coin_type<CoinType: drop>(
    account: &mut Account<FutarchyConfig>,
    coin: Coin<CoinType>,
    vault_name: String,
    ctx: &mut TxContext,
) {
    // Check if the vault exists and has this coin type
    assert!(
        vault::has_vault(account, vault_name) &&
        vault::borrow_vault(account, vault_name).coin_type_exists<CoinType>(),
        ECoinTypeDoesNotExist
    );
    
    // Get a permissionless auth token
    let auth = futarchy_config::authenticate(account, ctx);
    
    // Deposit to vault
    vault::deposit(auth, account, vault_name, coin);
}

/// ENTRY: Public entry function for depositing revenue/donations to a DAO
/// Anyone can send coins of a type the DAO already holds
public entry fun deposit_revenue<CoinType: drop>(
    account: &mut Account<FutarchyConfig>,
    coin: Coin<CoinType>,
    ctx: &mut TxContext,
) {
    // Use default vault name for revenue deposits (primary)
    let vault_name = b"primary".to_string();
    let amount = coin.value();
    let dao_id = object::id(account);
    
    // Deposit only if DAO already has this coin type
    deposit_existing_coin_type<CoinType>(account, coin, vault_name, ctx);
    
    // Emit event for transparency
    event::emit(RevenueDeposited {
        dao_id,
        depositor: ctx.sender(),
        coin_type: type_name::get<CoinType>(),
        amount,
        vault_name,
    });
}

/// GOVERNANCE: Initial deposit of a new coin type
/// Requires governance approval to add a new coin type to the vault
public fun deposit_new_coin_type<CoinType: drop>(
    auth: Auth,
    account: &mut Account<FutarchyConfig>,
    coin: Coin<CoinType>,
    vault_name: String,
) {
    // Direct deposit with auth - this will verify and create the coin type entry if it doesn't exist
    vault::deposit(auth, account, vault_name, coin);
}

/// GOVERNANCE ONLY: Add a new coin type to the allowed list
/// This should only be called through a governance proposal
public fun do_add_coin_type<Outcome: store, CoinType, IW: drop>(
    executable: &mut Executable<Outcome>,
    account: &mut Account<FutarchyConfig>,
    version: VersionWitness,
    intent_witness: IW,
    _ctx: &mut TxContext,
) {
    let action: &AddCoinTypeAction<CoinType> = executable.next_action(intent_witness);
    
    // Add coin type to allowed list
    let allowed: &mut AllowedCoinTypes = account::borrow_managed_data_mut(
        account,
        ALLOWED_COINS_KEY,
        version
    );
    
    let type_name = type_name::get<CoinType>();
    if (!allowed.types.contains(&type_name)) {
        allowed.types.insert(type_name);
    };
    
    // Note: The vault itself will automatically create storage for this type
    // when the first deposit happens
    let _ = action.vault_name;
}

/// GOVERNANCE ONLY: Remove a coin type from the allowed list
public fun do_remove_coin_type<Outcome: store, CoinType, IW: drop>(
    executable: &mut Executable<Outcome>,
    account: &mut Account<FutarchyConfig>,
    version: VersionWitness,
    intent_witness: IW,
    _ctx: &mut TxContext,
) {
    let action: &RemoveCoinTypeAction<CoinType> = executable.next_action(intent_witness);
    
    // Remove coin type from allowed list
    let allowed: &mut AllowedCoinTypes = account::borrow_managed_data_mut(
        account,
        ALLOWED_COINS_KEY,
        version
    );
    
    let type_name = type_name::get<CoinType>();
    if (allowed.types.contains(&type_name)) {
        allowed.types.remove(&type_name);
    };
    
    // Note: This doesn't remove existing coins of this type from the vault,
    // it just prevents future deposits
    let _ = action.vault_name;
}

// === Helper Functions ===

/// Create a new add coin type action
public fun new_add_coin_type_action<CoinType>(
    vault_name: String,
): AddCoinTypeAction<CoinType> {
    AddCoinTypeAction { vault_name }
}

/// Create a new remove coin type action
public fun new_remove_coin_type_action<CoinType>(
    vault_name: String,
): RemoveCoinTypeAction<CoinType> {
    RemoveCoinTypeAction { vault_name }
}

// === Cleanup Functions ===

/// Delete an add coin type action from an expired intent
public fun delete_add_coin_type<CoinType>(expired: &mut account_protocol::intents::Expired) {
    let AddCoinTypeAction<CoinType> { vault_name: _ } = expired.remove_action();
}

/// Delete a remove coin type action from an expired intent
public fun delete_remove_coin_type<CoinType>(expired: &mut account_protocol::intents::Expired) {
    let RemoveCoinTypeAction<CoinType> { vault_name: _ } = expired.remove_action();
}/// Futarchy vault initialization module
/// The vault itself is managed by account_actions::vault
module futarchy::futarchy_vault_init;

use account_protocol::{
    account::Account,
    version_witness::VersionWitness,
};
use futarchy::futarchy_config::FutarchyConfig;
use futarchy::futarchy_vault;

// === Public Functions ===

/// Initialize vault during DAO creation
public(package) fun initialize(
    account: &mut Account<FutarchyConfig>,
    version: VersionWitness,
    ctx: &mut TxContext
) {
    // Initialize the vault in the futarchy_vault actions module
    futarchy_vault::init_vault(account, version, ctx);
}module futarchy::custody_actions;

use std::string::String;
use sui::object::ID;
use account_protocol::intents::Expired;

/// DAO-side approval to accept an object R into council custody.
public struct ApproveCustodyAction<phantom R> has store {
    dao_id: ID,
    object_id: ID,
    resource_key: String,
    context: String,
    expires_at: u64,
}

/// Council action to accept an object R into custody.
public struct AcceptIntoCustodyAction<phantom R> has store {
    object_id: ID,
    resource_key: String,
    context: String,
}

// Constructors

public fun new_approve_custody<R>(
    dao_id: ID,
    object_id: ID,
    resource_key: String,
    context: String,
    expires_at: u64,
): ApproveCustodyAction<R> {
    ApproveCustodyAction<R> { dao_id, object_id, resource_key, context, expires_at }
}

public fun new_accept_into_custody<R>(
    object_id: ID,
    resource_key: String,
    context: String,
): AcceptIntoCustodyAction<R> {
    AcceptIntoCustodyAction<R> { object_id, resource_key, context }
}

// Getters

public fun get_approve_custody_params<R>(
    a: &ApproveCustodyAction<R>
): (ID, ID, &String, &String, u64) {
    (a.dao_id, a.object_id, &a.resource_key, &a.context, a.expires_at)
}

public fun get_accept_params<R>(
    a: &AcceptIntoCustodyAction<R>
): (ID, &String, &String) {
    (a.object_id, &a.resource_key, &a.context)
}

// Cleanup

public fun delete_approve_custody<R>(expired: &mut Expired) {
    let ApproveCustodyAction<R> {
        dao_id: _,
        object_id: _,
        resource_key: _,
        context: _,
        expires_at: _
    } = expired.remove_action();
}

public fun delete_accept_into_custody<R>(expired: &mut Expired) {
    let AcceptIntoCustodyAction<R> {
        object_id: _,
        resource_key: _,
        context: _
    } = expired.remove_action();
}/// Dispatcher for vault actions
module futarchy::vault_dispatcher;

// === Imports ===
use sui::tx_context::TxContext;
use account_protocol::{
    account::Account,
    executable::{Self, Executable},
};
use futarchy::{
    futarchy_config::FutarchyConfig,
    version,
    futarchy_vault,
};

// === Public(friend) Functions ===

/// Execute typed vault actions for managing allowed coin types
public(package) fun try_execute_typed_vault_action<CoinType, IW: drop, Outcome: store + drop + copy>(
    executable: &mut Executable<Outcome>,
    account: &mut Account<FutarchyConfig>,
    witness: IW,
    ctx: &mut TxContext
): bool {
    // Try to execute AddCoinTypeAction
    if (executable::contains_action<Outcome, futarchy_vault::AddCoinTypeAction<CoinType>>(executable)) {
        futarchy_vault::do_add_coin_type<Outcome, CoinType, IW>(
            executable,
            account,
            version::current(),
            witness,
            ctx
        );
        return true
    };
    
    // Try to execute RemoveCoinTypeAction
    if (executable::contains_action<Outcome, futarchy_vault::RemoveCoinTypeAction<CoinType>>(executable)) {
        futarchy_vault::do_remove_coin_type<Outcome, CoinType, IW>(
            executable,
            account,
            version::current(),
            witness,
            ctx
        );
        return true
    };
    
    false
}module futarchy::vectors;

use std::string::String;
use sui::vec_set;
use sui::coin::{Self, Coin};

// === Introduction ===
// Vector Methods and processing

// === Public Functions ===
// Combined check that a vector contains only unique elements and that all the elements are less then a certain length
public fun check_valid_outcomes(outcome: vector<String>, max_length: u64): bool {
    let length = outcome.length();
    if (length == 0) return false;

    // Create a vec_set to track unique strings
    let mut seen = vec_set::empty<String>();

    let mut i = 0;
    while (i < length) {
        let current_string_ref = &outcome[i];
        // Check length constraint
        let string_length = current_string_ref.length();
        if (string_length == 0 || string_length > max_length) {
            return false
        };
        if (seen.contains(current_string_ref)) {
            return false
        };

        // Add to our set of seen strings
        seen.insert(*current_string_ref);
        i = i + 1;
    };

    true
}

/// Validates a single outcome message - checks length bounds
public fun validate_outcome_message(message: &String, max_length: u64): bool {
    let length = message.length();
    length > 0 && length <= max_length
}

/// Validates outcome detail - checks length bounds
public fun validate_outcome_detail(detail: &String, max_length: u64): bool {
    let length = detail.length();
    length > 0 && length <= max_length
}

/// Checks if a message already exists in the outcome messages
public fun is_duplicate_message(outcome_messages: &vector<String>, new_message: &String): bool {
    let mut i = 0;
    let len = outcome_messages.length();
    while (i < len) {
        if (outcome_messages[i] == *new_message) {
            return true
        };
        i = i + 1;
    };
    false
}

/// Merges a vector of coins into a single coin
public fun merge_coins<T>(mut coins: vector<Coin<T>>, ctx: &mut TxContext): Coin<T> {
    assert!(!coins.is_empty(), 0);
    
    let mut merged = coins.pop_back();
    while (!coins.is_empty()) {
        coin::join(&mut merged, coins.pop_back());
    };
    coins.destroy_empty();
    
    merged
}
module futarchy::market_state;

use std::string::String;
use sui::clock::Clock;
use sui::event;

// === Introduction ===
// This module tracks proposal life cycle and acts as a source of truth for proposal state

// === Errors ===
const ETradingAlreadyStarted: u64 = 0;
const EOutcomeOutOfBounds: u64 = 1;
const EAlreadyFinalized: u64 = 2;
const ETradingAlreadyEnded: u64 = 3;
const ETradingNotEnded: u64 = 4;
const ENotFinalized: u64 = 5;
const ETradingNotStarted: u64 = 6;
const EInvalidDuration: u64 = 7;

// === Constants ===
const MAX_TRADING_DURATION_MS: u64 = 30 * 24 * 60 * 60 * 1000; // 30 days

// === Structs ===
public struct MarketStatus has copy, drop, store {
    trading_started: bool,
    trading_ended: bool,
    finalized: bool,
}

public struct MarketState has key, store {
    id: UID,
    market_id: ID,
    dao_id: ID,
    outcome_count: u64,
    outcome_messages: vector<String>,
    status: MarketStatus,
    winning_outcome: Option<u64>,
    creation_time: u64,
    trading_start: u64,
    trading_end: Option<u64>,
    finalization_time: Option<u64>,
}

// === Events ===
public struct TradingStartedEvent has copy, drop {
    market_id: ID,
    start_time: u64,
}

public struct TradingEndedEvent has copy, drop {
    market_id: ID,
    timestamp_ms: u64,
}

public struct MarketStateFinalizedEvent has copy, drop {
    market_id: ID,
    winning_outcome: u64,
    timestamp_ms: u64,
}

// === Public Package Functions ===
public(package) fun new(
    market_id: ID,
    dao_id: ID,
    outcome_count: u64,
    outcome_messages: vector<String>,
    clock: &Clock,
    ctx: &mut TxContext,
): MarketState {
    let timestamp = clock.timestamp_ms();

    MarketState {
        id: object::new(ctx),
        market_id,
        dao_id,
        outcome_count,
        outcome_messages,
        status: MarketStatus {
            trading_started: false,
            trading_ended: false,
            finalized: false,
        },
        winning_outcome: option::none(),
        creation_time: timestamp,
        trading_start: 0,
        trading_end: option::none(),
        finalization_time: option::none(),
    }
}

public(package) fun start_trading(state: &mut MarketState, duration_ms: u64, clock: &Clock) {
    assert!(!state.status.trading_started, ETradingAlreadyStarted);
    assert!(duration_ms > 0 && duration_ms <= MAX_TRADING_DURATION_MS, EInvalidDuration);

    let start_time = clock.timestamp_ms();
    let end_time = start_time + duration_ms;

    state.status.trading_started = true;
    state.trading_start = start_time;
    state.trading_end = option::some(end_time);

    event::emit(TradingStartedEvent {
        market_id: state.market_id,
        start_time,
    });
}

// === Public Functions ===
public fun assert_trading_active(state: &MarketState) {
    assert!(state.status.trading_started, ETradingNotStarted);
    assert!(!state.status.trading_ended, ETradingAlreadyEnded);
}

public fun assert_in_trading_or_pre_trading(state: &MarketState) {
    assert!(!state.status.trading_ended, ETradingAlreadyEnded);
    assert!(!state.status.finalized, EAlreadyFinalized);
}

public(package) fun end_trading(state: &mut MarketState, clock: &Clock) {
    assert!(state.status.trading_started, ETradingNotStarted);
    assert!(!state.status.trading_ended, ETradingAlreadyEnded);

    let timestamp = clock.timestamp_ms();
    state.status.trading_ended = true;

    event::emit(TradingEndedEvent {
        market_id: state.market_id,
        timestamp_ms: timestamp,
    });
}

public(package) fun finalize(state: &mut MarketState, winner: u64, clock: &Clock) {
    assert!(state.status.trading_ended, ETradingNotEnded);
    assert!(!state.status.finalized, EAlreadyFinalized);
    assert!(winner < state.outcome_count, EOutcomeOutOfBounds);

    let timestamp = clock.timestamp_ms();
    state.status.finalized = true;
    state.winning_outcome = option::some(winner);
    state.finalization_time = option::some(timestamp);

    event::emit(MarketStateFinalizedEvent {
        market_id: state.market_id,
        winning_outcome: winner,
        timestamp_ms: timestamp,
    });
}

// === Assertion Functions ===
public fun assert_market_finalized(state: &MarketState) {
    assert!(state.status.finalized, ENotFinalized);
}

public fun assert_not_finalized(state: &MarketState) {
    assert!(!state.status.finalized, EAlreadyFinalized);
}

public fun validate_outcome(state: &MarketState, outcome: u64) {
    assert!(outcome < state.outcome_count, EOutcomeOutOfBounds);
}

// === View Functions (Getters) ===
public fun market_id(state: &MarketState): ID {
    state.market_id
}

public fun outcome_count(state: &MarketState): u64 {
    state.outcome_count
}

// === View Functions (Predicates) ===
public fun is_trading_active(state: &MarketState): bool {
    state.status.trading_started && !state.status.trading_ended
}

public fun is_finalized(state: &MarketState): bool {
    state.status.finalized
}

public fun dao_id(state: &MarketState): ID {
    state.dao_id
}

public fun get_winning_outcome(state: &MarketState): u64 {
    use std::option;
    assert!(state.status.finalized, ENotFinalized);
    let opt_ref = &state.winning_outcome;
    assert!(option::is_some(opt_ref), ENotFinalized);
    *option::borrow(opt_ref)
}

public fun get_outcome_message(state: &MarketState, outcome_idx: u64): String {
    assert!(outcome_idx < state.outcome_count, EOutcomeOutOfBounds);
    state.outcome_messages[outcome_idx]
}

public fun get_creation_time(state: &MarketState): u64 {
    state.creation_time
}

public(package) fun get_trading_end_time(state: &MarketState): Option<u64> {
    state.trading_end
}

public fun get_trading_start(state: &MarketState): u64 {
    state.trading_start
}

public fun get_finalization_time(state: &MarketState): Option<u64> {
    state.finalization_time
}

// === Test Functions ===
#[test_only]
public fun create_for_testing(outcomes: u64, ctx: &mut TxContext): MarketState {
    let dummy_id = object::new(ctx);
    let market_id = dummy_id.uid_to_inner();
    dummy_id.delete();

    MarketState {
        id: object::new(ctx),
        market_id,
        dao_id: market_id,
        outcome_messages: vector[],
        outcome_count: outcomes,
        status: MarketStatus {
            trading_started: false,
            trading_ended: false,
            finalized: false,
        },
        winning_outcome: option::none(),
        creation_time: 0,
        trading_start: 0,
        trading_end: option::none(),
        finalization_time: option::none(),
    }
}

#[test_only]
public fun init_trading_for_testing(state: &mut MarketState) {
    state.status.trading_started = true;
    state.trading_start = 0;
    state.trading_end = option::some(9999999999999);
}
#[test_only]
public fun reset_state_for_testing(state: &mut MarketState) {
    state.status.trading_started = false;
    state.trading_start = 0;
}

#[test_only]
public fun finalize_for_testing(state: &mut MarketState) {
    state.status.trading_ended = true;
    state.status.finalized = true;
    state.winning_outcome = option::some(0);
    state.finalization_time = option::some(0);
}

#[test_only]
public fun destroy_for_testing(state: MarketState) {
    sui::test_utils::destroy(state);
}

#[test_only]
public fun copy_market_id(state: &MarketState): ID {
    state.market_id
}

#[test_only]
public fun copy_status(state: &MarketState): MarketStatus {
    state.status
}

#[test_only]
public fun copy_winning_outcome(state: &MarketState): Option<u64> {
    state.winning_outcome
}

#[test_only]
public fun test_set_winning_outcome(state: &mut MarketState, outcome: u64) {
    state.winning_outcome = option::some(outcome);
}

#[test_only]
public fun test_set_finalized(state: &mut MarketState) {
    state.status.finalized = true;
    state.status.trading_ended = true;
    state.finalization_time = option::some(0);
}
/// Centralized constants for the Futarchy protocol
/// This module contains all magic numbers and configuration constants
/// to ensure consistency across the codebase
module futarchy::constants;

// === AMM Fee Constants ===

/// Maximum fee in basis points (100%)
public fun max_fee_bps(): u64 { 10000 }

/// LP fee share in basis points (80% of fees go to LPs)
public fun lp_fee_share_bps(): u64 { 8000 }

/// Total fee basis points denominator (100%)
public fun total_fee_bps(): u64 { 10000 }

/// Default AMM total fee in basis points (0.3%)
public fun default_amm_total_fee_bps(): u64 { 30 }

// === Price Precision Constants ===

/// Basis points precision for price calculations (10^12)
/// We use high precision to prevent rounding to 0
public fun basis_points(): u64 { 1_000_000_000_000 }

/// Parts per million denominator for percentage calculations
public fun ppm_denominator(): u64 { 1_000_000 }

// === Time Constants ===

/// TWAP price cap window in milliseconds (60 seconds)
public fun twap_price_cap_window(): u64 { 60_000 }

/// One week in milliseconds
public fun one_week_ms(): u64 { 604_800_000 }

/// Default permit expiry time (5 minutes)
public fun default_permit_expiry_ms(): u64 { 5 * 60_000 }

// === Governance Constants ===

/// Maximum concurrent proposals allowed in the queue
public fun max_concurrent_proposals(): u64 { 100 }

/// Maximum queue size for proposals
public fun max_queue_size(): u64 { 100 }

/// Grace period for proposal eviction
public fun proposal_grace_period_ms(): u64 { 24 * 60 * 60_000 } // 24 hours

// === Cleanup Constants ===

/// Maximum intents that can be cleaned in one call
public fun max_cleanup_per_call(): u64 { 20 }

/// Maximum pending withdrawals per payment stream
public fun max_pending_withdrawals(): u64 { 10 }

// === Market Constants ===

/// Number of outcomes for binary markets
public fun binary_outcomes(): u64 { 2 }

/// Token type constants
public fun token_type_asset(): u8 { 0 }
public fun token_type_stable(): u8 { 1 }
public fun token_type_lp(): u8 { 2 }

// === Validation Functions ===

/// Check if a fee is valid (not exceeding maximum)
public fun is_valid_fee(fee_bps: u64): bool {
    fee_bps <= max_fee_bps()
}

/// Check if a cap percentage is valid (not exceeding 100%)
public fun is_valid_cap_ppm(cap_ppm: u64): bool {
    cap_ppm <= ppm_denominator()
}/// Simple unique key generation for intents
module futarchy::unique_key;

use std::string::String;
use sui::{object, tx_context::TxContext};

/// Generate a guaranteed unique key using Sui's object ID
public fun new(ctx: &mut TxContext): String {
    // Object IDs are globally unique in Sui
    let uid = object::new(ctx);
    let id = object::uid_to_inner(&uid);
    let addr = object::id_to_address(&id);
    object::delete(uid);
    
    // Convert address to hex string (built-in Sui function)
    addr.to_string()
}

/// Generate with a prefix for readability
public fun with_prefix(prefix: String, ctx: &mut TxContext): String {
    let mut key = prefix;
    key.append_utf8(b"_");
    key.append(new(ctx));
    key
}/// Priority Queue Implementation Using Binary Heap
/// Provides O(log n) insertion and extraction for scalable gas costs
module futarchy::priority_queue;

use std::string::String;
use std::u64;
use std::u128;
use std::vector;
use std::option::{Self, Option};
use sui::clock::{Self, Clock};
use sui::coin::{Self, Coin};
use sui::sui::SUI;
use sui::object::{Self, ID, UID};
use sui::tx_context::{Self, TxContext};
use sui::event;
use sui::transfer;

use futarchy::futarchy_config::{Self, FutarchyConfig, SlashDistribution};
use futarchy::proposal_fee_manager::{Self, ProposalFeeManager};
use account_protocol::account::{Self, Account};

// === Events ===

/// Emitted when a proposal is evicted from the queue due to a higher-priority proposal
public struct ProposalEvicted has copy, drop {
    proposal_id: ID,
    proposer: address,
    fee: u64,
    evicted_by: ID,
    timestamp: u64,
    priority_score: u128,
    new_proposal_priority_score: u128, // Priority score of the proposal that caused eviction
}

/// Emitted when a proposal's fee is updated
public struct ProposalFeeUpdated has copy, drop {
    proposal_id: ID,
    proposer: address,
    old_fee: u64,
    new_fee: u64,
    new_priority_score: u128,
    timestamp: u64,
}

/// Emitted when a proposal is added to the queue
public struct ProposalQueued has copy, drop {
    proposal_id: ID,
    proposer: address,
    fee: u64,
    priority_score: u128,
    queue_position: u64,
}

/// Emitted when an evicted proposal has an associated intent that needs cleanup
public struct EvictedIntentNeedsCleanup has copy, drop {
    proposal_id: ID,
    intent_key: String,
    dao_id: ID,
    timestamp: u64,
}

// === Errors ===

const EQueueFullAndFeeTooLow: u64 = 0;
const EDaoSlotOccupied: u64 = 1;
const EQueueEmpty: u64 = 2;
const EInvalidProposalId: u64 = 3;
const EProposalNotFound: u64 = 4;
const EInvalidBond: u64 = 5;
const EProposalInGracePeriod: u64 = 6;
const EHeapInvariantViolated: u64 = 7;

// === Constants ===

const MAX_QUEUE_SIZE: u64 = 100;
const EVICTION_GRACE_PERIOD_MS: u64 = 300000; // 5 minutes
const COMPARE_GREATER: u8 = 1;
const COMPARE_EQUAL: u8 = 0;
const COMPARE_LESS: u8 = 2;

// === Structs ===

/// Priority score combining fee and timestamp
public struct PriorityScore has store, copy, drop {
    fee: u64,
    timestamp: u64,
    computed_value: u128,
}

/// Proposal data stored in the queue
public struct ProposalData has store, copy, drop {
    title: String,
    metadata: String,
    outcome_messages: vector<String>,
    outcome_details: vector<String>,
}

/// Queued proposal with priority
public struct QueuedProposal<phantom StableCoin> has store {
    bond: Option<Coin<StableCoin>>,
    proposal_id: ID,
    dao_id: ID,
    proposer: address,
    fee: u64,
    timestamp: u64,
    priority_score: PriorityScore,
    intent_key: Option<String>,
    uses_dao_liquidity: bool,
    data: ProposalData,
}

/// Priority queue using binary heap for O(log n) operations
public struct ProposalQueue<phantom StableCoin> has key, store {
    id: UID,
    /// DAO ID this queue belongs to
    dao_id: ID,
    /// Binary heap of proposals - stored as vector but maintains heap property
    heap: vector<QueuedProposal<StableCoin>>,
    /// Current size of the heap
    size: u64,
    /// Maximum concurrent proposals allowed
    max_concurrent_proposals: u64,
    /// Current number of active proposals
    active_proposal_count: u64,
    /// Maximum proposer-funded proposals
    max_proposer_funded: u64,
    /// Whether the DAO liquidity slot is occupied
    dao_liquidity_slot_occupied: bool,
    /// Grace period in milliseconds before a proposal can be evicted
    eviction_grace_period_ms: u64,
    /// Reserved next on-chain Proposal ID (if locked as the next one to go live)
    reserved_next_proposal: Option<ID>,
}

/// Information about an evicted proposal
public struct EvictionInfo has copy, drop, store {
    proposal_id: ID,
    proposer: address,
}

// === Heap Operations (Private) ===

/// Get parent index in heap
fun parent_idx(i: u64): u64 {
    if (i == 0) 0 else (i - 1) / 2
}

/// Get left child index
fun left_child_idx(i: u64): u64 {
    2 * i + 1
}

/// Get right child index
fun right_child_idx(i: u64): u64 {
    2 * i + 2
}

/// Bubble up element to maintain heap property - O(log n)
fun bubble_up<StableCoin>(heap: &mut vector<QueuedProposal<StableCoin>>, mut idx: u64) {
    while (idx > 0) {
        let parent = parent_idx(idx);
        
        let child_priority = &vector::borrow(heap, idx).priority_score;
        let parent_priority = &vector::borrow(heap, parent).priority_score;
        
        // If child has higher priority, swap with parent
        if (compare_priority_scores(child_priority, parent_priority) == COMPARE_GREATER) {
            vector::swap(heap, idx, parent);
            idx = parent;
        } else {
            break
        };
    }
}

/// Bubble down element to maintain heap property - O(log n)
fun bubble_down<StableCoin>(heap: &mut vector<QueuedProposal<StableCoin>>, mut idx: u64, size: u64) {
    loop {
        let left = left_child_idx(idx);
        let right = right_child_idx(idx);
        let mut largest = idx;
        
        // Compare with left child
        if (left < size) {
            let left_priority = &vector::borrow(heap, left).priority_score;
            let largest_priority = &vector::borrow(heap, largest).priority_score;
            if (compare_priority_scores(left_priority, largest_priority) == COMPARE_GREATER) {
                largest = left;
            };
        };
        
        // Compare with right child
        if (right < size) {
            let right_priority = &vector::borrow(heap, right).priority_score;
            let largest_priority = &vector::borrow(heap, largest).priority_score;
            if (compare_priority_scores(right_priority, largest_priority) == COMPARE_GREATER) {
                largest = right;
            };
        };
        
        // If current node is largest, we're done
        if (largest == idx) break;
        
        // Otherwise swap and continue
        vector::swap(heap, idx, largest);
        idx = largest;
    }
}

/// Find minimum priority element in heap (it's in the leaves) - O(n/2)
fun find_min_index<StableCoin>(heap: &vector<QueuedProposal<StableCoin>>, size: u64): u64 {
    if (size == 0) return 0;
    if (size == 1) return 0;
    
    // Minimum is in the second half of the array (leaves)
    let start = size / 2;
    let mut min_idx = start;
    let mut min_priority = &vector::borrow(heap, start).priority_score;
    
    let mut i = start + 1;
    while (i < size) {
        let current_priority = &vector::borrow(heap, i).priority_score;
        if (compare_priority_scores(current_priority, min_priority) == COMPARE_LESS) {
            min_priority = current_priority;
            min_idx = i;
        };
        i = i + 1;
    };
    
    min_idx
}

/// Remove element at index and maintain heap property - O(log n)
fun remove_at<StableCoin>(heap: &mut vector<QueuedProposal<StableCoin>>, idx: u64, size: &mut u64): QueuedProposal<StableCoin> {
    assert!(idx < *size, EInvalidProposalId);
    
    // Swap with last element
    let last_idx = *size - 1;
    if (idx != last_idx) {
        vector::swap(heap, idx, last_idx);
    };
    
    // Remove the element
    let removed = vector::pop_back(heap);
    *size = *size - 1;
    
    // Reheapify if we didn't remove the last element
    if (idx < *size && *size > 0) {
        // Check if we need to bubble up or down
        if (idx > 0) {
            let parent = parent_idx(idx);
            let current_priority = &vector::borrow(heap, idx).priority_score;
            let parent_priority = &vector::borrow(heap, parent).priority_score;
            
            if (compare_priority_scores(current_priority, parent_priority) == COMPARE_GREATER) {
                bubble_up(heap, idx);
            } else {
                bubble_down(heap, idx, *size);
            };
        } else {
            bubble_down(heap, idx, *size);
        };
    };
    
    removed
}

// === Public Functions ===

/// Create a new proposal queue with DAO ID
public fun new<StableCoin>(
    dao_id: ID,
    max_concurrent_proposals: u64,
    max_proposer_funded: u64,
    eviction_grace_period_ms: u64,
    ctx: &mut TxContext,
): ProposalQueue<StableCoin> {
    ProposalQueue {
        id: object::new(ctx),
        dao_id,
        heap: vector::empty(),
        size: 0,
        max_concurrent_proposals,
        active_proposal_count: 0,
        max_proposer_funded,
        dao_liquidity_slot_occupied: false,
        eviction_grace_period_ms,
        reserved_next_proposal: option::none(),
    }
}

/// Create a new proposal queue (backward compatibility)
public fun new_with_config<StableCoin>(
    dao_id: ID,
    max_proposer_funded: u64,
    max_concurrent_proposals: u64,
    _max_queue_size: u64,  // Ignored - we use MAX_QUEUE_SIZE constant
    eviction_grace_period_ms: u64,
    ctx: &mut TxContext,
): ProposalQueue<StableCoin> {
    new(dao_id, max_concurrent_proposals, max_proposer_funded, eviction_grace_period_ms, ctx)
}

/// Create priority score from fee and timestamp
public fun create_priority_score(fee: u64, timestamp: u64): PriorityScore {
    // Higher fee = higher priority
    // Earlier timestamp = higher priority (for tie-breaking)
    let computed_value = ((fee as u128) << 64) | ((18446744073709551615u64 - timestamp) as u128);
    
    PriorityScore {
        fee,
        timestamp,
        computed_value,
    }
}

/// Compare two priority scores
public fun compare_priority_scores(a: &PriorityScore, b: &PriorityScore): u8 {
    if (a.computed_value > b.computed_value) {
        COMPARE_GREATER
    } else if (a.computed_value < b.computed_value) {
        COMPARE_LESS
    } else {
        COMPARE_EQUAL
    }
}

/// Insert a proposal into the queue - O(log n) complexity!
public fun insert<StableCoin>(
    queue: &mut ProposalQueue<StableCoin>,
    mut proposal: QueuedProposal<StableCoin>,
    clock: &Clock,
    ctx: &mut TxContext,
): Option<EvictionInfo> {
    // Generate proposal ID if needed
    if (proposal.proposal_id == @0x0.to_id()) {
        let id = object::new(ctx);
        proposal.proposal_id = id.to_inner();
        id.delete();
    };
    let mut eviction_info = option::none<EvictionInfo>();
    let current_time = clock::timestamp_ms(clock);
    
    // Check capacity and eviction logic
    if (proposal.uses_dao_liquidity) {
        if (queue.dao_liquidity_slot_occupied && 
            queue.active_proposal_count >= queue.max_concurrent_proposals) {
            abort EDaoSlotOccupied
        };
    } else {
        // Count proposer-funded proposals
        let proposer_funded_count = count_proposer_funded(&queue.heap, queue.size);
        
        if (proposer_funded_count >= queue.max_proposer_funded) {
            // Find lowest priority proposer-funded proposal
            let lowest_idx = find_min_index(&queue.heap, queue.size);
            let lowest = vector::borrow(&queue.heap, lowest_idx);
            
            // Check grace period BEFORE removing
            assert!(
                current_time - lowest.timestamp >= queue.eviction_grace_period_ms,
                EProposalInGracePeriod
            );
            
            // New proposal must have higher priority to evict
            assert!(
                compare_priority_scores(&proposal.priority_score, &lowest.priority_score) == COMPARE_GREATER,
                EQueueFullAndFeeTooLow
            );
            
            // Now safe to remove - assertions have passed
            let evicted = remove_at(&mut queue.heap, lowest_idx, &mut queue.size);
            
            // Save eviction info before destructuring
            let evicted_proposal_id = evicted.proposal_id;
            let evicted_proposer = evicted.proposer;
            let evicted_fee = evicted.fee;
            let evicted_timestamp = evicted.timestamp;
            let evicted_priority_value = evicted.priority_score.computed_value;
            
            // Handle eviction
            eviction_info = option::some(EvictionInfo {
                proposal_id: evicted_proposal_id,
                proposer: evicted_proposer,
            });
            
            // Emit eviction event with both priority scores for transparency
            event::emit(ProposalEvicted {
                proposal_id: evicted_proposal_id,
                proposer: evicted_proposer,
                fee: evicted_fee,
                evicted_by: proposal.proposal_id,
                timestamp: evicted_timestamp,
                priority_score: evicted_priority_value,
                new_proposal_priority_score: proposal.priority_score.computed_value,
            });
            
            // Clean up evicted proposal
            let QueuedProposal { mut bond, proposal_id, dao_id, proposer: evicted_proposer_addr, fee: _, timestamp: _, priority_score: _, mut intent_key, uses_dao_liquidity: _, data: _ } = evicted;
            
            if (intent_key.is_some()) {
                let key = intent_key.extract();
                event::emit(EvictedIntentNeedsCleanup {
                    proposal_id,
                    intent_key: key,
                    dao_id,
                    timestamp: current_time,
                });
            };
            
            // Handle bond properly - return to evicted proposer if it exists
            if (option::is_some(&bond)) {
                // Return the bond to the proposer who got evicted
                transfer::public_transfer(option::extract(&mut bond), evicted_proposer_addr);
            };
            option::destroy_none(bond);
        };
    };
    
    // Save values before moving proposal
    let proposal_id = proposal.proposal_id;
    let proposer = proposal.proposer;
    let fee = proposal.fee;
    let priority_value = proposal.priority_score.computed_value;
    
    // Add to heap and bubble up - O(log n)!
    vector::push_back(&mut queue.heap, proposal);
    queue.size = queue.size + 1;
    bubble_up(&mut queue.heap, queue.size - 1);
    
    // Emit queued event
    event::emit(ProposalQueued {
        proposal_id,
        proposer,
        fee,
        priority_score: priority_value,
        queue_position: queue.size - 1,
    });
    
    eviction_info
}

/// Extract the highest priority proposal - O(log n) complexity!
/// Made package-visible to prevent unauthorized extraction
public(package) fun extract_max<StableCoin>(queue: &mut ProposalQueue<StableCoin>): Option<QueuedProposal<StableCoin>> {
    if (queue.size == 0) {
        return option::none()
    };
    
    // Remove root (max element) - O(log n)!
    let max_proposal = remove_at(&mut queue.heap, 0, &mut queue.size);
    option::some(max_proposal)
}

/// Peek at the highest priority proposal - O(1)
/// Returns the proposal ID if queue is not empty
public fun peek_max<StableCoin>(queue: &ProposalQueue<StableCoin>): Option<ID> {
    if (queue.size == 0) {
        option::none()
    } else {
        option::some(vector::borrow(&queue.heap, 0).proposal_id)
    }
}

/// Count proposer-funded proposals
fun count_proposer_funded<StableCoin>(heap: &vector<QueuedProposal<StableCoin>>, size: u64): u64 {
    let mut count = 0;
    let mut i = 0;
    while (i < size) {
        if (!vector::borrow(heap, i).uses_dao_liquidity) {
            count = count + 1;
        };
        i = i + 1;
    };
    count
}

// === Compatibility functions for ProposalData ===

// For compatibility, we need to return owned vectors since we don't store these fields
public fun get_initial_asset_amounts(_data: &ProposalData): vector<u64> {
    vector::empty<u64>()  // Not used in new version, return empty for compatibility
}

public fun get_initial_stable_amounts(_data: &ProposalData): vector<u64> {
    vector::empty<u64>()  // Not used in new version, return empty for compatibility
}

/// Get proposal data from a queued proposal
public fun get_proposal_data<StableCoin>(proposal: &QueuedProposal<StableCoin>): &ProposalData {
    &proposal.data
}

/// Check if proposal uses DAO liquidity
public fun uses_dao_liquidity<StableCoin>(proposal: &QueuedProposal<StableCoin>): bool {
    proposal.uses_dao_liquidity
}

/// Get the DAO ID associated with this queue
public fun dao_id<StableCoin>(queue: &ProposalQueue<StableCoin>): ID {
    queue.dao_id
}

/// Get the length of the queue
public fun length<StableCoin>(queue: &ProposalQueue<StableCoin>): u64 {
    queue.size
}

// === Additional Public Functions (maintaining compatibility) ===

/// Create a new queued proposal
public fun new_queued_proposal<StableCoin>(
    dao_id: ID,
    fee: u64,
    uses_dao_liquidity: bool,
    proposer: address,
    data: ProposalData,
    bond: Option<Coin<StableCoin>>,
    intent_key: Option<String>,
    clock: &Clock,
): QueuedProposal<StableCoin> {
    let timestamp = clock::timestamp_ms(clock);
    let priority_score = create_priority_score(fee, timestamp);
    
    QueuedProposal {
        bond,
        proposal_id: @0x0.to_id(),  // Will be set during insert
        dao_id,
        proposer,
        fee,
        timestamp,
        priority_score,
        intent_key,
        uses_dao_liquidity,
        data,
    }
}

/// Create a new queued proposal with a specific ID
public fun new_queued_proposal_with_id<StableCoin>(
    proposal_id: ID,
    dao_id: ID,
    fee: u64,
    uses_dao_liquidity: bool,
    proposer: address,
    data: ProposalData,
    bond: Option<Coin<StableCoin>>,
    intent_key: Option<String>,
    clock: &Clock,
): QueuedProposal<StableCoin> {
    let timestamp = clock::timestamp_ms(clock);
    let priority_score = create_priority_score(fee, timestamp);
    
    QueuedProposal {
        bond,
        proposal_id,
        dao_id,
        proposer,
        fee,
        timestamp,
        priority_score,
        intent_key,
        uses_dao_liquidity,
        data,
    }
}

/// Create proposal data
public fun new_proposal_data(
    title: String,
    metadata: String,
    outcome_messages: vector<String>,
    outcome_details: vector<String>,
    _initial_asset_amounts: vector<u64>,  // Ignored for compatibility
    _initial_stable_amounts: vector<u64>, // Ignored for compatibility
): ProposalData {
    ProposalData {
        title,
        metadata,
        outcome_messages,
        outcome_details,
    }
}

/// Get queue size
public fun size<StableCoin>(queue: &ProposalQueue<StableCoin>): u64 {
    queue.size
}

/// Check if queue is empty
public fun is_empty<StableCoin>(queue: &ProposalQueue<StableCoin>): bool {
    queue.size == 0
}

/// Get proposals vector (for compatibility)
public fun get_proposals<StableCoin>(queue: &ProposalQueue<StableCoin>): &vector<QueuedProposal<StableCoin>> {
    &queue.heap
}

// Getter functions for QueuedProposal
public fun get_proposal_id<StableCoin>(proposal: &QueuedProposal<StableCoin>): ID { proposal.proposal_id }
public fun get_proposer<StableCoin>(proposal: &QueuedProposal<StableCoin>): address { proposal.proposer }
public fun get_fee<StableCoin>(proposal: &QueuedProposal<StableCoin>): u64 { proposal.fee }
public fun get_timestamp<StableCoin>(proposal: &QueuedProposal<StableCoin>): u64 { proposal.timestamp }
public fun get_priority_score<StableCoin>(proposal: &QueuedProposal<StableCoin>): &PriorityScore { &proposal.priority_score }
public fun get_intent_key<StableCoin>(proposal: &QueuedProposal<StableCoin>): &Option<String> { &proposal.intent_key }
public fun get_uses_dao_liquidity<StableCoin>(proposal: &QueuedProposal<StableCoin>): bool { proposal.uses_dao_liquidity }
public fun get_data<StableCoin>(proposal: &QueuedProposal<StableCoin>): &ProposalData { &proposal.data }
public fun get_dao_id<StableCoin>(proposal: &QueuedProposal<StableCoin>): ID { proposal.dao_id }

// Getter functions for EvictionInfo
public fun eviction_proposal_id(info: &EvictionInfo): ID { info.proposal_id }
public fun eviction_proposer(info: &EvictionInfo): address { info.proposer }

// Getter functions for ProposalData
public fun get_title(data: &ProposalData): &String { &data.title }
public fun get_metadata(data: &ProposalData): &String { &data.metadata }
public fun get_outcome_messages(data: &ProposalData): &vector<String> { &data.outcome_messages }
public fun get_outcome_details(data: &ProposalData): &vector<String> { &data.outcome_details }

// Getter functions for PriorityScore
public fun priority_score_value(score: &PriorityScore): u128 { score.computed_value }

/// Tries to activate the next proposal from the queue
/// Made package-visible to prevent unauthorized activation
public(package) fun try_activate_next<StableCoin>(queue: &mut ProposalQueue<StableCoin>): Option<QueuedProposal<StableCoin>> {
    extract_max(queue)
}

/// Calculate minimum required fee based on queue occupancy
/// 
/// The fee scaling regime works as follows:
/// - Below 50% occupancy: Base fee (1 unit)
/// - 50-75% occupancy: 2x base fee
/// - 75-90% occupancy: 5x base fee
/// - 90-100% occupancy: 10x base fee
/// - Above 100%: Clamped to 10x (queue can exceed max_concurrent_proposals in pending state)
/// 
/// Note: The queue can have more proposals than max_concurrent_proposals since that limit
/// only applies to ACTIVE proposals. The queue size can grow larger with pending proposals.
public fun calculate_min_fee<StableCoin>(queue: &ProposalQueue<StableCoin>): u64 {
    let queue_size = queue.size;
    
    // Calculate occupancy ratio, clamped to 100% maximum
    // This ensures we don't overflow and provides predictable fee scaling
    let occupancy_ratio = if (queue.max_concurrent_proposals == 0) {
        100 // If max is 0 (edge case), treat as full
    } else {
        let raw_ratio = (queue_size * 100) / queue.max_concurrent_proposals;
        // Clamp to 100% - queue can exceed max_concurrent but fee stops scaling at 100%
        if (raw_ratio > 100) { 100 } else { raw_ratio }
    };
    
    // Base minimum fee
    let min_fee_base = 1_000_000; // 1 unit with 6 decimals
    
    // Escalate fee based on clamped queue occupancy
    if (occupancy_ratio >= 90) {
        min_fee_base * 10  // 10x when queue is 90%+ full
    } else if (occupancy_ratio >= 75) {
        min_fee_base * 5   // 5x when queue is 75-90% full
    } else if (occupancy_ratio >= 50) {
        min_fee_base * 2   // 2x when queue is 50-75% full
    } else {
        min_fee_base       // 1x when queue is below 50% full
    }
}

/// Get proposals by a specific proposer
public fun get_proposals_by_proposer<StableCoin>(
    queue: &ProposalQueue<StableCoin>,
    proposer: address
): vector<ID> {
    let mut result = vector::empty<ID>();
    let mut i = 0;
    
    while (i < queue.size) {
        let proposal = vector::borrow(&queue.heap, i);
        if (proposal.proposer == proposer) {
            vector::push_back(&mut result, proposal.proposal_id);
        };
        i = i + 1;
    };
    
    result
}

/// Check if a proposal with given fee would be accepted
public fun would_accept_proposal<StableCoin>(
    queue: &ProposalQueue<StableCoin>,
    fee: u64,
    uses_dao_liquidity: bool,
    clock: &Clock
): bool {
    // Check basic fee requirements
    let min_fee = calculate_min_fee(queue);
    if (fee < min_fee) {
        return false
    };
    
    // Check capacity
    if (uses_dao_liquidity) {
        if (queue.dao_liquidity_slot_occupied && 
            queue.active_proposal_count >= queue.max_concurrent_proposals) {
            return false
        };
    } else {
        let proposer_funded_count = count_proposer_funded(&queue.heap, queue.size);
        if (proposer_funded_count >= queue.max_proposer_funded) {
            // Would need to evict - check if fee is high enough
            let min_idx = find_min_index(&queue.heap, queue.size);
            if (min_idx < queue.size) {
                let lowest = vector::borrow(&queue.heap, min_idx);
                let new_priority = create_priority_score(fee, clock::timestamp_ms(clock));
                return compare_priority_scores(&new_priority, &lowest.priority_score) == COMPARE_GREATER
            };
        };
    };
    
    true
}

/// Slash and distribute fee according to DAO configuration
public fun slash_and_distribute_fee<StableCoin>(
    _queue: &ProposalQueue<StableCoin>,
    fee_manager: &mut ProposalFeeManager,
    proposal_id: ID,
    slasher: address,
    account: &Account<FutarchyConfig>,
    ctx: &mut TxContext
): (Coin<SUI>, Coin<SUI>) {
    let config = account::config(account);
    let slash_config = futarchy_config::slash_distribution(config);
    
    // Use the fee manager to slash and distribute
    let (slasher_reward, dao_coin) = proposal_fee_manager::slash_proposal_fee_with_distribution(
        fee_manager,
        proposal_id,
        slash_config,
        ctx
    );
    
    // Transfer slasher reward directly to the slasher
    if (coin::value(&slasher_reward) > 0) {
        transfer::public_transfer(slasher_reward, slasher);
    } else {
        coin::destroy_zero(slasher_reward);
    };
    
    // Return DAO treasury coin for the caller to handle
    (coin::zero(ctx), dao_coin)
}

/// Mark a proposal as completed, freeing up space
public fun mark_proposal_completed<StableCoin>(
    queue: &mut ProposalQueue<StableCoin>,
    uses_dao_liquidity: bool
) {
    assert!(queue.active_proposal_count > 0, EInvalidProposalId);
    
    queue.active_proposal_count = queue.active_proposal_count - 1;
    
    if (uses_dao_liquidity) {
        assert!(queue.dao_liquidity_slot_occupied, EInvalidProposalId);
        queue.dao_liquidity_slot_occupied = false;
    };
}

/// Remove a specific proposal from the queue
/// Made package-visible to prevent unauthorized removal
public(package) fun remove_from_queue<StableCoin>(
    queue: &mut ProposalQueue<StableCoin>,
    proposal_id: ID
): QueuedProposal<StableCoin> {
    let mut i = 0;
    
    while (i < queue.size) {
        let proposal = vector::borrow(&queue.heap, i);
        if (proposal.proposal_id == proposal_id) {
            // Found it - remove using our heap function
            return remove_at(&mut queue.heap, i, &mut queue.size)
        };
        i = i + 1;
    };
    
    abort EProposalNotFound
}

/// Get the number of active proposals
public fun active_count<StableCoin>(queue: &ProposalQueue<StableCoin>): u64 {
    queue.active_proposal_count
}

/// Check if the DAO liquidity slot is occupied
public fun is_dao_slot_occupied<StableCoin>(queue: &ProposalQueue<StableCoin>): bool {
    queue.dao_liquidity_slot_occupied
}

/// Get top N proposal IDs from the queue
public fun get_top_n_ids<StableCoin>(queue: &ProposalQueue<StableCoin>, n: u64): vector<ID> {
    let mut result = vector::empty<ID>();
    let limit = if (n < queue.size) { n } else { queue.size };
    let mut i = 0;
    
    // Note: The heap is not necessarily in sorted order except for the root
    // For true top-N, we'd need to extract and re-insert, but this gives
    // a reasonable approximation for display purposes
    while (i < limit) {
        let proposal = vector::borrow(&queue.heap, i);
        vector::push_back(&mut result, proposal.proposal_id);
        i = i + 1;
    };
    
    result
}

/// Update the maximum number of proposer-funded proposals
public(package) fun update_max_proposer_funded<StableCoin>(
    queue: &mut ProposalQueue<StableCoin>,
    new_max: u64
) {
    assert!(new_max > 0, EInvalidProposalId);
    queue.max_proposer_funded = new_max;
}

/// Update the maximum concurrent proposals allowed
public(package) fun update_max_concurrent_proposals<StableCoin>(
    queue: &mut ProposalQueue<StableCoin>,
    new_max: u64
) {
    assert!(new_max > 0, EInvalidProposalId);
    queue.max_concurrent_proposals = new_max;
}

/// Cancel a proposal and refund the fee - secured to prevent theft
/// Now this is an entry function that transfers funds directly to the proposer
public entry fun cancel_proposal<StableCoin>(
    queue: &mut ProposalQueue<StableCoin>,
    fee_manager: &mut ProposalFeeManager,
    proposal_id: ID,
    ctx: &mut TxContext
) {
    let mut i = 0;
    
    while (i < queue.size) {
        let proposal = vector::borrow(&queue.heap, i);
        if (proposal.proposal_id == proposal_id) {
            // Critical fix: Require that the transaction sender is the proposer
            assert!(proposal.proposer == tx_context::sender(ctx), EProposalNotFound);
            
            // Store proposer address before removing
            let proposer_addr = proposal.proposer;
            
            let removed = remove_at(&mut queue.heap, i, &mut queue.size);
            let QueuedProposal { proposal_id, mut bond, .. } = removed;
            
            // Get the fee refunded as a Coin
            let refunded_fee = proposal_fee_manager::refund_proposal_fee(
                fee_manager,
                proposal_id,
                ctx
            );
            
            // Critical fix: Transfer the refunded fee directly to the proposer
            transfer::public_transfer(refunded_fee, proposer_addr);
            
            // Critical fix: Transfer the bond directly to the proposer if it exists
            if (option::is_some(&bond)) {
                transfer::public_transfer(option::extract(&mut bond), proposer_addr);
            };
            option::destroy_none(bond);
            
            return
        };
        i = i + 1;
    };
    
    abort EProposalNotFound
}

/// Update a proposal's priority by adding more fee
public fun update_proposal_fee<StableCoin>(
    queue: &mut ProposalQueue<StableCoin>,
    proposal_id: ID,
    additional_fee: u64,
    clock: &Clock,
    ctx: &TxContext,
) {
    assert!(additional_fee > 0, EProposalNotFound);
    
    let mut i = 0;
    while (i < queue.size) {
        let proposal = vector::borrow(&queue.heap, i);
        if (proposal.proposal_id == proposal_id) {
            assert!(proposal.proposer == ctx.sender(), EProposalNotFound);
            
            // Remove the proposal temporarily
            let mut removed = remove_at(&mut queue.heap, i, &mut queue.size);
            let old_fee = removed.fee;
            
            // Update fee and recalculate priority
            removed.fee = removed.fee + additional_fee;
            removed.priority_score = create_priority_score(removed.fee, clock::timestamp_ms(clock));
            
            // Emit fee update event
            event::emit(ProposalFeeUpdated {
                proposal_id,
                proposer: removed.proposer,
                old_fee,
                new_fee: removed.fee,
                new_priority_score: removed.priority_score.computed_value,
                timestamp: clock::timestamp_ms(clock),
            });
            
            // Re-insert with new priority - O(log n)!
            vector::push_back(&mut queue.heap, removed);
            queue.size = queue.size + 1;
            bubble_up(&mut queue.heap, queue.size - 1);
            
            return
        };
        i = i + 1;
    };
    
    abort EProposalNotFound
}

/// Get queue statistics
public fun get_stats<StableCoin>(queue: &ProposalQueue<StableCoin>): (u64, u64, u64, bool) {
    (
        queue.size,
        queue.active_proposal_count,
        count_proposer_funded(&queue.heap, queue.size),
        queue.dao_liquidity_slot_occupied
    )
}

/// True if the queue already has a reserved next proposal
public fun has_reserved<StableCoin>(queue: &ProposalQueue<StableCoin>): bool {
    option::is_some(&queue.reserved_next_proposal)
}

/// Get reserved on-chain proposal ID (if any)
public fun reserved_proposal_id<StableCoin>(queue: &ProposalQueue<StableCoin>): Option<ID> {
    queue.reserved_next_proposal
}

/// Set the reserved next proposal (package)
public(package) fun set_reserved<StableCoin>(queue: &mut ProposalQueue<StableCoin>, id: ID) {
    assert!(!has_reserved(queue), EHeapInvariantViolated);
    queue.reserved_next_proposal = option::some(id);
}

/// Clear the reserved next proposal (package)
public(package) fun clear_reserved<StableCoin>(queue: &mut ProposalQueue<StableCoin>) {
    queue.reserved_next_proposal = option::none();
}

/// Check if a specific proposal can be activated
public fun can_activate_proposal<StableCoin>(
    queue: &ProposalQueue<StableCoin>,
    proposal: &QueuedProposal<StableCoin>
): bool {
    // Check global limit
    if (queue.active_proposal_count >= queue.max_concurrent_proposals) {
        return false
    };
    
    // Check DAO liquidity constraint
    if (proposal.uses_dao_liquidity && queue.dao_liquidity_slot_occupied) {
        return false
    };
    
    true
}

/// Get all proposals in the queue (for viewing)
public fun get_all_proposals<StableCoin>(queue: &ProposalQueue<StableCoin>): &vector<QueuedProposal<StableCoin>> {
    &queue.heap
}

/// Extract bond from a queued proposal (mutable)
/// Made package-visible to prevent unauthorized bond extraction
public(package) fun extract_bond<StableCoin>(proposal: &mut QueuedProposal<StableCoin>): Option<Coin<StableCoin>> {
    let bond_ref = &mut proposal.bond;
    if (option::is_some(bond_ref)) {
        option::some(option::extract(bond_ref))
    } else {
        option::none()
    }
}

/// Destroy a queued proposal
public(package) fun destroy_proposal<StableCoin>(proposal: QueuedProposal<StableCoin>) {
    let QueuedProposal {
        bond,
        proposal_id: _,
        dao_id: _,
        proposer: _,
        fee: _,
        timestamp: _,
        priority_score: _,
        intent_key: _,
        uses_dao_liquidity: _,
        data: _,
    } = proposal;
    bond.destroy_none();
}

// === Test Functions ===

#[test_only]
public fun test_internals<StableCoin>(queue: &ProposalQueue<StableCoin>): (u64, u64, bool) {
    (
        queue.max_proposer_funded,
        queue.max_concurrent_proposals,
        queue.dao_liquidity_slot_occupied
    )
}module futarchy::priority_queue_helpers;

use futarchy::priority_queue::{Self, ProposalData, QueuedProposal, ProposalQueue};
use std::string::String;
use sui::coin::Coin;

// === Errors ===
const EQueueEmpty: u64 = 0;

/// Creates proposal data for a queued proposal
public fun new_proposal_data(
    title: String,
    metadata: String,
    outcome_messages: vector<String>,
    outcome_details: vector<String>,
    initial_asset_amounts: vector<u64>,
    initial_stable_amounts: vector<u64>,
): ProposalData {
    priority_queue::new_proposal_data(
        title,
        metadata,
        outcome_messages,
        outcome_details,
        initial_asset_amounts,
        initial_stable_amounts,
    )
}

/// Extracts the maximum priority proposal from the queue without activating it
public fun extract_max<StableCoin>(queue: &mut ProposalQueue<StableCoin>): QueuedProposal<StableCoin> {
    let result = priority_queue::try_activate_next(queue);
    assert!(option::is_some(&result), EQueueEmpty);
    option::destroy_some(result)
}

// === Getter functions for QueuedProposal ===

public fun get_proposal_id<StableCoin>(proposal: &QueuedProposal<StableCoin>): ID {
    priority_queue::get_proposal_id(proposal)
}

public fun get_proposer<StableCoin>(proposal: &QueuedProposal<StableCoin>): address {
    priority_queue::get_proposer(proposal)
}

public fun get_fee<StableCoin>(proposal: &QueuedProposal<StableCoin>): u64 {
    priority_queue::get_fee(proposal)
}

public fun uses_dao_liquidity<StableCoin>(proposal: &QueuedProposal<StableCoin>): bool {
    priority_queue::uses_dao_liquidity(proposal)
}

public fun get_data<StableCoin>(proposal: &QueuedProposal<StableCoin>): &ProposalData {
    priority_queue::get_proposal_data(proposal)
}

public fun get_bond<StableCoin>(proposal: &mut QueuedProposal<StableCoin>): Option<Coin<StableCoin>> {
    priority_queue::extract_bond(proposal)
}

public fun get_timestamp<StableCoin>(proposal: &QueuedProposal<StableCoin>): u64 {
    priority_queue::get_timestamp(proposal)
}

// === Getter functions for ProposalData ===

public fun get_title(data: &ProposalData): &String {
    priority_queue::get_title(data)
}

public fun get_metadata(data: &ProposalData): &String {
    priority_queue::get_metadata(data)
}

public fun get_outcome_messages(data: &ProposalData): &vector<String> {
    priority_queue::get_outcome_messages(data)
}

public fun get_outcome_details(data: &ProposalData): &vector<String> {
    priority_queue::get_outcome_details(data)
}

public fun get_initial_asset_amounts(data: &ProposalData): vector<u64> {
    priority_queue::get_initial_asset_amounts(data)
}

public fun get_initial_stable_amounts(data: &ProposalData): vector<u64> {
    priority_queue::get_initial_stable_amounts(data)
}module futarchy::math;

use std::u128;
use std::u64;

// === Introduction ===
// Integer type conversion and integer methods

// === Errors ===
const EOverflow: u64 = 0;
const EDivideByZero: u64 = 1;
const EValueExceedsU64: u64 = 2;

// === Public Functions ===
// Multiplies two u64 values and divides by a third, checking for overflow
// Returns (a * b) / c
// 
// SAFETY: The product of two u64 values can be at most (2^64 - 1)^2 = 2^128 - 2^65 + 1,
// which is less than 2^128 and therefore always fits in a u128. This property ensures
// that the intermediate multiplication a_128 * b_128 will never overflow.
// The division by c then reduces the result, and we verify it fits in u64 before casting.
public fun mul_div_to_64(a: u64, b: u64, c: u64): u64 {
    assert!(c != 0, EDivideByZero);
    
    // Cast to u128 to prevent overflow during multiplication
    // SAFE: Product of two u64s always fits in u128 (see safety note above)
    let a_128 = (a as u128);
    let b_128 = (b as u128);
    let c_128 = (c as u128);
    
    // Perform the multiplication and division
    let result = (a_128 * b_128) / c_128;
    
    // Ensure the result fits back into u64
    assert!(result <= (u64::max_value!() as u128), EOverflow);
    (result as u64)
}

public fun mul_div_to_128(a: u64, b: u64, c: u64): u128 {
    assert!(c != 0, EDivideByZero);
    // Use u256 for intermediate calculation to avoid overflow
    let a_256 = (a as u256);
    let b_256 = (b as u256);
    let c_256 = (c as u256);
    let result_256 = (a_256 * b_256) / c_256;
    // Ensure result fits in u128
    assert!(result_256 <= (u128::max_value!() as u256), EOverflow);
    (result_256 as u128)
}

public fun mul_div_mixed(a: u128, b: u64, c: u128): u128 {
    assert!(c != 0, EDivideByZero);
    let a_256 = (a as u256);
    let b_256 = (b as u256);
    let c_256 = (c as u256);
    let result = (a_256 * b_256) / c_256;
    assert!(result <= (u128::max_value!() as u256), EOverflow);
    (result as u128)
}

// Safely multiplies two u64 values and divides by a third, rounding up
// Returns ceil((a * b) / c)
// 
// SAFETY: Same as mul_div_to_64 - the product of two u64s always fits in u128.
// The rounding up operation adds at most (c-1) to the numerator before division.
public fun mul_div_up(a: u64, b: u64, c: u64): u64 {
    assert!(c != 0, EDivideByZero);
    
    // Cast to u128 to prevent overflow during multiplication
    // SAFE: Product of two u64s always fits in u128
    let a_128 = (a as u128);
    let b_128 = (b as u128);
    let c_128 = (c as u128);
    
    // Calculate the numerator (product of a and b)
    let numerator = a_128 * b_128;
    
    // Perform division with rounding up
    let result = if (numerator == 0) {
        0
    } else {
        // Add (c-1) to round up: ceil(n/c) = floor((n + c - 1) / c)
        let sum = numerator + c_128 - 1;
        assert!(sum >= numerator, EOverflow); // Verify no overflow in addition
        sum / c_128
    };
    
    // Ensure the result fits back into u64
    assert!(result <= (u64::max_value!() as u128), EOverflow);
    (result as u64)
}

// Saturating addition that won't overflow
public fun saturating_add(a: u128, b: u128): u128 {
    if (u128::max_value!() - a < b) {
        u128::max_value!()
    } else {
        a + b
    }
}

// Saturating subtraction that won't underflow
public fun saturating_sub(a: u128, b: u128): u128 {
    if (a < b) {
        0
    } else {
        a - b
    }
}

public fun safe_u128_to_u64(value: u128): u64 {
    assert!(value <= (u64::max_value!() as u128), EValueExceedsU64);
    (value as u64)
}

// Returns the smaller of two u64 values
public fun min(a: u64, b: u64): u64 {
    if (a < b) { a } else { b }
}

// Returns the larger of two u64 values
public fun max(a: u64, b: u64): u64 {
    if (a > b) { a } else { b }
}

// Integer square root using Newton's method
// Returns the largest integer x such that x * x <= n
public fun sqrt(n: u64): u64 {
    if (n == 0) return 0;
    if (n < 4) return 1;
    
    // Initial guess: half of n
    let mut x = n / 2;
    let mut last_x = x;
    
    loop {
        // Newton's iteration: x = (x + n/x) / 2
        x = (x + n / x) / 2;
        
        // Check convergence
        if (x >= last_x) {
            return last_x;
        };
        last_x = x;
    }
}

// Integer square root for u128 values
public fun sqrt_u128(n: u128): u128 {
    if (n == 0) return 0;
    if (n < 4) return 1;
    
    // Initial guess
    let mut x = n / 2;
    let mut last_x = x;
    
    loop {
        // Newton's iteration
        x = (x + n / x) / 2;
        
        // Check convergence
        if (x >= last_x) {
            return last_x;
        };
        last_x = x;
    }
}

// Absolute difference between two u64 values
public fun abs_diff(a: u64, b: u64): u64 {
    if (a > b) { a - b } else { b - a }
}

// Check if a value is within a percentage tolerance
// Returns true if |a - b| <= (tolerance_bps * max(a,b)) / 10000
public fun within_tolerance(a: u64, b: u64, tolerance_bps: u64): bool {
    let diff = abs_diff(a, b);
    let max_val = max(a, b);
    let tolerance = mul_div_to_64(max_val, tolerance_bps, 10000);
    diff <= tolerance
}
module futarchy::metadata;

use std::string::String;
use sui::table::{Self, Table};
use sui::bag::{Self, Bag};

// === Errors ===
const EInvalidMetadataLength: u64 = 0; // Keys and values vectors must have same length
const EEmptyKey: u64 = 1; // Metadata key cannot be empty
const EKeyTooLong: u64 = 2; // Metadata key exceeds maximum length
const EValueTooLong: u64 = 3; // Metadata value exceeds maximum length
const EDuplicateKey: u64 = 4; // Duplicate key in metadata

// === Constants ===
const MAX_KEY_LENGTH: u64 = 64; // Maximum length for metadata keys
const MAX_VALUE_LENGTH: u64 = 256; // Maximum length for metadata values
const MAX_ENTRIES: u64 = 50; // Maximum number of metadata entries

// === Public Functions ===

/// Create a new metadata table from parallel vectors of keys and values
/// This is useful for entry functions that can't accept Table parameters
public fun new_from_vectors(
    keys: vector<String>,
    values: vector<String>,
    ctx: &mut TxContext
): Table<String, String> {
    let keys_len = keys.length();
    let values_len = values.length();
    
    // Validate input
    assert!(keys_len == values_len, EInvalidMetadataLength);
    assert!(keys_len <= MAX_ENTRIES, EInvalidMetadataLength);
    
    let mut metadata = table::new<String, String>(ctx);
    let mut i = 0;
    
    while (i < keys_len) {
        let key = &keys[i];
        let value = &values[i];
        
        // Validate key and value
        assert!(key.length() > 0, EEmptyKey);
        assert!(key.length() <= MAX_KEY_LENGTH, EKeyTooLong);
        assert!(value.length() <= MAX_VALUE_LENGTH, EValueTooLong);
        
        // Check for duplicates
        assert!(!table::contains(&metadata, *key), EDuplicateKey);
        
        table::add(&mut metadata, *key, *value);
        i = i + 1;
    };
    
    metadata
}

/// Add a single key-value pair to an existing metadata table
public fun add_entry(
    metadata: &mut Table<String, String>,
    key: String,
    value: String
) {
    // Validate
    assert!(key.length() > 0, EEmptyKey);
    assert!(key.length() <= MAX_KEY_LENGTH, EKeyTooLong);
    assert!(value.length() <= MAX_VALUE_LENGTH, EValueTooLong);
    assert!(table::length(metadata) < MAX_ENTRIES, EInvalidMetadataLength);
    
    if (table::contains(metadata, key)) {
        // Update existing entry
        table::remove(metadata, key);
        table::add(metadata, key, value);
    } else {
        // Add new entry
        table::add(metadata, key, value);
    }
}

/// Update an existing entry in the metadata table
public fun update_entry(
    metadata: &mut Table<String, String>,
    key: String,
    value: String
) {
    assert!(value.length() <= MAX_VALUE_LENGTH, EValueTooLong);
    
    // Update existing entry
    if (table::contains(metadata, key)) {
        let val_ref = table::borrow_mut(metadata, key);
        *val_ref = value;
    } else {
        // Add new entry if it doesn't exist
        add_entry(metadata, key, value);
    }
}

/// Remove an entry from the metadata table
public fun remove_entry(
    metadata: &mut Table<String, String>,
    key: String
): String {
    table::remove(metadata, key)
}

/// Check if a key exists in the metadata
public fun contains_key(
    metadata: &Table<String, String>,
    key: &String
): bool {
    table::contains(metadata, *key)
}

/// Get a value from the metadata table
public fun get_value(
    metadata: &Table<String, String>,
    key: &String
): &String {
    table::borrow(metadata, *key)
}

/// Get the number of entries in the metadata table
public fun length(metadata: &Table<String, String>): u64 {
    table::length(metadata)
}

/// Validate metadata without creating a table (useful for pre-validation)
public fun validate_metadata_vectors(
    keys: &vector<String>,
    values: &vector<String>,
    ctx: &mut TxContext
) {
    let keys_len = keys.length();
    let values_len = values.length();
    
    assert!(keys_len == values_len, EInvalidMetadataLength);
    assert!(keys_len <= MAX_ENTRIES, EInvalidMetadataLength);
    
    let mut i = 0;
    let mut seen_keys = bag::new(ctx);
    
    while (i < keys_len) {
        let key = &keys[i];
        let value = &values[i];
        
        // Validate key and value
        assert!(key.length() > 0, EEmptyKey);
        assert!(key.length() <= MAX_KEY_LENGTH, EKeyTooLong);
        assert!(value.length() <= MAX_VALUE_LENGTH, EValueTooLong);
        
        // Check for duplicates
        assert!(!bag::contains(&seen_keys, *key), EDuplicateKey);
        bag::add(&mut seen_keys, *key, true);
        
        i = i + 1;
    };
    bag::destroy_empty(seen_keys);
}

// === Common Metadata Keys ===
// These constants define standard metadata keys used across the protocol

/// Website URL for the DAO or proposal
public fun key_website(): String { b"website".to_string() }

/// Twitter/X handle
public fun key_twitter(): String { b"twitter".to_string() }

/// Discord server invite link
public fun key_discord(): String { b"discord".to_string() }

/// GitHub organization or repository
public fun key_github(): String { b"github".to_string() }

/// Telegram group link
public fun key_telegram(): String { b"telegram".to_string() }

/// Documentation URL
public fun key_docs(): String { b"docs".to_string() }

/// Whitepaper or litepaper URL
public fun key_whitepaper(): String { b"whitepaper".to_string() }

/// Token contract address (for existing tokens)
public fun key_token_address(): String { b"token_address".to_string() }

/// Total token supply
public fun key_token_supply(): String { b"token_supply".to_string() }

/// Token distribution details
public fun key_token_distribution(): String { b"token_distribution".to_string() }

/// Team information
public fun key_team(): String { b"team".to_string() }

/// Roadmap URL or description
public fun key_roadmap(): String { b"roadmap".to_string() }

/// Legal entity information
public fun key_legal_entity(): String { b"legal_entity".to_string() }

/// Terms of service URL
public fun key_terms(): String { b"terms".to_string() }

/// Privacy policy URL
public fun key_privacy(): String { b"privacy".to_string() }module futarchy::conditional_amm;

use futarchy::market_state::MarketState;
use futarchy::conditional_token::ConditionalToken;
use futarchy::math;
use futarchy::oracle::{Self, Oracle};
use futarchy::ring_buffer_oracle::{Self, RingBufferOracle};
use futarchy::constants;
use sui::clock::Clock;
use sui::event;
use std::u64;

// === Introduction ===
// This is a Uniswap V2-style XY=K AMM implementation for futarchy prediction markets.
// 
// === Live-Flow Model Architecture ===
// This AMM is part of the "live-flow" liquidity model which allows dynamic liquidity
// management even while proposals are active. Key features:
// 
// 1. **No Liquidity Locking**: Unlike traditional prediction markets, liquidity providers
//    can add or remove liquidity at any time, even during active proposals.
// 
// 2. **Conditional Token Pools**: Each AMM pool trades conditional tokens (not spot tokens)
//    for a specific outcome. This allows the spot pool to remain liquid.
// 
// 3. **Proportional Liquidity**: When LPs add/remove from the spot pool during active
//    proposals, liquidity is proportionally distributed/collected across all outcome AMMs.
// 
// 4. **LP Token Architecture**: Each AMM pool has its own LP token type, but in the live-flow
//    model, these are managed internally. LPs only receive spot pool LP tokens.
// 
// The flow works as follows:
// - Add liquidity: Spot tokens → Mint conditional tokens → Distribute to AMMs
// - Remove liquidity: Collect from AMMs → Redeem conditional tokens → Return spot tokens

// === Errors ===
const ELowLiquidity: u64 = 0; // Pool liquidity below minimum threshold
const EPoolEmpty: u64 = 1; // Attempting to swap/remove from empty pool
const EExcessiveSlippage: u64 = 2; // Output amount less than minimum specified
const EDivByZero: u64 = 3; // Division by zero in calculations
const EZeroLiquidity: u64 = 4; // Pool has zero liquidity
const EPriceTooHigh: u64 = 5; // Price exceeds maximum allowed value
const EZeroAmount: u64 = 6; // Input amount is zero
const EMarketIdMismatch: u64 = 7; // Market ID doesn't match expected value
const EInsufficientLPTokens: u64 = 8; // Not enough LP tokens to burn
const EInvalidTokenType: u64 = 9; // Wrong conditional token type provided
const EOverflow: u64 = 10; // Arithmetic overflow detected
const EInvalidLiquidityRatio: u64 = 11; // Liquidity provided does not match pool ratio
const EInvalidFeeRate: u64 = 12; // Fee rate is invalid (e.g., >= 100%)

// === Constants ===
const FEE_SCALE: u64 = 10000;
const DEFAULT_FEE: u64 = 30; // 0.3%
const MINIMUM_LIQUIDITY: u128 = 1000;
// Other constants moved to constants module

// === Structs ===

public struct LiquidityPool has key, store {
    id: UID,
    market_id: ID,
    outcome_idx: u8,
    asset_reserve: u64,
    stable_reserve: u64,
    fee_percent: u64,
    oracle: Oracle,  // Original write-through oracle for futarchy
    ring_buffer_oracle: RingBufferOracle,  // Ring buffer oracle for lending protocols
    protocol_fees: u64, // Track accumulated stable fees
    lp_supply: u64, // Track total LP shares for this pool
}

// === Events ===
public struct SwapEvent has copy, drop {
    market_id: ID,
    outcome: u8,
    is_buy: bool,
    amount_in: u64,
    amount_out: u64,
    price_impact: u128,
    price: u128,
    sender: address,
    asset_reserve: u64,
    stable_reserve: u64,
    timestamp: u64,
}

public struct LiquidityAdded has copy, drop {
    market_id: ID,
    outcome: u8,
    asset_amount: u64,
    stable_amount: u64,
    lp_amount: u64,
    sender: address,
    timestamp: u64,
}

public struct LiquidityRemoved has copy, drop {
    market_id: ID,
    outcome: u8,
    asset_amount: u64,
    stable_amount: u64,
    lp_amount: u64,
    sender: address,
    timestamp: u64,
}

// === Public Functions ===
public(package) fun new_pool(
    state: &MarketState,
    outcome_idx: u8,
    fee_percent: u64,
    initial_asset: u64,
    initial_stable: u64,
    twap_initial_observation: u128,
    twap_start_delay: u64,
    twap_step_max: u64,
    ctx: &mut TxContext,
): LiquidityPool {
    assert!(initial_asset > 0 && initial_stable > 0, EZeroAmount);
    let k = math::mul_div_to_128(initial_asset, initial_stable, 1);
    assert!(k >= MINIMUM_LIQUIDITY, ELowLiquidity);
    assert!(fee_percent < FEE_SCALE, EInvalidFeeRate); // Fee cannot be 100% or more

    let twap_initialization_price = twap_initial_observation;
    let initial_price = math::mul_div_to_128(initial_stable, constants::basis_points(), initial_asset);

    check_price_under_max(initial_price);
    check_price_under_max(twap_initialization_price);

    // Initialize oracle
    let oracle = oracle::new_oracle(
        twap_initialization_price,
        twap_start_delay,
        twap_step_max,
        ctx, // Add ctx parameter here
    );

    // Create pool object
    let pool = LiquidityPool {
        id: object::new(ctx),
        market_id: state.market_id(),
        outcome_idx,
        asset_reserve: initial_asset,
        stable_reserve: initial_stable,
        fee_percent,
        oracle,
        ring_buffer_oracle: ring_buffer_oracle::new(1440), // 24 hours of observations
        protocol_fees: 0,
        lp_supply: 0, // Start at 0 so first provider logic works correctly
    };

    pool
}

// === Getter Functions ===

/// Get ring buffer oracle reference (for spot_oracle_interface)
public fun get_ring_buffer_oracle(pool: &LiquidityPool): &RingBufferOracle {
    &pool.ring_buffer_oracle
}

// === Core Swap Functions ===
public(package) fun swap_asset_to_stable(
    pool: &mut LiquidityPool,
    state: &MarketState,
    amount_in: u64,
    min_amount_out: u64,
    clock: &Clock,
    ctx: &TxContext,
): u64 {
    state.assert_trading_active();
    assert!(pool.market_id == state.market_id(), EMarketIdMismatch);
    assert!(amount_in > 0, EZeroAmount);

    // When selling outcome tokens (asset -> stable):
    // 1. Calculate the gross output amount (amount_out_before_fee) based on current reserves and amount_in.
    // 2. Calculate the fee amount from this gross output.
    // 3. Split the fee: 80% for LPs (lp_share), 20% for the protocol (protocol_share).
    // 4. The `protocol_share` is moved to `pool.protocol_fees`.
    // 5. The `lp_share` is left in the pool's stable reserve to reward LPs, causing `k` to grow.
    // 6. The user receives the net output `amount_out = amount_out_before_fee - total_fee`.
    let amount_out_before_fee = calculate_output(
        amount_in,
        pool.asset_reserve,
        pool.stable_reserve,
    );

    // Calculate fee from stable output
    let total_fee = calculate_fee(amount_out_before_fee, pool.fee_percent);
    let lp_share = math::mul_div_to_64(total_fee, constants::lp_fee_share_bps(), constants::total_fee_bps());
    let protocol_share = total_fee - lp_share;

    // Net amount for the user
    let amount_out = amount_out_before_fee - total_fee;

    // Send protocol's share to the fee collector
    pool.protocol_fees = pool.protocol_fees + protocol_share;

    assert!(amount_out >= min_amount_out, EExcessiveSlippage);
    assert!(amount_out_before_fee < pool.stable_reserve, EPoolEmpty);

    let price_impact = calculate_price_impact(
        amount_in,
        pool.asset_reserve,
        amount_out_before_fee, // Use before-fee amount for impact calculation
        pool.stable_reserve,
    );

    // Capture previous reserve state before the update
    let old_asset = pool.asset_reserve;
    let old_stable = pool.stable_reserve;

    let timestamp = clock.timestamp_ms();
    let old_price = math::mul_div_to_128(old_stable, constants::basis_points(), old_asset);
    // Oracle observation is recorded using the reserves *before* the swap.
    // This ensures that the TWAP accurately reflects the price at the beginning of the swap.
    write_observation(
        &mut pool.oracle,
        timestamp,
        old_price,
    );
    
    // Also update ring buffer oracle for continuous price feeds
    ring_buffer_oracle::write(&mut pool.ring_buffer_oracle, old_price, clock);

    // Update reserves.
    pool.asset_reserve = pool.asset_reserve + amount_in;

    // The stable reserve is reduced by the gross output, BUT the LPs' share is kept in the pool.
    // So we add it back.
    // This is equivalent to `pool.stable_reserve - (amount_out + protocol_share)`
    pool.stable_reserve = pool.stable_reserve - amount_out_before_fee + lp_share;

    let current_price = get_current_price(pool);
    check_price_under_max(current_price);

    event::emit(SwapEvent {
        market_id: pool.market_id,
        outcome: pool.outcome_idx,
        is_buy: false,
        amount_in,
        amount_out, // Amount after fee for event logging
        price_impact,
        price: current_price,
        sender: ctx.sender(),
        asset_reserve: pool.asset_reserve,
        stable_reserve: pool.stable_reserve,
        timestamp,
    });

    amount_out
}

// Modified swap_asset_to_stable (selling outcome tokens)
public(package) fun swap_stable_to_asset(
    pool: &mut LiquidityPool,
    state: &MarketState,
    amount_in: u64,
    min_amount_out: u64,
    clock: &Clock,
    ctx: &TxContext,
): u64 {
    state.assert_trading_active();
    assert!(pool.market_id == state.market_id(), EMarketIdMismatch);
    assert!(amount_in > 0, EZeroAmount);

    // When buying outcome tokens (stable -> asset):
    // 1. Calculate the fee from the input amount (amount_in).
    // 2. The actual amount used for the swap (amount_in_after_fee) is the original input minus the fee.
    // 3. Split the total fee: 80% for LPs (lp_share), 20% for the protocol (protocol_share).
    // 4. `protocol_share` is moved to `pool.protocol_fees`.
    // 5. `amount_in_after_fee` is used to calculate the swap output.
    // 6. The pool's stable reserve increases by `amount_in_after_fee + lp_share`, growing `k`.
    let total_fee = calculate_fee(amount_in, pool.fee_percent);
    let lp_share = math::mul_div_to_64(total_fee, constants::lp_fee_share_bps(), constants::total_fee_bps());
    let protocol_share = total_fee - lp_share;

    // Amount used for the swap calculation
    let amount_in_after_fee = amount_in - total_fee;

    // Send protocol's share to the fee collector
    pool.protocol_fees = pool.protocol_fees + protocol_share;

    // Calculate output based on amount after fee
    let amount_out = calculate_output(
        amount_in_after_fee,
        pool.stable_reserve,
        pool.asset_reserve,
    );

    assert!(amount_out >= min_amount_out, EExcessiveSlippage);
    assert!(amount_out < pool.asset_reserve, EPoolEmpty);

    let price_impact = calculate_price_impact(
        amount_in_after_fee,
        pool.stable_reserve,
        amount_out,
        pool.asset_reserve,
    );

    // Capture previous reserve state before the update
    let old_asset = pool.asset_reserve;
    let old_stable = pool.stable_reserve;

    let timestamp = clock.timestamp_ms();
    let old_price = math::mul_div_to_128(old_stable, constants::basis_points(), old_asset);
    // Oracle observation is recorded using the reserves *before* the swap.
    // This ensures that the TWAP accurately reflects the price at the beginning of the swap.
    write_observation(
        &mut pool.oracle,
        timestamp,
        old_price,
    );
    
    // Also update ring buffer oracle for continuous price feeds
    ring_buffer_oracle::write(&mut pool.ring_buffer_oracle, old_price, clock);

    // Update reserves. The amount added to the stable reserve is the portion used for the swap
    // PLUS the LP share of the fee. The protocol share was already removed.
    let new_stable_reserve = pool.stable_reserve + amount_in_after_fee + lp_share;
    assert!(new_stable_reserve >= pool.stable_reserve, EOverflow);

    pool.stable_reserve = new_stable_reserve;
    pool.asset_reserve = pool.asset_reserve - amount_out;

    let current_price = get_current_price(pool);
    check_price_under_max(current_price);

    event::emit(SwapEvent {
        market_id: pool.market_id,
        outcome: pool.outcome_idx,
        is_buy: true,
        amount_in, // Original amount for event logging
        amount_out,
        price_impact,
        price: current_price,
        sender: ctx.sender(),
        asset_reserve: pool.asset_reserve,
        stable_reserve: pool.stable_reserve,
        timestamp,
    });

    amount_out
}

// === Liquidity Functions ===

/// Add liquidity proportionally to the AMM pool
/// Only handles calculations and reserve updates, no token operations
/// Returns the amount of LP tokens to mint
public fun add_liquidity_proportional(
    pool: &mut LiquidityPool,
    asset_amount: u64,
    stable_amount: u64,
    min_lp_out: u64,
    clock: &Clock,
    ctx: &TxContext,
): u64 {
    assert!(asset_amount > 0, EZeroAmount);
    assert!(stable_amount > 0, EZeroAmount);
    
    // Calculate LP tokens to mint based on current pool state
    let (lp_to_mint, new_lp_supply) = if (pool.lp_supply == 0) {
        // First liquidity provider - bootstrap the pool
        let k_squared = math::mul_div_to_128(asset_amount, stable_amount, 1);
        let k = (math::sqrt_u128(k_squared) as u64);
        assert!(k > (MINIMUM_LIQUIDITY as u64), ELowLiquidity);
        // For the first liquidity provider, a small amount of LP tokens (MINIMUM_LIQUIDITY)
        // is intentionally burned and locked in the pool. This is a standard practice in Uniswap V2
        // to prevent division-by-zero errors and to ensure that LP token prices are always well-defined.
        // This amount is accounted for in the `lp_supply` but is not redeemable.
        let locked = (MINIMUM_LIQUIDITY as u64);
        let minted = k - locked;
        // Return the minted amount and the resulting total supply
        (minted, k)
    } else {
        // Subsequent providers - mint proportionally
        // The `math::min` function is used here, similar to Uniswap V2, to calculate the LP tokens to mint.
        // This approach inherently protects against adding imbalanced liquidity by only considering the
        // smaller of the two potential LP amounts derived from asset and stable contributions.
        //
        // Additionally, the `assert!` statement below provides explicit ratio validation (slippage protection)
        // to ensure that the provided asset and stable amounts are close to the current pool ratio,
        // preventing users from adding liquidity at highly unfavorable rates.
        let expected_stable_amount = math::mul_div_to_64(asset_amount, pool.stable_reserve, pool.asset_reserve);
        let expected_asset_amount = math::mul_div_to_64(stable_amount, pool.asset_reserve, pool.stable_reserve);

        // Use a tolerance of 0.1% (10 basis points) to allow for small rounding differences
        // while still preventing imbalanced liquidity attacks
        let tolerance_bps = 10; // 0.1%
        assert!(
            math::within_tolerance(stable_amount, expected_stable_amount, tolerance_bps) && 
            math::within_tolerance(asset_amount, expected_asset_amount, tolerance_bps), 
            EInvalidLiquidityRatio
        );

        let lp_from_asset = math::mul_div_to_64(asset_amount, pool.lp_supply, pool.asset_reserve);
        let lp_from_stable = math::mul_div_to_64(stable_amount, pool.lp_supply, pool.stable_reserve);
        // Use minimum to ensure proper ratio
        let minted = math::min(lp_from_asset, lp_from_stable);
        (minted, pool.lp_supply + minted)
    };
    
    // Slippage protection: ensure LP tokens minted meet minimum expectation
    assert!(lp_to_mint >= min_lp_out, EExcessiveSlippage);
    
    // Update reserves with overflow checks
    let new_asset_reserve = pool.asset_reserve + asset_amount;
    let new_stable_reserve = pool.stable_reserve + stable_amount;
    // Use the precomputed total supply
    
    // Check for overflow
    assert!(new_asset_reserve >= pool.asset_reserve, EOverflow);
    assert!(new_stable_reserve >= pool.stable_reserve, EOverflow);
    assert!(new_lp_supply >= pool.lp_supply, EOverflow);
    
    pool.asset_reserve = new_asset_reserve;
    pool.stable_reserve = new_stable_reserve;
    pool.lp_supply = new_lp_supply;
    
    // Update ring buffer oracle with new price after liquidity change
    let new_price = get_current_price(pool);
    ring_buffer_oracle::write(&mut pool.ring_buffer_oracle, new_price, clock);
    
    event::emit(LiquidityAdded {
        market_id: pool.market_id,
        outcome: pool.outcome_idx,
        asset_amount,
        stable_amount,
        lp_amount: lp_to_mint,
        sender: ctx.sender(),
        timestamp: clock.timestamp_ms(),
    });

    lp_to_mint
}

/// Remove liquidity proportionally from the AMM pool
/// Only handles calculations and reserve updates, no token operations
/// Returns the amounts of asset and stable tokens to mint
public fun remove_liquidity_proportional(
    pool: &mut LiquidityPool,
    lp_amount: u64,
    clock: &Clock,
    ctx: &TxContext
): (u64, u64) {
    // Check for zero liquidity in the pool first to provide a more accurate error message
    assert!(pool.lp_supply > 0, EZeroLiquidity);
    assert!(lp_amount > 0, EZeroAmount);
    
    // Calculate proportional share to remove from this AMM
    let asset_to_remove = math::mul_div_to_64(lp_amount, pool.asset_reserve, pool.lp_supply);
    let stable_to_remove = math::mul_div_to_64(lp_amount, pool.stable_reserve, pool.lp_supply);
    
    // Ensure minimum liquidity remains
    assert!(pool.asset_reserve > asset_to_remove, EPoolEmpty);
    assert!(pool.stable_reserve > stable_to_remove, EPoolEmpty);
    assert!(pool.lp_supply > lp_amount, EInsufficientLPTokens);
    
    // Ensure remaining liquidity is above minimum threshold
    let remaining_asset = pool.asset_reserve - asset_to_remove;
    let remaining_stable = pool.stable_reserve - stable_to_remove;
    let remaining_k = math::mul_div_to_128(remaining_asset, remaining_stable, 1);
    assert!(remaining_k >= (MINIMUM_LIQUIDITY as u128), ELowLiquidity);
    
    // Update pool state (underflow already checked by earlier asserts)
    pool.asset_reserve = pool.asset_reserve - asset_to_remove;
    pool.stable_reserve = pool.stable_reserve - stable_to_remove;
    pool.lp_supply = pool.lp_supply - lp_amount;
    
    // Update ring buffer oracle with new price after liquidity change
    let new_price = get_current_price(pool);
    ring_buffer_oracle::write(&mut pool.ring_buffer_oracle, new_price, clock);

    event::emit(LiquidityRemoved {
        market_id: pool.market_id,
        outcome: pool.outcome_idx,
        asset_amount: asset_to_remove,
        stable_amount: stable_to_remove,
        lp_amount,
        sender: ctx.sender(),
        timestamp: clock.timestamp_ms(),
    });
    
    (asset_to_remove, stable_to_remove)
}

public(package) fun empty_all_amm_liquidity(
    pool: &mut LiquidityPool,
    _ctx: &mut TxContext,
): (u64, u64) {
    // This function is now only used in the final step of the old model and can be deprecated/removed.
    // Or kept for admin/emergency purposes.
    let asset_amount_out = pool.asset_reserve;
    let stable_amount_out = pool.stable_reserve;
    pool.asset_reserve = 0;
    pool.stable_reserve = 0;
    (asset_amount_out, stable_amount_out)
}

// === Oracle Functions ===
// Update new_oracle to be simpler:
fun write_observation(oracle: &mut Oracle, timestamp: u64, price: u128) {
    oracle.write_observation(timestamp, price)
}

public fun get_oracle(pool: &LiquidityPool): &Oracle {
    &pool.oracle
}

// === View Functions ===

public fun get_reserves(pool: &LiquidityPool): (u64, u64) {
    (pool.asset_reserve, pool.stable_reserve)
}

public fun get_lp_supply(pool: &LiquidityPool): u64 {
    pool.lp_supply
}

public fun get_price(pool: &LiquidityPool): u128 {
    pool.oracle.last_price()
}

public(package) fun get_twap(pool: &mut LiquidityPool, clock: &Clock): u128 {
    update_twap_observation(pool, clock);
    pool.oracle.get_twap(clock)
}

public fun quote_swap_asset_to_stable(pool: &LiquidityPool, amount_in: u64): u64 {
    // First calculate total output
    let amount_out_before_fee = calculate_output(
        amount_in,
        pool.asset_reserve,
        pool.stable_reserve,
    );
    // Then take fee from stable output (same as swap function)
    let fee_amount = calculate_fee(amount_out_before_fee, pool.fee_percent);
    amount_out_before_fee - fee_amount
}

public fun quote_swap_stable_to_asset(pool: &LiquidityPool, amount_in: u64): u64 {
    let amount_in_with_fee = amount_in - calculate_fee(amount_in, pool.fee_percent);
    calculate_output(
        amount_in_with_fee,
        pool.stable_reserve,
        pool.asset_reserve,
    )
}

fun calculate_price_impact(
    amount_in: u64,
    reserve_in: u64,
    amount_out: u64,
    reserve_out: u64,
): u128 {
    // Use u256 for intermediate calculations to prevent overflow
    let amount_in_256 = (amount_in as u256);
    let reserve_out_256 = (reserve_out as u256);
    let reserve_in_256 = (reserve_in as u256);
    
    // Calculate ideal output with u256 to prevent overflow
    let ideal_out_256 = (amount_in_256 * reserve_out_256) / reserve_in_256;
    assert!(ideal_out_256 <= (std::u128::max_value!() as u256), EOverflow);
    let ideal_out = (ideal_out_256 as u128);
    
    // The assert below ensures that `ideal_out` is always greater than or equal to `amount_out`.
    // This prevents underflow when calculating `ideal_out - (amount_out as u128)`.
    assert!(ideal_out >= (amount_out as u128), EOverflow); // Ensure no underflow
    math::mul_div_mixed(ideal_out - (amount_out as u128), FEE_SCALE, ideal_out)
}

// Update the LiquidityPool struct price calculation to use TWAP:
public fun get_current_price(pool: &LiquidityPool): u128 {
    assert!(pool.asset_reserve > 0 && pool.stable_reserve > 0, EZeroLiquidity);

    let price = math::mul_div_to_128(
        pool.stable_reserve,
        constants::basis_points(),
        pool.asset_reserve,
    );

    price
}

public(package) fun update_twap_observation(pool: &mut LiquidityPool, clock: &Clock) {
    let timestamp = clock.timestamp_ms();
    let current_price = get_current_price(pool);
    // Use the sum of reserves as a liquidity measure
    pool.oracle.write_observation(timestamp, current_price);
}

public(package) fun set_oracle_start_time(pool: &mut LiquidityPool, state: &MarketState) {
    assert!(get_ms_id(pool) == state.market_id(), EMarketIdMismatch);
    let trading_start_time = state.get_trading_start();
    pool.oracle.set_oracle_start_time(trading_start_time);
}

// === Private Functions ===
fun calculate_fee(amount: u64, fee_percent: u64): u64 {
    math::mul_div_to_64(amount, fee_percent, FEE_SCALE)
}

public(package) fun calculate_output(
    amount_in_with_fee: u64,
    reserve_in: u64,
    reserve_out: u64,
): u64 {
    assert!(reserve_in > 0 && reserve_out > 0, EPoolEmpty);

    let denominator = reserve_in + amount_in_with_fee;
    assert!(denominator > 0, EDivByZero);
    let numerator = (amount_in_with_fee as u256) * (reserve_out as u256);
    let output = numerator / (denominator as u256);
    assert!(output <= (u64::max_value!() as u256), EOverflow);
    (output as u64)
}

public fun get_outcome_idx(pool: &LiquidityPool): u8 {
    pool.outcome_idx
}

public fun get_id(pool: &LiquidityPool): ID {
    pool.id.to_inner()
}

public fun get_k(pool: &LiquidityPool): u128 {
    math::mul_div_to_128(pool.asset_reserve, pool.stable_reserve, 1)
}

public fun check_price_under_max(price: u128) {
    let max_price = (0xFFFFFFFFFFFFFFFFu64 as u128) * (constants::basis_points() as u128);
    assert!(price <= max_price, EPriceTooHigh)
}

public(package) fun get_protocol_fees(pool: &LiquidityPool): u64 {
    pool.protocol_fees
}

public(package) fun get_ms_id(pool: &LiquidityPool): ID {
    pool.market_id
}

public(package) fun reset_protocol_fees(pool: &mut LiquidityPool) {
    pool.protocol_fees = 0;
}

// === Test Functions ===
#[test_only]
public fun create_test_pool(
    market_id: ID,
    outcome_idx: u8,
    fee_percent: u64,
    asset_reserve: u64,
    stable_reserve: u64,
    ctx: &mut TxContext,
): LiquidityPool {
    LiquidityPool {
        id: object::new(ctx),
        market_id,
        outcome_idx,
        asset_reserve,
        stable_reserve,
        fee_percent,
        oracle: oracle::new_oracle(
            math::mul_div_to_128(stable_reserve, 1_000_000_000_000, asset_reserve),
            0, // Use 0 which is always a valid multiple of TWAP_PRICE_CAP_WINDOW
            1_000,
            ctx, // Add ctx parameter here
        ),
        ring_buffer_oracle: ring_buffer_oracle::new(1440), // 24 hours of observations
        protocol_fees: 0,
        lp_supply: (MINIMUM_LIQUIDITY as u64),
    }
}

#[test_only]
public fun destroy_for_testing(pool: LiquidityPool) {
    let LiquidityPool {
        id,
        market_id: _,
        outcome_idx: _,
        asset_reserve: _,
        stable_reserve: _,
        fee_percent: _,
        oracle,
        ring_buffer_oracle,
        protocol_fees: _,
        lp_supply: _,
    } = pool;
    id.delete();
    oracle.destroy_for_testing();
    ring_buffer_oracle::destroy_for_testing(ring_buffer_oracle);
}
/// ============================================================================
/// SPOT AMM WITH BASE FAIR VALUE TWAP - CRITICAL ARCHITECTURE NOTES
/// ============================================================================
/// 
/// This is a specialized spot AMM designed for Hanson-style futarchy with quantum
/// liquidity splitting. The TWAP here serves as the "base fair value" price for
/// internal protocol functions like founder token minting based on price targets.
/// 
/// KEY ARCHITECTURAL DECISIONS:
/// 
/// 1. QUANTUM LIQUIDITY MODEL (Hanson Futarchy)
///    - When a proposal uses DAO liquidity, 1 spot dollar becomes 1 conditional 
///      dollar in EACH outcome (not split, but quantum - exists in all states)
///    - Spot pool becomes COMPLETELY EMPTY during these proposals
///    - Only the highest-priced conditional market determines the winner
/// 
/// 2. TWAP CONTINUITY ACROSS TRANSITIONS
///    The spot TWAP must maintain continuity even when liquidity moves to conditional AMMs:
///    
///    Timeline example:
///    [Spot Active: N seconds] → [Proposal Live: M seconds] → [Spot Active Again]
///    
///    - N could be >> M (spot active much longer than proposal)
///    - M could be >> N (long proposal, short spot history)
///    - We don't know relative durations in advance
/// 
/// 3. LOCKING MECHANISM
///    When proposal starts:
///    - Spot pool is LOCKED (last_proposal_usage timestamp set)
///    - No TWAP updates allowed while locked
///    - All liquidity moves to conditional AMMs
///    
///    During proposal (spot locked):
///    - get_twap() reads from WINNING conditional AMM (highest price)
///    - Adds conditional TWAP for the missing time period
///    - Maintains continuous price history
///    
///    When proposal ends:
///    - Winning conditional's TWAP fills the gap in spot history
///    - Pool unlocks and resumes normal operation
///    - Liquidity returns from winning conditional
/// 
/// 4. TWAP CALCULATION LOGIC
///    
///    Normal operation (no active proposal):
///    - Standard rolling 3-day window
///    - Accumulates price × time
///    - Updates on swaps and liquidity events
///    
///    During live proposal:
///    - Spot accumulator frozen at proposal start time
///    - get_twap() adds: winning_conditional_twap × time_since_proposal_start
///    - Returns combined TWAP over full window
///    
///    After proposal (hot path):
///    - fill_twap_gap_from_proposal() writes: winning_twap × proposal_duration
///    - Adds to window_cumulative_price permanently
///    - Resumes from winning conditional's final price
/// 
/// 5. NOT FOR EXTERNAL PROTOCOLS
///    This TWAP is NOT suitable for:
///    - Lending protocols (need continuous updates)
///    - External price oracles (too specialized)
///    - High-frequency trading (updates only on major events)
///    
///    It IS designed for:
///    - Founder token minting based on price milestones
///    - Long-term protocol health metrics
///    - Base fair value for protocol decisions
/// 
/// 6. SECURITY CONSIDERATIONS
///    - Manipulation requires attacking the WINNING conditional market
///    - Historical segments cannot be modified after writing
///    - Lock prevents TWAP updates during proposals (no double-counting)
///    - Window sliding uses last_window_twap (stable reference) not current price
/// 
/// ============================================================================

module futarchy::spot_amm;

use std::option::{Self, Option};
use std::vector::{Self};
use sui::balance::{Self, Balance};
use sui::coin::{Self, Coin};
use sui::object::{Self, UID, ID};
use sui::transfer;
use sui::tx_context::{Self, TxContext};
use sui::clock::{Self, Clock};
use sui::event;
use futarchy::math;
use futarchy::ring_buffer_oracle::{Self, RingBufferOracle};
use futarchy::conditional_amm;
use futarchy::constants;

// Basic errors
const EZeroAmount: u64 = 1;
const EInsufficientLiquidity: u64 = 2;
const ESlippageExceeded: u64 = 3;
const EInvalidFee: u64 = 4;
const EOverflow: u64 = 5;
const EImbalancedLiquidity: u64 = 6;
const ENotInitialized: u64 = 7;
const EAlreadyInitialized: u64 = 8;
const ETwapNotReady: u64 = 9;
const EPoolLockedForProposal: u64 = 10;

// MAX_FEE_BPS moved to constants module
const MINIMUM_LIQUIDITY: u64 = 1000;

// TWAP constants
const THREE_DAYS_MS: u64 = 259_200_000; // 3 days in milliseconds (3 * 24 * 60 * 60 * 1000)
const PRICE_SCALE: u128 = 1_000_000_000_000; // 10^12 for price precision

/// Historical price segment from conditional AMMs
public struct PriceSegment has store, drop, copy {
    start_timestamp: u64,
    end_timestamp: u64,
    cumulative_price: u256,  // Cumulative price over this segment
    avg_price: u128,          // Average price for quick access
}

/// Simple spot AMM for <AssetType, StableType> with dual oracle system
public struct SpotAMM<phantom AssetType, phantom StableType> has key, store {
    id: UID,
    asset_reserve: Balance<AssetType>,
    stable_reserve: Balance<StableType>,
    lp_supply: u64,
    fee_bps: u64,
    // Ring buffer oracle for lending protocols (continuous updates)
    ring_buffer_oracle: RingBufferOracle,
    // Base fair value TWAP oracle fields - maintains rolling 3-day window
    initialized_at: Option<u64>,
    last_price: u128,
    last_timestamp: u64,
    // Rolling 3-day window accumulator (resets every update)
    window_start_timestamp: u64,      // Timestamp exactly 3 days ago
    // The TWAP of the last completed full price window. More stable than last_price for estimations.
    last_window_twap: u128,
    window_cumulative_price: u256,    // Cumulative price over the 3-day window
    // Historical segments from conditional AMMs (used when DAO liquidity was in proposals)
    historical_segments: vector<PriceSegment>,
    // Track when DAO liquidity was last used in a proposal
    last_proposal_usage: Option<u64>,
}

/// Spot LP token
public struct SpotLP<phantom AssetType, phantom StableType> has key, store {
    id: UID,
    amount: u64,
}

/// Event emitted when spot price updates
public struct SpotPriceUpdate has copy, drop {
    pool_id: ID,
    price: u128,
    timestamp: u64,
    asset_reserve: u64,
    stable_reserve: u64,
}

/// Event emitted when TWAP is updated
public struct SpotTwapUpdate has copy, drop {
    pool_id: ID,
    twap: u128,
    window_start: u64,
    window_end: u64,
}

/// Create a new pool (simple Uniswap V2 style)
public fun new<AssetType, StableType>(fee_bps: u64, ctx: &mut TxContext): SpotAMM<AssetType, StableType> {
    assert!(fee_bps <= constants::max_fee_bps(), EInvalidFee);
    SpotAMM<AssetType, StableType> {
        id: object::new(ctx),
        asset_reserve: balance::zero<AssetType>(),
        stable_reserve: balance::zero<StableType>(),
        lp_supply: 0,
        fee_bps,
        // Ring buffer oracle for lending
        ring_buffer_oracle: ring_buffer_oracle::new(1440), // 24 hours of observations at 1 per minute
        // TWAP fields initially unset
        initialized_at: option::none(),
        last_price: 0,
        last_timestamp: 0,
        window_start_timestamp: 0,
        last_window_twap: 0,
        window_cumulative_price: 0,
        historical_segments: vector::empty(),
        last_proposal_usage: option::none(),
    }
}

/// Initialize TWAP oracle when first liquidity is added
fun initialize_twap<AssetType, StableType>(
    pool: &mut SpotAMM<AssetType, StableType>,
    clock: &Clock,
) {
    assert!(pool.initialized_at.is_none(), EAlreadyInitialized);
    let now = clock.timestamp_ms();
    pool.initialized_at = option::some(now);
    pool.last_timestamp = now;
    pool.window_start_timestamp = now;
    pool.window_cumulative_price = 0;
    
    // Calculate initial price from reserves
    let price = calculate_spot_price(
        pool.asset_reserve.value(),
        pool.stable_reserve.value()
    );
    pool.last_price = price;
    pool.last_window_twap = price; // Initialize with current price as best estimate
}

/// Update TWAP oracle on price changes (maintains rolling 3-day window)
fun update_twap<AssetType, StableType>(
    pool: &mut SpotAMM<AssetType, StableType>,
    clock: &Clock,
) {
    assert!(pool.initialized_at.is_some(), ENotInitialized);
    let now = clock.timestamp_ms();
    
    // Skip if no time has passed
    if (now == pool.last_timestamp) return;
    
    // Update ring buffer oracle for lending protocols
    let current_price = calculate_spot_price(
        pool.asset_reserve.value(),
        pool.stable_reserve.value()
    );
    ring_buffer_oracle::write(&mut pool.ring_buffer_oracle, current_price, clock);
    
    // Accumulate price for the elapsed time BEFORE updating the window
    // This ensures we capture the price impact over the time period
    let time_elapsed = now - pool.last_timestamp;
    let price_time = (pool.last_price as u256) * (time_elapsed as u256);
    pool.window_cumulative_price = pool.window_cumulative_price + price_time;
    
    // Update the rolling window accumulator
    update_rolling_window(pool, now);
    
    // Update current price
    let new_price = calculate_spot_price(
        pool.asset_reserve.value(),
        pool.stable_reserve.value()
    );
    pool.last_price = new_price;
    pool.last_timestamp = now;
    
    // Emit price update event
    event::emit(SpotPriceUpdate {
        pool_id: object::id(pool),
        price: new_price,
        timestamp: now,
        asset_reserve: pool.asset_reserve.value(),
        stable_reserve: pool.stable_reserve.value(),
    });
}

/// Update the rolling 3-day window accumulator
fun update_rolling_window<AssetType, StableType>(
    pool: &mut SpotAMM<AssetType, StableType>,
    now: u64,
) {
    // Check if we need to slide the window forward
    let window_age = now - pool.window_start_timestamp;
    
    if (window_age > THREE_DAYS_MS) {
        // Window is older than 3 days, need to slide it forward
        let new_window_start = now - THREE_DAYS_MS;
        
        // Calculate how much to remove from the accumulator
        // (the part that's now outside the 3-day window)
        let time_to_remove = new_window_start - pool.window_start_timestamp;
        
        // SECURITY FIX: Use the stable TWAP instead of current price for estimation
        // This prevents manipulation where an attacker could corrupt the TWAP
        // by manipulating the current price just before a window slide
        let price_to_remove = (pool.last_window_twap as u256) * (time_to_remove as u256);
        
        // Slide the window: remove old data, keep only last 3 days
        if (pool.window_cumulative_price > price_to_remove) {
            pool.window_cumulative_price = pool.window_cumulative_price - price_to_remove;
        } else {
            // Fallback: if removal would underflow (extreme volatility case),
            // reset to current price * 3 days as baseline
            pool.window_cumulative_price = (pool.last_price as u256) * (THREE_DAYS_MS as u256);
        };
        
        pool.window_start_timestamp = new_window_start;
    };
    
    // Update the last_window_twap with current window average for next time
    // This keeps our stable reference price fresh
    let window_duration = if (window_age > THREE_DAYS_MS) { 
        THREE_DAYS_MS 
    } else { 
        window_age 
    };
    
    if (window_duration > 0) {
        pool.last_window_twap = (pool.window_cumulative_price / (window_duration as u256)) as u128;
    };
}

/// Calculate spot price (stable per asset) with scaling
fun calculate_spot_price(asset_reserve: u64, stable_reserve: u64): u128 {
    if (asset_reserve == 0) return 0;
    
    // Price = stable_reserve / asset_reserve * PRICE_SCALE
    ((stable_reserve as u128) * PRICE_SCALE) / (asset_reserve as u128)
}

/// Add liquidity (entry)
public entry fun add_liquidity<AssetType, StableType>(
    pool: &mut SpotAMM<AssetType, StableType>,
    asset_in: Coin<AssetType>,
    stable_in: Coin<StableType>,
    min_lp_out: u64,
    clock: &Clock,
    ctx: &mut TxContext,
) {
    let a = asset_in.value();
    let s = stable_in.value();
    assert!(a > 0 && s > 0, EZeroAmount);

    let minted = if (pool.lp_supply == 0) {
        let prod = (a as u128) * (s as u128);
        let root_u128 = math::sqrt_u128(prod);
        assert!(root_u128 <= (std::u64::max_value!() as u128), EOverflow);
        let root = root_u128 as u64;
        assert!(root > MINIMUM_LIQUIDITY, EInsufficientLiquidity);
        // Lock MINIMUM_LIQUIDITY permanently to prevent rounding attacks
        pool.lp_supply = root;  // FIX: Set to total root amount, not just minimum
        
        // Initialize TWAP oracle on first liquidity
        pool.asset_reserve.join(asset_in.into_balance());
        pool.stable_reserve.join(stable_in.into_balance());
        initialize_twap(pool, clock);
        
        root - MINIMUM_LIQUIDITY  // Return minted amount minus locked liquidity
    } else {
        // Update TWAP before liquidity change
        update_twap(pool, clock);
        
        // For subsequent deposits, calculate LP tokens based on proportional contribution
        let from_a = math::mul_div_to_64(a, pool.lp_supply, pool.asset_reserve.value());
        let from_s = math::mul_div_to_64(s, pool.lp_supply, pool.stable_reserve.value());
        
        // Enforce balanced deposits with 1% tolerance to prevent value extraction
        let max_delta = if (from_a > from_s) {
            from_a - from_s
        } else {
            from_s - from_a
        };
        let avg = (from_a + from_s) / 2;
        assert!(max_delta <= avg / 100, EImbalancedLiquidity); // Max 1% imbalance
        
        // Add liquidity to reserves
        pool.asset_reserve.join(asset_in.into_balance());
        pool.stable_reserve.join(stable_in.into_balance());
        
        // Use minimum to be conservative
        math::min(from_a, from_s)
    };
    assert!(minted >= min_lp_out, ESlippageExceeded);

    pool.lp_supply = pool.lp_supply + minted;

    let lp = SpotLP<AssetType, StableType> { id: object::new(ctx), amount: minted };
    transfer::public_transfer(lp, ctx.sender());
}

/// Remove liquidity (entry)
public entry fun remove_liquidity<AssetType, StableType>(
    pool: &mut SpotAMM<AssetType, StableType>,
    lp: SpotLP<AssetType, StableType>,
    min_asset_out: u64,
    min_stable_out: u64,
    clock: &Clock,
    ctx: &mut TxContext,
) {
    // Update TWAP before liquidity change
    if (pool.initialized_at.is_some()) {
        update_twap(pool, clock);
    };
    let SpotLP { id, amount } = lp;
    id.delete();
    assert!(amount > 0, EZeroAmount);
    assert!(pool.lp_supply > MINIMUM_LIQUIDITY, EInsufficientLiquidity);

    let a = math::mul_div_to_64(amount, pool.asset_reserve.value(), pool.lp_supply);
    let s = math::mul_div_to_64(amount, pool.stable_reserve.value(), pool.lp_supply);
    assert!(a >= min_asset_out, ESlippageExceeded);
    assert!(s >= min_stable_out, ESlippageExceeded);

    pool.lp_supply = pool.lp_supply - amount;
    let a_out = coin::from_balance(pool.asset_reserve.split(a), ctx);
    let s_out = coin::from_balance(pool.stable_reserve.split(s), ctx);
    transfer::public_transfer(a_out, ctx.sender());
    transfer::public_transfer(s_out, ctx.sender());
}

/// Swap asset for stable (simple Uniswap V2 style)
public entry fun swap_asset_for_stable<AssetType, StableType>(
    pool: &mut SpotAMM<AssetType, StableType>,
    asset_in: Coin<AssetType>,
    min_stable_out: u64,
    clock: &Clock,
    ctx: &mut TxContext,
) {
    assert!(pool.initialized_at.is_some(), ENotInitialized);
    update_twap(pool, clock);
    
    let amount_in = asset_in.value();
    assert!(amount_in > 0, EZeroAmount);
    
    // Apply fee
    let amount_after_fee = amount_in - (math::mul_div_to_64(amount_in, pool.fee_bps, constants::max_fee_bps()));
    
    // Calculate output using constant product formula (x * y = k)
    let asset_reserve = pool.asset_reserve.value();
    let stable_reserve = pool.stable_reserve.value();
    let stable_out = math::mul_div_to_64(
        amount_after_fee,
        stable_reserve,
        asset_reserve + amount_after_fee
    );
    assert!(stable_out >= min_stable_out, ESlippageExceeded);
    assert!(stable_out < stable_reserve, EInsufficientLiquidity);
    
    // Update reserves
    pool.asset_reserve.join(asset_in.into_balance());
    let stable_coin = coin::from_balance(pool.stable_reserve.split(stable_out), ctx);
    transfer::public_transfer(stable_coin, ctx.sender());
}

/// Swap stable for asset (simple Uniswap V2 style)
public entry fun swap_stable_for_asset<AssetType, StableType>(
    pool: &mut SpotAMM<AssetType, StableType>,
    stable_in: Coin<StableType>,
    min_asset_out: u64,
    clock: &Clock,
    ctx: &mut TxContext,
) {
    assert!(pool.initialized_at.is_some(), ENotInitialized);
    update_twap(pool, clock);
    
    let amount_in = stable_in.value();
    assert!(amount_in > 0, EZeroAmount);
    
    // Apply fee
    let amount_after_fee = amount_in - (math::mul_div_to_64(amount_in, pool.fee_bps, constants::max_fee_bps()));
    
    // Calculate output using constant product formula (x * y = k)
    let asset_reserve = pool.asset_reserve.value();
    let stable_reserve = pool.stable_reserve.value();
    let asset_out = math::mul_div_to_64(
        amount_after_fee,
        asset_reserve,
        stable_reserve + amount_after_fee
    );
    assert!(asset_out >= min_asset_out, ESlippageExceeded);
    assert!(asset_out < asset_reserve, EInsufficientLiquidity);
    
    // Update reserves
    pool.stable_reserve.join(stable_in.into_balance());
    let asset_coin = coin::from_balance(pool.asset_reserve.split(asset_out), ctx);
    transfer::public_transfer(asset_coin, ctx.sender());
}

/// ---- Conversion hook used by coin_escrow during LP conversion (no balance movement here) ----
/// Returns the ID of the minted spot LP token (the LP is transferred to the sender).
public fun mint_lp_for_conversion<AssetType, StableType>(
    pool: &mut SpotAMM<AssetType, StableType>,
    _asset_amount: u64,
    _stable_amount: u64,
    lp_amount_to_mint: u64,
    _total_lp_supply_at_finalization: u64,
    _market_id: ID,
    ctx: &mut TxContext,
): ID {
    assert!(lp_amount_to_mint > 0, EZeroAmount);
    pool.lp_supply = pool.lp_supply + lp_amount_to_mint;
    let lp = SpotLP<AssetType, StableType> { id: object::new(ctx), amount: lp_amount_to_mint };
    let lp_id = object::id(&lp);
    transfer::public_transfer(lp, ctx.sender());
    lp_id
}

// === View Functions ===

public fun get_lp_amount<AssetType, StableType>(lp: &SpotLP<AssetType, StableType>): u64 {
    lp.amount
}

/// Get current spot price
public fun get_spot_price<AssetType, StableType>(pool: &SpotAMM<AssetType, StableType>): u128 {
    calculate_spot_price(
        pool.asset_reserve.value(),
        pool.stable_reserve.value()
    )
}

/// Get current TWAP with automatic update (requires mutable reference)
public fun get_twap_mut<AssetType, StableType>(
    pool: &mut SpotAMM<AssetType, StableType>,
    clock: &Clock,
): u128 {
    assert!(pool.initialized_at.is_some(), ENotInitialized);
    let init_time = *pool.initialized_at.borrow();
    let now = clock.timestamp_ms();
    
    // Require at least 3 days of trading before TWAP is valid
    assert!(now >= init_time + THREE_DAYS_MS, ETwapNotReady);
    
    // First, accumulate any pending price updates since last timestamp
    // This is crucial for cases where get_twap_mut is called without prior updates
    if (now > pool.last_timestamp) {
        let time_elapsed = now - pool.last_timestamp;
        let price_time = (pool.last_price as u256) * (time_elapsed as u256);
        pool.window_cumulative_price = pool.window_cumulative_price + price_time;
        pool.last_timestamp = now;
    };
    
    // IMPORTANT: Update the rolling window to current time
    // This ensures we always have the most recent 3-day average
    update_rolling_window(pool, now);
    
    // Calculate the exact 3-day TWAP
    let window_duration = now - pool.window_start_timestamp;
    
    if (window_duration >= THREE_DAYS_MS) {
        // We have a full 3-day window
        (pool.window_cumulative_price / (THREE_DAYS_MS as u256)) as u128
    } else {
        // Window is less than 3 days (shouldn't happen after init period)
        // Use actual duration for accuracy
        if (window_duration > 0) {
            (pool.window_cumulative_price / (window_duration as u256)) as u128
        } else {
            pool.last_price
        }
    }
}

/// Get current TWAP with live conditional integration
/// During proposals: adds winning conditional's TWAP for missing time
/// Normal operation: returns standard spot TWAP
public fun get_twap<AssetType, StableType>(
    pool: &SpotAMM<AssetType, StableType>,
    winning_conditional_twap: Option<u128>, // Pass Some(twap) if proposal is live, None otherwise
    clock: &Clock,
): u128 {
    assert!(pool.initialized_at.is_some(), ENotInitialized);
    let init_time = *pool.initialized_at.borrow();
    let now = clock.timestamp_ms();
    
    // Require at least 3 days of trading before TWAP is valid
    assert!(now >= init_time + THREE_DAYS_MS, ETwapNotReady);
    
    // If proposal is live and we have winning conditional TWAP, integrate it
    if (pool.last_proposal_usage.is_some() && winning_conditional_twap.is_some()) {
        let proposal_start = *pool.last_proposal_usage.borrow();
        let conditional_twap = *winning_conditional_twap.borrow();
        
        // Calculate spot TWAP up to proposal start
        let spot_duration = proposal_start - pool.window_start_timestamp;
        let spot_cumulative = pool.window_cumulative_price; // Frozen at proposal start
        
        // Calculate conditional contribution for time since proposal started
        let gap_duration = now - proposal_start;
        let gap_contribution = (conditional_twap as u256) * (gap_duration as u256);
        
        // Combine spot and conditional portions
        let total_cumulative = spot_cumulative + gap_contribution;
        let total_duration = now - pool.window_start_timestamp;
        
        // Handle rolling window
        let effective_duration = if (total_duration > THREE_DAYS_MS) {
            THREE_DAYS_MS
        } else {
            total_duration
        };
        
        if (effective_duration > 0) {
            (total_cumulative / (effective_duration as u256)) as u128
        } else {
            conditional_twap
        }
    } else {
        // No active proposal - return normal spot TWAP
        // Calculate what the cumulative would be if updated to now
        let time_since_last_update = now - pool.last_timestamp;
        let projected_cumulative = pool.window_cumulative_price + 
            ((pool.last_price as u256) * (time_since_last_update as u256));
        
        // Calculate window duration
        let window_age = now - pool.window_start_timestamp;
        let effective_duration = if (window_age > THREE_DAYS_MS) {
            THREE_DAYS_MS // Cap at 3 days
        } else {
            window_age
        };
        
        if (effective_duration > 0) {
            (projected_cumulative / (effective_duration as u256)) as u128
        } else {
            pool.last_price
        }
    }
}

/// Get TWAP for conditional AMM initialization
/// This is used when transitioning from spot trading to proposal trading
public fun get_twap_for_conditional_amm<AssetType, StableType>(
    pool: &SpotAMM<AssetType, StableType>,
    clock: &Clock,
): u128 {
    // If 3-day TWAP is ready, use it; otherwise use spot price
    if (pool.initialized_at.is_some()) {
        let init_time = *pool.initialized_at.borrow();
        let now = clock.timestamp_ms();
        
        if (now >= init_time + THREE_DAYS_MS) {
            // Calculate TWAP from rolling window
            let window_duration = now - pool.window_start_timestamp;
            if (window_duration > 0 && pool.window_cumulative_price > 0) {
                let effective_duration = if (window_duration > THREE_DAYS_MS) {
                    THREE_DAYS_MS
                } else {
                    window_duration
                };
                return (pool.window_cumulative_price / (effective_duration as u256)) as u128
            }
        }
    };
    
    // Fall back to spot price if TWAP not ready
    // This allows proposals before 3-day TWAP is available
    get_spot_price(pool)
}

/// Check if TWAP oracle is ready (has been running for at least 3 days)
public fun is_twap_ready<AssetType, StableType>(
    pool: &SpotAMM<AssetType, StableType>,
    clock: &Clock,
): bool {
    if (pool.initialized_at.is_none()) return false;
    
    let init_time = *pool.initialized_at.borrow();
    let now = clock.timestamp_ms();
    // Require 3 full days of price data for valid TWAP
    now >= init_time + THREE_DAYS_MS
}

/// Check if pool is locked for a proposal
public fun is_locked_for_proposal<AssetType, StableType>(
    pool: &SpotAMM<AssetType, StableType>
): bool {
    pool.last_proposal_usage.is_some()
}

/// Get ring buffer oracle reference (for spot_oracle_interface)
public fun get_ring_buffer_oracle<AssetType, StableType>(
    pool: &SpotAMM<AssetType, StableType>
): &RingBufferOracle {
    &pool.ring_buffer_oracle
}

/// Get longest possible TWAP for governance/minting
/// This uses the ring buffer oracle which has continuous history
public fun get_longest_twap_for_minting<AssetType, StableType>(
    pool: &SpotAMM<AssetType, StableType>,
    clock: &Clock,
): u128 {
    ring_buffer_oracle::get_longest_twap(&pool.ring_buffer_oracle, clock)
}

/// Get pool reserves
public fun get_reserves<AssetType, StableType>(
    pool: &SpotAMM<AssetType, StableType>
): (u64, u64) {
    (pool.asset_reserve.value(), pool.stable_reserve.value())
}

/// Get pool state including TWAP data
public fun get_pool_state<AssetType, StableType>(
    pool: &SpotAMM<AssetType, StableType>
): (u64, u64, u64, u128, u128, u64, Option<u64>) {
    (
        pool.asset_reserve.value(),
        pool.stable_reserve.value(),
        pool.lp_supply,
        pool.last_price,
        pool.last_window_twap,
        pool.window_start_timestamp,
        pool.initialized_at
    )
}

/// Update TWAP with a specific price (for transitions between spot and conditional)
public(package) fun update_twap_with_price<AssetType, StableType>(
    pool: &mut SpotAMM<AssetType, StableType>,
    price: u128,
    clock: &Clock,
) {
    assert!(pool.initialized_at.is_some(), ENotInitialized);
    let now = clock.timestamp_ms();
    
    // Update the rolling window with the new price
    update_rolling_window(pool, now);
    
    // Set the new price
    pool.last_price = price;
    pool.last_timestamp = now;
    
    // Emit price update event
    event::emit(SpotPriceUpdate {
        pool_id: object::id(pool),
        price,
        timestamp: now,
        asset_reserve: pool.asset_reserve.value(),
        stable_reserve: pool.stable_reserve.value(),
    });
}

// === Conditional TWAP Integration ===

/// Write the winning conditional AMM's TWAP to fill the gap when liquidity was in proposals
/// This is called when a proposal that used DAO liquidity is finalized
public(package) fun write_conditional_twap<AssetType, StableType>(
    pool: &mut SpotAMM<AssetType, StableType>,
    proposal_start: u64,   // When liquidity moved to conditional
    proposal_end: u64,     // When proposal finalized
    conditional_twap: u128, // TWAP from winning conditional AMM
    clock: &Clock,
) {
    // Calculate cumulative price for this period using the conditional TWAP
    let duration = proposal_end - proposal_start;
    let cumulative_price = (conditional_twap as u256) * (duration as u256);
    
    // Create a segment with the conditional AMM's TWAP data
    let segment = PriceSegment {
        start_timestamp: proposal_start,
        end_timestamp: proposal_end,
        cumulative_price,
        avg_price: conditional_twap,
    };
    
    // Add to historical segments
    pool.historical_segments.push_back(segment);
    
    // Clean up old segments (keep only last 3 days worth)
    let now = clock.timestamp_ms();
    let cutoff = if (now > THREE_DAYS_MS) {
        now - THREE_DAYS_MS
    } else {
        0
    };
    
    let mut i = 0;
    while (i < pool.historical_segments.length()) {
        let segment = pool.historical_segments.borrow(i);
        if (segment.end_timestamp < cutoff) {
            pool.historical_segments.swap_remove(i);
        } else {
            i = i + 1;
        };
    };
}

/// Mark when DAO liquidity moves to a proposal
/// This records the timestamp for later TWAP integration
public(package) fun mark_liquidity_to_proposal<AssetType, StableType>(
    pool: &mut SpotAMM<AssetType, StableType>,
    clock: &Clock,
) {
    // Update TWAP one last time before liquidity moves to proposal
    if (pool.initialized_at.is_some()) {
        update_twap(pool, clock);
    };
    // Record when liquidity moved to proposal (for TWAP integration later)
    pool.last_proposal_usage = option::some(clock.timestamp_ms());
}

/// Merge winning conditional's ring buffer observations into spot after proposal finalizes
/// This ensures continuous price history for lending protocols
public(package) fun merge_winning_conditional_oracle<AssetType, StableType>(
    pool: &mut SpotAMM<AssetType, StableType>,
    winning_conditional: &conditional_amm::LiquidityPool,
    proposal_start_ms: u64,
    proposal_end_ms: u64,
) {
    // Get the winning conditional's ring buffer oracle
    let conditional_oracle = conditional_amm::get_ring_buffer_oracle(winning_conditional);
    
    // Merge observations from the proposal period into spot's ring buffer
    ring_buffer_oracle::merge_observations(
        &mut pool.ring_buffer_oracle,
        conditional_oracle,
        proposal_start_ms,
        proposal_end_ms,
    );
}

/// Fill TWAP gap when proposal finalizes (hot path)
/// This is called when a proposal ends and we need to fill the gap in spot TWAP
/// with the winning conditional AMM's TWAP
public(package) fun fill_twap_gap_from_proposal<AssetType, StableType>(
    pool: &mut SpotAMM<AssetType, StableType>,
    winning_conditional_twap: u128,
    winning_conditional_price: u128,
    clock: &Clock,
) {
    let now = clock.timestamp_ms();
    
    // Only fill gap if pool was locked for proposal
    if (pool.last_proposal_usage.is_some()) {
        let proposal_start = *pool.last_proposal_usage.borrow();
        let gap_duration = now - proposal_start;
        
        // Fill the gap in spot TWAP with winning conditional's TWAP
        if (gap_duration > 0) {
            let gap_contribution = (winning_conditional_twap as u256) * (gap_duration as u256);
            
            // Add to the spot's cumulative window
            pool.window_cumulative_price = pool.window_cumulative_price + gap_contribution;
            
            // Also write to historical segments for long-term tracking
            let segment = PriceSegment {
                start_timestamp: proposal_start,
                end_timestamp: now,
                cumulative_price: gap_contribution,
                avg_price: winning_conditional_twap,
            };
            pool.historical_segments.push_back(segment);
        };
        
        // Update timestamps and price to reflect filled gap
        pool.last_timestamp = now;
        pool.last_price = winning_conditional_price; // Resume from winning price
        pool.last_window_twap = winning_conditional_twap; // Update stable reference
        
        // Unlock the pool - clear proposal lock
        pool.last_proposal_usage = option::none();
    };
}

/// Get TWAP including conditional AMM prices when liquidity was in proposals
/// This provides continuous TWAP by using conditional prices during proposal periods
public fun get_twap_with_conditionals<AssetType, StableType>(
    pool: &SpotAMM<AssetType, StableType>,
    clock: &Clock,
): u128 {
    let now = clock.timestamp_ms();
    
    // If liquidity is currently in a proposal, we can't compute full TWAP yet
    // Return last known TWAP or price
    if (pool.last_proposal_usage.is_some()) {
        return pool.last_price
    };
    
    // Calculate the time range we need (last 3 days)
    let window_start = if (now > THREE_DAYS_MS) {
        now - THREE_DAYS_MS
    } else {
        0
    };
    
    let mut total_cumulative: u256 = 0;
    let mut total_duration: u64 = 0;
    
    // Process historical segments (conditional TWAP periods)
    let mut i = 0;
    let mut last_segment_end: u64 = 0;
    
    while (i < pool.historical_segments.length()) {
        let segment = pool.historical_segments.borrow(i);
        
        // Check if this segment overlaps with our 3-day window
        if (segment.end_timestamp > window_start && segment.start_timestamp < now) {
            let overlap_start = if (segment.start_timestamp > window_start) {
                segment.start_timestamp
            } else {
                window_start
            };
            
            let overlap_end = if (segment.end_timestamp < now) {
                segment.end_timestamp
            } else {
                now
            };
            
            let overlap_duration = overlap_end - overlap_start;
            
            // Add conditional TWAP contribution
            total_cumulative = total_cumulative + ((segment.avg_price as u256) * (overlap_duration as u256));
            total_duration = total_duration + overlap_duration;
            
            // Track the end of last segment
            if (segment.end_timestamp > last_segment_end) {
                last_segment_end = segment.end_timestamp;
            };
        };
        i = i + 1;
    };
    
    // Add spot TWAP for periods after the last conditional segment
    if (now > last_segment_end) {
        let spot_start = if (last_segment_end > window_start) {
            last_segment_end
        } else {
            if (pool.window_start_timestamp > window_start) {
                pool.window_start_timestamp
            } else {
                window_start
            }
        };
        
        let spot_duration = now - spot_start;
        if (spot_duration > 0 && pool.window_cumulative_price > 0) {
            // Add current spot window contribution
            let time_since_update = now - pool.last_timestamp;
            let projected_cumulative = pool.window_cumulative_price + 
                ((pool.last_price as u256) * (time_since_update as u256));
            
            // Scale to the actual spot duration we're using
            let spot_contribution = if (pool.window_start_timestamp == spot_start) {
                projected_cumulative
            } else {
                // Approximate by using average price
                let avg_spot_price = if ((now - pool.window_start_timestamp) > 0) {
                    (projected_cumulative / ((now - pool.window_start_timestamp) as u256)) as u128
                } else {
                    pool.last_price
                };
                (avg_spot_price as u256) * (spot_duration as u256)
            };
            
            total_cumulative = total_cumulative + spot_contribution;
            total_duration = total_duration + spot_duration;
        };
    };
    
    // Calculate final TWAP
    if (total_duration > 0) {
        (total_cumulative / (total_duration as u256)) as u128
    } else {
        pool.last_price
    }
}
module futarchy::swap;

use futarchy::coin_escrow::TokenEscrow;
use futarchy::conditional_token::ConditionalToken;
use futarchy::liquidity_interact;
use futarchy::market_state::MarketState;
use futarchy::proposal::{Self, Proposal};
use sui::clock::Clock;
use sui::coin::Coin;

// === Introduction ===
// Defines entry methods for swaping and combining coins and conditional tokens

// === Errors ===
const EInvalidOutcome: u64 = 0;
const EWrongTokenType: u64 = 1;
const EWrongOutcome: u64 = 2;
const EInvalidState: u64 = 3;
const EMarketIdMismatch: u64 = 4;

// === Constants ===
const STATE_TRADING: u8 = 2; // Must match proposal.move STATE_TRADING

// === Helper Functions ===
/// Efficiently transfers all tokens in a vector to the recipient
fun transfer_tokens_to_recipient(mut tokens: vector<ConditionalToken>, recipient: address) {
    while (!tokens.is_empty()) {
        transfer::public_transfer(tokens.pop_back(), recipient);
    };
    tokens.destroy_empty();
}

// === Public Functions ===

public fun swap_asset_to_stable<AssetType, StableType>(
    proposal: &mut Proposal<AssetType, StableType>,
    escrow: &mut TokenEscrow<AssetType, StableType>,
    outcome_idx: u64,
    token_to_swap: ConditionalToken,
    min_amount_out: u64,
    clock: &Clock,
    ctx: &mut TxContext,
): ConditionalToken {
    assert!(proposal::market_state_id(proposal) == escrow.get_market_state_id(), EMarketIdMismatch);
    assert!(token_to_swap.asset_type() == 0, EWrongTokenType);
    let amount_in = token_to_swap.value();

    // Calculate the swap amount using AMM
    let amount_out = swap_asset_to_stable_internal(
        proposal,
        escrow.get_market_state(),
        outcome_idx,
        amount_in,
        min_amount_out,
        clock,
        ctx,
    );

    // Handle token swap atomically in escrow - tokens will be minted directly to sender
    let stable_token = escrow.swap_token_asset_to_stable(
        token_to_swap,
        outcome_idx,
        amount_out,
        clock,
        ctx,
    );

    liquidity_interact::assert_all_reserves_consistency(proposal, escrow);

    stable_token
}

public entry fun swap_asset_to_stable_entry<AssetType, StableType>(
    proposal: &mut Proposal<AssetType, StableType>,
    escrow: &mut TokenEscrow<AssetType, StableType>,
    outcome_idx: u64,
    token_to_swap: ConditionalToken,
    min_amount_out: u64,
    clock: &Clock,
    ctx: &mut TxContext,
) {
    let recipient = ctx.sender();
    let result_token = swap_asset_to_stable(
        proposal,
        escrow,
        outcome_idx,
        token_to_swap,
        min_amount_out,
        clock,
        ctx,
    );
    transfer::public_transfer(result_token, recipient);
}

public fun swap_stable_to_asset<AssetType, StableType>(
    proposal: &mut Proposal<AssetType, StableType>,
    escrow: &mut TokenEscrow<AssetType, StableType>,
    outcome_idx: u64,
    token_to_swap: ConditionalToken,
    min_amount_out: u64,
    clock: &Clock,
    ctx: &mut TxContext,
): ConditionalToken {
    assert!(proposal::market_state_id(proposal) == escrow.get_market_state_id(), EMarketIdMismatch);
    assert!(token_to_swap.asset_type() == 1, EWrongTokenType);
    let amount_in = token_to_swap.value();

    // Calculate the swap amount using AMM
    let amount_out = swap_stable_to_asset_internal(
        proposal,
        escrow.get_market_state(),
        outcome_idx,
        amount_in,
        min_amount_out,
        clock,
        ctx,
    );

    // Handle token swap atomically in escrow - tokens will be minted directly to sender
    let asset_token = escrow.swap_token_stable_to_asset(
        token_to_swap,
        outcome_idx,
        amount_out,
        clock,
        ctx,
    );

    liquidity_interact::assert_all_reserves_consistency(proposal, escrow);

    asset_token
}

public entry fun swap_stable_to_asset_entry<AssetType, StableType>(
    proposal: &mut Proposal<AssetType, StableType>,
    escrow: &mut TokenEscrow<AssetType, StableType>,
    outcome_idx: u64,
    token_to_swap: ConditionalToken,
    min_amount_out: u64,
    clock: &Clock,
    ctx: &mut TxContext,
) {
    let recipient = ctx.sender();
    let result_token = swap_stable_to_asset(
        proposal,
        escrow,
        outcome_idx,
        token_to_swap,
        min_amount_out,
        clock,
        ctx,
    );
    transfer::public_transfer(result_token, recipient);
}

/// Returns all tokens with swapped token at the end
public fun create_and_swap_stable_to_asset_with_existing<AssetType, StableType>(
    proposal: &mut Proposal<AssetType, StableType>,
    escrow: &mut TokenEscrow<AssetType, StableType>,
    outcome_idx: u64,
    existing_token: ConditionalToken,
    min_amount_out: u64,
    coin_in: Coin<StableType>,
    clock: &Clock,
    ctx: &mut TxContext,
): (vector<ConditionalToken>, ConditionalToken) {
    assert!(proposal::market_state_id(proposal) == escrow.get_market_state_id(), EMarketIdMismatch);
    let mut tokens = escrow.mint_complete_set_stable(coin_in, clock, ctx);

    assert!(outcome_idx < tokens.length(), EInvalidOutcome);
    let mut swap_token = tokens.remove(outcome_idx);

    // Merge existing token if present
    assert!(existing_token.outcome() == (outcome_idx as u8), EWrongOutcome);
    assert!(existing_token.asset_type() == 1, EWrongTokenType);
    assert!(existing_token.market_id() == escrow.get_market_state().market_id(), EMarketIdMismatch);

    // swap_token.outcome() is guaranteed to be outcome_idx since it came from tokens[outcome_idx]
    let mut existing_token_in_vector = vector[];
    existing_token_in_vector.push_back(existing_token);
    swap_token.merge_many(existing_token_in_vector, clock, ctx);

    // Swap the selected token
    let asset_token = swap_stable_to_asset(
        proposal,
        escrow,
        outcome_idx,
        swap_token,
        min_amount_out,
        clock,
        ctx,
    );

    // Add the swapped token to the end of the vector
    (tokens, asset_token)
}

#[allow(lint(self_transfer))]
public entry fun create_and_swap_stable_to_asset_with_existing_entry<AssetType, StableType>(
    proposal: &mut Proposal<AssetType, StableType>,
    escrow: &mut TokenEscrow<AssetType, StableType>,
    outcome_idx: u64,
    existing_token: ConditionalToken,
    min_amount_out: u64,
    coin_in: Coin<StableType>,
    clock: &Clock,
    ctx: &mut TxContext,
) {
    let (mut tokens, asset_token) = create_and_swap_stable_to_asset_with_existing(
        proposal,
        escrow,
        outcome_idx,
        existing_token,
        min_amount_out,
        coin_in,
        clock,
        ctx,
    );

    let recipient = ctx.sender();

    // Transfer all tokens to the recipient
    transfer_tokens_to_recipient(tokens, recipient);
    transfer::public_transfer(asset_token, recipient);
}

/// Returns all tokens with swapped token at the end
public fun create_and_swap_asset_to_stable_with_existing<AssetType, StableType>(
    proposal: &mut Proposal<AssetType, StableType>,
    escrow: &mut TokenEscrow<AssetType, StableType>,
    outcome_idx: u64,
    existing_token: ConditionalToken,
    min_amount_out: u64,
    coin_in: Coin<AssetType>,
    clock: &Clock,
    ctx: &mut TxContext,
): (vector<ConditionalToken>, ConditionalToken) {
    assert!(proposal::market_state_id(proposal) == escrow.get_market_state_id(), EMarketIdMismatch);
    let mut tokens = escrow.mint_complete_set_asset(coin_in, clock, ctx);

    assert!(outcome_idx < tokens.length(), EInvalidOutcome);
    let mut swap_token = tokens.remove(outcome_idx);

    assert!(existing_token.outcome() == (outcome_idx as u8), EWrongOutcome);
    assert!(existing_token.asset_type() == 0, EWrongTokenType);
    assert!(existing_token.market_id() == escrow.get_market_state().market_id(), EMarketIdMismatch);

    // swap_token.outcome() is guaranteed to be outcome_idx since it came from tokens[outcome_idx]
    let mut existing_token_in_vector = vector[];
    existing_token_in_vector.push_back(existing_token);
    swap_token.merge_many(existing_token_in_vector, clock, ctx);

    // Swap the selected token
    let stable_token = swap_asset_to_stable(
        proposal,
        escrow,
        outcome_idx,
        swap_token,
        min_amount_out,
        clock,
        ctx,
    );

    // Add the swapped token to the end of the vector
    (tokens, stable_token)
}

#[allow(lint(self_transfer))]
public entry fun create_and_swap_asset_to_stable_with_existing_entry<AssetType, StableType>(
    proposal: &mut Proposal<AssetType, StableType>,
    escrow: &mut TokenEscrow<AssetType, StableType>,
    outcome_idx: u64,
    existing_token: ConditionalToken,
    min_amount_out: u64,
    coin_in: Coin<AssetType>,
    clock: &Clock,
    ctx: &mut TxContext,
) {
    let (mut tokens, stable_token) = create_and_swap_asset_to_stable_with_existing(
        proposal,
        escrow,
        outcome_idx,
        existing_token,
        min_amount_out,
        coin_in,
        clock,
        ctx,
    );

    let recipient = ctx.sender();

    // Transfer all tokens to the recipient
    transfer_tokens_to_recipient(tokens, recipient);
    transfer::public_transfer(stable_token, recipient);
}

/// Returns all tokens with swapped token at the end
public fun create_and_swap_asset_to_stable<AssetType, StableType>(
    proposal: &mut Proposal<AssetType, StableType>,
    escrow: &mut TokenEscrow<AssetType, StableType>,
    outcome_idx: u64,
    min_amount_out: u64,
    coin_in: Coin<AssetType>,
    clock: &Clock,
    ctx: &mut TxContext,
): (vector<ConditionalToken>, ConditionalToken) {
    assert!(proposal::market_state_id(proposal) == escrow.get_market_state_id(), EMarketIdMismatch);
    let mut tokens = escrow.mint_complete_set_asset(coin_in, clock, ctx);

    assert!(outcome_idx < tokens.length(), EInvalidOutcome);
    let token_to_swap = tokens.remove(outcome_idx);

    // Swap the selected token
    let stable_token = swap_asset_to_stable(
        proposal,
        escrow,
        outcome_idx,
        token_to_swap,
        min_amount_out,
        clock,
        ctx,
    );

    // Add the swapped token to the end of the vector
    (tokens, stable_token)
}

#[allow(lint(self_transfer))]
public entry fun create_and_swap_asset_to_stable_entry<AssetType, StableType>(
    proposal: &mut Proposal<AssetType, StableType>,
    escrow: &mut TokenEscrow<AssetType, StableType>,
    outcome_idx: u64,
    min_amount_out: u64,
    coin_in: Coin<AssetType>,
    clock: &Clock,
    ctx: &mut TxContext,
) {
    let (mut tokens, stable_token) = create_and_swap_asset_to_stable(
        proposal,
        escrow,
        outcome_idx,
        min_amount_out,
        coin_in,
        clock,
        ctx,
    );

    let recipient = ctx.sender();

    // Transfer all tokens to the recipient
    transfer_tokens_to_recipient(tokens, recipient);
    transfer::public_transfer(stable_token, recipient);
}

/// Returns all tokens with swapped token at the end
public fun create_and_swap_stable_to_asset<AssetType, StableType>(
    proposal: &mut Proposal<AssetType, StableType>,
    escrow: &mut TokenEscrow<AssetType, StableType>,
    outcome_idx: u64,
    min_amount_out: u64,
    coin_in: Coin<StableType>,
    clock: &Clock,
    ctx: &mut TxContext,
): (vector<ConditionalToken>, ConditionalToken) {
    assert!(proposal::market_state_id(proposal) == escrow.get_market_state_id(), EMarketIdMismatch);
    let mut tokens = escrow.mint_complete_set_stable(coin_in, clock, ctx);

    assert!(outcome_idx < tokens.length(), EInvalidOutcome);
    let token_to_swap = tokens.remove(outcome_idx);

    // Swap the selected token
    let asset_token = swap_stable_to_asset(
        proposal,
        escrow,
        outcome_idx,
        token_to_swap,
        min_amount_out,
        clock,
        ctx,
    );

    // Add the swapped token to the end of the vector
    (tokens, asset_token)
}

#[allow(lint(self_transfer))]
public entry fun create_and_swap_stable_to_asset_entry<AssetType, StableType>(
    proposal: &mut Proposal<AssetType, StableType>,
    escrow: &mut TokenEscrow<AssetType, StableType>,
    outcome_idx: u64,
    min_amount_out: u64,
    coin_in: Coin<StableType>,
    clock: &Clock,
    ctx: &mut TxContext,
) {
    let (mut tokens, asset_token) = create_and_swap_stable_to_asset(
        proposal,
        escrow,
        outcome_idx,
        min_amount_out,
        coin_in,
        clock,
        ctx,
    );

    let recipient = ctx.sender();

    // Transfer all tokens to the recipient
    transfer_tokens_to_recipient(tokens, recipient);
    transfer::public_transfer(asset_token, recipient);
}

// === Private Functions ===

fun swap_asset_to_stable_internal<AssetType, StableType>(
    proposal: &mut Proposal<AssetType, StableType>,
    state: &MarketState,
    outcome_idx: u64,
    amount_in: u64,
    min_amount_out: u64,
    clock: &Clock,
    ctx: &TxContext,
): u64 {
    assert!(proposal::proposal_id(proposal) == state.market_id(), EMarketIdMismatch);

    assert!(outcome_idx < proposal::outcome_count(proposal), EInvalidOutcome);
    assert!(proposal::state(proposal) == STATE_TRADING, EInvalidState);

    let pool = proposal::get_pool_mut_by_outcome(proposal, (outcome_idx as u8));
    pool.swap_asset_to_stable(state, amount_in, min_amount_out, clock, ctx)
}

fun swap_stable_to_asset_internal<AssetType, StableType>(
    proposal: &mut Proposal<AssetType, StableType>,
    state: &MarketState,
    outcome_idx: u64,
    amount_in: u64,
    min_amount_out: u64,
    clock: &Clock,
    ctx: &TxContext,
): u64 {
    assert!(proposal::proposal_id(proposal) == state.market_id(), EMarketIdMismatch);
    assert!(outcome_idx < proposal::outcome_count(proposal), EInvalidOutcome);
    assert!(proposal::state(proposal) == STATE_TRADING, EInvalidState);

    let pool = proposal::get_pool_mut_by_outcome(proposal, (outcome_idx as u8));
    pool.swap_stable_to_asset(state, amount_in, min_amount_out, clock, ctx)
}
module futarchy::liquidity_initialize;

use futarchy::conditional_amm::{Self, LiquidityPool};
use futarchy::coin_escrow::TokenEscrow;
use futarchy::conditional_token as token;
use sui::balance::Balance;
use sui::clock::Clock;

// === Introduction ===
// Method to initialize AMM liquidity

// === Errors ===
const EInitAssetReservesMismatch: u64 = 100;
const EInitStableReservesMismatch: u64 = 101;
const EInitPoolCountMismatch: u64 = 102;
const EInitPoolOutcomeMismatch: u64 = 103;
const EInitZeroLiquidity: u64 = 104;

// === Public Functions ===
public(package) fun create_outcome_markets<AssetType, StableType>(
    escrow: &mut TokenEscrow<AssetType, StableType>,
    outcome_count: u64,
    asset_amounts: vector<u64>,
    stable_amounts: vector<u64>,
    twap_start_delay: u64,
    twap_initial_observation: u128,
    twap_step_max: u64,
    amm_total_fee_bps: u64,
    initial_asset: Balance<AssetType>,
    initial_stable: Balance<StableType>,
    clock: &Clock,
    ctx: &mut TxContext,
): (vector<ID>, vector<LiquidityPool>) {
    assert!(asset_amounts.length() == outcome_count, EInitAssetReservesMismatch);
    assert!(stable_amounts.length() == outcome_count, EInitStableReservesMismatch);
    
    // Validate that all amounts are non-zero to prevent division by zero in AMM calculations
    let mut j = 0;
    while (j < outcome_count) {
        assert!(asset_amounts[j] > 0, EInitZeroLiquidity);
        assert!(stable_amounts[j] > 0, EInitZeroLiquidity);
        j = j + 1;
    };

    let mut supply_ids = vector[];
    let mut amm_pools = vector[];

    // 1. Create supplies and register them for each outcome
    let mut i = 0;
    while (i < outcome_count) {
        // Use same pattern as original to avoid borrow issues
        {
            let ms = escrow.get_market_state(); // Immutable borrow
            let asset_supply = token::new_supply(ms, 0, (i as u8), ctx);
            let stable_supply = token::new_supply(ms, 1, (i as u8), ctx);
            let lp_supply = token::new_supply(ms, 2, (i as u8), ctx);

            // Record their IDs (asset, stable, lp for each outcome)
            let asset_supply_id = object::id(&asset_supply);
            let stable_supply_id = object::id(&stable_supply);
            let lp_supply_id = object::id(&lp_supply);
            supply_ids.push_back(asset_supply_id);
            supply_ids.push_back(stable_supply_id);
            supply_ids.push_back(lp_supply_id);

            // Register
            escrow.register_supplies(i, asset_supply, stable_supply, lp_supply);
        };

        i = i + 1;
    };

    // 2. Deposit liquidity and handle differential minting in one step
    escrow.deposit_initial_liquidity(
        outcome_count,
        &asset_amounts,
        &stable_amounts,
        initial_asset,
        initial_stable,
        clock,
        ctx,
    );

    // 3. Create AMM pools for each outcome - same as original
    i = 0;
    while (i < outcome_count) {
        let asset_amt = asset_amounts[i];
        let stable_amt = stable_amounts[i];

        // Use same scoped borrow pattern as original
        {
            let ms = escrow.get_market_state(); // Immutable borrow
            let pool = conditional_amm::new_pool(
                ms,
                (i as u8),
                amm_total_fee_bps,
                asset_amt,
                stable_amt,
                twap_initial_observation,
                twap_start_delay,
                twap_step_max,
                ctx,
            );
            amm_pools.push_back(pool);
        };

        i = i + 1;
    };

    assert_initial_reserves_consistency<AssetType, StableType>(escrow, &amm_pools);

    (supply_ids, amm_pools)
}

fun assert_initial_reserves_consistency<AssetType, StableType>(
    escrow: &TokenEscrow<AssetType, StableType>,
    amm_pools: &vector<LiquidityPool>,
) {
    let outcome_count = escrow.get_market_state().outcome_count();

    assert!(amm_pools.length() == outcome_count, EInitPoolCountMismatch);

    let (escrow_asset, escrow_stable) = escrow.get_balances();

    let mut i = 0;
    while (i < outcome_count) {
        let pool = &amm_pools[i];

        assert!(pool.get_outcome_idx() == (i as u8), EInitPoolOutcomeMismatch);

        let (amm_asset, amm_stable) = pool.get_reserves();
        let protocol_fees = pool.get_protocol_fees();
        assert!(protocol_fees == 0, EInitStableReservesMismatch); // Fees must be 0 initially

        let (
            _fetched_escrow_asset,
            _fetched_escrow_stable,
            asset_total_supply,
            stable_total_supply,
        ) = escrow.get_escrow_balances_and_supply(i);

        // --- Perform the Core Assertions ---

        // Verify asset equation: AMM asset reserves + asset token supply = total escrow asset
        assert!(amm_asset + asset_total_supply == escrow_asset, EInitAssetReservesMismatch);

        // Verify stable equation: AMM stable reserves + protocol fees (0) + stable token supply = total escrow stable
        assert!(
            amm_stable + protocol_fees + stable_total_supply == escrow_stable, // protocol_fees is 0 here
            EInitStableReservesMismatch,
        );

        i = i + 1;
    };
}
/// ============================================================================
/// RING BUFFER ORACLE - CONTINUOUS PRICE FEED FOR LENDING PROTOCOLS
/// ============================================================================
/// 
/// PURPOSE: Provides uninterrupted price feeds for external integrations
/// 
/// USED BY:
/// - Lending protocols (Compound, Aave style)
/// - Liquidation bots
/// - Price aggregators
/// - Minting actions (longest TWAP for security)
/// - Any protocol needing standard TWAP access
/// 
/// KEY FEATURES:
/// - Ring buffer with up to 65535 observations (~9 days)
/// - Updates on every swap/liquidity event
/// - Standard read-only TWAP queries (no write requirement)
/// - Flexible time windows (1 second to 9 days)
/// - Observation merging for proposal finalization
/// 
/// BEHAVIOR:
/// - SpotAMM: Continuously updated during normal trading
/// - ConditionalAMMs: Updated during proposals for each outcome
/// - During proposals: Spot reads from highest conditional (no storage)
/// - After finalization: Winning conditional's data merges into spot
/// 
/// WHY IT EXISTS:
/// Lending protocols expect continuous, queryable price feeds that work like
/// Uniswap V2/V3 oracles. This module provides that standard interface while
/// the futarchy oracle handles the specialized prediction market mechanics.
/// The ring buffer ensures lending protocols always have fresh prices, even
/// during proposals when liquidity moves to conditional markets.
/// 
/// INTEGRATION:
/// - Each SpotAMM has one for normal trading
/// - Each ConditionalAMM has one for proposal periods
/// - spot_oracle_interface combines them seamlessly
/// - merge_observations() consolidates winning data after finalization
/// 
/// ============================================================================

module futarchy::ring_buffer_oracle;

use std::vector;
use sui::clock::Clock;
use futarchy::math;

// ============================================================================
// Constants
// ============================================================================

const MAX_OBSERVATIONS: u64 = 65535; // ~9 days at 12 second blocks
const PRICE_SCALE: u128 = 1_000_000_000_000; // 10^12 for precision
const MIN_UPDATE_INTERVAL_MS: u64 = 1000; // 1 second minimum between updates

// Errors
const ENotInitialized: u64 = 1;
const EInvalidWindow: u64 = 2;
const EInsufficientHistory: u64 = 3;
const EUpdateTooSoon: u64 = 4;

// ============================================================================
// Structs
// ============================================================================

/// Single price observation
public struct Observation has store, copy, drop {
    timestamp_ms: u64,
    cumulative_price: u256,  // Price × time accumulator
    price: u128,              // Spot price at observation
}

/// Ring buffer oracle used by AMMs
public struct RingBufferOracle has store {
    observations: vector<Observation>,
    current_index: u64,
    num_observations: u64,
    capacity: u64,
    last_update_ms: u64,
}

// ============================================================================
// Core Functions
// ============================================================================

/// Create new ring buffer oracle
public fun new(initial_capacity: u64): RingBufferOracle {
    let mut observations = vector::empty();
    let mut i = 0;
    while (i < initial_capacity) {
        observations.push_back(Observation {
            timestamp_ms: 0,
            cumulative_price: 0,
            price: 0,
        });
        i = i + 1;
    };
    
    RingBufferOracle {
        observations,
        current_index: 0,
        num_observations: 0,
        capacity: initial_capacity,
        last_update_ms: 0,
    }
}

/// Write new price observation
public fun write(
    oracle: &mut RingBufferOracle,
    price: u128,
    clock: &Clock,
) {
    let now = clock.timestamp_ms();
    
    // Prevent spam
    if (oracle.last_update_ms > 0) {
        assert!(now >= oracle.last_update_ms + MIN_UPDATE_INTERVAL_MS, EUpdateTooSoon);
    };
    
    // Calculate cumulative
    let new_cumulative = if (oracle.num_observations > 0) {
        let last = oracle.observations.borrow(oracle.current_index);
        let time_delta = now - last.timestamp_ms;
        last.cumulative_price + ((last.price as u256) * (time_delta as u256))
    } else {
        0
    };
    
    // Move to next slot
    let next_index = if (oracle.num_observations == 0) {
        0
    } else {
        (oracle.current_index + 1) % oracle.capacity
    };
    
    // Write observation
    *oracle.observations.borrow_mut(next_index) = Observation {
        timestamp_ms: now,
        cumulative_price: new_cumulative,
        price,
    };
    
    oracle.current_index = next_index;
    if (oracle.num_observations < oracle.capacity) {
        oracle.num_observations = oracle.num_observations + 1;
    };
    oracle.last_update_ms = now;
}

/// Get TWAP for any time window
public fun get_twap(
    oracle: &RingBufferOracle,
    seconds_ago: u64,
    clock: &Clock,
): u128 {
    assert!(oracle.num_observations > 0, ENotInitialized);
    
    let now = clock.timestamp_ms();
    let target_ms = now - (seconds_ago * 1000);
    
    // Find observations for TWAP calculation
    let (old_obs, new_obs) = find_observations_for_twap(oracle, target_ms, now);
    
    // Calculate TWAP
    let time_diff = new_obs.timestamp_ms - old_obs.timestamp_ms;
    if (time_diff == 0) {
        return new_obs.price
    };
    
    let cumulative_diff = new_obs.cumulative_price - old_obs.cumulative_price;
    ((cumulative_diff / (time_diff as u256)) as u128)
}

/// Get TWAP for lending (30 minutes standard)
public fun get_lending_twap(
    oracle: &RingBufferOracle,
    clock: &Clock,
): u128 {
    get_twap(oracle, 1800, clock) // 30 minutes
}

/// Get longest possible TWAP (for governance)
public fun get_longest_twap(
    oracle: &RingBufferOracle,
    clock: &Clock,
): u128 {
    if (oracle.num_observations == 0) {
        return PRICE_SCALE
    };
    
    // Find oldest observation
    let oldest_idx = if (oracle.num_observations < oracle.capacity) {
        0
    } else {
        (oracle.current_index + 1) % oracle.capacity
    };
    
    let oldest = oracle.observations.borrow(oldest_idx);
    let now = clock.timestamp_ms();
    let age_seconds = (now - oldest.timestamp_ms) / 1000;
    
    if (age_seconds > 0) {
        get_twap(oracle, age_seconds, clock)
    } else {
        oracle.observations.borrow(oracle.current_index).price
    }
}

// ============================================================================
// Helper Functions
// ============================================================================

/// Find observations for TWAP calculation
fun find_observations_for_twap(
    oracle: &RingBufferOracle,
    target_ms: u64,
    now_ms: u64,
): (Observation, Observation) {
    // Get newest observation
    let newest = *oracle.observations.borrow(oracle.current_index);
    
    // Handle single observation
    if (oracle.num_observations == 1) {
        return (newest, newest)
    };
    
    // Find oldest index
    let oldest_idx = if (oracle.num_observations < oracle.capacity) {
        0
    } else {
        (oracle.current_index + 1) % oracle.capacity
    };
    
    // Linear search for target (simple for Move)
    let mut before = *oracle.observations.borrow(oldest_idx);
    let mut i = 0;
    
    while (i < oracle.num_observations) {
        let idx = (oldest_idx + i) % oracle.capacity;
        let obs = *oracle.observations.borrow(idx);
        
        if (obs.timestamp_ms <= target_ms) {
            before = obs;
        } else {
            break
        };
        
        i = i + 1;
    };
    
    // Interpolate if needed
    if (before.timestamp_ms < target_ms && i < oracle.num_observations) {
        let after_idx = (oldest_idx + i) % oracle.capacity;
        let after = *oracle.observations.borrow(after_idx);
        
        // Interpolate to exact target time
        let time_before = target_ms - before.timestamp_ms;
        let interpolated_cumulative = before.cumulative_price + 
            ((before.price as u256) * (time_before as u256));
        
        before = Observation {
            timestamp_ms: target_ms,
            cumulative_price: interpolated_cumulative,
            price: before.price,
        };
    };
    
    // Add time since last observation for "now"
    let mut newest_adjusted = newest;
    if (newest.timestamp_ms < now_ms) {
        let time_since = now_ms - newest.timestamp_ms;
        newest_adjusted.cumulative_price = newest.cumulative_price + 
            ((newest.price as u256) * (time_since as u256));
        newest_adjusted.timestamp_ms = now_ms;
    };
    
    (before, newest_adjusted)
}

/// Check if sufficient history exists
public fun has_sufficient_history(
    oracle: &RingBufferOracle,
    seconds_required: u64,
    clock: &Clock,
): bool {
    if (oracle.num_observations == 0) {
        return false
    };
    
    let oldest_idx = if (oracle.num_observations < oracle.capacity) {
        0
    } else {
        (oracle.current_index + 1) % oracle.capacity
    };
    
    let oldest = oracle.observations.borrow(oldest_idx);
    let now = clock.timestamp_ms();
    
    (now - oldest.timestamp_ms) >= (seconds_required * 1000)
}

/// Get latest price
public fun get_latest_price(oracle: &RingBufferOracle): u128 {
    if (oracle.num_observations > 0) {
        oracle.observations.borrow(oracle.current_index).price
    } else {
        0
    }
}

/// Merge observations from source oracle into target oracle
/// Used when proposal finalizes to merge winning conditional's history into spot
public fun merge_observations(
    target: &mut RingBufferOracle,
    source: &RingBufferOracle,
    start_ms: u64,  // Start of period to merge
    end_ms: u64,    // End of period to merge
) {
    if (source.num_observations == 0) {
        return
    };
    
    // Find starting index in source
    let oldest_idx = if (source.num_observations < source.capacity) {
        0
    } else {
        (source.current_index + 1) % source.capacity
    };
    
    // Copy observations within time range
    let mut i = 0;
    while (i < source.num_observations) {
        let idx = (oldest_idx + i) % source.capacity;
        let obs = source.observations.borrow(idx);
        
        // Only merge observations within the proposal period
        if (obs.timestamp_ms >= start_ms && obs.timestamp_ms <= end_ms) {
            // Write to target (this handles cumulative calculation)
            write_with_timestamp(target, obs.price, obs.timestamp_ms);
        };
        
        i = i + 1;
    };
}

/// Internal write with specific timestamp (for merging)
fun write_with_timestamp(
    oracle: &mut RingBufferOracle,
    price: u128,
    timestamp_ms: u64,
) {
    // Calculate cumulative
    let new_cumulative = if (oracle.num_observations > 0) {
        let last = oracle.observations.borrow(oracle.current_index);
        if (timestamp_ms > last.timestamp_ms) {
            let time_delta = timestamp_ms - last.timestamp_ms;
            last.cumulative_price + ((last.price as u256) * (time_delta as u256))
        } else {
            // Skip if timestamp is not newer
            return
        }
    } else {
        0
    };
    
    // Move to next slot
    let next_index = if (oracle.num_observations == 0) {
        0
    } else {
        (oracle.current_index + 1) % oracle.capacity
    };
    
    // Write observation
    *oracle.observations.borrow_mut(next_index) = Observation {
        timestamp_ms,
        cumulative_price: new_cumulative,
        price,
    };
    
    oracle.current_index = next_index;
    if (oracle.num_observations < oracle.capacity) {
        oracle.num_observations = oracle.num_observations + 1;
    };
    oracle.last_update_ms = timestamp_ms;
}

// ============================================================================
// Test Functions
// ============================================================================

#[test_only]
/// Destroy oracle for testing
public fun destroy_for_testing(oracle: RingBufferOracle) {
    let RingBufferOracle {
        observations: _,
        current_index: _,
        num_observations: _,
        capacity: _,
        last_update_ms: _,
    } = oracle;
}module futarchy::spot_conditional_router;

use futarchy::swap;
use futarchy::coin_escrow::{Self, TokenEscrow};
use futarchy::conditional_token::ConditionalToken;
use futarchy::proposal::Proposal;
use sui::coin::{Self, Coin};
use sui::clock::Clock;
use sui::transfer;
use sui::tx_context::TxContext;
use std::vector;

// Errors
const EMinOutNotMet: u64 = 1;
const EInvalidState: u64 = 2;
const EZeroAmount: u64 = 3;
const ESlippageTooHigh: u64 = 4;

/// Asset → Stable (spot exact-in)
/// Route: deposit ASSET → mint complete set of ASSET tokens →
///        swap each to STABLE in its outcome AMM → redeem STABLE complete set → STABLE coin.
#[allow(lint(self_transfer))]
public entry fun swap_spot_asset_to_spot_stable_exact_in<AssetType, StableType>(
    proposal: &mut Proposal<AssetType, StableType>,
    escrow: &mut TokenEscrow<AssetType, StableType>,
    asset_in: Coin<AssetType>,
    min_stable_out: u64,
    clock: &Clock,
    ctx: &mut TxContext,
) {
    // Disallow if market is finalized
    let market_state = escrow.get_market_state();
    assert!(!market_state.is_finalized(), EInvalidState);

    // 1) Mint complete set of ASSET conditional tokens
    let mut tokens = coin_escrow::mint_complete_set_asset(escrow, asset_in, clock, ctx);

    // Calculate per-leg minimum to prevent MEV attacks
    // Allow max 5% slippage per leg (95% of expected fair share)
    let num_outcomes = tokens.length();
    assert!(num_outcomes > 0, EZeroAmount);
    let per_leg_min = if (min_stable_out > 0 && num_outcomes > 0) {
        // Distribute minimum proportionally with 5% tolerance
        (min_stable_out * 95 / 100) / num_outcomes
    } else {
        0
    };

    // 2) Convert each token ASSET→STABLE via its outcome AMM
    let mut stable_tokens = vector::empty<ConditionalToken>();
    while (!tokens.is_empty()) {
        let t = tokens.pop_back();                     // take ownership
        let outcome_idx = (t.outcome() as u64);        // safe to rely on token metadata
        let s = swap::swap_asset_to_stable(
            proposal,
            escrow,
            outcome_idx,
            t,                                         // moved here
            per_leg_min,                               // MEV protection per swap
            clock,
            ctx
        );
        stable_tokens.push_back(s);
    };
    tokens.destroy_empty();

    // 3) Redeem STABLE complete set back to spot coin
    let balance_out = coin_escrow::redeem_complete_set_stable(escrow, stable_tokens, clock, ctx);
    let stable_out = coin::from_balance(balance_out, ctx);
    let out_amt = coin::value(&stable_out);
    assert!(out_amt >= min_stable_out, EMinOutNotMet);

    transfer::public_transfer(stable_out, ctx.sender());
}

/// Stable → Asset (spot exact-in)
/// Route: deposit STABLE → mint complete set of STABLE tokens →
///        swap each to ASSET in its outcome AMM → redeem ASSET complete set → ASSET coin.
#[allow(lint(self_transfer))]
public entry fun swap_spot_stable_to_spot_asset_exact_in<AssetType, StableType>(
    proposal: &mut Proposal<AssetType, StableType>,
    escrow: &mut TokenEscrow<AssetType, StableType>,
    stable_in: Coin<StableType>,
    min_asset_out: u64,
    clock: &Clock,
    ctx: &mut TxContext,
) {
    // Disallow if market is finalized
    let market_state = escrow.get_market_state();
    assert!(!market_state.is_finalized(), EInvalidState);

    // 1) Mint complete set of STABLE conditional tokens
    let mut tokens = coin_escrow::mint_complete_set_stable(escrow, stable_in, clock, ctx);

    // Calculate per-leg minimum to prevent MEV attacks
    let num_outcomes = tokens.length();
    assert!(num_outcomes > 0, EZeroAmount);
    let per_leg_min = if (min_asset_out > 0 && num_outcomes > 0) {
        // Distribute minimum proportionally with 5% tolerance
        (min_asset_out * 95 / 100) / num_outcomes
    } else {
        0
    };

    // 2) Convert each token STABLE→ASSET via its outcome AMM
    let mut asset_tokens = vector::empty<ConditionalToken>();
    while (!tokens.is_empty()) {
        let t = tokens.pop_back();
        let outcome_idx = (t.outcome() as u64);
        let a = swap::swap_stable_to_asset(
            proposal,
            escrow,
            outcome_idx,
            t,
            per_leg_min,                               // MEV protection per swap
            clock,
            ctx
        );
        asset_tokens.push_back(a);
    };
    tokens.destroy_empty();

    // 3) Redeem ASSET complete set back to spot coin
    let balance_out = coin_escrow::redeem_complete_set_asset(escrow, asset_tokens, clock, ctx);
    let asset_out = coin::from_balance(balance_out, ctx);
    let out_amt = coin::value(&asset_out);
    assert!(out_amt >= min_asset_out, EMinOutNotMet);

    transfer::public_transfer(asset_out, ctx.sender());
}module futarchy::coin_escrow;

use futarchy::conditional_token::{Self as token, ConditionalToken, Supply};
use futarchy::market_state::MarketState;
use futarchy::spot_amm;
use sui::balance::{Self, Balance};
use sui::clock::Clock;
use sui::coin::Coin;
use sui::event;

// === Introduction ===
// The TokenEscrow manages the relationship between spot tokens and conditional tokens
// in the futarchy prediction market system.
//
// === Live-Flow Model Integration ===
// In the live-flow model, the escrow plays a critical role:
// 1. **Minting Complete Sets**: When LPs add liquidity during active proposals,
//    spot tokens are converted to complete sets of conditional tokens (one for each outcome)
// 2. **Redeeming Complete Sets**: When LPs remove liquidity, conditional tokens
//    are redeemed back to spot tokens
// 3. **Supply Tracking**: Maintains Supply objects for each outcome's tokens
//
// This enables the key innovation: LPs can freely add/remove liquidity even while
// proposals are active, as their spot tokens are automatically converted to/from
// conditional tokens as needed.
//
// === CRITICAL: Market Finalization and LP Token Conversion ===
//
// **Key Points:**
// 1. **Finalization is a One-Way Door**: Once a market is finalized, NO conditional token
//    operations (swaps, mints) are allowed. Only redemption and LP conversion are permitted.
//
// 2. **LP Token 1:1 Exchange**: Conditional LP tokens and spot LP tokens use identical amounts.
//    When liquidity moves from conditional AMM to spot AMM during finalization, the LP token
//    amounts remain the same. This is a simple 1:1 burn-and-mint operation.
//
// 3. **Conditional LP Cannot Be Redeemed for Underlying**: After finalization, conditional LP
//    tokens from the winning outcome CANNOT be redeemed for underlying asset/stable tokens.
//    They can ONLY be converted to spot LP tokens via convert_winning_lp_to_spot_lp().
//    Before finalization, conditional LP tokens can be burned to withdraw conditional tokens
//    from the AMM (via remove_liquidity), but after finalization this is not allowed.
//
// 4. **Liquidity Movement During Finalization**: The actual liquidity (asset and stable tokens)
//    is transferred from the winning conditional AMM to the spot AMM during finalization.
//    The LP tokens just track ownership shares - they don't hold the liquidity themselves.
//
// **Function Restrictions by Phase:**
//
// BEFORE Finalization (Market Active):
// - ✅ mint_single_conditional_token() - Create new conditional tokens
// - ✅ mint_complete_set_asset/stable() - Mint complete sets
// - ✅ deposit_initial_liquidity() - Add conditional tokens to AMM, receive conditional LP tokens
// - ✅ remove_liquidity() - Burn conditional LP tokens, receive conditional tokens back
// - ✅ swap_token_asset_to_stable() - Swap between conditional tokens
// - ✅ swap_token_stable_to_asset() - Swap between conditional tokens
// - ✅ redeem_complete_set() - Redeem complete sets back to spot
// - ❌ redeem_winning_tokens() - Not allowed until finalized
// - ❌ convert_winning_lp_to_spot_lp() - Not allowed until finalized
//
// AFTER Finalization (Market Settled):
// - ❌ mint_single_conditional_token() - No new minting allowed
// - ❌ mint_complete_set_asset/stable() - No new minting allowed
// - ❌ deposit_initial_liquidity() - Cannot add liquidity to conditional AMMs
// - ❌ remove_liquidity() - Cannot remove liquidity from conditional AMMs
// - ❌ swap_token_asset_to_stable() - No swapping allowed
// - ❌ swap_token_stable_to_asset() - No swapping allowed
// - ❌ redeem_complete_set() - Cannot form complete sets anymore
// - ✅ redeem_winning_tokens_asset/stable() - Redeem winning outcome tokens
// - ✅ convert_winning_lp_to_spot_lp() - Convert winning LP tokens 1:1 to spot LP
// - ✅ burn_losing_lp_tokens() - Burn worthless losing outcome LP tokens
//
// **Security Invariants:**
// - The 1:1 LP conversion preserves ownership percentages exactly
// - No value can be created or destroyed during conversion
// - The underlying liquidity has already moved; LP conversion just updates token type
// - These restrictions prevent any manipulation after market settlement

// === Errors ===
const EInsufficientBalance: u64 = 0; // Token balance insufficient for operation
const EIncorrectSequence: u64 = 1; // Tokens not provided in correct sequence/order
const EWrongMarket: u64 = 2; // Token belongs to different market
const EWrongTokenType: u64 = 3; // Wrong token type (asset vs stable)
const ESuppliesNotInitialized: u64 = 4; // Token supplies not yet initialized
const EOutcomeOutOfBounds: u64 = 5; // Outcome index exceeds market outcomes
const EWrongOutcome: u64 = 6; // Token outcome doesn't match expected
const ENotEnough: u64 = 7; // Not enough tokens/balance for operation
const ENotEnoughLiquidity: u64 = 8; // Insufficient liquidity in escrow
const EInsufficientAsset: u64 = 9; // Not enough asset tokens provided
const EInsufficientStable: u64 = 10; // Not enough stable tokens provided
const EMarketNotExpired: u64 = 11; // Market hasn't reached expiry period
const EBadWitness: u64 = 12; // Invalid one-time witness
const EZeroAmount: u64 = 13; // Amount must be greater than zero
const EInvalidAssetType: u64 = 14; // Asset type must be 0 (asset) or 1 (stable)
const EOverflow: u64 = 15; // Arithmetic overflow protection
const EInvariantViolation: u64 = 16; // Differential minting invariant violated

// === Constants ===
const TOKEN_TYPE_ASSET: u8 = 0;
const TOKEN_TYPE_STABLE: u8 = 1;
const TOKEN_TYPE_LP: u8 = 2;
const ETokenTypeMismatch: u64 = 100;
const MARKET_EXPIRY_PERIOD_MS: u64 = 2_592_000_000; // 30 days in ms

// === Structs ===
public struct TokenEscrow<phantom AssetType, phantom StableType> has key, store {
    id: UID,
    market_state: MarketState,
    // Central balances used for tokens and liquidity
    escrowed_asset: Balance<AssetType>,
    escrowed_stable: Balance<StableType>,
    // Token supplies for tracking issuance
    outcome_asset_supplies: vector<Supply>,
    outcome_stable_supplies: vector<Supply>,
    outcome_lp_supplies: vector<Supply>,
    // Track final amounts from winning pool for LP conversion invariance
    winning_pool_final_asset: u64,
    winning_pool_final_stable: u64,
    // Track original winning LP supply for conversion invariant
    winning_lp_supply_at_finalization: u64,
    // Track total LP converted so far to ensure no over-conversion
    winning_lp_converted: u64,
}

public struct COIN_ESCROW has drop {}

// === Events ===
public struct LiquidityWithdrawal has copy, drop {
    escrowed_asset: u64,
    escrowed_stable: u64,
    asset_amount: u64,
    stable_amount: u64,
}

public struct LiquidityDeposit has copy, drop {
    escrowed_asset: u64,
    escrowed_stable: u64,
    asset_amount: u64,
    stable_amount: u64,
}

public struct TokenRedemption has copy, drop {
    outcome: u64,
    token_type: u8,
    amount: u64,
}
// === New Functions for Live-Flow Model ===

/// Mint a single conditional token for AMM liquidity removal
/// This function is used by the AMM when removing liquidity proportionally
public (package) fun mint_single_conditional_token<AssetType, StableType>(
    escrow: &mut TokenEscrow<AssetType, StableType>,
    asset_type: u8,
    outcome: u8,
    amount: u64,
    recipient: address,
    clock: &Clock,
    ctx: &mut TxContext,
): ConditionalToken {
    assert!(amount > 0, EZeroAmount);
    assert!(asset_type <= 2, EInvalidAssetType);
    
    // Safety checks
    escrow.market_state.assert_not_finalized();
    assert_supplies_initialized(escrow);
    
    let outcome_idx = (outcome as u64);
    assert!(outcome_idx < escrow.market_state.outcome_count(), EOutcomeOutOfBounds);
    
    // Get the appropriate supply based on token type
    let escrow_id = object::id(escrow);
    if (asset_type == TOKEN_TYPE_ASSET) {
        let supply = &mut escrow.outcome_asset_supplies[outcome_idx];
        token::mint_with_escrow(
            &escrow.market_state,
            supply,
            amount,
            recipient,
            escrow_id,
            clock,
            ctx
        )
    } else if (asset_type == TOKEN_TYPE_STABLE) {
        let supply = &mut escrow.outcome_stable_supplies[outcome_idx];
        token::mint_with_escrow(
            &escrow.market_state,
            supply,
            amount,
            recipient,
            escrow_id,
            clock,
            ctx
        )
    } else {
        let supply = &mut escrow.outcome_lp_supplies[outcome_idx];
        token::mint_with_escrow(
            &escrow.market_state,
            supply,
            amount,
            recipient,
            escrow_id,
            clock,
            ctx
        )
    }
}

/// Burn a single conditional token - used by AMM when absorbing liquidity
public (package) fun burn_single_conditional_token<AssetType, StableType>(
    escrow: &mut TokenEscrow<AssetType, StableType>,
    token: ConditionalToken,
    clock: &Clock,
    ctx: &TxContext,
) {
    // Safety checks
    escrow.market_state.assert_not_finalized();
    assert_supplies_initialized(escrow);
    
    let asset_type = token.asset_type();
    let outcome = token.outcome();
    let outcome_idx = (outcome as u64);
    
    assert!(token.market_id() == escrow.market_state.market_id(), EWrongMarket);
    assert!(outcome_idx < escrow.market_state.outcome_count(), EOutcomeOutOfBounds);
    
    // Get the appropriate supply and burn
    if (asset_type == TOKEN_TYPE_ASSET) {
        let supply = &mut escrow.outcome_asset_supplies[outcome_idx];
        token::burn(token, supply, clock, ctx);
    } else if (asset_type == TOKEN_TYPE_STABLE) {
        let supply = &mut escrow.outcome_stable_supplies[outcome_idx];
        token::burn(token, supply, clock, ctx);
    } else {
        let supply = &mut escrow.outcome_lp_supplies[outcome_idx];
        token::burn(token, supply, clock, ctx);
    };
}

/// Mint a complete set of asset conditional tokens for all outcomes
public fun mint_complete_set_asset<AssetType, StableType>(
    escrow: &mut TokenEscrow<AssetType, StableType>,
    asset_in: Coin<AssetType>,
    _clock: &Clock,
    ctx: &mut TxContext,
): vector<ConditionalToken> {
    let amount = asset_in.value();
    assert!(amount > 0, EInsufficientAsset);
    
    // Safety checks
    escrow.market_state.assert_not_finalized();
    assert_supplies_initialized(escrow);
    
    // Deposit asset into escrow
    escrow.escrowed_asset.join(asset_in.into_balance());
    
    // Mint conditional tokens for each outcome
    let mut tokens = vector::empty();
    let outcome_count = escrow.outcome_asset_supplies.length();
    let mut i = 0;
    
    let escrow_id = object::id(escrow);
    while (i < outcome_count) {
        let supply = &mut escrow.outcome_asset_supplies[i];
        let token = token::mint_with_escrow(
            &escrow.market_state,
            supply,
            amount,
            ctx.sender(),
            escrow_id,
            _clock,
            ctx
        );
        tokens.push_back(token);
        i = i + 1;
    };
    
    tokens
}

/// Mint a complete set of stable conditional tokens for all outcomes
public fun mint_complete_set_stable<AssetType, StableType>(
    escrow: &mut TokenEscrow<AssetType, StableType>,
    stable_in: Coin<StableType>,
    _clock: &Clock,
    ctx: &mut TxContext,
): vector<ConditionalToken> {
    let amount = stable_in.value();
    assert!(amount > 0, EInsufficientStable);
    
    // Safety checks
    escrow.market_state.assert_not_finalized();
    assert_supplies_initialized(escrow);
    
    // Deposit stable into escrow
    escrow.escrowed_stable.join(stable_in.into_balance());
    
    // Mint conditional tokens for each outcome
    let mut tokens = vector::empty();
    let outcome_count = escrow.outcome_stable_supplies.length();
    let mut i = 0;
    
    let escrow_id = object::id(escrow);
    while (i < outcome_count) {
        let supply = &mut escrow.outcome_stable_supplies[i];
        let token = token::mint_with_escrow(
            &escrow.market_state,
            supply,
            amount,
            ctx.sender(),
            escrow_id,
            _clock,
            ctx
        );
        tokens.push_back(token);
        i = i + 1;
    };
    
    tokens
}

/// Redeem a complete set of asset conditional tokens back to asset
public fun redeem_complete_set_asset<AssetType, StableType>(
    escrow: &mut TokenEscrow<AssetType, StableType>,
    mut tokens: vector<ConditionalToken>,
    _clock: &Clock,
    _ctx: &mut TxContext,
): Balance<AssetType> {
    // Safety checks
    escrow.market_state.assert_not_finalized();
    assert_supplies_initialized(escrow);
    
    // Use the helper function to verify we have a complete set
    let amount = verify_token_set(escrow, &tokens, TOKEN_TYPE_ASSET);
    
    // Verify escrow has sufficient balance
    assert!(escrow.escrowed_asset.value() >= amount, EInsufficientBalance);
    
    // Burn all tokens - use the token's outcome to find the correct supply
    while (!tokens.is_empty()) {
        let token = tokens.pop_back();
        let outcome_idx = (token.outcome() as u64);
        let supply = &mut escrow.outcome_asset_supplies[outcome_idx];
        token::burn(token, supply, _clock, _ctx);
    };
    tokens.destroy_empty();
    
    // Return asset
    escrow.escrowed_asset.split(amount)
}

/// Redeem a complete set of stable conditional tokens back to stable
public fun redeem_complete_set_stable<AssetType, StableType>(
    escrow: &mut TokenEscrow<AssetType, StableType>,
    mut tokens: vector<ConditionalToken>,
    _clock: &Clock,
    _ctx: &mut TxContext,
): Balance<StableType> {
    // Safety checks
    escrow.market_state.assert_not_finalized();
    assert_supplies_initialized(escrow);
    
    // Use the helper function to verify we have a complete set
    let amount = verify_token_set(escrow, &tokens, TOKEN_TYPE_STABLE);
    
    // Verify escrow has sufficient balance
    assert!(escrow.escrowed_stable.value() >= amount, EInsufficientBalance);
    
    // Burn all tokens - use the token's outcome to find the correct supply
    while (!tokens.is_empty()) {
        let token = tokens.pop_back();
        let outcome_idx = (token.outcome() as u64);
        let supply = &mut escrow.outcome_stable_supplies[outcome_idx];
        token::burn(token, supply, _clock, _ctx);
    };
    tokens.destroy_empty();
    
    // Return stable
    escrow.escrowed_stable.split(amount)
}

public(package) fun new<AssetType, StableType>(
    market_state: MarketState,
    ctx: &mut TxContext,
): TokenEscrow<AssetType, StableType> {
    TokenEscrow {
        id: object::new(ctx),
        market_state,
        escrowed_asset: balance::zero(), // Initial liquidity goes directly to escrowed
        escrowed_stable: balance::zero(),
        outcome_asset_supplies: vector[],
        outcome_stable_supplies: vector[],
        outcome_lp_supplies: vector[],
        winning_pool_final_asset: 0,
        winning_pool_final_stable: 0,
        winning_lp_supply_at_finalization: 0,
        winning_lp_converted: 0,
    }
}

public(package) fun register_supplies<AssetType, StableType>(
    escrow: &mut TokenEscrow<AssetType, StableType>,
    outcome_idx: u64,
    asset_supply: Supply,
    stable_supply: Supply,
    lp_supply: Supply,
) {
    let outcome_count = escrow.market_state.outcome_count();
    assert!(outcome_idx < outcome_count, EOutcomeOutOfBounds);
    assert!(escrow.outcome_asset_supplies.length() == outcome_idx, EIncorrectSequence);

    escrow.outcome_asset_supplies.push_back(asset_supply);
    escrow.outcome_stable_supplies.push_back(stable_supply);
    escrow.outcome_lp_supplies.push_back(lp_supply);
}

/// Deposits initial liquidity into the escrow and implements "differential minting" mechanism.
/// 
/// ## Differential Minting Economics
/// This function implements a critical economic mechanism called "differential minting" which maintains
/// the complete-set conservation invariant. When initial liquidity is deposited:
/// 
/// 1. The function calculates the maximum liquidity needed across all outcomes
/// 2. For outcomes that require less than the maximum liquidity, the difference is minted 
///    as conditional tokens and transferred to the liquidity provider (market activator)
/// 3. This ensures that the total value in the system remains conserved:
///    - Escrow Balance + Outstanding Conditional Tokens = Initial Deposit
/// 
/// ## Economic Rationale
/// The differential tokens represent the "unused" liquidity for specific outcomes. Since not all
/// outcomes need the maximum amount of liquidity, the differential tokens allow the liquidity
/// provider to reclaim this unused portion if needed, while still maintaining full collateralization.
/// 
/// ## Important Invariants
/// - The sum of AMM reserves plus conditional token supplies always equals the escrow balance
/// - Differential tokens are fully backed by the escrow and can be redeemed as part of a complete set
/// - This mechanism prevents value leakage while optimizing capital efficiency
/// 
/// ## Example
/// If outcome A needs 100 tokens and outcome B needs 80 tokens:
/// - Maximum needed: 100 tokens
/// - Escrow receives: 100 tokens  
/// - Outcome B differential: 20 conditional tokens minted to the liquidity provider
/// - These 20 tokens + 80 in the AMM = 100 total for outcome B
#[allow(lint(self_transfer))]
public(package) fun deposit_initial_liquidity<AssetType, StableType>(
    escrow: &mut TokenEscrow<AssetType, StableType>,
    outcome_count: u64,
    asset_amounts: &vector<u64>,
    stable_amounts: &vector<u64>,
    initial_asset: Balance<AssetType>,
    initial_stable: Balance<StableType>,
    clock: &Clock,
    ctx: &mut TxContext,
) {
    let asset_amount = initial_asset.value();
    let stable_amount = initial_stable.value();
    let sender = ctx.sender();

    // 1. Add to escrow balances
    escrow.escrowed_asset.join(initial_asset);
    escrow.escrowed_stable.join(initial_stable);

    // 2. Calculate maximum amounts needed across outcomes with overflow protection
    let mut max_asset = 0u64;
    let mut max_stable = 0u64;
    let mut i = 0;
    while (i < outcome_count) {
        let asset_amt = asset_amounts[i];
        let stable_amt = stable_amounts[i];
        if (asset_amt > max_asset) { max_asset = asset_amt };
        if (stable_amt > max_stable) { max_stable = stable_amt };
        i = i + 1;
    };

    assert!(asset_amount == max_asset, EInsufficientAsset);
    assert!(stable_amount == max_stable, EInsufficientStable);

    // 3. Mint differential tokens for each outcome
    // DIFFERENTIAL MINTING: For outcomes that need less than the maximum liquidity,
    // we mint the difference as conditional tokens to the liquidity provider.
    // This maintains the invariant: AMM_reserves[i] + conditional_supply[i] = max_liquidity
    let escrow_id = object::id(escrow);
    i = 0;
    while (i < outcome_count) {
        let asset_amt = asset_amounts[i];
        let stable_amt = stable_amounts[i];

        // Mint differential asset tokens if this outcome needs less than max
        // These tokens represent the "unused" asset liquidity for this outcome
        if (asset_amt < max_asset) {
            let diff = max_asset - asset_amt;
            let asset_supply = &mut escrow.outcome_asset_supplies[i];
            let token = token::mint_with_escrow(
                &escrow.market_state,
                asset_supply,
                diff,
                sender,
                escrow_id,
                clock,
                ctx,
            );
            // Transfer differential tokens to the liquidity provider
            transfer::public_transfer(token, sender);
        };

        // Mint differential stable tokens if this outcome needs less than max
        // These tokens represent the "unused" stable liquidity for this outcome
        if (stable_amt < max_stable) {
            let diff = max_stable - stable_amt;
            let stable_supply = &mut escrow.outcome_stable_supplies[i];
            let token = token::mint_with_escrow(
                &escrow.market_state,
                stable_supply,
                diff,
                sender,
                escrow_id,
                clock,
                ctx,
            );
            // Transfer differential tokens to the liquidity provider
            transfer::public_transfer(token, sender);
        };

        i = i + 1;
    };

    // 4. INVARIANT CHECK: Verify conservation of value
    // For each outcome: AMM_reserves + minted_differential_tokens = max_liquidity
    // This ensures no value can be created or destroyed through the minting process
    verify_differential_minting_invariants(
        escrow,
        outcome_count,
        asset_amounts,
        stable_amounts,
        max_asset,
        max_stable
    );
    
    // 5. Emit event with deposit information showing final escrow balances
    event::emit(LiquidityDeposit {
        escrowed_asset: escrow.escrowed_asset.value(),  // Actual escrow balance after deposit
        escrowed_stable: escrow.escrowed_stable.value(), // Actual escrow balance after deposit
        asset_amount: asset_amount,  // Amount deposited
        stable_amount: stable_amount, // Amount deposited
    });
}

public(package) fun remove_liquidity<AssetType, StableType>(
    escrow: &mut TokenEscrow<AssetType, StableType>,
    asset_amount: u64,
    stable_amount: u64,
    ctx: &mut TxContext,
): (Coin<AssetType>, Coin<StableType>) {
    // Changed return type

    // Verify there's enough liquidity to withdraw
    assert!(escrow.escrowed_asset.value() >= asset_amount, ENotEnoughLiquidity);
    assert!(escrow.escrowed_stable.value() >= stable_amount, ENotEnoughLiquidity);

    // Withdraw the liquidity into balances
    let asset_balance_out = escrow.escrowed_asset.split(asset_amount);
    let stable_balance_out = escrow.escrowed_stable.split(stable_amount);

    // Convert balances to coins
    let asset_coin_out = asset_balance_out.into_coin(ctx);
    let stable_coin_out = stable_balance_out.into_coin(ctx);

    // Emit event with withdrawal information (reflects state *after* split)
    event::emit(LiquidityWithdrawal {
        escrowed_asset: escrow.escrowed_asset.value(),
        escrowed_stable: escrow.escrowed_stable.value(),
        asset_amount: asset_amount, // Amount withdrawn
        stable_amount: stable_amount, // Amount withdrawn
    });

    // Return the coins instead of transferring
    (asset_coin_out, stable_coin_out)
}

public(package) fun extract_stable_fees<AssetType, StableType>(
    escrow: &mut TokenEscrow<AssetType, StableType>,
    amount: u64,
): Balance<StableType> {
    escrow.market_state.assert_market_finalized();
    assert!(escrow.escrowed_stable.value() >= amount, ENotEnough);
    escrow.escrowed_stable.split(amount)
}

// === Private Functions ===

/// Check if supplies are properly initialized for all outcomes
fun assert_supplies_initialized<AssetType, StableType>(
    escrow: &TokenEscrow<AssetType, StableType>,
) {
    let outcome_count = escrow.market_state.outcome_count();
    assert!(
        escrow.outcome_asset_supplies.length() == outcome_count &&
                escrow.outcome_stable_supplies.length() == outcome_count &&
                escrow.outcome_lp_supplies.length() == outcome_count,
        ESuppliesNotInitialized,
    );
}

/// Helper function to verify tokens form a complete set and return the amount
fun verify_token_set<AssetType, StableType>(
    escrow: &TokenEscrow<AssetType, StableType>,
    tokens: &vector<ConditionalToken>,
    token_type: u8,
): u64 {
    // Get market details from escrow
    let market_id = escrow.market_state.market_id();
    let outcome_count = escrow.market_state.outcome_count();

    // Must have exactly one token per outcome
    assert!(tokens.length() == outcome_count, EIncorrectSequence);
    
    // Ensure tokens vector is not empty before accessing
    assert!(tokens.length() > 0, EIncorrectSequence);

    // Initialize outcomes_seen vector
    let mut outcomes_seen = vector[];
    // We still need to initialize the vector, but we can combine with the token validation
    let mut i = 0;
    while (i < outcome_count) {
        outcomes_seen.push_back(false);
        i = i + 1;
    };

    // Get amount from first token to verify consistency
    let first_token = &tokens[0];
    let amount = first_token.value();

    // Verify all tokens and mark outcomes as seen in a single pass
    i = 0;
    while (i < outcome_count) {
        let token = &tokens[i];

        // Verify all token properties comprehensively
        assert!(token.market_id() == market_id, EWrongMarket);
        assert!(token.asset_type() == token_type, EWrongTokenType);
        assert!(token.value() == amount, EInsufficientBalance);
        assert!(amount > 0, EZeroAmount);

        let outcome = token.outcome();
        let outcome_idx = (outcome as u64);

        // Verify outcome is valid and not seen before
        assert!(outcome_idx < outcome_count, EWrongOutcome);
        assert!(!outcomes_seen[outcome_idx], EWrongOutcome);

        // Mark outcome as seen
        *&mut outcomes_seen[outcome_idx] = true;
        i = i + 1;
    };

    // Ensure all outcomes are represented
    i = 0;
    while (i < outcome_count) {
        assert!(outcomes_seen[i], EWrongOutcome);
        i = i + 1;
    };

    amount
}



// Asset token redemption for winning outcome
/// Redeem winning outcome ASSET tokens after finalization
/// 
/// RESTRICTION: This function can ONLY be called AFTER market finalization.
/// Only ASSET/STABLE tokens from the WINNING outcome can be redeemed.
/// For conditional LP tokens, use convert_winning_lp_to_spot_lp() instead - they cannot be redeemed for underlying tokens.
public(package) fun redeem_winning_tokens_asset<AssetType, StableType>(
    escrow: &mut TokenEscrow<AssetType, StableType>,
    token: ConditionalToken,
    clock: &Clock,
    ctx: &TxContext,
): Balance<AssetType> {
    // Verify market is finalized and get winning outcome
    escrow.market_state.assert_market_finalized();
    let winner = escrow.market_state.get_winning_outcome();
    assert_supplies_initialized(escrow);

    // Verify token matches winning outcome
    let winner_u8 = (winner as u8);
    assert!(token.outcome() == winner_u8, EWrongOutcome);
    assert!(token.market_id() == escrow.market_state.market_id(), EWrongMarket);
    assert!(token.asset_type() == TOKEN_TYPE_ASSET, EWrongTokenType);

    // Get token amount and burn token
    let amount = token.value();
    let winning_supply = &mut escrow.outcome_asset_supplies[winner];
    token.burn(winning_supply, clock, ctx);
    assert!(escrow.escrowed_asset.value() >= amount, EInsufficientBalance);
    // Emit redemption event
    event::emit(TokenRedemption {
        outcome: winner,
        token_type: TOKEN_TYPE_ASSET,
        amount: amount,
    });

    // Return amount from central asset balance
    escrow.escrowed_asset.split(amount)
}

// Stable token redemption for winning outcome
/// Redeem winning outcome STABLE tokens after finalization
/// 
/// RESTRICTION: This function can ONLY be called AFTER market finalization.
/// Only ASSET/STABLE tokens from the WINNING outcome can be redeemed.
/// For conditional LP tokens, use convert_winning_lp_to_spot_lp() instead - they cannot be redeemed for underlying tokens.
public(package) fun redeem_winning_tokens_stable<AssetType, StableType>(
    escrow: &mut TokenEscrow<AssetType, StableType>,
    token: ConditionalToken,
    clock: &Clock,
    ctx: &TxContext,
): Balance<StableType> {
    // Verify market is finalized and get winning outcome
    escrow.market_state.assert_market_finalized();
    let winner = escrow.market_state.get_winning_outcome();
    assert_supplies_initialized(escrow);

    // Verify token matches winning outcome
    let winner_u8 = (winner as u8);
    assert!(token.outcome() == winner_u8, EWrongOutcome);
    assert!(token.market_id() == escrow.market_state.market_id(), EWrongMarket);
    assert!(token.asset_type() == TOKEN_TYPE_STABLE, EWrongTokenType);

    // Get token amount and burn token
    let amount = token.value();
    let winning_supply = &mut escrow.outcome_stable_supplies[winner];
    token.burn(winning_supply, clock, ctx);
    assert!(escrow.escrowed_stable.value() >= amount, EInsufficientBalance);
    // Emit redemption event
    event::emit(TokenRedemption {
        outcome: winner,
        token_type: TOKEN_TYPE_STABLE,
        amount: amount,
    });

    // Return amount from central stable balance
    escrow.escrowed_stable.split(amount)
}



/// ======= Swap Methods =========
public(package) fun swap_token_asset_to_stable<AssetType, StableType>(
    escrow: &mut TokenEscrow<AssetType, StableType>,
    token_in: ConditionalToken,
    outcome_idx: u64,
    amount_out: u64,
    clock: &Clock,
    ctx: &mut TxContext,
): ConditionalToken {
    let ms = &escrow.market_state;
    ms.assert_trading_active();
    assert!(outcome_idx < ms.outcome_count(), EOutcomeOutOfBounds);

    let market_id = ms.market_id();
    assert!(token_in.market_id() == market_id, EWrongMarket);
    assert!(token_in.outcome() == (outcome_idx as u8), EWrongOutcome);
    assert!(token_in.asset_type() == TOKEN_TYPE_ASSET, EWrongTokenType);

    let escrow_id = object::id(escrow);
    
    let asset_supply = &mut escrow.outcome_asset_supplies[outcome_idx];
    token_in.burn(asset_supply, clock, ctx);

    let stable_supply = &mut escrow.outcome_stable_supplies[outcome_idx];
    let token = token::mint_with_escrow(
        ms,
        stable_supply,
        amount_out,
        ctx.sender(),
        escrow_id,
        clock,
        ctx,
    );
    token
}

public(package) fun swap_token_stable_to_asset<AssetType, StableType>(
    escrow: &mut TokenEscrow<AssetType, StableType>,
    token_in: ConditionalToken,
    outcome_idx: u64,
    amount_out: u64,
    clock: &Clock,
    ctx: &mut TxContext,
): ConditionalToken {
    let ms = &escrow.market_state;
    ms.assert_trading_active();
    assert!(outcome_idx < ms.outcome_count(), EOutcomeOutOfBounds);

    let market_id = ms.market_id();
    assert!(token_in.market_id() == market_id, EWrongMarket);
    assert!(token_in.outcome() == (outcome_idx as u8), EWrongOutcome);
    assert!(token_in.asset_type() == TOKEN_TYPE_STABLE, EWrongTokenType);

    let escrow_id = object::id(escrow);
    
    let stable_supply = &mut escrow.outcome_stable_supplies[outcome_idx];
    token_in.burn(stable_supply, clock, ctx);

    let asset_supply = &mut escrow.outcome_asset_supplies[outcome_idx];
    let token = token::mint_with_escrow(
        ms,
        asset_supply,
        amount_out,
        ctx.sender(),
        escrow_id,
        clock,
        ctx,
    );
    token
}

/// Allows anyone to burn a conditional token associated with this escrow
/// if the market is finalized and the token's outcome is not the winning outcome.
public(package) fun burn_unused_tokens<AssetType, StableType>(
    escrow: &mut TokenEscrow<AssetType, StableType>,
    mut tokens_to_burn: vector<ConditionalToken>,
    clock: &Clock,
    ctx: &TxContext,
) {
    // 1. Get Market State and verify it's finalized (check once)
    let market_state = &escrow.market_state; // Read-only borrow is sufficient for checks
    market_state.assert_market_finalized();
    assert_supplies_initialized(escrow); // Check once

    // 2. Get required information from market state (fetch once)
    let escrow_market_id = market_state.market_id();
    let winning_outcome = market_state.get_winning_outcome();
    let outcome_count = market_state.outcome_count();

    // 3. Iterate through the vector and burn eligible tokens
    while (!tokens_to_burn.is_empty()) {
        // Borrow mutably for pop_back
        let token = tokens_to_burn.pop_back();

        // a. Get token details
        let token_market_id = token.market_id();
        let token_outcome = token.outcome();
        let token_type = token.asset_type();
        let outcome_idx = (token_outcome as u64); // Index for supply vectors

        assert!(token_market_id == escrow_market_id, EWrongMarket);
        assert!(token_outcome != (winning_outcome as u8), EWrongOutcome);
        assert!(outcome_idx < outcome_count, EOutcomeOutOfBounds);

        // c. Get the appropriate supply AND burn the token within the correct branch
        if (token_type == TOKEN_TYPE_ASSET) {
            let supply_ref = &mut escrow.outcome_asset_supplies[outcome_idx];
            // burn consumes the token object
            token.burn(supply_ref, clock, ctx);
        } else if (token_type == TOKEN_TYPE_STABLE) {
            let supply_ref = &mut escrow.outcome_stable_supplies[outcome_idx];
            // burn consumes the token object
            token.burn(supply_ref, clock, ctx);
        } else if (token_type == TOKEN_TYPE_LP) {
            let supply_ref = &mut escrow.outcome_lp_supplies[outcome_idx];
            // burn consumes the token object
            token.burn(supply_ref, clock, ctx);
        } else {
            abort EWrongTokenType
        }
    };
    // 4. Destroy the now empty vector
    tokens_to_burn.destroy_empty();
}

// === LP Invariant Checking ===

/// Assert LP supply invariants for all operations
/// Called after minting, burning, or converting LP tokens
public(package) fun assert_lp_supply_invariants<AssetType, StableType>(
    escrow: &TokenEscrow<AssetType, StableType>,
) {
    // If market is finalized, check conversion invariants
    if (escrow.market_state.is_finalized()) {
        // Total converted cannot exceed original winning supply
        assert!(
            escrow.winning_lp_converted <= escrow.winning_lp_supply_at_finalization,
            EOverflow
        );
        
        // Current winning LP supply + converted should equal original
        let winning_outcome = escrow.market_state.get_winning_outcome();
        let current_winning_supply = escrow.outcome_lp_supplies[winning_outcome].total_supply();
        assert!(
            current_winning_supply + escrow.winning_lp_converted == escrow.winning_lp_supply_at_finalization,
            EOverflow
        );
    };
    
    // Check that all LP supplies are non-negative (implicit through u64)
    // and that minting/burning operations maintain consistency
    let outcome_count = escrow.outcome_lp_supplies.length();
    let mut i = 0;
    while (i < outcome_count) {
        let supply = &escrow.outcome_lp_supplies[i];
        // Supply should always be >= 0 (guaranteed by u64 type)
        // Could add additional checks here if needed
        let _ = supply.total_supply();
        i = i + 1;
    };
}

// === View Functions ===

// Entry function that gets and emits the current escrow balances and supply information as an event
public entry fun get_escrow_balances_and_supply<AssetType, StableType>(
    escrow: &TokenEscrow<AssetType, StableType>,
    outcome: u64, // Added parameter
): (u64, u64, u64, u64) {
    // Changed return type to a tuple
    // Get current escrow balances
    let (escrowed_asset_balance, escrowed_stable_balance) = get_balances(escrow);
    let outcome_count = escrow.market_state.outcome_count();

    // Ensure the outcome index is valid
    assert!(outcome < outcome_count, EOutcomeOutOfBounds);
    // Ensure supplies were initialized
    assert_supplies_initialized(escrow);

    // Get the supply counts for the outcome directly
    let asset_supply_cap = &escrow.outcome_asset_supplies[outcome];
    let stable_supply_cap = &escrow.outcome_stable_supplies[outcome];

    let asset_total_supply = asset_supply_cap.total_supply();
    let stable_total_supply = stable_supply_cap.total_supply();

    // Return the tuple: (escrow_asset, escrow_stable, asset_supply, stable_supply)
    (escrowed_asset_balance, escrowed_stable_balance, asset_total_supply, stable_total_supply)
}

// === Package Functions ===

public(package) fun get_balances<AssetType, StableType>(
    escrow: &TokenEscrow<AssetType, StableType>,
): (u64, u64) {
    (escrow.escrowed_asset.value(), escrow.escrowed_stable.value())
}

public(package) fun get_market_state<AssetType, StableType>(
    escrow: &TokenEscrow<AssetType, StableType>,
): &MarketState {
    &escrow.market_state
}

public(package) fun get_market_state_id<AssetType, StableType>(
    escrow: &TokenEscrow<AssetType, StableType>,
): ID {
    object::id(&escrow.market_state)
}

public(package) fun get_market_state_mut<AssetType, StableType>(
    escrow: &mut TokenEscrow<AssetType, StableType>,
): &mut MarketState {
    &mut escrow.market_state
}

public(package) fun get_stable_supply<AssetType, StableType>(
    escrow: &mut TokenEscrow<AssetType, StableType>,
    outcome_idx: u64,
): &mut Supply {
    &mut escrow.outcome_stable_supplies[outcome_idx]
}

public(package) fun get_asset_supply<AssetType, StableType>(
    escrow: &mut TokenEscrow<AssetType, StableType>,
    outcome_idx: u64,
): &mut Supply {
    &mut escrow.outcome_asset_supplies[outcome_idx]
}

// === LP Token Finalization Functions ===

/// Convert winning outcome conditional LP tokens to spot LP tokens
/// 
/// SECURITY CRITICAL: This function maintains the invariant that:
/// 1. The proportion of LP ownership is preserved
/// 2. The total value in the system remains constant
/// 3. Each conditional LP token can only be converted once (enforced by burning)
/// 
/// INVARIANCE CHECK:
/// - Before: User owns X% of conditional LP supply for winning outcome
/// - After: User owns X% of the liquidity that was in that pool (now in spot)
/// 
/// The escrow tracks the final liquidity amounts that were extracted from the winning pool
/// during finalization. This ensures we can verify the conversion is correct.
/// 
/// IMPORTANT: This function:
/// - Can ONLY be called AFTER market finalization
/// - Can ONLY convert LP tokens from the WINNING outcome
/// - Is a simple 1:1 exchange: burns conditional LP tokens, mints spot LP tokens
/// - After finalization, NO conditional token operations are allowed - only this direct LP conversion
public fun convert_winning_lp_to_spot_lp<AssetType, StableType>(
    escrow: &mut TokenEscrow<AssetType, StableType>,
    spot_amm: &mut spot_amm::SpotAMM<AssetType, StableType>,
    conditional_lp_token: ConditionalToken,
    clock: &Clock,
    ctx: &mut TxContext,
): ID { // Returns the ID of the minted spot LP token
    // Step 1: Verify market is finalized
    assert!(escrow.market_state.is_finalized(), EMarketNotExpired);
    
    // Step 2: Verify this is the winning outcome
    let winning_outcome = escrow.market_state.get_winning_outcome();
    let token_outcome = conditional_lp_token.outcome();
    assert!((token_outcome as u64) == winning_outcome, EOutcomeOutOfBounds);
    
    // Step 3: Verify this is an LP token
    assert!(conditional_lp_token.asset_type() == TOKEN_TYPE_LP, ETokenTypeMismatch);
    
    let lp_amount = conditional_lp_token.value();
    assert!(lp_amount > 0, EZeroAmount);
    
    // Step 4: Get the LP supply for tracking
    let outcome_idx = (token_outcome as u64);
    let lp_supply = &escrow.outcome_lp_supplies[outcome_idx];
    
    // Step 5: This is a simple 1:1 exchange
    // Conditional LP tokens and spot LP tokens have the same amounts
    // since they represent the same liquidity shares
    
    // Step 7: INVARIANCE CHECK - Verify we haven't over-converted
    assert!(escrow.winning_lp_converted + lp_amount <= escrow.winning_lp_supply_at_finalization, EOverflow);
    
    // Step 8: INVARIANCE CHECK - Record state before burn
    let supply_before = lp_supply.total_supply();
    
    // Step 9: Burn the conditional LP token (this updates the supply)
    burn_single_conditional_token(escrow, conditional_lp_token, clock, ctx);
    
    // Step 10: INVARIANCE CHECK - Verify supply decreased correctly
    let supply_after = escrow.outcome_lp_supplies[outcome_idx].total_supply();
    assert!(supply_before - supply_after == lp_amount, EOverflow);
    
    // Step 11: Update conversion tracking
    escrow.winning_lp_converted = escrow.winning_lp_converted + lp_amount;
    
    // Step 12: INVARIANCE CHECK - Verify total conversions don't exceed original supply
    assert!(escrow.winning_lp_converted <= escrow.winning_lp_supply_at_finalization, EOverflow);
    
    // Step 13: Call spot AMM to mint spot LP tokens (1:1 exchange)
    // After finalization, conditional LP tokens cannot be redeemed for conditional tokens
    // They can ONLY be exchanged 1:1 for spot LP tokens
    let spot_lp_id = spot_amm::mint_lp_for_conversion(
        spot_amm,
        0, // not used - no conditional token redemption allowed
        0, // not used - no conditional token redemption allowed
        lp_amount, // 1:1 exchange - mint exact same amount of spot LP
        0, // not needed for 1:1 exchange
        escrow.market_state.market_id(),
        ctx
    );
    
    spot_lp_id
}

/// Track the final amounts that were in the winning pool before it was emptied
/// This is called during finalization when the pool is emptied
public(package) fun record_winning_pool_final_amounts<AssetType, StableType>(
    escrow: &mut TokenEscrow<AssetType, StableType>,
    asset_amount: u64,
    stable_amount: u64,
) {
    // Store these amounts for LP conversion calculations
    escrow.winning_pool_final_asset = asset_amount;
    escrow.winning_pool_final_stable = stable_amount;
    
    // Also record the winning LP supply at finalization for invariant checking
    let winning_outcome = escrow.market_state.get_winning_outcome();
    let winning_lp_supply = &escrow.outcome_lp_supplies[winning_outcome];
    escrow.winning_lp_supply_at_finalization = winning_lp_supply.total_supply();
    
    // Reset converted counter
    escrow.winning_lp_converted = 0;
}

/// Get the final amounts that were in the winning pool
fun get_winning_pool_final_amounts<AssetType, StableType>(
    escrow: &TokenEscrow<AssetType, StableType>
): (u64, u64) {
    // Return the recorded amounts
    (escrow.winning_pool_final_asset, escrow.winning_pool_final_stable)
}


/// Burn losing outcome LP tokens
/// 
/// After finalization, LP tokens from losing outcomes have no value.
/// This function allows holders to burn these worthless tokens.
public fun burn_losing_lp_tokens<AssetType, StableType>(
    escrow: &mut TokenEscrow<AssetType, StableType>,
    conditional_lp_token: ConditionalToken,
    clock: &Clock,
    ctx: &mut TxContext,
) {
    // Verify market is finalized
    assert!(escrow.market_state.is_finalized(), EMarketNotExpired);
    
    // Verify this is NOT the winning outcome
    let winning_outcome = escrow.market_state.get_winning_outcome();
    let token_outcome = conditional_lp_token.outcome();
    assert!((token_outcome as u64) != winning_outcome, EOutcomeOutOfBounds);
    
    // Verify this is an LP token
    assert!(conditional_lp_token.asset_type() == TOKEN_TYPE_LP, ETokenTypeMismatch);
    
    // Burn the worthless LP token
    burn_single_conditional_token(escrow, conditional_lp_token, clock, ctx);
}

/// Batch burn multiple losing LP tokens
public fun burn_losing_lp_tokens_batch<AssetType, StableType>(
    escrow: &mut TokenEscrow<AssetType, StableType>,
    mut conditional_lp_tokens: vector<ConditionalToken>,
    clock: &Clock,
    ctx: &mut TxContext,
) {
    // Verify market is finalized once
    assert!(escrow.market_state.is_finalized(), EMarketNotExpired);
    let winning_outcome = escrow.market_state.get_winning_outcome();
    
    while (!conditional_lp_tokens.is_empty()) {
        let token = conditional_lp_tokens.pop_back();
        
        // Verify this is a losing outcome LP token
        let token_outcome = token.outcome();
        assert!((token_outcome as u64) != winning_outcome, EOutcomeOutOfBounds);
        assert!(token.asset_type() == TOKEN_TYPE_LP, ETokenTypeMismatch);
        
        // Burn the token
        burn_single_conditional_token(escrow, token, clock, ctx);
    };
    
    conditional_lp_tokens.destroy_empty();
}

/// Verify differential minting invariants
/// 
/// CRITICAL INVARIANTS:
/// 1. For each outcome: AMM_reserves + conditional_token_supply = max_liquidity
/// 2. Total escrow balance >= sum of all obligations (tokens + reserves)
/// 3. No value creation: escrowed_amount = max(needed_amounts)
/// 
/// This function ensures that the differential minting mechanism cannot be exploited
/// to create or destroy value. The invariants guarantee that:
/// - All conditional tokens are fully backed by escrow funds
/// - The optimization (minting differentials) doesn't break accounting
/// - Users can always redeem complete sets for the original deposit
fun verify_differential_minting_invariants<AssetType, StableType>(
    escrow: &TokenEscrow<AssetType, StableType>,
    outcome_count: u64,
    asset_amounts: &vector<u64>,
    stable_amounts: &vector<u64>,
    max_asset: u64,
    max_stable: u64,
) {
    let mut i = 0;
    while (i < outcome_count) {
        let asset_amt = asset_amounts[i];
        let stable_amt = stable_amounts[i];
        
        // Get the supply of minted differential tokens for this outcome
        let asset_supply = escrow.outcome_asset_supplies[i].total_supply();
        let stable_supply = escrow.outcome_stable_supplies[i].total_supply();
        
        // INVARIANT 1: AMM reserves + differential tokens = max liquidity
        // This ensures complete conservation of value
        let expected_asset_differential = if (asset_amt < max_asset) {
            max_asset - asset_amt
        } else {
            0
        };
        
        let expected_stable_differential = if (stable_amt < max_stable) {
            max_stable - stable_amt  
        } else {
            0
        };
        
        // The supply should match the expected differential
        // (Note: This check assumes this is the first deposit; for subsequent deposits
        // the invariant would be: new_supply - old_supply = expected_differential)
        assert!(
            asset_supply >= expected_asset_differential,
            EInvariantViolation
        );
        assert!(
            stable_supply >= expected_stable_differential,
            EInvariantViolation
        );
        
        // INVARIANT 2: Total obligations don't exceed escrow
        // AMM will receive asset_amt and stable_amt
        // Tokens minted are asset_supply and stable_supply
        // Both are backed by the escrow balance
        
        i = i + 1;
    };
    
    // INVARIANT 3: Escrow received exactly the maximum needed
    // This was already checked with the assertions:
    // assert!(asset_amount == max_asset, EInsufficientAsset);
    // assert!(stable_amount == max_stable, EInsufficientStable);
    
    // Additional safety check: Escrow balance >= max needed
    assert!(escrow.escrowed_asset.value() >= max_asset, EInvariantViolation);
    assert!(escrow.escrowed_stable.value() >= max_stable, EInvariantViolation);
}

/// Entry point for converting winning LP to spot LP tokens
/// 
/// After a proposal is finalized, holders of conditional LP tokens from the winning
/// outcome can convert them to spot LP tokens. The underlying liquidity has already
/// been transferred to the spot pool during finalization.
/// 
/// This is a simple 1:1 exchange - burn conditional LP, mint spot LP.
public entry fun convert_winning_lp_to_spot_claim_entry<AssetType, StableType>(
    escrow: &mut TokenEscrow<AssetType, StableType>,
    spot_amm: &mut spot_amm::SpotAMM<AssetType, StableType>,
    conditional_lp_token: ConditionalToken,
    clock: &Clock,
    ctx: &mut TxContext,
) {
    let spot_lp_id = convert_winning_lp_to_spot_lp(
        escrow,
        spot_amm,
        conditional_lp_token,
        clock,
        ctx
    );
    
    // Emit event with the conversion details
    event::emit(WinningLPConverted {
        market_id: escrow.market_state.market_id(),
        spot_lp_id,
        sender: ctx.sender(),
        timestamp: clock.timestamp_ms(),
    });
}

/// Entry point for burning losing LP tokens
public entry fun burn_losing_lp_tokens_entry<AssetType, StableType>(
    escrow: &mut TokenEscrow<AssetType, StableType>,
    conditional_lp_token: ConditionalToken,
    clock: &Clock,
    ctx: &mut TxContext,
) {
    burn_losing_lp_tokens(escrow, conditional_lp_token, clock, ctx);
}

// === Events for LP Finalization ===

public struct WinningLPConverted has copy, drop {
    market_id: ID,
    spot_lp_id: ID,  // ID of the newly minted spot LP token
    sender: address,
    timestamp: u64,
}

// === Test Functions ===

#[test_only]
/// Creates a complete set of tokens and returns specific token for testing
public fun create_asset_token_for_testing<AssetType, StableType>(
    escrow: &mut TokenEscrow<AssetType, StableType>,
    outcome_idx: u64,
    amount: u64,
    clock: &Clock,
    ctx: &mut TxContext,
): ConditionalToken {
    // First create all tokens using an existing function
    let mut tokens = mint_complete_set_asset(
        escrow,
        balance::create_for_testing<AssetType>(amount).into_coin(ctx),
        clock,
        ctx,
    );

    // Find and return the token for the requested outcome
    let outcome_count = tokens.length();
    let mut result_token = tokens.pop_back();

    // Process all other tokens
    let mut i = 0;
    while (i < outcome_count - 1) {
        let token = tokens.pop_back();
        let this_outcome = token.outcome();

        if (this_outcome == (outcome_idx as u8)) {
            // Swap if we found the requested token
            transfer::public_transfer(result_token, ctx.sender());
            result_token = token;
        } else {
            // Otherwise transfer to sender
            transfer::public_transfer(token, ctx.sender());
        };
        i = i + 1;
    };

    tokens.destroy_empty();
    result_token
}

#[test_only]
/// Creates a complete set of stable tokens and returns specific token for testing
public fun create_stable_token_for_testing<AssetType, StableType>(
    escrow: &mut TokenEscrow<AssetType, StableType>,
    outcome_idx: u64,
    amount: u64,
    clock: &Clock,
    ctx: &mut TxContext,
): ConditionalToken {
    // Same approach as asset token but for stable tokens
    let coin = balance::create_for_testing<StableType>(amount).into_coin(ctx);
    let mut tokens = mint_complete_set_stable(escrow, coin, clock, ctx);

    // Extract the token we want and return it
    let token = tokens.remove(outcome_idx);

    // Transfer the other tokens to the sender
    let token_count = tokens.length();
    let mut i = 0;
    while (i < token_count) {
        let t = tokens.pop_back();
        transfer::public_transfer(t, ctx.sender());
        i = i + 1;
    };
    tokens.destroy_empty();

    token
}
/// ============================================================================
/// SPOT ORACLE INTERFACE - UNIFIED ACCESS POINT FOR ALL PRICE QUERIES
/// ============================================================================
/// 
/// PURPOSE: Single interface that abstracts away futarchy complexity
/// 
/// USED BY:
/// - Lending protocols that need continuous prices
/// - Governance actions that need long-term TWAPs
/// - Any external protocol integrating with the DAO token
/// 
/// KEY FEATURES:
/// - Automatically switches between spot and conditional oracles
/// - Hides proposal state from external consumers
/// - Provides both short (lending) and long (governance) windows
/// - Never returns empty/null - always has a price
/// 
/// WHY IT EXISTS:
/// External protocols shouldn't need to understand futarchy mechanics.
/// This interface makes our complex oracle system look like a standard
/// Uniswap oracle to the outside world. Lending protocols can integrate
/// without knowing about proposals, conditional AMMs, or quantum liquidity.
/// 
/// HOW IT WORKS:
/// - Normal times: Reads from spot's ring_buffer_oracle
/// - During proposals: Reads from winning conditional's ring_buffer_oracle
/// - Seamless transition with no gaps in price feed
/// 
/// ============================================================================

module futarchy::spot_oracle_interface;

use sui::clock::Clock;
use futarchy::ring_buffer_oracle::{Self, RingBufferOracle};
use futarchy::spot_amm::SpotAMM;
use futarchy::conditional_amm::LiquidityPool;
use std::vector;

// ============================================================================
// Constants
// ============================================================================

const LENDING_WINDOW_SECONDS: u64 = 1800; // 30 minutes standard
const GOVERNANCE_MAX_WINDOW: u64 = 777600; // 9 days maximum

// Errors
const ENoOracles: u64 = 1;
const ESpotLocked: u64 = 2;

// ============================================================================
// Public Functions for Lending Protocols
// ============================================================================

/// Get TWAP for lending protocols (continuous, 30-minute window)
/// This ALWAYS returns a value, even during proposals
/// During proposals: reads from highest conditional (but doesn't store)
/// After finalization: reads from spot (which has merged winning data)
public fun get_lending_twap<AssetType, StableType>(
    spot_pool: &SpotAMM<AssetType, StableType>,
    conditional_pools: &vector<LiquidityPool>,
    clock: &Clock,
): u128 {
    // Check if spot is locked for proposal
    if (spot_pool.is_locked_for_proposal()) {
        // READ from highest priced conditional (no storage in spot)
        // This is temporary - winner can change until finalization
        get_highest_conditional_twap(conditional_pools, LENDING_WINDOW_SECONDS, clock)
    } else {
        // Get TWAP from spot's ring buffer (includes merged history)
        ring_buffer_oracle::get_lending_twap(spot_pool.get_ring_buffer_oracle(), clock)
    }
}

/// Get custom window TWAP (for protocols that need different windows)
public fun get_twap_custom_window<AssetType, StableType>(
    spot_pool: &SpotAMM<AssetType, StableType>,
    conditional_pools: &vector<LiquidityPool>,
    seconds: u64,
    clock: &Clock,
): u128 {
    if (spot_pool.is_locked_for_proposal()) {
        get_highest_conditional_twap(conditional_pools, seconds, clock)
    } else {
        ring_buffer_oracle::get_twap(spot_pool.get_ring_buffer_oracle(), seconds, clock)
    }
}

/// Get instantaneous price (1 second TWAP)
public fun get_spot_price<AssetType, StableType>(
    spot_pool: &SpotAMM<AssetType, StableType>,
    conditional_pools: &vector<LiquidityPool>,
    clock: &Clock,
): u128 {
    if (spot_pool.is_locked_for_proposal()) {
        get_highest_conditional_price(conditional_pools)
    } else {
        ring_buffer_oracle::get_latest_price(spot_pool.get_ring_buffer_oracle())
    }
}

// ============================================================================
// Public Functions for Governance/Minting
// ============================================================================

/// Get longest possible TWAP for governance decisions and token minting
/// Uses base fair value from spot AMM (includes historical stitching)
public fun get_governance_twap<AssetType, StableType>(
    spot_pool: &SpotAMM<AssetType, StableType>,
    conditional_pools: &vector<LiquidityPool>,
    clock: &Clock,
): u128 {
    // For governance, we want the base fair value TWAP
    // This includes historical segments from past proposals
    if (spot_pool.is_locked_for_proposal()) {
        // During proposal, add conditional contribution
        let winning_conditional = get_highest_conditional_twap(
            conditional_pools,
            GOVERNANCE_MAX_WINDOW,
            clock
        );
        // This would integrate with spot's base fair value calculation
        spot_pool.get_twap(option::some(winning_conditional), clock)
    } else {
        // Use spot's longest TWAP
        ring_buffer_oracle::get_longest_twap(spot_pool.get_ring_buffer_oracle(), clock)
    }
}

// ============================================================================
// Helper Functions
// ============================================================================

/// Get highest TWAP from conditional pools
fun get_highest_conditional_twap(
    pools: &vector<LiquidityPool>,
    seconds: u64,
    clock: &Clock,
): u128 {
    assert!(!pools.is_empty(), ENoOracles);
    
    let mut highest_twap = 0u128;
    let mut i = 0;
    
    while (i < pools.length()) {
        let pool = pools.borrow(i);
        let twap = ring_buffer_oracle::get_twap(pool.get_ring_buffer_oracle(), seconds, clock);
        if (twap > highest_twap) {
            highest_twap = twap;
        };
        i = i + 1;
    };
    
    highest_twap
}

/// Get highest current price from conditional pools
fun get_highest_conditional_price(pools: &vector<LiquidityPool>): u128 {
    assert!(!pools.is_empty(), ENoOracles);
    
    let mut highest_price = 0u128;
    let mut i = 0;
    
    while (i < pools.length()) {
        let pool = pools.borrow(i);
        let price = ring_buffer_oracle::get_latest_price(pool.get_ring_buffer_oracle());
        if (price > highest_price) {
            highest_price = price;
        };
        i = i + 1;
    };
    
    highest_price
}

/// Check if TWAP is available for a given window
public fun is_twap_available<AssetType, StableType>(
    spot_pool: &SpotAMM<AssetType, StableType>,
    conditional_pools: &vector<LiquidityPool>,
    seconds: u64,
    clock: &Clock,
): bool {
    if (spot_pool.is_locked_for_proposal()) {
        // Check conditionals
        if (conditional_pools.is_empty()) {
            return false
        };
        let pool = conditional_pools.borrow(0);
        ring_buffer_oracle::has_sufficient_history(pool.get_ring_buffer_oracle(), seconds, clock)
    } else {
        // Check spot
        ring_buffer_oracle::has_sufficient_history(spot_pool.get_ring_buffer_oracle(), seconds, clock)
    }
}

// ============================================================================
// Integration Examples for Lending Protocols
// ============================================================================

/// Example: How a lending protocol would use this
/// 
/// ```move
/// // In lending protocol
/// let price = spot_oracle_interface::get_lending_twap(
///     &spot_pool,
///     &conditional_pools,
///     clock
/// );
/// 
/// // Use price for collateral valuation, liquidations, etc.
/// ```
/// 
/// The lending protocol doesn't need to know about:
/// - Futarchy proposals
/// - Conditional AMMs
/// - Quantum liquidity
/// - Lock states
/// 
/// It just gets a continuous price feed that never stops./// Simplified spot liquidity pool for use with Account<FutarchyConfig>
/// This module provides a basic AMM pool that doesn't depend on the DAO structure
module futarchy::account_spot_pool;

// === Imports ===
use std::option::{Self, Option};
use sui::{
    balance::{Self, Balance},
    coin::{Self, Coin},
    object::{Self, UID},
    transfer,
    event,
};
use futarchy::{
    math,
};

// === Errors ===
const EInsufficientLiquidity: u64 = 1;
const EZeroAmount: u64 = 2;
const ESlippageExceeded: u64 = 3;
const EInvalidFee: u64 = 4;
const EPoolNotInitialized: u64 = 5;

// === Constants ===
const MAX_FEE_BPS: u64 = 10000; // 100%
const MINIMUM_LIQUIDITY: u64 = 1000;

// === Structs ===

/// A simple spot liquidity pool for trading between two assets
public struct AccountSpotPool<phantom AssetType, phantom StableType> has key, store {
    id: UID,
    /// Asset token reserves
    asset_reserve: Balance<AssetType>,
    /// Stable token reserves
    stable_reserve: Balance<StableType>,
    /// Total LP token supply
    lp_supply: u64,
    /// Trading fee in basis points
    fee_bps: u64,
    /// Minimum liquidity locked (for first LP)
    minimum_liquidity: u64,
}

/// LP token for the pool
public struct LPToken<phantom AssetType, phantom StableType> has key, store {
    id: UID,
    /// Amount of LP tokens
    amount: u64,
}

/// Result of a swap operation
public struct SwapResult<phantom T> has drop {
    /// Output amount
    amount_out: u64,
    /// Fee amount
    fee_amount: u64,
}

// === Events ===

public struct PoolCreated<phantom AssetType, phantom StableType> has copy, drop {
    pool_id: ID,
    fee_bps: u64,
}

public struct LiquidityAdded<phantom AssetType, phantom StableType> has copy, drop {
    pool_id: ID,
    asset_amount: u64,
    stable_amount: u64,
    lp_minted: u64,
}

public struct LiquidityRemoved<phantom AssetType, phantom StableType> has copy, drop {
    pool_id: ID,
    asset_amount: u64,
    stable_amount: u64,
    lp_burned: u64,
}

public struct Swap<phantom AssetType, phantom StableType> has copy, drop {
    pool_id: ID,
    is_asset_to_stable: bool,
    amount_in: u64,
    amount_out: u64,
    fee: u64,
}

// === Public Functions ===

/// Create a new spot pool
public fun new<AssetType, StableType>(
    fee_bps: u64,
    ctx: &mut TxContext,
): AccountSpotPool<AssetType, StableType> {
    assert!(fee_bps <= MAX_FEE_BPS, EInvalidFee);
    
    let id = object::new(ctx);
    let pool_id = object::uid_to_inner(&id);
    
    event::emit(PoolCreated<AssetType, StableType> {
        pool_id,
        fee_bps,
    });
    
    AccountSpotPool {
        id,
        asset_reserve: balance::zero<AssetType>(),
        stable_reserve: balance::zero<StableType>(),
        lp_supply: 0,
        fee_bps,
        minimum_liquidity: MINIMUM_LIQUIDITY,
    }
}

/// Share the pool object
#[allow(lint(custom_state_change, share_owned))]
public fun share<AssetType, StableType>(pool: AccountSpotPool<AssetType, StableType>) {
    transfer::share_object(pool);
}

/// Add liquidity to the pool
public entry fun add_liquidity<AssetType, StableType>(
    pool: &mut AccountSpotPool<AssetType, StableType>,
    asset_coin: Coin<AssetType>,
    stable_coin: Coin<StableType>,
    min_lp_out: u64,
    ctx: &mut TxContext,
) {
    let asset_amount = asset_coin.value();
    let stable_amount = stable_coin.value();
    
    assert!(asset_amount > 0 && stable_amount > 0, EZeroAmount);
    
    let lp_minted = if (pool.lp_supply == 0) {
        // First liquidity provider
        // Calculate initial LP as sqrt(asset * stable)
        let product = (asset_amount as u128) * (stable_amount as u128);
        let initial_lp = math::sqrt_u128(product) as u64;
        assert!(initial_lp > pool.minimum_liquidity, EInsufficientLiquidity);
        
        // Lock minimum liquidity
        pool.lp_supply = pool.minimum_liquidity;
        initial_lp - pool.minimum_liquidity
    } else {
        // Calculate proportional LP tokens
        // Calculate LP tokens based on ratio of added liquidity to existing reserves
        let asset_ratio = math::mul_div_to_64(asset_amount, pool.lp_supply, pool.asset_reserve.value());
        let stable_ratio = math::mul_div_to_64(stable_amount, pool.lp_supply, pool.stable_reserve.value());
        
        // Use the minimum ratio to maintain pool ratio
        math::min(asset_ratio, stable_ratio)
    };
    
    assert!(lp_minted >= min_lp_out, ESlippageExceeded);
    
    // Update reserves
    pool.asset_reserve.join(asset_coin.into_balance());
    pool.stable_reserve.join(stable_coin.into_balance());
    pool.lp_supply = pool.lp_supply + lp_minted;
    
    // Mint LP tokens
    let lp_token = LPToken<AssetType, StableType> {
        id: object::new(ctx),
        amount: lp_minted,
    };
    
    transfer::public_transfer(lp_token, ctx.sender());
    
    event::emit(LiquidityAdded<AssetType, StableType> {
        pool_id: object::id(pool),
        asset_amount,
        stable_amount,
        lp_minted,
    });
}

/// Add liquidity and return LP token (for use in actions)
public fun add_liquidity_and_return<AssetType, StableType>(
    pool: &mut AccountSpotPool<AssetType, StableType>,
    asset_coin: Coin<AssetType>,
    stable_coin: Coin<StableType>,
    min_lp_out: u64,
    ctx: &mut TxContext,
): LPToken<AssetType, StableType> {
    let asset_amount = asset_coin.value();
    let stable_amount = stable_coin.value();
    
    assert!(asset_amount > 0 && stable_amount > 0, EZeroAmount);
    
    let lp_minted = if (pool.lp_supply == 0) {
        // First liquidity provider
        let product = (asset_amount as u128) * (stable_amount as u128);
        let initial_lp = math::sqrt_u128(product) as u64;
        assert!(initial_lp > pool.minimum_liquidity, EInsufficientLiquidity);
        
        // Lock minimum liquidity
        pool.lp_supply = pool.minimum_liquidity;
        initial_lp - pool.minimum_liquidity
    } else {
        // Calculate proportional LP tokens
        let asset_ratio = math::mul_div_to_64(asset_amount, pool.lp_supply, pool.asset_reserve.value());
        let stable_ratio = math::mul_div_to_64(stable_amount, pool.lp_supply, pool.stable_reserve.value());
        math::min(asset_ratio, stable_ratio)
    };
    
    assert!(lp_minted >= min_lp_out, ESlippageExceeded);
    
    // Update reserves
    pool.asset_reserve.join(asset_coin.into_balance());
    pool.stable_reserve.join(stable_coin.into_balance());
    pool.lp_supply = pool.lp_supply + lp_minted;
    
    // Create and return LP token
    let lp_token = LPToken<AssetType, StableType> {
        id: object::new(ctx),
        amount: lp_minted,
    };
    
    event::emit(LiquidityAdded<AssetType, StableType> {
        pool_id: object::id(pool),
        asset_amount,
        stable_amount,
        lp_minted,
    });
    
    lp_token
}

/// Remove liquidity and return coins (for use in actions)
public fun remove_liquidity_and_return<AssetType, StableType>(
    pool: &mut AccountSpotPool<AssetType, StableType>,
    lp_token: LPToken<AssetType, StableType>,
    min_asset_out: u64,
    min_stable_out: u64,
    ctx: &mut TxContext,
): (Coin<AssetType>, Coin<StableType>) {
    let LPToken { id, amount: lp_amount } = lp_token;
    id.delete();
    
    assert!(lp_amount > 0, EZeroAmount);
    assert!(pool.lp_supply > pool.minimum_liquidity, EInsufficientLiquidity);
    
    // Calculate proportional share
    let asset_amount = math::mul_div_to_64(lp_amount, pool.asset_reserve.value(), pool.lp_supply);
    let stable_amount = math::mul_div_to_64(lp_amount, pool.stable_reserve.value(), pool.lp_supply);
    
    assert!(asset_amount >= min_asset_out, ESlippageExceeded);
    assert!(stable_amount >= min_stable_out, ESlippageExceeded);
    
    // Update state
    pool.lp_supply = pool.lp_supply - lp_amount;
    
    // Create coins
    let asset_out = coin::from_balance(
        pool.asset_reserve.split(asset_amount),
        ctx
    );
    let stable_out = coin::from_balance(
        pool.stable_reserve.split(stable_amount),
        ctx
    );
    
    event::emit(LiquidityRemoved<AssetType, StableType> {
        pool_id: object::id(pool),
        asset_amount,
        stable_amount,
        lp_burned: lp_amount,
    });
    
    (asset_out, stable_out)
}

/// Remove liquidity from the pool
public entry fun remove_liquidity<AssetType, StableType>(
    pool: &mut AccountSpotPool<AssetType, StableType>,
    lp_token: LPToken<AssetType, StableType>,
    min_asset_out: u64,
    min_stable_out: u64,
    ctx: &mut TxContext,
) {
    let LPToken { id, amount: lp_amount } = lp_token;
    id.delete();
    
    assert!(lp_amount > 0, EZeroAmount);
    assert!(pool.lp_supply > pool.minimum_liquidity, EInsufficientLiquidity);
    
    // Calculate proportional share
    // Calculate proportional assets to return
    let asset_amount = math::mul_div_to_64(lp_amount, pool.asset_reserve.value(), pool.lp_supply);
    let stable_amount = math::mul_div_to_64(lp_amount, pool.stable_reserve.value(), pool.lp_supply);
    
    assert!(asset_amount >= min_asset_out, ESlippageExceeded);
    assert!(stable_amount >= min_stable_out, ESlippageExceeded);
    
    // Update state
    pool.lp_supply = pool.lp_supply - lp_amount;
    
    // Transfer tokens
    let asset_out = coin::from_balance(
        pool.asset_reserve.split(asset_amount),
        ctx
    );
    let stable_out = coin::from_balance(
        pool.stable_reserve.split(stable_amount),
        ctx
    );
    
    transfer::public_transfer(asset_out, ctx.sender());
    transfer::public_transfer(stable_out, ctx.sender());
    
    event::emit(LiquidityRemoved<AssetType, StableType> {
        pool_id: object::id(pool),
        asset_amount,
        stable_amount,
        lp_burned: lp_amount,
    });
}

/// Swap asset for stable
public entry fun swap_asset_to_stable<AssetType, StableType>(
    pool: &mut AccountSpotPool<AssetType, StableType>,
    asset_in: Coin<AssetType>,
    min_stable_out: u64,
    ctx: &mut TxContext,
) {
    let amount_in = asset_in.value();
    assert!(amount_in > 0, EZeroAmount);
    
    let (amount_out, fee) = calculate_output(
        amount_in,
        pool.asset_reserve.value(),
        pool.stable_reserve.value(),
        pool.fee_bps
    );
    
    assert!(amount_out >= min_stable_out, ESlippageExceeded);
    assert!(amount_out <= pool.stable_reserve.value(), EInsufficientLiquidity);
    
    // Update reserves
    pool.asset_reserve.join(asset_in.into_balance());
    
    // Send output
    let stable_out = coin::from_balance(
        pool.stable_reserve.split(amount_out),
        ctx
    );
    transfer::public_transfer(stable_out, ctx.sender());
    
    event::emit(Swap<AssetType, StableType> {
        pool_id: object::id(pool),
        is_asset_to_stable: true,
        amount_in,
        amount_out,
        fee,
    });
}

/// Swap stable for asset
public entry fun swap_stable_to_asset<AssetType, StableType>(
    pool: &mut AccountSpotPool<AssetType, StableType>,
    stable_in: Coin<StableType>,
    min_asset_out: u64,
    ctx: &mut TxContext,
) {
    let amount_in = stable_in.value();
    assert!(amount_in > 0, EZeroAmount);
    
    let (amount_out, fee) = calculate_output(
        amount_in,
        pool.stable_reserve.value(),
        pool.asset_reserve.value(),
        pool.fee_bps
    );
    
    assert!(amount_out >= min_asset_out, ESlippageExceeded);
    assert!(amount_out <= pool.asset_reserve.value(), EInsufficientLiquidity);
    
    // Update reserves
    pool.stable_reserve.join(stable_in.into_balance());
    
    // Send output
    let asset_out = coin::from_balance(
        pool.asset_reserve.split(amount_out),
        ctx
    );
    transfer::public_transfer(asset_out, ctx.sender());
    
    event::emit(Swap<AssetType, StableType> {
        pool_id: object::id(pool),
        is_asset_to_stable: false,
        amount_in,
        amount_out,
        fee,
    });
}

// === View Functions ===

/// Get pool reserves
public fun get_reserves<AssetType, StableType>(
    pool: &AccountSpotPool<AssetType, StableType>
): (u64, u64) {
    (pool.asset_reserve.value(), pool.stable_reserve.value())
}

/// Get spot price (asset per stable)
public fun get_spot_price<AssetType, StableType>(
    pool: &AccountSpotPool<AssetType, StableType>
): u128 {
    if (pool.asset_reserve.value() == 0) {
        0
    } else {
        // Price = stable_reserve / asset_reserve * 10^9 for precision
        ((pool.stable_reserve.value() as u128) * 1_000_000_000) / (pool.asset_reserve.value() as u128)
    }
}

/// Get pool ID
public fun pool_id<AssetType, StableType>(
    pool: &AccountSpotPool<AssetType, StableType>
): ID {
    object::id(pool)
}

/// Get LP supply
public fun lp_supply<AssetType, StableType>(
    pool: &AccountSpotPool<AssetType, StableType>
): u64 {
    pool.lp_supply
}

/// Get fee in basis points
public fun fee_bps<AssetType, StableType>(
    pool: &AccountSpotPool<AssetType, StableType>
): u64 {
    pool.fee_bps
}

// === Internal Functions ===

/// Calculate output amount for a swap
fun calculate_output(
    amount_in: u64,
    reserve_in: u64,
    reserve_out: u64,
    fee_bps: u64,
): (u64, u64) {
    // Calculate fee
    // Calculate fee amount
    let fee_amount = math::mul_div_to_64(amount_in, fee_bps, 10000);
    let amount_in_after_fee = amount_in - fee_amount;
    
    // Calculate output using constant product formula
    // amount_out = (amount_in_after_fee * reserve_out) / (reserve_in + amount_in_after_fee)
    // Use mul_div_to_64 to calculate output amount
    let amount_out = math::mul_div_to_64(amount_in_after_fee, reserve_out, reserve_in + amount_in_after_fee);
    
    (amount_out, fee_amount)
}

// === LP Token Functions ===

/// Get LP token amount
public fun lp_token_amount<AssetType, StableType>(
    token: &LPToken<AssetType, StableType>
): u64 {
    token.amount
}

/// Merge two LP tokens and return the result
public fun merge_lp_tokens<AssetType, StableType>(
    token1: LPToken<AssetType, StableType>,
    token2: LPToken<AssetType, StableType>,
    ctx: &mut TxContext,
): LPToken<AssetType, StableType> {
    let LPToken { id: id1, amount: amount1 } = token1;
    let LPToken { id: id2, amount: amount2 } = token2;
    
    id1.delete();
    id2.delete();
    
    LPToken<AssetType, StableType> {
        id: object::new(ctx),
        amount: amount1 + amount2,
    }
}

/// Merge two LP tokens (entry function)
public entry fun merge_lp_tokens_entry<AssetType, StableType>(
    token1: LPToken<AssetType, StableType>,
    token2: LPToken<AssetType, StableType>,
    ctx: &mut TxContext,
) {
    let merged = merge_lp_tokens(token1, token2, ctx);
    transfer::public_transfer(merged, ctx.sender());
}

/// Split an LP token and return both parts
public fun split_lp_token<AssetType, StableType>(
    token: LPToken<AssetType, StableType>,
    split_amount: u64,
    ctx: &mut TxContext,
): (LPToken<AssetType, StableType>, LPToken<AssetType, StableType>) {
    let LPToken { id, amount } = token;
    id.delete();
    
    assert!(split_amount > 0 && split_amount < amount, EZeroAmount);
    
    let token1 = LPToken<AssetType, StableType> {
        id: object::new(ctx),
        amount: split_amount,
    };
    
    let token2 = LPToken<AssetType, StableType> {
        id: object::new(ctx),
        amount: amount - split_amount,
    };
    
    (token1, token2)
}

/// Split an LP token (entry function)
public entry fun split_lp_token_entry<AssetType, StableType>(
    token: LPToken<AssetType, StableType>,
    split_amount: u64,
    ctx: &mut TxContext,
) {
    let (token1, token2) = split_lp_token(token, split_amount, ctx);
    transfer::public_transfer(token1, ctx.sender());
    transfer::public_transfer(token2, ctx.sender());
}

// === LP Token Recovery Functions ===
// These functions allow DAOs to recover LP tokens that were sent to the account address

/// Get information about an LP token
public fun lp_token_info<AssetType, StableType>(
    token: &LPToken<AssetType, StableType>
): (ID, u64) {
    (object::id(token), token.amount)
}module futarchy::conditional_token;

use futarchy::market_state;
use sui::clock::Clock;
use sui::event;

// === Introduction ===
// This module implements conditional tokens for prediction markets.
// Conditional tokens represent claims on specific outcomes in a futarchy proposal.
//
// === Live-Flow Model Integration ===
// Conditional tokens are central to the live-flow liquidity model:
// - Each outcome has two token types: asset-based and stable-based
// - Tokens can only be minted in "complete sets" (all outcomes together)
// - Complete sets can be redeemed back to spot tokens at any time
// - This ensures conservation of value: 1 spot token = 1 complete set
//
// The key innovation is that these tokens trade in outcome-specific AMMs,
// while LPs interact only with spot tokens, with automatic conversion handled
// by the protocol.

// === Constants ===
const TOKEN_TYPE_ASSET: u8 = 0;
const TOKEN_TYPE_STABLE: u8 = 1;
const TOKEN_TYPE_LP: u8 = 2;

// === Errors ===
const EInvalidAssetType: u64 = 0; // Asset type must be 0 (asset), 1 (stable), or 2 (LP)
const EWrongMarket: u64 = 1; // Token doesn't belong to expected market
const EWrongTokenType: u64 = 2; // Wrong token type for operation
const EWrongOutcome: u64 = 3; // Token outcome doesn't match expected
const EZeroAmount: u64 = 4; // Amount must be greater than zero
const EInsufficientBalance: u64 = 5; // Insufficient token balance
const EEmptyVector: u64 = 6; // Vector is empty when it shouldn't be
const ENoTokenFound: u64 = 7; // Expected token not found in Option
const ENonzeroBalance: u64 = 8; // Token must have zero balance to destroy

// === Structs ===
/// Supply tracking object for a specific conditional token type.
/// Total supply is tracked to aid with testing, it is not a source of truth. Token balances are the source of truth.
public struct Supply has key, store {
    id: UID,
    market_id: ID,
    asset_type: u8,
    outcome: u8,
    total_supply: u64,
}

/// The conditional token representing a position in a prediction market
public struct ConditionalToken has key, store {
    id: UID,
    market_id: ID,
    asset_type: u8, // 0 for asset, 1 for stable, 2 for LP
    outcome: u8, // outcome index
    balance: u64,
    escrow_id: Option<ID>, // Optional escrow ID for auto-reclaim
}

// === Events ===
/// Event emitted when tokens are minted
public struct TokenMinted has copy, drop {
    id: ID,
    market_id: ID,
    asset_type: u8,
    outcome: u8,
    amount: u64,
    recipient: address,
    timestamp: u64,
}

/// Event emitted when tokens are burned
public struct TokenBurned has copy, drop {
    id: ID,
    market_id: ID,
    asset_type: u8,
    outcome: u8,
    amount: u64,
    sender: address,
    timestamp: u64,
}

/// Event emitted when a token is split
public struct TokenSplit has copy, drop {
    original_token_id: ID,
    new_token_id: ID,
    market_id: ID,
    asset_type: u8,
    outcome: u8,
    original_amount: u64,
    split_amount: u64,
    owner: address,
    timestamp: u64,
}

/// Event emitted when multiple tokens are merged
public struct TokenMergeMany has copy, drop {
    base_token_id: ID,
    merged_token_ids: vector<ID>,
    market_id: ID,
    asset_type: u8,
    outcome: u8,
    base_amount: u64,
    merged_amount: u64,
    owner: address,
    timestamp: u64,
}

// === Package Functions ===
/// Create a new supply tracker for a specific conditional token type
public(package) fun new_supply(
    state: &market_state::MarketState,
    asset_type: u8,
    outcome: u8,
    ctx: &mut TxContext,
): Supply {
    // Verify authority and market state
    state.validate_outcome((outcome as u64));
    assert!(asset_type <= 2, EInvalidAssetType);

    Supply {
        id: object::new(ctx),
        market_id: state.market_id(),
        asset_type,
        outcome,
        total_supply: 0,
    }
}

/// Update the total supply by increasing or decreasing the amount
public(package) fun update_supply(supply: &mut Supply, amount: u64, increase: bool) {
    assert!(amount > 0, EZeroAmount);
    if (increase) {
        supply.total_supply = supply.total_supply + amount;
    } else {
        assert!(supply.total_supply >= amount, EInsufficientBalance);
        supply.total_supply = supply.total_supply - amount;
    };
}

/// Destroys a ConditionalToken. The token's balance must be zero.
public(package) fun destroy(token: ConditionalToken) {
    let ConditionalToken { id, market_id: _, asset_type: _, outcome: _, balance, escrow_id: _ } = token;
    assert!(balance == 0, ENonzeroBalance);
    id.delete();
}

/// Split a conditional token into two parts, transferring the split amount to a recipient
public(package) fun split(
    token: &mut ConditionalToken,
    amount: u64,
    recipient: address,
    clock: &Clock, // new parameter
    ctx: &mut TxContext,
) {
    assert!(amount > 0, EZeroAmount);
    assert!(token.balance > amount, EInsufficientBalance);

    token.balance = token.balance - amount;

    let new_token = ConditionalToken {
        id: object::new(ctx),
        market_id: token.market_id,
        asset_type: token.asset_type,
        outcome: token.outcome,
        balance: amount,
        escrow_id: token.escrow_id,
    };

    // Emit split event
    event::emit(TokenSplit {
        original_token_id: token.id.to_inner(),
        new_token_id: object::id(&new_token),
        market_id: token.market_id,
        asset_type: token.asset_type,
        outcome: token.outcome,
        original_amount: token.balance,
        split_amount: amount,
        owner: recipient,
        timestamp: clock.timestamp_ms(),
    });

    transfer::transfer(new_token, recipient);
}

/// Split a conditional token and return the new token instead of transferring it
/// This is useful when the caller needs to process the split token further
public(package) fun split_and_return(
    token: &mut ConditionalToken,
    amount: u64,
    clock: &Clock,
    ctx: &mut TxContext,
): ConditionalToken {
    assert!(amount > 0, EZeroAmount);
    assert!(token.balance > amount, EInsufficientBalance);

    token.balance = token.balance - amount;

    let new_token = ConditionalToken {
        id: object::new(ctx),
        market_id: token.market_id,
        asset_type: token.asset_type,
        outcome: token.outcome,
        balance: amount,
        escrow_id: token.escrow_id,
    };

    // Emit split event
    event::emit(TokenSplit {
        original_token_id: token.id.to_inner(),
        new_token_id: object::id(&new_token),
        market_id: token.market_id,
        asset_type: token.asset_type,
        outcome: token.outcome,
        original_amount: token.balance,
        split_amount: amount,
        owner: ctx.sender(),
        timestamp: clock.timestamp_ms(),
    });

    new_token
}

/// Split tokens for the sender
entry fun split_entry(
    token: &mut ConditionalToken,
    amount: u64,
    clock: &Clock,
    ctx: &mut TxContext,
) {
    let sender = ctx.sender();
    split(token, amount, sender, clock, ctx);
}

/// Merge multiple conditional tokens of the same type into the base token
public(package) fun merge_many(
    base_token: &mut ConditionalToken,
    mut tokens: vector<ConditionalToken>,
    clock: &Clock,
    ctx: &TxContext,
) {
    assert!(!tokens.is_empty(), EEmptyVector);

    let mut total_merged_amount = 0;
    let mut token_ids = vector[];
    // Iterate by popping from the end - O(1) operation per element
    while (!tokens.is_empty()) {
        // Remove the last token from the vector
        let token = tokens.pop_back();
        // Verify token matches
        assert!(token.market_id == base_token.market_id, EWrongMarket);
        assert!(token.asset_type == base_token.asset_type, EWrongTokenType);
        assert!(token.outcome == base_token.outcome, EWrongOutcome);

        let merged_token_object_id = object::id(&token);

        let ConditionalToken {
            id,
            market_id: _,
            asset_type: _,
            outcome: _,
            balance,
            escrow_id: _,
        } = token;

        // Add to totals and the ID list
        token_ids.push_back(merged_token_object_id);
        total_merged_amount = total_merged_amount + balance;

        base_token.balance = base_token.balance + balance;
        id.delete();
    };

    // Emit merge event with all token IDs
    event::emit(TokenMergeMany {
        base_token_id: base_token.id.to_inner(),
        merged_token_ids: token_ids,
        market_id: base_token.market_id,
        asset_type: base_token.asset_type,
        outcome: base_token.outcome,
        base_amount: base_token.balance - total_merged_amount,
        merged_amount: total_merged_amount,
        owner: ctx.sender(),
        timestamp: clock.timestamp_ms(),
    });

    tokens.destroy_empty();
}

/// Merge multiple tokens for the sender
entry fun merge_many_entry(
    base_token: &mut ConditionalToken,
    tokens: vector<ConditionalToken>,
    clock: &Clock,
    ctx: &TxContext,
) {
    merge_many(base_token, tokens, clock, ctx);
}

/// Burn a conditional token and update the supply tracker
public(package) fun burn(
    token: ConditionalToken,
    supply: &mut Supply,
    clock: &Clock,
    ctx: &TxContext,
) {
    // Verify token matches supply
    assert!(token.market_id == supply.market_id, EWrongMarket);
    assert!(token.asset_type == supply.asset_type, EWrongTokenType);
    assert!(token.outcome == supply.outcome, EWrongOutcome);

    let ConditionalToken {
        id,
        market_id,
        asset_type,
        outcome,
        balance,
        escrow_id: _,
    } = token;

    // Update supply
    update_supply(supply, balance, false);

    // Emit event
    event::emit(TokenBurned {
        id: id.to_inner(),
        market_id,
        asset_type,
        outcome,
        amount: balance,
        sender: ctx.sender(),
        timestamp: clock.timestamp_ms(),
    });

    // Clean up
    id.delete();
}

/// Mint new conditional tokens and update the supply tracker
public(package) fun mint(
    state: &market_state::MarketState,
    supply: &mut Supply,
    amount: u64,
    recipient: address,
    clock: &Clock,
    ctx: &mut TxContext,
): ConditionalToken {
    // Verify market state and trading period
    market_state::assert_in_trading_or_pre_trading(state);
    assert!(amount > 0, EZeroAmount);

    assert!(state.market_id() == supply.market_id, EWrongMarket);
    // Update supply
    update_supply(supply, amount, true);

    // Create new token
    let token = ConditionalToken {
        id: object::new(ctx),
        market_id: supply.market_id,
        asset_type: supply.asset_type,
        outcome: supply.outcome,
        balance: amount,
        escrow_id: option::none(),
    };

    // Emit event
    event::emit(TokenMinted {
        id: object::id(&token),
        market_id: supply.market_id,
        asset_type: supply.asset_type,
        outcome: supply.outcome,
        amount,
        recipient,
        timestamp: clock.timestamp_ms(),
    });

    // Return token instead of transferring
    token
}

/// Extract a conditional token from an Option, asserting it exists
public(package) fun extract(option: &mut Option<ConditionalToken>): ConditionalToken {
    assert!(option.is_some(), ENoTokenFound);
    let token = option.extract();
    token
}


// === View Functions ===

public fun market_id(token: &ConditionalToken): ID {
    token.market_id
}

public fun asset_type(token: &ConditionalToken): u8 {
    token.asset_type
}

public fun outcome(token: &ConditionalToken): u8 {
    token.outcome
}

public fun value(token: &ConditionalToken): u64 {
    token.balance
}

public fun escrow_id(token: &ConditionalToken): Option<ID> {
    token.escrow_id
}

public fun total_supply(supply: &Supply): u64 {
    supply.total_supply
}

// === Package Functions for Escrow Management ===

/// Set the escrow ID for a conditional token (can only be set once)
public(package) fun set_escrow_id(token: &mut ConditionalToken, escrow_id: ID) {
    assert!(token.escrow_id.is_none(), 0); // Can only set once
    token.escrow_id = option::some(escrow_id);
}

/// Create a token with a specific escrow ID
public(package) fun mint_with_escrow(
    state: &market_state::MarketState,
    supply: &mut Supply,
    amount: u64,
    recipient: address,
    escrow_id: ID,
    clock: &Clock,
    ctx: &mut TxContext,
): ConditionalToken {
    // Verify market state and trading period
    market_state::assert_in_trading_or_pre_trading(state);
    assert!(amount > 0, EZeroAmount);

    assert!(state.market_id() == supply.market_id, EWrongMarket);
    // Update supply
    update_supply(supply, amount, true);

    // Create new token with escrow ID
    let token = ConditionalToken {
        id: object::new(ctx),
        market_id: supply.market_id,
        asset_type: supply.asset_type,
        outcome: supply.outcome,
        balance: amount,
        escrow_id: option::some(escrow_id),
    };

    // Emit event
    event::emit(TokenMinted {
        id: object::id(&token),
        market_id: supply.market_id,
        asset_type: supply.asset_type,
        outcome: supply.outcome,
        amount,
        recipient,
        timestamp: clock.timestamp_ms(),
    });

    // Return token instead of transferring
    token
}

// === Test Functions ===

#[test_only]
/// Creates a ConditionalToken with specified values for testing purposes.
/// This function bypasses normal validation checks and is only available in test code.
public fun mint_for_testing(
    market_id: ID,
    asset_type: u8,
    outcome: u8,
    balance: u64,
    ctx: &mut TxContext,
): ConditionalToken {
    ConditionalToken {
        id: object::new(ctx),
        market_id,
        asset_type,
        outcome,
        balance,
        escrow_id: option::none(),
    }
}
module futarchy::spot_conditional_quoter;

use std::option::Option;
use futarchy::conditional_amm::{Self, LiquidityPool};
use futarchy::proposal::{Self, Proposal};
use futarchy::coin_escrow::TokenEscrow;
use futarchy::market_state::MarketState;
use futarchy::spot_amm::{Self, SpotAMM};
use sui::clock::Clock;

// === Introduction ===
// This module provides quote functionality for spot token swaps through conditional AMMs.
// It simulates the routing process to provide accurate quotes without executing trades.
//
// Key features:
// - Provides accurate quotes for spot-to-spot swaps through conditional AMMs
// - Accounts for complete set minting/redemption costs
// - Simulates the full routing path without state changes
// - Returns both output amounts and price impact information

// === Errors ===
const EInvalidOutcome: u64 = 0;
const EZeroAmount: u64 = 1;
const EMarketNotActive: u64 = 2;
const EInsufficientLiquidity: u64 = 3;

// === Structs ===

/// Quote result for a spot swap
public struct SpotQuote has copy, drop {
    /// The expected output amount
    amount_out: u64,
    /// The effective price (amount_out / amount_in scaled by 1e9)
    effective_price: u64,
    /// The price impact percentage (scaled by 1e4, so 100 = 1%)
    price_impact_bps: u64,
    /// The outcome being traded through
    outcome: u64,
    /// Whether this is asset->stable (true) or stable->asset (false)
    is_asset_to_stable: bool,
}

/// Detailed quote with breakdown
public struct DetailedSpotQuote has copy, drop {
    /// Basic quote information
    quote: SpotQuote,
    /// Amount of conditional tokens created
    conditional_tokens_created: u64,
    /// Amount of conditional tokens that would be returned as excess
    excess_conditional_tokens: u64,
    /// The spot price before the trade
    spot_price_before: u64,
    /// The spot price after the trade
    spot_price_after: u64,
}

// === Public View Functions ===

/// Get a quote for swapping spot asset to spot stable through a specific outcome
public fun quote_spot_asset_to_stable<AssetType, StableType>(
    proposal: &Proposal<AssetType, StableType>,
    escrow: &TokenEscrow<AssetType, StableType>,
    outcome_idx: u64,
    amount_in: u64,
    clock: &Clock,
): SpotQuote {
    // Validate inputs
    assert!(amount_in > 0, EZeroAmount);
    assert!(outcome_idx < proposal.outcome_count(), EInvalidOutcome);
    
    // Verify market is active
    let market_state = escrow.get_market_state();
    assert!(market_state.is_trading_active(), EMarketNotActive);
    
    // Step 1: Complete set minting creates amount_in of each conditional token
    let conditional_asset_amount = amount_in;
    
    // Step 2: Get the AMM for this outcome
    let amm = proposal.get_pool_by_outcome((outcome_idx as u8));
    
    // Step 3: Calculate swap output for asset -> stable
    let stable_out = conditional_amm::quote_swap_asset_to_stable(
        amm,
        conditional_asset_amount
    );
    
    // Step 4: Complete set redemption would give us stable_out spot tokens
    // (other outcomes would have excess conditional tokens returned)
    
    // Calculate effective price (scaled by 1e9 for precision)
    let effective_price = if (amount_in > 0) {
        (stable_out as u128) * 1_000_000_000 / (amount_in as u128)
    } else {
        0
    };
    
    // Calculate price impact
    let (asset_reserve, stable_reserve) = conditional_amm::get_reserves(amm);
    let spot_price_before = if (asset_reserve > 0) {
        (stable_reserve as u128) * 1_000_000_000 / (asset_reserve as u128)
    } else {
        0
    };
    
    let price_impact_bps = calculate_price_impact(
        spot_price_before as u64,
        effective_price as u64
    );
    
    SpotQuote {
        amount_out: stable_out,
        effective_price: effective_price as u64,
        price_impact_bps,
        outcome: outcome_idx,
        is_asset_to_stable: true,
    }
}

/// Get a quote for swapping spot stable to spot asset through a specific outcome
public fun quote_spot_stable_to_asset<AssetType, StableType>(
    proposal: &Proposal<AssetType, StableType>,
    escrow: &TokenEscrow<AssetType, StableType>,
    outcome_idx: u64,
    amount_in: u64,
    clock: &Clock,
): SpotQuote {
    // Validate inputs
    assert!(amount_in > 0, EZeroAmount);
    assert!(outcome_idx < proposal.outcome_count(), EInvalidOutcome);
    
    // Verify market is active
    let market_state = escrow.get_market_state();
    assert!(market_state.is_trading_active(), EMarketNotActive);
    
    // Step 1: Complete set minting creates amount_in of each conditional token
    let conditional_stable_amount = amount_in;
    
    // Step 2: Get the AMM for this outcome
    let amm = proposal.get_pool_by_outcome((outcome_idx as u8));
    
    // Step 3: Calculate swap output for stable -> asset
    let asset_out = conditional_amm::quote_swap_stable_to_asset(
        amm,
        conditional_stable_amount
    );
    
    // Step 4: Complete set redemption would give us asset_out spot tokens
    
    // Calculate effective price (scaled by 1e9 for precision)
    let effective_price = if (amount_in > 0) {
        (asset_out as u128) * 1_000_000_000 / (amount_in as u128)
    } else {
        0
    };
    
    // Calculate price impact
    let (asset_reserve, stable_reserve) = conditional_amm::get_reserves(amm);
    let spot_price_before = if (stable_reserve > 0) {
        (asset_reserve as u128) * 1_000_000_000 / (stable_reserve as u128)
    } else {
        0
    };
    
    let price_impact_bps = calculate_price_impact(
        spot_price_before as u64,
        effective_price as u64
    );
    
    SpotQuote {
        amount_out: asset_out,
        effective_price: effective_price as u64,
        price_impact_bps,
        outcome: outcome_idx,
        is_asset_to_stable: false,
    }
}

/// Get a detailed quote with additional information
public fun quote_spot_asset_to_stable_detailed<AssetType, StableType>(
    proposal: &Proposal<AssetType, StableType>,
    escrow: &TokenEscrow<AssetType, StableType>,
    outcome_idx: u64,
    amount_in: u64,
    clock: &Clock,
): DetailedSpotQuote {
    // Get basic quote
    let quote = quote_spot_asset_to_stable(
        proposal,
        escrow,
        outcome_idx,
        amount_in,
        clock
    );
    
    // Get AMM for detailed calculations
    let amm = proposal.get_pool_by_outcome((outcome_idx as u8));
    let (asset_reserve_before, stable_reserve_before) = conditional_amm::get_reserves(amm);
    
    // Calculate reserves after trade
    let asset_reserve_after = asset_reserve_before + amount_in;
    let stable_reserve_after = stable_reserve_before - quote.amount_out;
    
    // Calculate spot prices
    let spot_price_before = if (asset_reserve_before > 0) {
        (stable_reserve_before as u128) * 1_000_000_000 / (asset_reserve_before as u128)
    } else {
        0
    };
    
    let spot_price_after = if (asset_reserve_after > 0) {
        (stable_reserve_after as u128) * 1_000_000_000 / (asset_reserve_after as u128)
    } else {
        0
    };
    
    // Calculate excess tokens (all non-traded outcomes)
    let outcome_count = proposal.outcome_count();
    let excess_conditional_tokens = (outcome_count - 1) * amount_in;
    
    DetailedSpotQuote {
        quote,
        conditional_tokens_created: outcome_count * amount_in,
        excess_conditional_tokens,
        spot_price_before: spot_price_before as u64,
        spot_price_after: spot_price_after as u64,
    }
}

/// Get a detailed quote for stable to asset swap
public fun quote_spot_stable_to_asset_detailed<AssetType, StableType>(
    proposal: &Proposal<AssetType, StableType>,
    escrow: &TokenEscrow<AssetType, StableType>,
    outcome_idx: u64,
    amount_in: u64,
    clock: &Clock,
): DetailedSpotQuote {
    // Get basic quote
    let quote = quote_spot_stable_to_asset(
        proposal,
        escrow,
        outcome_idx,
        amount_in,
        clock
    );
    
    // Get AMM for detailed calculations
    let amm = proposal.get_pool_by_outcome((outcome_idx as u8));
    let (asset_reserve_before, stable_reserve_before) = conditional_amm::get_reserves(amm);
    
    // Calculate reserves after trade
    let stable_reserve_after = stable_reserve_before + amount_in;
    let asset_reserve_after = asset_reserve_before - quote.amount_out;
    
    // Calculate spot prices
    let spot_price_before = if (stable_reserve_before > 0) {
        (asset_reserve_before as u128) * 1_000_000_000 / (stable_reserve_before as u128)
    } else {
        0
    };
    
    let spot_price_after = if (stable_reserve_after > 0) {
        (asset_reserve_after as u128) * 1_000_000_000 / (stable_reserve_after as u128)
    } else {
        0
    };
    
    // Calculate excess tokens
    let outcome_count = proposal.outcome_count();
    let excess_conditional_tokens = (outcome_count - 1) * amount_in;
    
    DetailedSpotQuote {
        quote,
        conditional_tokens_created: outcome_count * amount_in,
        excess_conditional_tokens,
        spot_price_before: spot_price_before as u64,
        spot_price_after: spot_price_after as u64,
    }
}

/// Find the best outcome to route a spot asset to stable swap through
public fun find_best_asset_to_stable_route<AssetType, StableType>(
    proposal: &Proposal<AssetType, StableType>,
    escrow: &TokenEscrow<AssetType, StableType>,
    amount_in: u64,
    clock: &Clock,
): (u64, SpotQuote) {
    assert!(amount_in > 0, EZeroAmount);
    
    let outcome_count = proposal.outcome_count();
    assert!(outcome_count > 0, EInvalidOutcome);
    
    let mut best_outcome = 0;
    let mut best_quote = quote_spot_asset_to_stable(
        proposal,
        escrow,
        0,
        amount_in,
        clock
    );
    
    let mut i = 1;
    while (i < outcome_count) {
        let quote = quote_spot_asset_to_stable(
            proposal,
            escrow,
            i,
            amount_in,
            clock
        );
        
        if (quote.amount_out > best_quote.amount_out) {
            best_outcome = i;
            best_quote = quote;
        };
        
        i = i + 1;
    };
    
    (best_outcome, best_quote)
}

/// Find the best outcome to route a spot stable to asset swap through
public fun find_best_stable_to_asset_route<AssetType, StableType>(
    proposal: &Proposal<AssetType, StableType>,
    escrow: &TokenEscrow<AssetType, StableType>,
    amount_in: u64,
    clock: &Clock,
): (u64, SpotQuote) {
    assert!(amount_in > 0, EZeroAmount);
    
    let outcome_count = proposal.outcome_count();
    assert!(outcome_count > 0, EInvalidOutcome);
    
    let mut best_outcome = 0;
    let mut best_quote = quote_spot_stable_to_asset(
        proposal,
        escrow,
        0,
        amount_in,
        clock
    );
    
    let mut i = 1;
    while (i < outcome_count) {
        let quote = quote_spot_stable_to_asset(
            proposal,
            escrow,
            i,
            amount_in,
            clock
        );
        
        if (quote.amount_out > best_quote.amount_out) {
            best_outcome = i;
            best_quote = quote;
        };
        
        i = i + 1;
    };
    
    (best_outcome, best_quote)
}

// === Helper Functions ===

/// Calculate price impact in basis points
fun calculate_price_impact(price_before: u64, effective_price: u64): u64 {
    if (price_before == 0) {
        return 0
    };
    
    let diff = if (effective_price > price_before) {
        effective_price - price_before
    } else {
        price_before - effective_price
    };
    
    // Calculate impact as basis points (1 bp = 0.01%)
    let impact = (diff as u128) * 10000 / (price_before as u128);
    impact as u64
}

// === Accessor Functions ===

public fun get_amount_out(quote: &SpotQuote): u64 {
    quote.amount_out
}

public fun get_effective_price(quote: &SpotQuote): u64 {
    quote.effective_price
}

public fun get_price_impact_bps(quote: &SpotQuote): u64 {
    quote.price_impact_bps
}

public fun get_outcome(quote: &SpotQuote): u64 {
    quote.outcome
}

public fun is_asset_to_stable(quote: &SpotQuote): bool {
    quote.is_asset_to_stable
}

public fun get_conditional_tokens_created(detailed: &DetailedSpotQuote): u64 {
    detailed.conditional_tokens_created
}

public fun get_excess_conditional_tokens(detailed: &DetailedSpotQuote): u64 {
    detailed.excess_conditional_tokens
}

public fun get_spot_price_before(detailed: &DetailedSpotQuote): u64 {
    detailed.spot_price_before
}

public fun get_spot_price_after(detailed: &DetailedSpotQuote): u64 {
    detailed.spot_price_after
}

// === Oracle Price Functions ===

/// Get combined oracle price from spot AMM
/// Uses get_twap_mut to ensure TWAP is up-to-date
public fun get_combined_oracle_price<AssetType, StableType>(
    spot_pool: &mut SpotAMM<AssetType, StableType>,
    clock: &Clock,
): u128 {
    // Return the spot AMM TWAP
    spot_amm::get_twap_mut(spot_pool, clock)
}

/// Check if a price meets a threshold condition
public fun check_price_threshold(
    price: u128,
    threshold: u128,
    is_above_threshold: bool,
): bool {
    if (is_above_threshold) {
        price >= threshold
    } else {
        price <= threshold
    }
}

/// Check if proposals can be created based on TWAP readiness
public fun can_create_proposal<AssetType, StableType>(
    spot_pool: &SpotAMM<AssetType, StableType>,
    clock: &Clock,
): bool {
    spot_amm::is_twap_ready(spot_pool, clock)
}

/// Get time until proposals are allowed (returns 0 if ready)
public fun time_until_proposals_allowed<AssetType, StableType>(
    spot_pool: &SpotAMM<AssetType, StableType>,
    clock: &Clock,
): u64 {
    // Check if TWAP is ready
    if (spot_amm::is_twap_ready(spot_pool, clock)) {
        return 0
    };
    
    // Calculate remaining time (simplified - assumes 3 days needed)
    259_200_000 // Return 3 days in ms as placeholder
}

/// Get initialization price for conditional AMMs
public fun get_initialization_price<AssetType, StableType>(
    spot_pool: &SpotAMM<AssetType, StableType>,
    clock: &Clock,
): u128 {
    spot_amm::get_twap_for_conditional_amm(spot_pool, clock)
}module futarchy::liquidity_interact;

use futarchy::conditional_amm;
use futarchy::coin_escrow::{Self, TokenEscrow};
use futarchy::conditional_token::ConditionalToken;
use futarchy::fee::FeeManager;
use futarchy::proposal::Proposal;
use sui::balance::Balance;
use sui::clock::Clock;
use sui::coin::{Self, Coin};
use sui::event;

// === Introduction ===
// Methods to interact with AMM liquidity and escrow balances

// === Errors ===
const EInvalidOutcome: u64 = 0;
const EInvalidLiquidityTransfer: u64 = 1;
const EWrongOutcome: u64 = 2;
const EInvalidState: u64 = 3;
const EMarketIdMismatch: u64 = 4;
const EAssetReservesMismatch: u64 = 5;
const EStableReservesMismatch: u64 = 6;

// === Events ===
public struct ProtocolFeesCollected has copy, drop {
    proposal_id: ID,
    winning_outcome: u64,
    fee_amount: u64,
    timestamp_ms: u64,
}

// === Helper Functions ===
/// Efficiently transfers all tokens in a vector to the recipient
fun transfer_tokens_to_recipient(mut tokens: vector<ConditionalToken>, recipient: address) {
    while (!tokens.is_empty()) {
        transfer::public_transfer(tokens.pop_back(), recipient);
    };
    tokens.destroy_empty();
}

/// Empties the winning AMM pool and transfers the underlying liquidity to the original provider.
/// Called internally by `advance_stage` when a user-funded proposal finalizes.
public(package) fun empty_amm_and_return_to_provider<AssetType, StableType>(
    proposal: &mut Proposal<AssetType, StableType>,
    escrow: &mut TokenEscrow<AssetType, StableType>,
    ctx: &mut TxContext,
) {
    assert!(proposal.is_finalized(), EInvalidState);
    assert!(!proposal.uses_dao_liquidity(), EInvalidState);

    // Validate that proposal and escrow belong to the same market
    let market_id = proposal.market_state_id();
    let escrow_market_id = escrow.get_market_state_id();
    assert!(market_id == escrow_market_id, EMarketIdMismatch);
    let market_state = escrow.get_market_state();
    let winning_outcome = proposal.get_winning_outcome();
    market_state.assert_market_finalized();

    let pool = proposal.get_pool_mut_by_outcome((winning_outcome as u8));
    let (asset_out, stable_out) = pool.empty_all_amm_liquidity(ctx);
    
    // Record the final amounts for LP conversion invariance
    coin_escrow::record_winning_pool_final_amounts(escrow, asset_out, stable_out);

    let (asset_coin, stable_coin) = escrow.remove_liquidity(asset_out, stable_out, ctx);
    
    let provider = *proposal.get_liquidity_provider().borrow();
    transfer::public_transfer(asset_coin, provider);
    transfer::public_transfer(stable_coin, provider);

    assert_winning_reserves_consistency(proposal, escrow);
}

/// Empties the winning AMM pool and returns the liquidity.
/// Called internally by `advance_stage` when a DAO-funded proposal finalizes.
/// Returns the asset and stable coins for the DAO to handle (e.g., deposit to vault).
public(package) fun empty_amm_and_return_to_dao<AssetType, StableType>(
    proposal: &mut Proposal<AssetType, StableType>,
    escrow: &mut TokenEscrow<AssetType, StableType>,
    ctx: &mut TxContext,
): (Coin<AssetType>, Coin<StableType>) {
    assert!(proposal.is_finalized(), EInvalidState);
    assert!(proposal.uses_dao_liquidity(), EInvalidState);

    let market_id = proposal.market_state_id();
    let escrow_market_id = escrow.get_market_state_id();
    assert!(market_id == escrow_market_id, EMarketIdMismatch);
    escrow.get_market_state().assert_market_finalized();

    let winning_outcome = proposal.get_winning_outcome();
    let pool = proposal.get_pool_mut_by_outcome((winning_outcome as u8));
    let (asset_out, stable_out) = pool.empty_all_amm_liquidity(ctx);
    
    // Record the final amounts for LP conversion invariance
    coin_escrow::record_winning_pool_final_amounts(escrow, asset_out, stable_out);

    let (asset_coin, stable_coin) = escrow.remove_liquidity(asset_out, stable_out, ctx);
    
    // Return coins for the caller to handle (deposit to vault, add to spot pool, etc.)
    (asset_coin, stable_coin)
}

public fun assert_all_reserves_consistency<AssetType, StableType>(
    proposal: &Proposal<AssetType, StableType>,
    escrow: &TokenEscrow<AssetType, StableType>,
) {
    // Get outcome count
    let outcome_count = proposal.outcome_count();

    // Get escrow balances
    let (escrow_asset, escrow_stable) = escrow.get_balances();

    // Check each outcome
    let mut i = 0;
    while (i < outcome_count) {
        // Get pool for this outcome
        let pool = &proposal.get_amm_pools()[i];

        // Get reserves and fees
        let (amm_asset, amm_stable) = pool.get_reserves();
        let protocol_fees = pool.get_protocol_fees();

        // Get token supplies
        let (_, _, asset_supply, stable_supply) = escrow.get_escrow_balances_and_supply(
            i,
        );

        assert!(amm_asset + asset_supply == escrow_asset, EAssetReservesMismatch);

        // Verify stable equation: AMM stable reserves + protocol fees + stable token supply = escrow stable
        // Protocol fees are explicitly collected and held outside the AMM's stable reserve.
        // Note: protocol_fees are tracked separately in pool.protocol_fees and are NOT included in amm_stable
        assert!(
            amm_stable + protocol_fees + stable_supply == escrow_stable,
            EStableReservesMismatch,
        );

        i = i + 1;
    };
}

public fun assert_winning_reserves_consistency<AssetType, StableType>(
    proposal: &Proposal<AssetType, StableType>,
    escrow: &TokenEscrow<AssetType, StableType>,
) {
    let winning_outcome = proposal.get_winning_outcome();

    // Get escrow balances
    let (escrow_asset, escrow_stable) = escrow.get_balances();

    // Get pool for this outcome
    let pool = &proposal.get_amm_pools()[winning_outcome];

    // Get reserves and fees
    let (amm_asset, amm_stable) = pool.get_reserves();
    let protocol_fees = pool.get_protocol_fees();

    // Get token supplies
    let (_, _, asset_supply, stable_supply) = escrow.get_escrow_balances_and_supply(
        winning_outcome,
    );

    assert!(amm_asset + asset_supply == escrow_asset, EAssetReservesMismatch);

    // Verify stable equation: AMM stable reserves + protocol fees + stable token supply = escrow stable
    // Note: protocol_fees are tracked separately in pool.protocol_fees and are NOT included in amm_stable
    assert!(amm_stable + protocol_fees + stable_supply == escrow_stable, EStableReservesMismatch);
}

/// Wrapper for redeeming winning stable tokens.
public entry fun redeem_winning_tokens_stable_entry<AssetType, StableType>(
    proposal: &Proposal<AssetType, StableType>, // Added
    escrow: &mut TokenEscrow<AssetType, StableType>,
    token: ConditionalToken,
    clock: &Clock,
    ctx: &mut TxContext,
) {
    let balance_out = escrow.redeem_winning_tokens_stable(token, clock, ctx);

    assert_winning_reserves_consistency(proposal, escrow);

    let coin_out = coin::from_balance(balance_out, ctx);
    transfer::public_transfer(coin_out, ctx.sender());
}

/// Wrapper for minting a complete set of asset tokens.
public entry fun mint_complete_set_asset_entry<AssetType, StableType>(
    proposal: &Proposal<AssetType, StableType>, // Added
    escrow: &mut TokenEscrow<AssetType, StableType>,
    coin_in: Coin<AssetType>,
    clock: &Clock,
    ctx: &mut TxContext,
) {
    let tokens_out = escrow.mint_complete_set_asset(coin_in, clock, ctx);

    // Assert consistency
    assert_all_reserves_consistency(proposal, escrow);

    transfer_tokens_to_recipient(tokens_out, ctx.sender());
}

/// Wrapper for minting a complete set of stable tokens.
public entry fun mint_complete_set_stable_entry<AssetType, StableType>(
    proposal: &Proposal<AssetType, StableType>, // Added
    escrow: &mut TokenEscrow<AssetType, StableType>,
    coin_in: Coin<StableType>,
    clock: &Clock,
    ctx: &mut TxContext,
) {
    let tokens_out = escrow.mint_complete_set_stable(coin_in, clock, ctx);

    assert_all_reserves_consistency(proposal, escrow);

    transfer_tokens_to_recipient(tokens_out, ctx.sender());
}

/// Wrapper for redeeming a complete set of asset tokens.
public entry fun redeem_complete_set_asset_entry<AssetType, StableType>(
    proposal: &Proposal<AssetType, StableType>, // Added
    escrow: &mut TokenEscrow<AssetType, StableType>,
    tokens: vector<ConditionalToken>,
    clock: &Clock,
    ctx: &mut TxContext,
) {
    // Call the underlying package function from coin_escrow
    let balance_out = escrow.redeem_complete_set_asset(tokens, clock, ctx);

    // Assert consistency
    assert_all_reserves_consistency(proposal, escrow);

    // Handle result (transfer coin)
    let coin_out = coin::from_balance(balance_out, ctx);
    transfer::public_transfer(coin_out, ctx.sender());
}

/// Wrapper for redeeming a complete set of stable tokens.
public entry fun redeem_complete_set_stable_entry<AssetType, StableType>(
    proposal: &Proposal<AssetType, StableType>, // Added
    escrow: &mut TokenEscrow<AssetType, StableType>,
    tokens: vector<ConditionalToken>,
    clock: &Clock,
    ctx: &mut TxContext,
) {
    let balance_out = escrow.redeem_complete_set_stable(tokens, clock, ctx);

    assert_all_reserves_consistency(proposal, escrow);

    // Handle result (transfer coin)
    let coin_out = coin::from_balance(balance_out, ctx);
    transfer::public_transfer(coin_out, ctx.sender());
}

public entry fun redeem_winning_tokens_asset_entry<AssetType, StableType>(
    proposal: &Proposal<AssetType, StableType>, // Added
    escrow: &mut TokenEscrow<AssetType, StableType>,
    token: ConditionalToken,
    clock: &Clock,
    ctx: &mut TxContext,
) {
    let balance_out = escrow.redeem_winning_tokens_asset(token, clock, ctx);

    // Pass ctx only if the assert function requires it
    assert_winning_reserves_consistency(proposal, escrow);

    // Handle result (transfer coin)
    let coin_out = coin::from_balance(balance_out, ctx);
    transfer::public_transfer(coin_out, ctx.sender());
}

// === AMM Liquidity Management Entry Points ===

/// Add liquidity to an AMM pool for a specific outcome
/// Takes asset and stable conditional tokens and returns LP tokens
public entry fun add_liquidity_entry<AssetType, StableType>(
    proposal: &mut Proposal<AssetType, StableType>,
    escrow: &mut TokenEscrow<AssetType, StableType>,
    outcome_idx: u64,
    asset_in: ConditionalToken,
    stable_in: ConditionalToken,
    min_lp_out: u64,
    clock: &Clock,
    ctx: &mut TxContext,
) {
    // Verify market state consistency
    assert!(proposal.market_state_id() == escrow.get_market_state_id(), EMarketIdMismatch);
    assert!(!proposal.is_finalized(), EInvalidState);
    
    // Verify tokens match the pool's outcome
    assert!(asset_in.market_id() == proposal.market_state_id(), EMarketIdMismatch);
    assert!(stable_in.market_id() == proposal.market_state_id(), EMarketIdMismatch);
    assert!(asset_in.outcome() == (outcome_idx as u8), EWrongOutcome);
    assert!(stable_in.outcome() == (outcome_idx as u8), EWrongOutcome);
    assert!(asset_in.asset_type() == 0, EInvalidState); // Must be asset token
    assert!(stable_in.asset_type() == 1, EInvalidState); // Must be stable token
    
    let asset_amount = asset_in.value();
    let stable_amount = stable_in.value();
    
    // Burn the conditional tokens (they'll be absorbed into the pool)
    escrow.burn_single_conditional_token(asset_in, clock, ctx);
    escrow.burn_single_conditional_token(stable_in, clock, ctx);
    
    // Get the pool for this outcome
    let pool = proposal.get_pool_mut_by_outcome((outcome_idx as u8));
    
    // Add liquidity through the AMM (only calculations and reserve updates)
    let lp_amount = conditional_amm::add_liquidity_proportional(
        pool,
        asset_amount,
        stable_amount,
        min_lp_out,
        clock,
        ctx
    );
    
    // Mint LP tokens
    let lp_token = escrow.mint_single_conditional_token(
        2, // TOKEN_TYPE_LP
        (outcome_idx as u8),
        lp_amount,
        ctx.sender(),
        clock,
        ctx
    );
    
    // Assert consistency after operation
    assert_all_reserves_consistency(proposal, escrow);
    
    // Transfer LP token to the sender
    transfer::public_transfer(lp_token, ctx.sender());
}

/// Remove liquidity from an AMM pool proportionally
/// Takes LP tokens and returns asset and stable conditional tokens
public entry fun remove_liquidity_entry<AssetType, StableType>(
    proposal: &mut Proposal<AssetType, StableType>,
    escrow: &mut TokenEscrow<AssetType, StableType>,
    outcome_idx: u64,
    lp_token: ConditionalToken,
    min_asset_out: u64,
    min_stable_out: u64,
    clock: &Clock,
    ctx: &mut TxContext,
) {
    // Verify market state consistency
    assert!(proposal.market_state_id() == escrow.get_market_state_id(), EMarketIdMismatch);
    assert!(!proposal.is_finalized(), EInvalidState);
    
    // Verify LP token is for the correct outcome and market
    assert!(lp_token.market_id() == proposal.market_state_id(), EMarketIdMismatch);
    assert!(lp_token.outcome() == (outcome_idx as u8), EWrongOutcome);
    assert!(lp_token.asset_type() == 2, EInvalidState); // Must be LP token
    
    let lp_amount = lp_token.value();
    
    // Burn the LP token
    escrow.burn_single_conditional_token(lp_token, clock, ctx);
    
    // Get the pool for this outcome
    let pool = proposal.get_pool_mut_by_outcome((outcome_idx as u8));
    
    // Remove liquidity through the AMM (only calculations and reserve updates)
    let (asset_amount, stable_amount) = conditional_amm::remove_liquidity_proportional(
        pool,
        lp_amount,
        clock,
        ctx
    );
    
    // Verify slippage protection
    assert!(asset_amount >= min_asset_out, EInvalidState);
    assert!(stable_amount >= min_stable_out, EInvalidState);
    
    // Mint the asset and stable tokens
    let asset_token = escrow.mint_single_conditional_token(
        0, // TOKEN_TYPE_ASSET
        (outcome_idx as u8),
        asset_amount,
        ctx.sender(),
        clock,
        ctx
    );
    
    let stable_token = escrow.mint_single_conditional_token(
        1, // TOKEN_TYPE_STABLE
        (outcome_idx as u8),
        stable_amount,
        ctx.sender(),
        clock,
        ctx
    );
    
    // Assert consistency after operation
    assert_all_reserves_consistency(proposal, escrow);
    
    // Transfer tokens to the sender
    transfer::public_transfer(asset_token, ctx.sender());
    transfer::public_transfer(stable_token, ctx.sender());
}

public fun redeem_winning_tokens_stable<AssetType, StableType>(
    proposal: &Proposal<AssetType, StableType>, // Read-only needed for assertion & checks
    escrow: &mut TokenEscrow<AssetType, StableType>,
    token: ConditionalToken,
    clock: &Clock,
    ctx: &mut TxContext, // Still needed for coin_escrow call
): Balance<StableType> {
    // Pre-checks using proposal state
    assert!(proposal.is_finalized(), EInvalidState);
    let winning_outcome = proposal.get_winning_outcome();
    assert!(token.outcome() == (winning_outcome as u8), EWrongOutcome);

    // Call the core logic in coin_escrow
    let balance_out = escrow.redeem_winning_tokens_stable(token, clock, ctx);

    assert_winning_reserves_consistency(proposal, escrow);

    // Return the result
    balance_out
}

/// Redeems a winning asset token after the market has finalized.
/// Returns the Balance<AssetType> for use in PTBs.
public fun redeem_winning_tokens_asset<AssetType, StableType>(
    proposal: &Proposal<AssetType, StableType>, // Read-only needed for assertion & checks
    escrow: &mut TokenEscrow<AssetType, StableType>,
    token: ConditionalToken,
    clock: &Clock,
    ctx: &mut TxContext, // Still needed for coin_escrow call
): Balance<AssetType> {
    // Pre-checks using proposal state
    assert!(proposal.is_finalized(), EInvalidState);
    let winning_outcome = proposal.get_winning_outcome();
    assert!(token.outcome() == (winning_outcome as u8), EWrongOutcome);

    // Call the core logic in coin_escrow
    let balance_out = escrow.redeem_winning_tokens_asset(token, clock, ctx);

    assert_winning_reserves_consistency(proposal, escrow);

    // Return the result
    balance_out
}

/// Mints a complete set of asset tokens by depositing the base asset.
/// Returns the vector<ConditionalToken> for use in PTBs.
public fun mint_complete_set_asset<AssetType, StableType>(
    proposal: &Proposal<AssetType, StableType>, // Read-only needed for assertion
    escrow: &mut TokenEscrow<AssetType, StableType>,
    coin_in: Coin<AssetType>,
    clock: &Clock,
    ctx: &mut TxContext, // Still needed for coin_escrow call
): vector<ConditionalToken> {
    // Optional pre-checks using proposal state
    assert!(!proposal.is_finalized(), EInvalidState);

    // Call the core logic in coin_escrow
    let tokens_out = escrow.mint_complete_set_asset(coin_in, clock, ctx);

    assert_all_reserves_consistency(proposal, escrow);

    // Return the result
    tokens_out
}

/// Mints a complete set of stable tokens by depositing the stable coin.
/// Returns the vector<ConditionalToken> for use in PTBs.
public fun mint_complete_set_stable<AssetType, StableType>(
    proposal: &Proposal<AssetType, StableType>, // Read-only needed for assertion
    escrow: &mut TokenEscrow<AssetType, StableType>,
    coin_in: Coin<StableType>,
    clock: &Clock,
    ctx: &mut TxContext, // Still needed for coin_escrow call
): vector<ConditionalToken> {
    // Optional pre-checks using proposal state
    assert!(!proposal.is_finalized(), EInvalidState);

    // Call the core logic in coin_escrow
    let tokens_out = escrow.mint_complete_set_stable(coin_in, clock, ctx);

    assert_all_reserves_consistency(proposal, escrow);

    // Return the result
    tokens_out
}

/// Redeems a complete set of asset tokens for the base asset.
/// Returns the Balance<AssetType> for use in PTBs.
public fun redeem_complete_set_asset<AssetType, StableType>(
    proposal: &Proposal<AssetType, StableType>, // Read-only needed for assertion
    escrow: &mut TokenEscrow<AssetType, StableType>,
    tokens: vector<ConditionalToken>, // Consumed by the call
    clock: &Clock,
    ctx: &mut TxContext, // Still needed for coin_escrow call
): Balance<AssetType> {
    // Optional pre-checks using proposal state
    assert!(!proposal.is_finalized(), EInvalidState);

    // Call the core logic in coin_escrow
    let balance_out = escrow.redeem_complete_set_asset(tokens, clock, ctx);

    assert_all_reserves_consistency(proposal, escrow);

    // Return the result
    balance_out
}

/// Redeems a complete set of stable tokens for the stable coin.
/// Returns the Balance<StableType> for use in PTBs.
public fun redeem_complete_set_stable<AssetType, StableType>(
    proposal: &Proposal<AssetType, StableType>, // Read-only needed for assertion
    escrow: &mut TokenEscrow<AssetType, StableType>,
    tokens: vector<ConditionalToken>, // Consumed by the call
    clock: &Clock,
    ctx: &mut TxContext, // Still needed for coin_escrow call
): Balance<StableType> {
    // Optional pre-checks using proposal state
    assert!(!proposal.is_finalized(), EInvalidState);

    // Call the core logic in coin_escrow
    let balance_out = escrow.redeem_complete_set_stable(tokens, clock, ctx);

    // Assert consistency AFTER the operation
    assert_all_reserves_consistency(proposal, escrow);

    // Return the result
    balance_out
}

public entry fun burn_unused_tokens_entry<AssetType, StableType>(
    proposal: &Proposal<AssetType, StableType>, // Read-only for checks and assert
    escrow: &mut TokenEscrow<AssetType, StableType>, // Mutable for burning
    tokens_to_burn: vector<ConditionalToken>, // Consumed by the call
    clock: &Clock,
    ctx: &mut TxContext,
) {
    // 1. Pre-check: Ensure the proposal (and thus market) is finalized
    // This aligns with the check inside coin_escrow::burn_unused_tokens
    assert!(proposal.is_finalized(), EInvalidState);

    // 2. Call the package-private burn function in coin_escrow
    // This function will handle all individual token checks and burning.
    escrow.burn_unused_tokens(
        tokens_to_burn, // The vector is consumed here
        clock,
        ctx,
    );

    // 3. Assert reserve consistency for the winning outcome AFTER burning
    // Burning non-winning tokens should not affect the winning outcome's
    // reserves or its supply, so this check should pass if the state was
    // consistent before the call.
    assert_winning_reserves_consistency(proposal, escrow);
}

public(package) fun collect_protocol_fees<AssetType, StableType>(
    proposal: &mut Proposal<AssetType, StableType>,
    escrow: &mut TokenEscrow<AssetType, StableType>,
    fee_manager: &mut FeeManager,
    clock: &Clock,
) {
    // Can only collect fees if the proposal is finalized
    assert!(proposal.is_finalized(), EInvalidState);
    assert!(proposal.is_winning_outcome_set(), EInvalidState);

    assert!(escrow.get_market_state_id() == proposal.market_state_id(), EInvalidState);

    let winning_outcome = proposal.get_winning_outcome();
    let winning_pool = proposal.get_pool_mut_by_outcome((winning_outcome as u8));
    let protocol_fee_amount = winning_pool.get_protocol_fees();

    if (protocol_fee_amount > 0) {
        // Reset fees in the pool
        winning_pool.reset_protocol_fees();

        // Extract the fees from escrow
        let fee_balance = escrow.extract_stable_fees<AssetType, StableType>(
            protocol_fee_amount,
        );

        // Deposit to fee manager
        fee_manager.deposit_stable_fees<StableType>(
            fee_balance,
            proposal.get_id(),
            clock,
        );

        assert_winning_reserves_consistency(proposal, escrow);

        // Emit event
        event::emit(ProtocolFeesCollected {
            proposal_id: proposal.get_id(),
            winning_outcome,
            fee_amount: protocol_fee_amount,
            timestamp_ms: clock.timestamp_ms(),
        });
    }
}

#[test_only]
public(package) fun get_liquidity_for_proposal<AssetType, StableType>(
    proposal: &Proposal<AssetType, StableType>,
): vector<u64> {
    let pools = proposal.get_amm_pools();
    let mut liquidity = vector[];
    let mut i = 0;
    while (i < pools.length()) {
        let pool = &pools[i];
        let (asset, stable) = pool.get_reserves();
        liquidity.push_back(asset);
        liquidity.push_back(stable);
        i = i + 1;
    };
    liquidity
}
/// ============================================================================
/// FUTARCHY ORACLE - WRITE-THROUGH TWAP FOR PREDICTION MARKETS
/// ============================================================================
/// 
/// PURPOSE: Core oracle for futarchy decision-making and proposal resolution
/// 
/// USED BY:
/// - Conditional AMMs during proposals (outcome evaluation)
/// - Proposal resolution (determining winners based on TWAP)
/// - SpotAMM for governance TWAP (base fair value)
/// - NOT for lending protocols (use ring_buffer_oracle instead)
/// 
/// KEY FEATURES:
/// - Write-through pattern (MUST update before reading)
/// - Price capping to prevent manipulation
/// - Complex window-based accumulation
/// - Designed specifically for futarchy mechanics
/// - Does NOT merge with ring buffer data (separate concerns)
/// 
/// BEHAVIOR:
/// - During proposals: Each conditional AMM maintains its own oracle
/// - After finalization: Winning outcome's TWAP fills gap in spot oracle
/// - Ring buffer handles continuous feeds, this handles governance
/// 
/// WHY IT EXISTS:
/// Futarchy needs precise, manipulation-resistant price discovery during
/// proposals. This oracle enforces atomic write-then-read to ensure prices
/// are always fresh and prevents time-based manipulation attacks.
/// The separation from ring_buffer_oracle ensures governance decisions
/// cannot be influenced by lending protocol requirements.
/// 
/// ============================================================================

module futarchy::oracle;

use futarchy::math;
use futarchy::constants;
use std::u128;
use std::u64;
use sui::clock::Clock;
use sui::event;

// === Introduction ===
// Crankless Time Weighted Average Price (TWAP) Oracle

// === Constants ===
// Constants moved to constants module
// Using constants::twap_price_cap_window(), constants::one_week_ms(), constants::ppm_denominator()

// === Errors ===
const ETimestampRegression: u64 = 0;
const ETwapNotStarted: u64 = 1;
const EZeroPeriod: u64 = 2;
const EZeroInitialization: u64 = 3;
const EZeroStep: u64 = 4;
const ELongDelay: u64 = 5;
const EStaleTwap: u64 = 6;
const EOverflowVRamp: u64 = 7;
const EOverflowVFlat: u64 = 8;
const EOverflowSDevMag: u64 = 9;
const EOverflowBasePriceSumFinal: u64 = 10;
const EOverflowVSumPricesAdd: u64 = 11;
const EInternalTwapError: u64 = 12;
const ENoneFullWindowTwapDelay: u64 = 13;
const EMarketNotStarted: u64 = 14;
const EMarketAlreadyStarted: u64 = 15;
const EInvalidCapPpm: u64 = 16;
const EStepOverflow: u64 = 17;

// === Structs ===
public struct Oracle has key, store {
    id: UID,
    last_price: u128,
    last_timestamp: u64,
    total_cumulative_price: u256,
    // TWAP calculation fields - using u256 for overflow protection
    // Max TWAP accumulation is U256 Max ≈1.16 x 10^77
    // Max TWAP daily accumulation:
    //     Max price observation = u64::max_value!() x 1_000_000_000_000;
    //     Milliseconds a day (7 x 24 × 3,600 × 1,000) * max price observation
    //     Allows for 1.04×10 ^ 37 days of accumulation.
    last_window_end_cumulative_price: u256,
    last_window_end: u64,
    last_window_twap: u128,
    twap_start_delay: u64,
    // Reduces attacker advantage with surprise proposals
    twap_cap_step: u64,
    // Scaled relative maximum step size for TWAP calculations
    market_start_time: Option<u64>,
    twap_initialization_price: u128,
}

// === Events ===

public struct PriceEvent has copy, drop {
    last_price: u128,
}

// === Public Functions ===
public(package) fun new_oracle(
    twap_initialization_price: u128,
    twap_start_delay: u64,
    twap_cap_ppm: u64,
    ctx: &mut TxContext,
): Oracle {
    assert!(twap_initialization_price > 0, EZeroInitialization);
    assert!(twap_cap_ppm > 0, EZeroStep);
    assert!(twap_cap_ppm <= constants::ppm_denominator(), EInvalidCapPpm);
    assert!(twap_start_delay < constants::one_week_ms(), ELongDelay); // One week in milliseconds
    assert!((twap_start_delay % constants::twap_price_cap_window()) == 0, ENoneFullWindowTwapDelay);
    
    // Calculate the absolute step from PPM and initialization price
    // Use checked multiplication to avoid overflow
    let step_u128 = if (twap_cap_ppm > 0 && twap_initialization_price > (u128::max_value!() / (twap_cap_ppm as u128))) {
        // Would overflow, use max u64 as step
        (u64::max_value!() as u128)
    } else {
        twap_initialization_price * (twap_cap_ppm as u128) / (constants::ppm_denominator() as u128)
    };
    assert!(step_u128 <= (std::u64::max_value!() as u128), EStepOverflow);
    let mut twap_cap_step = step_u128 as u64;
    // Ensure step is at least 1 to avoid division by zero
    if (twap_cap_step == 0) {
        twap_cap_step = 1;
    };

    Oracle {
        id: object::new(ctx),
        last_price: twap_initialization_price,
        last_timestamp: 0, // set to current time when trading starts
        total_cumulative_price: 0,
        last_window_end_cumulative_price: 0,
        last_window_end: 0, // set to current time when trading starts
        last_window_twap: twap_initialization_price,
        twap_start_delay: twap_start_delay,
        twap_cap_step: twap_cap_step,
        market_start_time: option::none(), // nullable so that TWAP is not valid if not properly initialized
        twap_initialization_price: twap_initialization_price,
    }
}

// === Private Functions ===
fun one_step_cap_price_change(twap_base: u128, new_price: u128, twap_cap_step: u64): u128 {
    if (new_price > twap_base) {
        // Cap upward movement: min(new_price, saturating_add(twap_base, max_change))
        u128::min(new_price, math::saturating_add(twap_base, (twap_cap_step as u128)))
    } else {
        // Cap downward movement: max(new_price, saturating_sub(twap_base, max_change))
        u128::max(new_price, math::saturating_sub(twap_base, (twap_cap_step as u128)))
    }
}

// Called before swaps, LP events and before reading TWAP
public(package) fun write_observation(oracle: &mut Oracle, timestamp: u64, price: u128) {
    // Sanity time checks
    assert!(oracle.market_start_time.is_some(), EMarketNotStarted);
    let market_start_time_val = *oracle.market_start_time.borrow();
    assert!(timestamp >= oracle.last_timestamp, ETimestampRegression);

    let delay_threshold = market_start_time_val + oracle.twap_start_delay;
    // --- Case 0: No time has passed ---
    if (timestamp == oracle.last_timestamp) {
        // If last_price update is not needed here, just return.
        // twap_accumulate would also do nothing if called with 0 duration.
        return
    };

    // --- Case 1: Current observation interval is entirely BEFORE delay_threshold ---
    if (oracle.last_timestamp < delay_threshold && timestamp < delay_threshold) {
        twap_accumulate(oracle, timestamp, price);
        return
    };

    // --- Case 2: Current observation interval CROSSES (or starts at and goes beyond) delay_threshold ---
    if (oracle.last_timestamp <= delay_threshold && timestamp >= delay_threshold) {
        // Part A: Process segment up to delay_threshold.
        if (delay_threshold > oracle.last_timestamp) {
            twap_accumulate(oracle, delay_threshold, price);
        };

        // Part B: RESET accumulators and mark the true start of the accumulation period.
        oracle.total_cumulative_price = 0;
        oracle.last_window_end_cumulative_price = 0;
        oracle.last_window_end = delay_threshold;

        // Part C: Process segment from delay_threshold to current `timestamp`.
        // This uses the fresh accumulators.
        if (timestamp > delay_threshold) {
            // Ensure there's a duration for this segment
            // twap_accumulate will use oracle.last_timestamp (which is delay_threshold)
            twap_accumulate(oracle, timestamp, price);
        };
        return
    };

    // --- Case 3: Current observation interval is entirely AT or AFTER delay_threshold ---
    if (oracle.last_timestamp >= delay_threshold) {
        twap_accumulate(oracle, timestamp, price);
        return
    }
}

fun twap_accumulate(oracle: &mut Oracle, timestamp: u64, price: u128) {
    // --- Input Validation ---
    // Ensure timestamp is not regressing
    assert!(timestamp >= oracle.last_timestamp, ETimestampRegression);
    // Ensure initial state is consistent (last_timestamp should not be before the window end it relates to)
    // This is a pre-condition check, assuming the state was valid before this call.
    assert!(oracle.last_timestamp >= oracle.last_window_end, ETimestampRegression);

    // --- Handle Edge Case: No time passed ---
    let time_since_last_update = timestamp - oracle.last_timestamp;

    // --- Stage 1: Accumulate for the initial partial window segment ---
    // This segment starts at oracle.last_timestamp and ends at the first of:
    // 1. The next window boundary (relative to oracle.last_window_end).
    // 2. The final input timestamp.

    let diff_from_last_boundary = oracle.last_timestamp - oracle.last_window_end;
    let elapsed_in_current_segment = diff_from_last_boundary % constants::twap_price_cap_window();

    let time_to_next_boundary = constants::twap_price_cap_window() - elapsed_in_current_segment;

    let duration_stage1 = std::u64::min(
        time_to_next_boundary, // Limit by the time until the next window boundary
        time_since_last_update, // Limit by the total time available until the target timestamp
    );

    if (duration_stage1 > 0) {
        let end_timestamp_stage1 = oracle.last_timestamp + duration_stage1;
        intra_window_accumulation(
            oracle, // Passes mutable reference, state will be updated
            price,
            duration_stage1,
            end_timestamp_stage1, // This timestamp becomes the new oracle.last_timestamp
        );
        // After this call, oracle.last_timestamp is updated to end_timestamp_stage1.
        // If end_timestamp_stage1 hit a window boundary, oracle.last_window_end and TWAP state are also updated.
    };

    // --- Stage 2: Process all full windows that fit *after* Stage 1 ended ---
    // The starting point for these full windows is the current oracle.last_timestamp
    // (which is the end timestamp of the segment processed in Stage 1).

    let time_remaining_after_stage1 = timestamp - oracle.last_timestamp; // Use updated oracle.last_timestamp

    if (time_remaining_after_stage1 >= constants::twap_price_cap_window()) {
        let num_full_windows = time_remaining_after_stage1 / constants::twap_price_cap_window();

        // Calculate the end timestamp after processing these full windows.
        // Start from the *current* oracle.last_timestamp (end of Stage 1 segment).
        let end_timestamp_stage2 = oracle.last_timestamp + num_full_windows * constants::twap_price_cap_window();

        multi_full_window_accumulation(
            oracle, // Passes mutable reference, state will be updated
            price,
            num_full_windows,
            end_timestamp_stage2, // This timestamp becomes the new oracle.last_timestamp and oracle.last_window_end
        );
        // After this call, oracle.last_timestamp and oracle.last_window_end are updated to end_timestamp_stage2.
        // The oracle's TWAP state (last_window_twap, cumulative_price) is also updated for these full windows.
    };

    // --- Stage 3: Process any remaining partial window after Stage 2 ended ---
    // The starting point is the current oracle.last_timestamp
    // (which is the end timestamp of the segment processed in Stage 2, or Stage 1 if Stage 2 was skipped).

    let duration_stage3 = timestamp - oracle.last_timestamp; // Use updated oracle.last_timestamp

    // If duration_stage3 > 0, there is time left to accumulate up to the final timestamp.
    if (duration_stage3 > 0) {
        intra_window_accumulation(
            oracle, // Passes mutable reference, state will be updated
            price,
            duration_stage3,
            timestamp, // The end timestamp for this final segment is the target timestamp
        );
        // After this call, oracle.last_timestamp is updated to the final input timestamp.
        // If the final timestamp hits a window boundary, oracle.last_window_end and TWAP state are also updated.
    };
    assert!(oracle.last_timestamp == timestamp, EInternalTwapError); // Assuming an internal error code
}

fun intra_window_accumulation(
    oracle: &mut Oracle,
    price: u128,
    additional_time_to_include: u64,
    timestamp: u64,
) {
    let capped_price = one_step_cap_price_change(
        oracle.last_window_twap,
        price,
        oracle.twap_cap_step,
    );

    // Add accumulation for the partial period within the current (still open) window
    let scaled_price = (capped_price as u256);
    let price_contribution = scaled_price * (additional_time_to_include as u256);
    oracle.total_cumulative_price = oracle.total_cumulative_price + price_contribution;

    let time_since_last_window_end = timestamp - oracle.last_window_end;
    oracle.last_timestamp = timestamp;
    oracle.last_price = (scaled_price as u128);

    event::emit(PriceEvent {
        last_price: oracle.last_price,
    });

    if (time_since_last_window_end == constants::twap_price_cap_window()) {
        // Update last window data on window boundary
        oracle.last_window_end = timestamp;
        oracle.last_window_twap = (
            (
                (oracle.total_cumulative_price - oracle.last_window_end_cumulative_price) / (constants::twap_price_cap_window() as u256),
            ) as u128,
        );
        oracle.last_window_end_cumulative_price = oracle.total_cumulative_price
    }
}

fun multi_full_window_accumulation(
    oracle: &mut Oracle,
    price: u128,
    num_new_windows: u64, // N_W
    timestamp: u64,
) {
    // Notation: v_ = value, n_ = number/count, k_ = index, s_ = sum, g_ = gap
    // G_abs = |P - B|
    let g_abs: u128;
    if (price > oracle.last_window_twap) {
        g_abs = price - oracle.last_window_twap;
    } else {
        g_abs = oracle.last_window_twap - price;
    };

    let k_cap_idx_u128: u128;
    if (g_abs == 0) {
        k_cap_idx_u128 = 0;
    } else if (oracle.twap_cap_step == 0) {
        // If step is 0 (from very small PPM), treat as unlimited steps
        k_cap_idx_u128 = (u64::max_value!() as u128);
    } else {
        k_cap_idx_u128 = (g_abs - 1) / (oracle.twap_cap_step as u128) + 1;
    };

    let k_cap_idx: u64;
    if (k_cap_idx_u128 > (u64::max_value!() as u128)) {
        k_cap_idx = u64::max_value!();
    } else {
        k_cap_idx = k_cap_idx_u128 as u64;
    };

    let k_ramp_limit: u64;
    if (k_cap_idx == 0) {
        k_ramp_limit = 0;
    } else {
        k_ramp_limit = k_cap_idx - 1;
    };

    // N_ramp_terms = min(N_W, k_ramp_limit)
    let n_ramp_terms = std::u64::min(num_new_windows, k_ramp_limit); // n_ramp_terms is u64

    // V_ramp = \Delta_M * N_ramp_terms * (N_ramp_terms + 1) / 2
    let v_ramp: u128;
    if (n_ramp_terms == 0) {
        v_ramp = 0;
    } else {
        let nrt_u128 = n_ramp_terms as u128;
        let sum_indices_part: u128;
        // Calculate nrt_u128 * (nrt_u128 + 1) / 2 safely to avoid overflow.
        // Max nrt_u128 is std::u64::MAX (~2^64).
        // (nrt_u128/2) * (nrt_u128+1) OR ((nrt_u128+1)/2) * nrt_u128 will be ~2^63 * 2^64 = 2^127, which fits u128.
        if (nrt_u128 % 2 == 0) {
            sum_indices_part = (nrt_u128 / 2) * (nrt_u128 + 1);
        } else {
            sum_indices_part = ((nrt_u128 + 1) / 2) * nrt_u128;
        };

        // Check for overflow: delta_max_per_step * sum_indices_part
        if (
            sum_indices_part > 0 && (oracle.twap_cap_step as u128) > 0 && (oracle.twap_cap_step as u128) > u128::max_value!() / sum_indices_part
        ) {
            abort (EOverflowVRamp)
        };
        v_ramp = (oracle.twap_cap_step as u128) * sum_indices_part;
    };

    // V_flat = G_abs * (N_W - N_ramp_terms)
    let num_flat_terms = num_new_windows - n_ramp_terms; // u64
    let v_flat: u128;
    if (num_flat_terms == 0) {
        v_flat = 0;
    } else {
        let nft_u128 = num_flat_terms as u128;
        // Check for overflow: g_abs * nft_u128
        if (nft_u128 > 0 && g_abs > 0 && g_abs > u128::max_value!() / nft_u128) {
            abort (EOverflowVFlat)
        };
        v_flat = g_abs * nft_u128;
    };

    // S_dev_mag = V_ramp + V_flat
    // Check for overflow: v_ramp + v_flat
    if (v_ramp > u128::max_value!() - v_flat) {
        // Equivalent to v_ramp + v_flat > u128::max_value!()
        abort (EOverflowSDevMag)
    };
    let s_dev_mag = v_ramp + v_flat;

    // V_sum_prices = N_W * B + sign(P-B) * S_dev_mag
    let base_price_sum: u128;
    let nw_u128 = num_new_windows as u128;
    // Check for overflow: oracle.last_window_twap * nw_u128
    if (
        nw_u128 > 0 && oracle.last_window_twap > 0 && oracle.last_window_twap > u128::max_value!() / nw_u128
    ) {
        abort (EOverflowBasePriceSumFinal)
    };
    base_price_sum = oracle.last_window_twap * nw_u128;

    let v_sum_prices: u128;
    if (price >= oracle.last_window_twap) {
        // sign(P-B) is 0 or 1
        // Check for overflow: base_price_sum + s_dev_mag
        if (base_price_sum > u128::max_value!() - s_dev_mag) {
            abort (EOverflowVSumPricesAdd)
        };
        v_sum_prices = base_price_sum + s_dev_mag;
    } else {
        // sign(P-B) is -1
        // Since P'_i = B - dev_i, and we assume price (P) >= 0,
        // then P'_i >= 0 (as B - dev_i >= P >= 0).
        // So sum of P'_i (which is V_sum_prices) must be >= 0.
        // This also implies N_W * B >= S_dev_mag.
        // Thus, base_price_sum >= s_dev_mag, and subtraction will not underflow below zero.
        v_sum_prices = base_price_sum - s_dev_mag;
    };

    // P'_N_W = B + sign(P-B) * min(N_W * \Delta_M, G_abs)
    let p_n_w_effective: u128;

    // Calculate N_W * \Delta_M
    // delta_max_per_step is > 0 here. num_new_windows > 0.
    // No overflow possible: num_new_windows is u64, twap_cap_step is u64
    let nw_times_delta_m = (num_new_windows as u128) * (oracle.twap_cap_step as u128);

    let deviation_for_p_n_w = std::u128::min(nw_times_delta_m, g_abs);

    if (price >= oracle.last_window_twap) {
        p_n_w_effective = math::saturating_add(oracle.last_window_twap, deviation_for_p_n_w);
    } else {
        // price < oracle.last_window_twap
        p_n_w_effective = math::saturating_sub(oracle.last_window_twap, deviation_for_p_n_w);
    };

    oracle.last_timestamp = timestamp;
    oracle.last_window_end = timestamp;
    let cumulative_price_contribution = (v_sum_prices as u256) * (constants::twap_price_cap_window() as u256);
    oracle.last_window_end_cumulative_price =
        oracle.total_cumulative_price + cumulative_price_contribution;
    oracle.total_cumulative_price = oracle.total_cumulative_price + cumulative_price_contribution;
    oracle.last_price = p_n_w_effective;

    event::emit(PriceEvent {
        last_price: oracle.last_price,
    });

    oracle.last_window_twap = p_n_w_effective;
}

/// ARCHITECTURAL DECISION: Mutation-Required TWAP Oracle
/// 
/// This oracle REQUIRES write_observation() before get_twap() in the same transaction.
/// The assertion `current_time == oracle.last_timestamp` is INTENTIONAL.
/// 
/// Why this differs from read-only TWAP patterns:
/// - Stale prices are attack vectors, not features
/// - Interpolation adds complexity and manipulation surface  
/// - The AMM determines prices; the oracle just tracks them
/// - Every TWAP read MUST reflect current AMM state
/// 
/// This design makes it IMPOSSIBLE to:
/// ✗ Read stale/manipulated TWAPs
/// ✗ Forget to update before critical operations
/// ✗ Have price inconsistency within a transaction
/// 
/// This pattern differs from typical read-only oracles by design.
/// Serving stale TWAPs for "cleaner interfaces" is how protocols get exploited.
/// 
/// The AMM's get_twap() handles the update + read atomically. 
/// The oracle just validates freshness. This is correct.
public(package) fun get_twap(oracle: &Oracle, clock: &Clock): u128 {
    assert!(oracle.market_start_time.is_some(), EMarketNotStarted);
    let market_start_time_val = *oracle.market_start_time.borrow();
    let current_time = clock.timestamp_ms();

    // REQUIRED: Caller must have called write_observation() in this same transaction
    // This ensures TWAP is always fresh and prevents stale price exploitation
    assert!(current_time == oracle.last_timestamp, EStaleTwap);

    // Time checks
    assert!(oracle.last_timestamp != 0, ETimestampRegression);
    assert!(current_time - market_start_time_val >= oracle.twap_start_delay, ETwapNotStarted);
    assert!(current_time >= market_start_time_val, ETimestampRegression);

    // Calculate period
    let period = ( current_time - market_start_time_val) - oracle.twap_start_delay;
    assert!(period > 0, EZeroPeriod);

    // Calculate TWAP - dividing cumulative price by period gives average price
    // Safe cast: For reasonable token prices over max 7-day proposals, 
    // TWAP will be far below u128::MAX (even 10^18 price × 7 days / period ≈ 10^15)
    let twap = (oracle.total_cumulative_price) / (period as u256);

    (twap as u128)
}

public(package) fun set_oracle_start_time(oracle: &mut Oracle, market_start_time_param: u64) {
    // Prevent re-initialization
    assert!(oracle.market_start_time.is_none(), EMarketAlreadyStarted);

    oracle.market_start_time = option::some(market_start_time_param);
    oracle.last_window_end = market_start_time_param;
    oracle.last_timestamp = market_start_time_param;
}

// === View Functions ===
public fun last_price(oracle: &Oracle): u128 {
    oracle.last_price
}

public fun last_timestamp(oracle: &Oracle): u64 {
    oracle.last_timestamp
}

public fun config(oracle: &Oracle): (u64, u64) {
    (oracle.twap_start_delay, oracle.twap_cap_step)
}

public fun market_start_time(oracle: &Oracle): Option<u64> {
    oracle.market_start_time
}

public fun twap_initialization_price(oracle: &Oracle): u128 {
    oracle.twap_initialization_price
}

public fun total_cumulative_price(oracle: &Oracle): u256 {
    oracle.total_cumulative_price
}

public fun id(o: &Oracle): &UID {
    &o.id
}

// === Test Functions ===
#[test_only]
use std::debug;

#[test_only]
public fun debug_print_state(oracle: &Oracle) {
    debug::print(&b"Oracle State:");
    debug::print(&oracle.last_price);
    debug::print(&oracle.last_timestamp);
    debug::print(&oracle.total_cumulative_price);
}

#[test_only]
public fun debug_get_state(oracle: &Oracle): (u128, u64, u256) {
    (oracle.last_price, oracle.last_timestamp, oracle.total_cumulative_price)
}

#[test_only]
public fun test_oracle(ctx: &mut TxContext): Oracle {
    new_oracle(
        10000, // twap_initialization_price
        60_000, // twap_start_delay
        1000, // twap_cap_ppm (0.1% of initialization price)
        ctx,
    )
}

#[test_only]
public fun destroy_for_testing(oracle: Oracle) {
    let Oracle {
        id,
        last_price: _,
        last_timestamp: _,
        total_cumulative_price: _,
        last_window_end: _,
        last_window_end_cumulative_price: _,
        last_window_twap: _,
        twap_start_delay: _,
        twap_cap_step: _,
        market_start_time: _,
        twap_initialization_price: _,
    } = oracle;
    id.delete();
}

#[test_only]
public fun debug_get_window_twap(oracle: &Oracle): u128 {
    oracle.last_window_twap
}

#[test_only]
public fun is_twap_valid(oracle: &Oracle, min_period: u64, clock: &Clock): bool {
    let current_time = clock.timestamp_ms();
    current_time >= oracle.last_timestamp + min_period
}

#[test_only]
public fun debug_get_full_state(
    oracle: &Oracle,
): (
    u128, // last_price
    u64, // last_timestamp
    u256, // total_cumulative_price
    u256, // last_window_end_cumulative_price
    u64, // last_window_end
    u128, // last_window_twap
    Option<u64>, // market_start_time
    u128, // twap_initialization_price
    u64, // twap_start_delay
    u64, // twap_cap_step
) {
    (
        oracle.last_price,
        oracle.last_timestamp,
        oracle.total_cumulative_price,
        oracle.last_window_end_cumulative_price,
        oracle.last_window_end,
        oracle.last_window_twap,
        oracle.market_start_time,
        oracle.twap_initialization_price,
        oracle.twap_start_delay,
        oracle.twap_cap_step,
    )
}

#[test_only]
public fun set_last_timestamp_for_testing(oracle: &mut Oracle, new_last_timestamp: u64) {
    oracle.last_timestamp = new_last_timestamp;
}

#[test_only]
public fun set_last_window_end_for_testing(oracle: &mut Oracle, new_last_window_end: u64) {
    oracle.last_window_end = new_last_window_end;
}

#[test_only]
public fun set_last_window_twap_for_testing(oracle: &mut Oracle, new_last_window_twap: u128) {
    oracle.last_window_twap = new_last_window_twap;
}

#[test_only]
public fun set_cumulative_prices_for_testing(
    oracle: &mut Oracle,
    total_cumulative_price: u256,
    last_window_end_cumulative_price: u256,
) {
    oracle.total_cumulative_price = total_cumulative_price;
    oracle.last_window_end_cumulative_price = last_window_end_cumulative_price;
}

#[test_only]
public fun call_twap_accumulate_for_testing(oracle: &mut Oracle, timestamp: u64, price: u128) {
    twap_accumulate(oracle, timestamp, price);
}

#[test_only]
public fun get_last_window_end_cumulative_price_for_testing(oracle: &Oracle): u256 {
    oracle.last_window_end_cumulative_price
}

#[test_only]
public fun get_total_cumulative_price_for_testing(oracle: &Oracle): u256 {
    oracle.total_cumulative_price
}

#[test_only]
public fun get_last_window_end_for_testing(oracle: &Oracle): u64 {
    oracle.last_window_end
}

#[test_only]
public fun call_intra_window_accumulation_for_testing(
    oracle: &mut Oracle,
    price: u128,
    additional_time_to_include: u64,
    timestamp: u64,
) {
    intra_window_accumulation(
        oracle,
        price,
        additional_time_to_include,
        timestamp,
    );
}

#[test_only]
public fun call_multi_full_window_accumulation_for_testing(
    oracle: &mut Oracle,
    price: u128,
    num_new_windows: u64,
    timestamp: u64,
) {
    multi_full_window_accumulation(
        oracle,
        price,
        num_new_windows,
        timestamp,
    );
}
