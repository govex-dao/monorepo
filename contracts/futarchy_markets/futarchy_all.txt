module futarchy_markets::conditional_amm;

use futarchy_markets::market_state::MarketState;
use futarchy_markets::conditional_token::ConditionalToken;
use futarchy_one_shot_utils::math;
use futarchy_markets::oracle::{Self, Oracle};
use futarchy_markets::ring_buffer_oracle::{Self, RingBufferOracle};
use futarchy_one_shot_utils::constants;
use sui::clock::Clock;
use sui::event;
use std::u64;

// === Introduction ===
// This is a Uniswap V2-style XY=K AMM implementation for futarchy prediction markets.
// 
// === Live-Flow Model Architecture ===
// This AMM is part of the "live-flow" liquidity model which allows dynamic liquidity
// management even while proposals are active. Key features:
// 
// 1. **No Liquidity Locking**: Unlike traditional prediction markets, liquidity providers
//    can add or remove liquidity at any time, even during active proposals.
// 
// 2. **Conditional Token Pools**: Each AMM pool trades conditional tokens (not spot tokens)
//    for a specific outcome. This allows the spot pool to remain liquid.
// 
// 3. **Proportional Liquidity**: When LPs add/remove from the spot pool during active
//    proposals, liquidity is proportionally distributed/collected across all outcome AMMs.
// 
// 4. **LP Token Architecture**: Each AMM pool has its own LP token type, but in the live-flow
//    model, these are managed internally. LPs only receive spot pool LP tokens.
// 
// The flow works as follows:
// - Add liquidity: Spot tokens → Mint conditional tokens → Distribute to AMMs
// - Remove liquidity: Collect from AMMs → Redeem conditional tokens → Return spot tokens

// === Errors ===
const ELowLiquidity: u64 = 0; // Pool liquidity below minimum threshold
const EPoolEmpty: u64 = 1; // Attempting to swap/remove from empty pool
const EExcessiveSlippage: u64 = 2; // Output amount less than minimum specified
const EDivByZero: u64 = 3; // Division by zero in calculations
const EZeroLiquidity: u64 = 4; // Pool has zero liquidity
const EPriceTooHigh: u64 = 5; // Price exceeds maximum allowed value
const EZeroAmount: u64 = 6; // Input amount is zero
const EMarketIdMismatch: u64 = 7; // Market ID doesn't match expected value
const EInsufficientLPTokens: u64 = 8; // Not enough LP tokens to burn
const EInvalidTokenType: u64 = 9; // Wrong conditional token type provided
const EOverflow: u64 = 10; // Arithmetic overflow detected
const EInvalidLiquidityRatio: u64 = 11; // Liquidity provided does not match pool ratio
const EInvalidFeeRate: u64 = 12; // Fee rate is invalid (e.g., >= 100%)

// === Constants ===
const FEE_SCALE: u64 = 10000;
const DEFAULT_FEE: u64 = 30; // 0.3%
const MINIMUM_LIQUIDITY: u128 = 1000;
// Other constants moved to constants module

// === Structs ===

public struct LiquidityPool has key, store {
    id: UID,
    market_id: ID,
    outcome_idx: u8,
    asset_reserve: u64,
    stable_reserve: u64,
    fee_percent: u64,
    oracle: Oracle,  // Original write-through oracle for futarchy
    ring_buffer_oracle: RingBufferOracle,  // Ring buffer oracle for lending protocols
    protocol_fees: u64, // Track accumulated stable fees
    lp_supply: u64, // Track total LP shares for this pool
}

// === Events ===
public struct SwapEvent has copy, drop {
    market_id: ID,
    outcome: u8,
    is_buy: bool,
    amount_in: u64,
    amount_out: u64,
    price_impact: u128,
    price: u128,
    sender: address,
    asset_reserve: u64,
    stable_reserve: u64,
    timestamp: u64,
}

public struct LiquidityAdded has copy, drop {
    market_id: ID,
    outcome: u8,
    asset_amount: u64,
    stable_amount: u64,
    lp_amount: u64,
    sender: address,
    timestamp: u64,
}

public struct LiquidityRemoved has copy, drop {
    market_id: ID,
    outcome: u8,
    asset_amount: u64,
    stable_amount: u64,
    lp_amount: u64,
    sender: address,
    timestamp: u64,
}

// === Public Functions ===
public fun new_pool(
    state: &MarketState,
    outcome_idx: u8,
    fee_percent: u64,
    initial_asset: u64,
    initial_stable: u64,
    twap_initial_observation: u128,
    twap_start_delay: u64,
    twap_step_max: u64,
    ctx: &mut TxContext,
): LiquidityPool {
    assert!(initial_asset > 0 && initial_stable > 0, EZeroAmount);
    let k = math::mul_div_to_128(initial_asset, initial_stable, 1);
    assert!(k >= MINIMUM_LIQUIDITY, ELowLiquidity);
    assert!(fee_percent < FEE_SCALE, EInvalidFeeRate); // Fee cannot be 100% or more

    let twap_initialization_price = twap_initial_observation;
    let initial_price = math::mul_div_to_128(initial_stable, constants::basis_points(), initial_asset);

    check_price_under_max(initial_price);
    check_price_under_max(twap_initialization_price);

    // Initialize oracle
    let oracle = oracle::new_oracle(
        twap_initialization_price,
        twap_start_delay,
        twap_step_max,
        ctx, // Add ctx parameter here
    );

    // Create pool object
    let pool = LiquidityPool {
        id: object::new(ctx),
        market_id: state.market_id(),
        outcome_idx,
        asset_reserve: initial_asset,
        stable_reserve: initial_stable,
        fee_percent,
        oracle,
        ring_buffer_oracle: ring_buffer_oracle::new(1440), // 24 hours of observations
        protocol_fees: 0,
        lp_supply: 0, // Start at 0 so first provider logic works correctly
    };

    pool
}

// === Getter Functions ===

/// Get ring buffer oracle reference (for spot_oracle_interface)
public fun get_ring_buffer_oracle(pool: &LiquidityPool): &RingBufferOracle {
    &pool.ring_buffer_oracle
}

// === Core Swap Functions ===
public fun swap_asset_to_stable(
    pool: &mut LiquidityPool,
    state: &MarketState,
    amount_in: u64,
    min_amount_out: u64,
    clock: &Clock,
    ctx: &TxContext,
): u64 {
    state.assert_trading_active();
    assert!(pool.market_id == state.market_id(), EMarketIdMismatch);
    assert!(amount_in > 0, EZeroAmount);

    // When selling outcome tokens (asset -> stable):
    // 1. Calculate the gross output amount (amount_out_before_fee) based on current reserves and amount_in.
    // 2. Calculate the fee amount from this gross output.
    // 3. Split the fee: 80% for LPs (lp_share), 20% for the protocol (protocol_share).
    // 4. The `protocol_share` is moved to `pool.protocol_fees`.
    // 5. The `lp_share` is left in the pool's stable reserve to reward LPs, causing `k` to grow.
    // 6. The user receives the net output `amount_out = amount_out_before_fee - total_fee`.
    let amount_out_before_fee = calculate_output(
        amount_in,
        pool.asset_reserve,
        pool.stable_reserve,
    );

    // Calculate fee from stable output
    let total_fee = calculate_fee(amount_out_before_fee, pool.fee_percent);
    let lp_share = math::mul_div_to_64(total_fee, constants::lp_fee_share_bps(), constants::total_fee_bps());
    let protocol_share = total_fee - lp_share;

    // Net amount for the user
    let amount_out = amount_out_before_fee - total_fee;

    // Send protocol's share to the fee collector
    pool.protocol_fees = pool.protocol_fees + protocol_share;

    assert!(amount_out >= min_amount_out, EExcessiveSlippage);
    assert!(amount_out_before_fee < pool.stable_reserve, EPoolEmpty);

    let price_impact = calculate_price_impact(
        amount_in,
        pool.asset_reserve,
        amount_out_before_fee, // Use before-fee amount for impact calculation
        pool.stable_reserve,
    );

    // Capture previous reserve state before the update
    let old_asset = pool.asset_reserve;
    let old_stable = pool.stable_reserve;

    let timestamp = clock.timestamp_ms();
    let old_price = math::mul_div_to_128(old_stable, constants::basis_points(), old_asset);
    // Oracle observation is recorded using the reserves *before* the swap.
    // This ensures that the TWAP accurately reflects the price at the beginning of the swap.
    write_observation(
        &mut pool.oracle,
        timestamp,
        old_price,
    );
    
    // Also update ring buffer oracle for continuous price feeds
    ring_buffer_oracle::write(&mut pool.ring_buffer_oracle, old_price, clock);

    // Update reserves.
    pool.asset_reserve = pool.asset_reserve + amount_in;

    // The stable reserve is reduced by the gross output, BUT the LPs' share is kept in the pool.
    // So we add it back.
    // This is equivalent to `pool.stable_reserve - (amount_out + protocol_share)`
    pool.stable_reserve = pool.stable_reserve - amount_out_before_fee + lp_share;

    let current_price = get_current_price(pool);
    check_price_under_max(current_price);

    event::emit(SwapEvent {
        market_id: pool.market_id,
        outcome: pool.outcome_idx,
        is_buy: false,
        amount_in,
        amount_out, // Amount after fee for event logging
        price_impact,
        price: current_price,
        sender: ctx.sender(),
        asset_reserve: pool.asset_reserve,
        stable_reserve: pool.stable_reserve,
        timestamp,
    });

    amount_out
}

// Modified swap_asset_to_stable (selling outcome tokens)
public fun swap_stable_to_asset(
    pool: &mut LiquidityPool,
    state: &MarketState,
    amount_in: u64,
    min_amount_out: u64,
    clock: &Clock,
    ctx: &TxContext,
): u64 {
    state.assert_trading_active();
    assert!(pool.market_id == state.market_id(), EMarketIdMismatch);
    assert!(amount_in > 0, EZeroAmount);

    // When buying outcome tokens (stable -> asset):
    // 1. Calculate the fee from the input amount (amount_in).
    // 2. The actual amount used for the swap (amount_in_after_fee) is the original input minus the fee.
    // 3. Split the total fee: 80% for LPs (lp_share), 20% for the protocol (protocol_share).
    // 4. `protocol_share` is moved to `pool.protocol_fees`.
    // 5. `amount_in_after_fee` is used to calculate the swap output.
    // 6. The pool's stable reserve increases by `amount_in_after_fee + lp_share`, growing `k`.
    let total_fee = calculate_fee(amount_in, pool.fee_percent);
    let lp_share = math::mul_div_to_64(total_fee, constants::lp_fee_share_bps(), constants::total_fee_bps());
    let protocol_share = total_fee - lp_share;

    // Amount used for the swap calculation
    let amount_in_after_fee = amount_in - total_fee;

    // Send protocol's share to the fee collector
    pool.protocol_fees = pool.protocol_fees + protocol_share;

    // Calculate output based on amount after fee
    let amount_out = calculate_output(
        amount_in_after_fee,
        pool.stable_reserve,
        pool.asset_reserve,
    );

    assert!(amount_out >= min_amount_out, EExcessiveSlippage);
    assert!(amount_out < pool.asset_reserve, EPoolEmpty);

    let price_impact = calculate_price_impact(
        amount_in_after_fee,
        pool.stable_reserve,
        amount_out,
        pool.asset_reserve,
    );

    // Capture previous reserve state before the update
    let old_asset = pool.asset_reserve;
    let old_stable = pool.stable_reserve;

    let timestamp = clock.timestamp_ms();
    let old_price = math::mul_div_to_128(old_stable, constants::basis_points(), old_asset);
    // Oracle observation is recorded using the reserves *before* the swap.
    // This ensures that the TWAP accurately reflects the price at the beginning of the swap.
    write_observation(
        &mut pool.oracle,
        timestamp,
        old_price,
    );
    
    // Also update ring buffer oracle for continuous price feeds
    ring_buffer_oracle::write(&mut pool.ring_buffer_oracle, old_price, clock);

    // Update reserves. The amount added to the stable reserve is the portion used for the swap
    // PLUS the LP share of the fee. The protocol share was already removed.
    let new_stable_reserve = pool.stable_reserve + amount_in_after_fee + lp_share;
    assert!(new_stable_reserve >= pool.stable_reserve, EOverflow);

    pool.stable_reserve = new_stable_reserve;
    pool.asset_reserve = pool.asset_reserve - amount_out;

    let current_price = get_current_price(pool);
    check_price_under_max(current_price);

    event::emit(SwapEvent {
        market_id: pool.market_id,
        outcome: pool.outcome_idx,
        is_buy: true,
        amount_in, // Original amount for event logging
        amount_out,
        price_impact,
        price: current_price,
        sender: ctx.sender(),
        asset_reserve: pool.asset_reserve,
        stable_reserve: pool.stable_reserve,
        timestamp,
    });

    amount_out
}

// === Liquidity Functions ===

/// Add liquidity proportionally to the AMM pool
/// Only handles calculations and reserve updates, no token operations
/// Returns the amount of LP tokens to mint
public fun add_liquidity_proportional(
    pool: &mut LiquidityPool,
    asset_amount: u64,
    stable_amount: u64,
    min_lp_out: u64,
    clock: &Clock,
    ctx: &TxContext,
): u64 {
    assert!(asset_amount > 0, EZeroAmount);
    assert!(stable_amount > 0, EZeroAmount);
    
    // Calculate LP tokens to mint based on current pool state
    let (lp_to_mint, new_lp_supply) = if (pool.lp_supply == 0) {
        // First liquidity provider - bootstrap the pool
        let k_squared = math::mul_div_to_128(asset_amount, stable_amount, 1);
        let k = (math::sqrt_u128(k_squared) as u64);
        assert!(k > (MINIMUM_LIQUIDITY as u64), ELowLiquidity);
        // For the first liquidity provider, a small amount of LP tokens (MINIMUM_LIQUIDITY)
        // is intentionally burned and locked in the pool. This is a standard practice in Uniswap V2
        // to prevent division-by-zero errors and to ensure that LP token prices are always well-defined.
        // This amount is accounted for in the `lp_supply` but is not redeemable.
        let locked = (MINIMUM_LIQUIDITY as u64);
        let minted = k - locked;
        // Return the minted amount and the resulting total supply
        (minted, k)
    } else {
        // Subsequent providers - mint proportionally
        // The `math::min` function is used here, similar to Uniswap V2, to calculate the LP tokens to mint.
        // This approach inherently protects against adding imbalanced liquidity by only considering the
        // smaller of the two potential LP amounts derived from asset and stable contributions.
        //
        // Additionally, the `assert!` statement below provides explicit ratio validation (slippage protection)
        // to ensure that the provided asset and stable amounts are close to the current pool ratio,
        // preventing users from adding liquidity at highly unfavorable rates.
        let expected_stable_amount = math::mul_div_to_64(asset_amount, pool.stable_reserve, pool.asset_reserve);
        let expected_asset_amount = math::mul_div_to_64(stable_amount, pool.asset_reserve, pool.stable_reserve);

        // Use a tolerance of 0.1% (10 basis points) to allow for small rounding differences
        // while still preventing imbalanced liquidity attacks
        let tolerance_bps = 10; // 0.1%
        assert!(
            math::within_tolerance(stable_amount, expected_stable_amount, tolerance_bps) && 
            math::within_tolerance(asset_amount, expected_asset_amount, tolerance_bps), 
            EInvalidLiquidityRatio
        );

        let lp_from_asset = math::mul_div_to_64(asset_amount, pool.lp_supply, pool.asset_reserve);
        let lp_from_stable = math::mul_div_to_64(stable_amount, pool.lp_supply, pool.stable_reserve);
        // Use minimum to ensure proper ratio
        let minted = math::min(lp_from_asset, lp_from_stable);
        (minted, pool.lp_supply + minted)
    };
    
    // Slippage protection: ensure LP tokens minted meet minimum expectation
    assert!(lp_to_mint >= min_lp_out, EExcessiveSlippage);
    
    // Update reserves with overflow checks
    let new_asset_reserve = pool.asset_reserve + asset_amount;
    let new_stable_reserve = pool.stable_reserve + stable_amount;
    // Use the precomputed total supply
    
    // Check for overflow
    assert!(new_asset_reserve >= pool.asset_reserve, EOverflow);
    assert!(new_stable_reserve >= pool.stable_reserve, EOverflow);
    assert!(new_lp_supply >= pool.lp_supply, EOverflow);
    
    pool.asset_reserve = new_asset_reserve;
    pool.stable_reserve = new_stable_reserve;
    pool.lp_supply = new_lp_supply;
    
    // Update ring buffer oracle with new price after liquidity change
    let new_price = get_current_price(pool);
    ring_buffer_oracle::write(&mut pool.ring_buffer_oracle, new_price, clock);
    
    event::emit(LiquidityAdded {
        market_id: pool.market_id,
        outcome: pool.outcome_idx,
        asset_amount,
        stable_amount,
        lp_amount: lp_to_mint,
        sender: ctx.sender(),
        timestamp: clock.timestamp_ms(),
    });

    lp_to_mint
}

/// Remove liquidity proportionally from the AMM pool
/// Only handles calculations and reserve updates, no token operations
/// Returns the amounts of asset and stable tokens to mint
public fun remove_liquidity_proportional(
    pool: &mut LiquidityPool,
    lp_amount: u64,
    clock: &Clock,
    ctx: &TxContext
): (u64, u64) {
    // Check for zero liquidity in the pool first to provide a more accurate error message
    assert!(pool.lp_supply > 0, EZeroLiquidity);
    assert!(lp_amount > 0, EZeroAmount);
    
    // Calculate proportional share to remove from this AMM
    let asset_to_remove = math::mul_div_to_64(lp_amount, pool.asset_reserve, pool.lp_supply);
    let stable_to_remove = math::mul_div_to_64(lp_amount, pool.stable_reserve, pool.lp_supply);
    
    // Ensure minimum liquidity remains
    assert!(pool.asset_reserve > asset_to_remove, EPoolEmpty);
    assert!(pool.stable_reserve > stable_to_remove, EPoolEmpty);
    assert!(pool.lp_supply > lp_amount, EInsufficientLPTokens);
    
    // Ensure remaining liquidity is above minimum threshold
    let remaining_asset = pool.asset_reserve - asset_to_remove;
    let remaining_stable = pool.stable_reserve - stable_to_remove;
    let remaining_k = math::mul_div_to_128(remaining_asset, remaining_stable, 1);
    assert!(remaining_k >= (MINIMUM_LIQUIDITY as u128), ELowLiquidity);
    
    // Update pool state (underflow already checked by earlier asserts)
    pool.asset_reserve = pool.asset_reserve - asset_to_remove;
    pool.stable_reserve = pool.stable_reserve - stable_to_remove;
    pool.lp_supply = pool.lp_supply - lp_amount;
    
    // Update ring buffer oracle with new price after liquidity change
    let new_price = get_current_price(pool);
    ring_buffer_oracle::write(&mut pool.ring_buffer_oracle, new_price, clock);

    event::emit(LiquidityRemoved {
        market_id: pool.market_id,
        outcome: pool.outcome_idx,
        asset_amount: asset_to_remove,
        stable_amount: stable_to_remove,
        lp_amount,
        sender: ctx.sender(),
        timestamp: clock.timestamp_ms(),
    });
    
    (asset_to_remove, stable_to_remove)
}

public fun empty_all_amm_liquidity(
    pool: &mut LiquidityPool,
    _ctx: &mut TxContext,
): (u64, u64) {
    // This function is now only used in the final step of the old model and can be deprecated/removed.
    // Or kept for admin/emergency purposes.
    let asset_amount_out = pool.asset_reserve;
    let stable_amount_out = pool.stable_reserve;
    pool.asset_reserve = 0;
    pool.stable_reserve = 0;
    (asset_amount_out, stable_amount_out)
}

// === Oracle Functions ===
// Update new_oracle to be simpler:
fun write_observation(oracle: &mut Oracle, timestamp: u64, price: u128) {
    oracle.write_observation(timestamp, price)
}

public fun get_oracle(pool: &LiquidityPool): &Oracle {
    &pool.oracle
}

// === View Functions ===

public fun get_reserves(pool: &LiquidityPool): (u64, u64) {
    (pool.asset_reserve, pool.stable_reserve)
}

public fun get_lp_supply(pool: &LiquidityPool): u64 {
    pool.lp_supply
}

public fun get_price(pool: &LiquidityPool): u128 {
    pool.oracle.last_price()
}

public fun get_twap(pool: &mut LiquidityPool, clock: &Clock): u128 {
    update_twap_observation(pool, clock);
    pool.oracle.get_twap(clock)
}

public fun quote_swap_asset_to_stable(pool: &LiquidityPool, amount_in: u64): u64 {
    // First calculate total output
    let amount_out_before_fee = calculate_output(
        amount_in,
        pool.asset_reserve,
        pool.stable_reserve,
    );
    // Then take fee from stable output (same as swap function)
    let fee_amount = calculate_fee(amount_out_before_fee, pool.fee_percent);
    amount_out_before_fee - fee_amount
}

public fun quote_swap_stable_to_asset(pool: &LiquidityPool, amount_in: u64): u64 {
    let amount_in_with_fee = amount_in - calculate_fee(amount_in, pool.fee_percent);
    calculate_output(
        amount_in_with_fee,
        pool.stable_reserve,
        pool.asset_reserve,
    )
}

fun calculate_price_impact(
    amount_in: u64,
    reserve_in: u64,
    amount_out: u64,
    reserve_out: u64,
): u128 {
    // Use u256 for intermediate calculations to prevent overflow
    let amount_in_256 = (amount_in as u256);
    let reserve_out_256 = (reserve_out as u256);
    let reserve_in_256 = (reserve_in as u256);
    
    // Calculate ideal output with u256 to prevent overflow
    let ideal_out_256 = (amount_in_256 * reserve_out_256) / reserve_in_256;
    assert!(ideal_out_256 <= (std::u128::max_value!() as u256), EOverflow);
    let ideal_out = (ideal_out_256 as u128);
    
    // The assert below ensures that `ideal_out` is always greater than or equal to `amount_out`.
    // This prevents underflow when calculating `ideal_out - (amount_out as u128)`.
    assert!(ideal_out >= (amount_out as u128), EOverflow); // Ensure no underflow
    math::mul_div_mixed(ideal_out - (amount_out as u128), FEE_SCALE, ideal_out)
}

// Update the LiquidityPool struct price calculation to use TWAP:
public fun get_current_price(pool: &LiquidityPool): u128 {
    assert!(pool.asset_reserve > 0 && pool.stable_reserve > 0, EZeroLiquidity);

    let price = math::mul_div_to_128(
        pool.stable_reserve,
        constants::basis_points(),
        pool.asset_reserve,
    );

    price
}

public fun update_twap_observation(pool: &mut LiquidityPool, clock: &Clock) {
    let timestamp = clock.timestamp_ms();
    let current_price = get_current_price(pool);
    // Use the sum of reserves as a liquidity measure
    pool.oracle.write_observation(timestamp, current_price);
}

public fun set_oracle_start_time(pool: &mut LiquidityPool, state: &MarketState) {
    assert!(get_ms_id(pool) == state.market_id(), EMarketIdMismatch);
    let trading_start_time = state.get_trading_start();
    pool.oracle.set_oracle_start_time(trading_start_time);
}

// === Private Functions ===
fun calculate_fee(amount: u64, fee_percent: u64): u64 {
    math::mul_div_to_64(amount, fee_percent, FEE_SCALE)
}

public fun calculate_output(
    amount_in_with_fee: u64,
    reserve_in: u64,
    reserve_out: u64,
): u64 {
    assert!(reserve_in > 0 && reserve_out > 0, EPoolEmpty);

    let denominator = reserve_in + amount_in_with_fee;
    assert!(denominator > 0, EDivByZero);
    let numerator = (amount_in_with_fee as u256) * (reserve_out as u256);
    let output = numerator / (denominator as u256);
    assert!(output <= (u64::max_value!() as u256), EOverflow);
    (output as u64)
}

public fun get_outcome_idx(pool: &LiquidityPool): u8 {
    pool.outcome_idx
}

public fun get_id(pool: &LiquidityPool): ID {
    pool.id.to_inner()
}

public fun get_k(pool: &LiquidityPool): u128 {
    math::mul_div_to_128(pool.asset_reserve, pool.stable_reserve, 1)
}

public fun check_price_under_max(price: u128) {
    let max_price = (0xFFFFFFFFFFFFFFFFu64 as u128) * (constants::basis_points() as u128);
    assert!(price <= max_price, EPriceTooHigh)
}

public fun get_protocol_fees(pool: &LiquidityPool): u64 {
    pool.protocol_fees
}

public fun get_ms_id(pool: &LiquidityPool): ID {
    pool.market_id
}

public fun reset_protocol_fees(pool: &mut LiquidityPool) {
    pool.protocol_fees = 0;
}

// === Test Functions ===
#[test_only]
public fun create_test_pool(
    market_id: ID,
    outcome_idx: u8,
    fee_percent: u64,
    asset_reserve: u64,
    stable_reserve: u64,
    ctx: &mut TxContext,
): LiquidityPool {
    LiquidityPool {
        id: object::new(ctx),
        market_id,
        outcome_idx,
        asset_reserve,
        stable_reserve,
        fee_percent,
        oracle: oracle::new_oracle(
            math::mul_div_to_128(stable_reserve, 1_000_000_000_000, asset_reserve),
            0, // Use 0 which is always a valid multiple of TWAP_PRICE_CAP_WINDOW
            1_000,
            ctx, // Add ctx parameter here
        ),
        ring_buffer_oracle: ring_buffer_oracle::new(1440), // 24 hours of observations
        protocol_fees: 0,
        lp_supply: (MINIMUM_LIQUIDITY as u64),
    }
}

#[test_only]
public fun destroy_for_testing(pool: LiquidityPool) {
    let LiquidityPool {
        id,
        market_id: _,
        outcome_idx: _,
        asset_reserve: _,
        stable_reserve: _,
        fee_percent: _,
        oracle,
        ring_buffer_oracle,
        protocol_fees: _,
        lp_supply: _,
    } = pool;
    id.delete();
    oracle.destroy_for_testing();
    ring_buffer_oracle::destroy_for_testing(ring_buffer_oracle);
}
module futarchy_markets::market_state;

use std::string::String;
use sui::clock::Clock;
use sui::event;

// === Introduction ===
// This module tracks proposal life cycle and acts as a source of truth for proposal state

// === Errors ===
const ETradingAlreadyStarted: u64 = 0;
const EOutcomeOutOfBounds: u64 = 1;
const EAlreadyFinalized: u64 = 2;
const ETradingAlreadyEnded: u64 = 3;
const ETradingNotEnded: u64 = 4;
const ENotFinalized: u64 = 5;
const ETradingNotStarted: u64 = 6;
const EInvalidDuration: u64 = 7;

// === Constants ===
const MAX_TRADING_DURATION_MS: u64 = 30 * 24 * 60 * 60 * 1000; // 30 days

// === Structs ===
public struct MarketStatus has copy, drop, store {
    trading_started: bool,
    trading_ended: bool,
    finalized: bool,
}

public struct MarketState has key, store {
    id: UID,
    market_id: ID,
    dao_id: ID,
    outcome_count: u64,
    outcome_messages: vector<String>,
    status: MarketStatus,
    winning_outcome: Option<u64>,
    creation_time: u64,
    trading_start: u64,
    trading_end: Option<u64>,
    finalization_time: Option<u64>,
}

// === Events ===
public struct TradingStartedEvent has copy, drop {
    market_id: ID,
    start_time: u64,
}

public struct TradingEndedEvent has copy, drop {
    market_id: ID,
    timestamp_ms: u64,
}

public struct MarketStateFinalizedEvent has copy, drop {
    market_id: ID,
    winning_outcome: u64,
    timestamp_ms: u64,
}

// === Public Package Functions ===
public fun new(
    market_id: ID,
    dao_id: ID,
    outcome_count: u64,
    outcome_messages: vector<String>,
    clock: &Clock,
    ctx: &mut TxContext,
): MarketState {
    let timestamp = clock.timestamp_ms();

    MarketState {
        id: object::new(ctx),
        market_id,
        dao_id,
        outcome_count,
        outcome_messages,
        status: MarketStatus {
            trading_started: false,
            trading_ended: false,
            finalized: false,
        },
        winning_outcome: option::none(),
        creation_time: timestamp,
        trading_start: 0,
        trading_end: option::none(),
        finalization_time: option::none(),
    }
}

public fun start_trading(state: &mut MarketState, duration_ms: u64, clock: &Clock) {
    assert!(!state.status.trading_started, ETradingAlreadyStarted);
    assert!(duration_ms > 0 && duration_ms <= MAX_TRADING_DURATION_MS, EInvalidDuration);

    let start_time = clock.timestamp_ms();
    let end_time = start_time + duration_ms;

    state.status.trading_started = true;
    state.trading_start = start_time;
    state.trading_end = option::some(end_time);

    event::emit(TradingStartedEvent {
        market_id: state.market_id,
        start_time,
    });
}

// === Public Functions ===
public fun assert_trading_active(state: &MarketState) {
    assert!(state.status.trading_started, ETradingNotStarted);
    assert!(!state.status.trading_ended, ETradingAlreadyEnded);
}

public fun assert_in_trading_or_pre_trading(state: &MarketState) {
    assert!(!state.status.trading_ended, ETradingAlreadyEnded);
    assert!(!state.status.finalized, EAlreadyFinalized);
}

public fun end_trading(state: &mut MarketState, clock: &Clock) {
    assert!(state.status.trading_started, ETradingNotStarted);
    assert!(!state.status.trading_ended, ETradingAlreadyEnded);

    let timestamp = clock.timestamp_ms();
    state.status.trading_ended = true;

    event::emit(TradingEndedEvent {
        market_id: state.market_id,
        timestamp_ms: timestamp,
    });
}

public fun finalize(state: &mut MarketState, winner: u64, clock: &Clock) {
    assert!(state.status.trading_ended, ETradingNotEnded);
    assert!(!state.status.finalized, EAlreadyFinalized);
    assert!(winner < state.outcome_count, EOutcomeOutOfBounds);

    let timestamp = clock.timestamp_ms();
    state.status.finalized = true;
    state.winning_outcome = option::some(winner);
    state.finalization_time = option::some(timestamp);

    event::emit(MarketStateFinalizedEvent {
        market_id: state.market_id,
        winning_outcome: winner,
        timestamp_ms: timestamp,
    });
}

// === Assertion Functions ===
public fun assert_market_finalized(state: &MarketState) {
    assert!(state.status.finalized, ENotFinalized);
}

public fun assert_not_finalized(state: &MarketState) {
    assert!(!state.status.finalized, EAlreadyFinalized);
}

public fun validate_outcome(state: &MarketState, outcome: u64) {
    assert!(outcome < state.outcome_count, EOutcomeOutOfBounds);
}

// === View Functions (Getters) ===
public fun market_id(state: &MarketState): ID {
    state.market_id
}

public fun outcome_count(state: &MarketState): u64 {
    state.outcome_count
}

// === View Functions (Predicates) ===
public fun is_trading_active(state: &MarketState): bool {
    state.status.trading_started && !state.status.trading_ended
}

public fun is_finalized(state: &MarketState): bool {
    state.status.finalized
}

public fun dao_id(state: &MarketState): ID {
    state.dao_id
}

public fun get_winning_outcome(state: &MarketState): u64 {
    use std::option;
    assert!(state.status.finalized, ENotFinalized);
    let opt_ref = &state.winning_outcome;
    assert!(option::is_some(opt_ref), ENotFinalized);
    *option::borrow(opt_ref)
}

public fun get_outcome_message(state: &MarketState, outcome_idx: u64): String {
    assert!(outcome_idx < state.outcome_count, EOutcomeOutOfBounds);
    state.outcome_messages[outcome_idx]
}

public fun get_creation_time(state: &MarketState): u64 {
    state.creation_time
}

public fun get_trading_end_time(state: &MarketState): Option<u64> {
    state.trading_end
}

public fun get_trading_start(state: &MarketState): u64 {
    state.trading_start
}

public fun get_finalization_time(state: &MarketState): Option<u64> {
    state.finalization_time
}

// === Test Functions ===
#[test_only]
public fun create_for_testing(outcomes: u64, ctx: &mut TxContext): MarketState {
    let dummy_id = object::new(ctx);
    let market_id = dummy_id.uid_to_inner();
    dummy_id.delete();

    MarketState {
        id: object::new(ctx),
        market_id,
        dao_id: market_id,
        outcome_messages: vector[],
        outcome_count: outcomes,
        status: MarketStatus {
            trading_started: false,
            trading_ended: false,
            finalized: false,
        },
        winning_outcome: option::none(),
        creation_time: 0,
        trading_start: 0,
        trading_end: option::none(),
        finalization_time: option::none(),
    }
}

#[test_only]
public fun init_trading_for_testing(state: &mut MarketState) {
    state.status.trading_started = true;
    state.trading_start = 0;
    state.trading_end = option::some(9999999999999);
}
#[test_only]
public fun reset_state_for_testing(state: &mut MarketState) {
    state.status.trading_started = false;
    state.trading_start = 0;
}

#[test_only]
public fun finalize_for_testing(state: &mut MarketState) {
    state.status.trading_ended = true;
    state.status.finalized = true;
    state.winning_outcome = option::some(0);
    state.finalization_time = option::some(0);
}

#[test_only]
public fun destroy_for_testing(state: MarketState) {
    sui::test_utils::destroy(state);
}

#[test_only]
public fun copy_market_id(state: &MarketState): ID {
    state.market_id
}

#[test_only]
public fun copy_status(state: &MarketState): MarketStatus {
    state.status
}

#[test_only]
public fun copy_winning_outcome(state: &MarketState): Option<u64> {
    state.winning_outcome
}

#[test_only]
public fun test_set_winning_outcome(state: &mut MarketState, outcome: u64) {
    state.winning_outcome = option::some(outcome);
}

#[test_only]
public fun test_set_finalized(state: &mut MarketState) {
    state.status.finalized = true;
    state.status.trading_ended = true;
    state.finalization_time = option::some(0);
}
module futarchy_markets::liquidity_initialize;

use futarchy_markets::conditional_amm::{Self, LiquidityPool};
use futarchy_markets::coin_escrow::TokenEscrow;
use futarchy_markets::conditional_token as token;
use sui::balance::Balance;
use sui::clock::Clock;

// === Introduction ===
// Method to initialize AMM liquidity

// === Errors ===
const EInitAssetReservesMismatch: u64 = 100;
const EInitStableReservesMismatch: u64 = 101;
const EInitPoolCountMismatch: u64 = 102;
const EInitPoolOutcomeMismatch: u64 = 103;
const EInitZeroLiquidity: u64 = 104;

// === Public Functions ===
public fun create_outcome_markets<AssetType, StableType>(
    escrow: &mut TokenEscrow<AssetType, StableType>,
    outcome_count: u64,
    asset_amounts: vector<u64>,
    stable_amounts: vector<u64>,
    twap_start_delay: u64,
    twap_initial_observation: u128,
    twap_step_max: u64,
    amm_total_fee_bps: u64,
    initial_asset: Balance<AssetType>,
    initial_stable: Balance<StableType>,
    clock: &Clock,
    ctx: &mut TxContext,
): (vector<ID>, vector<LiquidityPool>) {
    assert!(asset_amounts.length() == outcome_count, EInitAssetReservesMismatch);
    assert!(stable_amounts.length() == outcome_count, EInitStableReservesMismatch);
    
    // Validate that all amounts are non-zero to prevent division by zero in AMM calculations
    let mut j = 0;
    while (j < outcome_count) {
        assert!(asset_amounts[j] > 0, EInitZeroLiquidity);
        assert!(stable_amounts[j] > 0, EInitZeroLiquidity);
        j = j + 1;
    };

    let mut supply_ids = vector[];
    let mut amm_pools = vector[];

    // 1. Create supplies and register them for each outcome
    let mut i = 0;
    while (i < outcome_count) {
        // Use same pattern as original to avoid borrow issues
        {
            let ms = escrow.get_market_state(); // Immutable borrow
            let asset_supply = token::new_supply(ms, 0, (i as u8), ctx);
            let stable_supply = token::new_supply(ms, 1, (i as u8), ctx);
            let lp_supply = token::new_supply(ms, 2, (i as u8), ctx);

            // Record their IDs (asset, stable, lp for each outcome)
            let asset_supply_id = object::id(&asset_supply);
            let stable_supply_id = object::id(&stable_supply);
            let lp_supply_id = object::id(&lp_supply);
            supply_ids.push_back(asset_supply_id);
            supply_ids.push_back(stable_supply_id);
            supply_ids.push_back(lp_supply_id);

            // Register
            escrow.register_supplies(i, asset_supply, stable_supply, lp_supply);
        };

        i = i + 1;
    };

    // 2. Deposit liquidity and handle differential minting in one step
    escrow.deposit_initial_liquidity(
        outcome_count,
        &asset_amounts,
        &stable_amounts,
        initial_asset,
        initial_stable,
        clock,
        ctx,
    );

    // 3. Create AMM pools for each outcome - same as original
    i = 0;
    while (i < outcome_count) {
        let asset_amt = asset_amounts[i];
        let stable_amt = stable_amounts[i];

        // Use same scoped borrow pattern as original
        {
            let ms = escrow.get_market_state(); // Immutable borrow
            let pool = conditional_amm::new_pool(
                ms,
                (i as u8),
                amm_total_fee_bps,
                asset_amt,
                stable_amt,
                twap_initial_observation,
                twap_start_delay,
                twap_step_max,
                ctx,
            );
            amm_pools.push_back(pool);
        };

        i = i + 1;
    };

    assert_initial_reserves_consistency<AssetType, StableType>(escrow, &amm_pools);

    (supply_ids, amm_pools)
}

fun assert_initial_reserves_consistency<AssetType, StableType>(
    escrow: &TokenEscrow<AssetType, StableType>,
    amm_pools: &vector<LiquidityPool>,
) {
    let outcome_count = escrow.get_market_state().outcome_count();

    assert!(amm_pools.length() == outcome_count, EInitPoolCountMismatch);

    let (escrow_asset, escrow_stable) = escrow.get_balances();

    let mut i = 0;
    while (i < outcome_count) {
        let pool = &amm_pools[i];

        assert!(pool.get_outcome_idx() == (i as u8), EInitPoolOutcomeMismatch);

        let (amm_asset, amm_stable) = pool.get_reserves();
        let protocol_fees = pool.get_protocol_fees();
        assert!(protocol_fees == 0, EInitStableReservesMismatch); // Fees must be 0 initially

        let (
            _fetched_escrow_asset,
            _fetched_escrow_stable,
            asset_total_supply,
            stable_total_supply,
        ) = escrow.get_escrow_balances_and_supply(i);

        // --- Perform the Core Assertions ---

        // Verify asset equation: AMM asset reserves + asset token supply = total escrow asset
        assert!(amm_asset + asset_total_supply == escrow_asset, EInitAssetReservesMismatch);

        // Verify stable equation: AMM stable reserves + protocol fees (0) + stable token supply = total escrow stable
        assert!(
            amm_stable + protocol_fees + stable_total_supply == escrow_stable, // protocol_fees is 0 here
            EInitStableReservesMismatch,
        );

        i = i + 1;
    };
}
module futarchy_markets::coin_escrow;

use futarchy_markets::conditional_token::{Self as token, ConditionalToken, Supply};
use futarchy_markets::market_state::MarketState;
use futarchy_markets::spot_amm;
use sui::balance::{Self, Balance};
use sui::clock::Clock;
use sui::coin::Coin;
use sui::event;

// === Introduction ===
// The TokenEscrow manages the relationship between spot tokens and conditional tokens
// in the futarchy prediction market system.
//
// === Live-Flow Model Integration ===
// In the live-flow model, the escrow plays a critical role:
// 1. **Minting Complete Sets**: When LPs add liquidity during active proposals,
//    spot tokens are converted to complete sets of conditional tokens (one for each outcome)
// 2. **Redeeming Complete Sets**: When LPs remove liquidity, conditional tokens
//    are redeemed back to spot tokens
// 3. **Supply Tracking**: Maintains Supply objects for each outcome's tokens
//
// This enables the key innovation: LPs can freely add/remove liquidity even while
// proposals are active, as their spot tokens are automatically converted to/from
// conditional tokens as needed.
//
// === CRITICAL: Market Finalization and LP Token Conversion ===
//
// **Key Points:**
// 1. **Finalization is a One-Way Door**: Once a market is finalized, NO conditional token
//    operations (swaps, mints) are allowed. Only redemption and LP conversion are permitted.
//
// 2. **LP Token 1:1 Exchange**: Conditional LP tokens and spot LP tokens use identical amounts.
//    When liquidity moves from conditional AMM to spot AMM during finalization, the LP token
//    amounts remain the same. This is a simple 1:1 burn-and-mint operation.
//
// 3. **Conditional LP Cannot Be Redeemed for Underlying**: After finalization, conditional LP
//    tokens from the winning outcome CANNOT be redeemed for underlying asset/stable tokens.
//    They can ONLY be converted to spot LP tokens via convert_winning_lp_to_spot_lp().
//    Before finalization, conditional LP tokens can be burned to withdraw conditional tokens
//    from the AMM (via remove_liquidity), but after finalization this is not allowed.
//
// 4. **Liquidity Movement During Finalization**: The actual liquidity (asset and stable tokens)
//    is transferred from the winning conditional AMM to the spot AMM during finalization.
//    The LP tokens just track ownership shares - they don't hold the liquidity themselves.
//
// **Function Restrictions by Phase:**
//
// BEFORE Finalization (Market Active):
// - ✅ mint_single_conditional_token() - Create new conditional tokens
// - ✅ mint_complete_set_asset/stable() - Mint complete sets
// - ✅ deposit_initial_liquidity() - Add conditional tokens to AMM, receive conditional LP tokens
// - ✅ remove_liquidity() - Burn conditional LP tokens, receive conditional tokens back
// - ✅ swap_token_asset_to_stable() - Swap between conditional tokens
// - ✅ swap_token_stable_to_asset() - Swap between conditional tokens
// - ✅ redeem_complete_set() - Redeem complete sets back to spot
// - ❌ redeem_winning_tokens() - Not allowed until finalized
// - ❌ convert_winning_lp_to_spot_lp() - Not allowed until finalized
//
// AFTER Finalization (Market Settled):
// - ❌ mint_single_conditional_token() - No new minting allowed
// - ❌ mint_complete_set_asset/stable() - No new minting allowed
// - ❌ deposit_initial_liquidity() - Cannot add liquidity to conditional AMMs
// - ❌ remove_liquidity() - Cannot remove liquidity from conditional AMMs
// - ❌ swap_token_asset_to_stable() - No swapping allowed
// - ❌ swap_token_stable_to_asset() - No swapping allowed
// - ❌ redeem_complete_set() - Cannot form complete sets anymore
// - ✅ redeem_winning_tokens_asset/stable() - Redeem winning outcome tokens
// - ✅ convert_winning_lp_to_spot_lp() - Convert winning LP tokens 1:1 to spot LP
// - ✅ burn_losing_lp_tokens() - Burn worthless losing outcome LP tokens
//
// **Security Invariants:**
// - The 1:1 LP conversion preserves ownership percentages exactly
// - No value can be created or destroyed during conversion
// - The underlying liquidity has already moved; LP conversion just updates token type
// - These restrictions prevent any manipulation after market settlement

// === Errors ===
const EInsufficientBalance: u64 = 0; // Token balance insufficient for operation
const EIncorrectSequence: u64 = 1; // Tokens not provided in correct sequence/order
const EWrongMarket: u64 = 2; // Token belongs to different market
const EWrongTokenType: u64 = 3; // Wrong token type (asset vs stable)
const ESuppliesNotInitialized: u64 = 4; // Token supplies not yet initialized
const EOutcomeOutOfBounds: u64 = 5; // Outcome index exceeds market outcomes
const EWrongOutcome: u64 = 6; // Token outcome doesn't match expected
const ENotEnough: u64 = 7; // Not enough tokens/balance for operation
const ENotEnoughLiquidity: u64 = 8; // Insufficient liquidity in escrow
const EInsufficientAsset: u64 = 9; // Not enough asset tokens provided
const EInsufficientStable: u64 = 10; // Not enough stable tokens provided
const EMarketNotExpired: u64 = 11; // Market hasn't reached expiry period
const EBadWitness: u64 = 12; // Invalid one-time witness
const EZeroAmount: u64 = 13; // Amount must be greater than zero
const EInvalidAssetType: u64 = 14; // Asset type must be 0 (asset) or 1 (stable)
const EOverflow: u64 = 15; // Arithmetic overflow protection
const EInvariantViolation: u64 = 16; // Differential minting invariant violated

// === Constants ===
const TOKEN_TYPE_ASSET: u8 = 0;
const TOKEN_TYPE_STABLE: u8 = 1;
const TOKEN_TYPE_LP: u8 = 2;
const ETokenTypeMismatch: u64 = 100;
const MARKET_EXPIRY_PERIOD_MS: u64 = 2_592_000_000; // 30 days in ms

// === Structs ===
public struct TokenEscrow<phantom AssetType, phantom StableType> has key, store {
    id: UID,
    market_state: MarketState,
    // Central balances used for tokens and liquidity
    escrowed_asset: Balance<AssetType>,
    escrowed_stable: Balance<StableType>,
    // Token supplies for tracking issuance
    outcome_asset_supplies: vector<Supply>,
    outcome_stable_supplies: vector<Supply>,
    outcome_lp_supplies: vector<Supply>,
    // Track final amounts from winning pool for LP conversion invariance
    winning_pool_final_asset: u64,
    winning_pool_final_stable: u64,
    // Track original winning LP supply for conversion invariant
    winning_lp_supply_at_finalization: u64,
    // Track total LP converted so far to ensure no over-conversion
    winning_lp_converted: u64,
}

public struct COIN_ESCROW has drop {}

// === Events ===
public struct LiquidityWithdrawal has copy, drop {
    escrowed_asset: u64,
    escrowed_stable: u64,
    asset_amount: u64,
    stable_amount: u64,
}

public struct LiquidityDeposit has copy, drop {
    escrowed_asset: u64,
    escrowed_stable: u64,
    asset_amount: u64,
    stable_amount: u64,
}

public struct TokenRedemption has copy, drop {
    outcome: u64,
    token_type: u8,
    amount: u64,
}
// === New Functions for Live-Flow Model ===

/// Mint a single conditional token for AMM liquidity removal
/// This function is used by the AMM when removing liquidity proportionally
public (package) fun mint_single_conditional_token<AssetType, StableType>(
    escrow: &mut TokenEscrow<AssetType, StableType>,
    asset_type: u8,
    outcome: u8,
    amount: u64,
    recipient: address,
    clock: &Clock,
    ctx: &mut TxContext,
): ConditionalToken {
    assert!(amount > 0, EZeroAmount);
    assert!(asset_type <= 2, EInvalidAssetType);
    
    // Safety checks
    escrow.market_state.assert_not_finalized();
    assert_supplies_initialized(escrow);
    
    let outcome_idx = (outcome as u64);
    assert!(outcome_idx < escrow.market_state.outcome_count(), EOutcomeOutOfBounds);
    
    // Get the appropriate supply based on token type
    let escrow_id = object::id(escrow);
    if (asset_type == TOKEN_TYPE_ASSET) {
        let supply = &mut escrow.outcome_asset_supplies[outcome_idx];
        token::mint_with_escrow(
            &escrow.market_state,
            supply,
            amount,
            recipient,
            escrow_id,
            clock,
            ctx
        )
    } else if (asset_type == TOKEN_TYPE_STABLE) {
        let supply = &mut escrow.outcome_stable_supplies[outcome_idx];
        token::mint_with_escrow(
            &escrow.market_state,
            supply,
            amount,
            recipient,
            escrow_id,
            clock,
            ctx
        )
    } else {
        let supply = &mut escrow.outcome_lp_supplies[outcome_idx];
        token::mint_with_escrow(
            &escrow.market_state,
            supply,
            amount,
            recipient,
            escrow_id,
            clock,
            ctx
        )
    }
}

/// Burn a single conditional token - used by AMM when absorbing liquidity
public (package) fun burn_single_conditional_token<AssetType, StableType>(
    escrow: &mut TokenEscrow<AssetType, StableType>,
    token: ConditionalToken,
    clock: &Clock,
    ctx: &TxContext,
) {
    // Safety checks
    escrow.market_state.assert_not_finalized();
    assert_supplies_initialized(escrow);
    
    let asset_type = token.asset_type();
    let outcome = token.outcome();
    let outcome_idx = (outcome as u64);
    
    assert!(token.market_id() == escrow.market_state.market_id(), EWrongMarket);
    assert!(outcome_idx < escrow.market_state.outcome_count(), EOutcomeOutOfBounds);
    
    // Get the appropriate supply and burn
    if (asset_type == TOKEN_TYPE_ASSET) {
        let supply = &mut escrow.outcome_asset_supplies[outcome_idx];
        token::burn(token, supply, clock, ctx);
    } else if (asset_type == TOKEN_TYPE_STABLE) {
        let supply = &mut escrow.outcome_stable_supplies[outcome_idx];
        token::burn(token, supply, clock, ctx);
    } else {
        let supply = &mut escrow.outcome_lp_supplies[outcome_idx];
        token::burn(token, supply, clock, ctx);
    };
}

/// Mint a complete set of asset conditional tokens for all outcomes
public fun mint_complete_set_asset<AssetType, StableType>(
    escrow: &mut TokenEscrow<AssetType, StableType>,
    asset_in: Coin<AssetType>,
    _clock: &Clock,
    ctx: &mut TxContext,
): vector<ConditionalToken> {
    let amount = asset_in.value();
    assert!(amount > 0, EInsufficientAsset);
    
    // Safety checks
    escrow.market_state.assert_not_finalized();
    assert_supplies_initialized(escrow);
    
    // Deposit asset into escrow
    escrow.escrowed_asset.join(asset_in.into_balance());
    
    // Mint conditional tokens for each outcome
    let mut tokens = vector::empty();
    let outcome_count = escrow.outcome_asset_supplies.length();
    let mut i = 0;
    
    let escrow_id = object::id(escrow);
    while (i < outcome_count) {
        let supply = &mut escrow.outcome_asset_supplies[i];
        let token = token::mint_with_escrow(
            &escrow.market_state,
            supply,
            amount,
            ctx.sender(),
            escrow_id,
            _clock,
            ctx
        );
        tokens.push_back(token);
        i = i + 1;
    };
    
    tokens
}

/// Mint a complete set of stable conditional tokens for all outcomes
public fun mint_complete_set_stable<AssetType, StableType>(
    escrow: &mut TokenEscrow<AssetType, StableType>,
    stable_in: Coin<StableType>,
    _clock: &Clock,
    ctx: &mut TxContext,
): vector<ConditionalToken> {
    let amount = stable_in.value();
    assert!(amount > 0, EInsufficientStable);
    
    // Safety checks
    escrow.market_state.assert_not_finalized();
    assert_supplies_initialized(escrow);
    
    // Deposit stable into escrow
    escrow.escrowed_stable.join(stable_in.into_balance());
    
    // Mint conditional tokens for each outcome
    let mut tokens = vector::empty();
    let outcome_count = escrow.outcome_stable_supplies.length();
    let mut i = 0;
    
    let escrow_id = object::id(escrow);
    while (i < outcome_count) {
        let supply = &mut escrow.outcome_stable_supplies[i];
        let token = token::mint_with_escrow(
            &escrow.market_state,
            supply,
            amount,
            ctx.sender(),
            escrow_id,
            _clock,
            ctx
        );
        tokens.push_back(token);
        i = i + 1;
    };
    
    tokens
}

/// Redeem a complete set of asset conditional tokens back to asset
public fun redeem_complete_set_asset<AssetType, StableType>(
    escrow: &mut TokenEscrow<AssetType, StableType>,
    mut tokens: vector<ConditionalToken>,
    _clock: &Clock,
    _ctx: &mut TxContext,
): Balance<AssetType> {
    // Safety checks
    escrow.market_state.assert_not_finalized();
    assert_supplies_initialized(escrow);
    
    // Use the helper function to verify we have a complete set
    let amount = verify_token_set(escrow, &tokens, TOKEN_TYPE_ASSET);
    
    // Verify escrow has sufficient balance
    assert!(escrow.escrowed_asset.value() >= amount, EInsufficientBalance);
    
    // Burn all tokens - use the token's outcome to find the correct supply
    while (!tokens.is_empty()) {
        let token = tokens.pop_back();
        let outcome_idx = (token.outcome() as u64);
        let supply = &mut escrow.outcome_asset_supplies[outcome_idx];
        token::burn(token, supply, _clock, _ctx);
    };
    tokens.destroy_empty();
    
    // Return asset
    escrow.escrowed_asset.split(amount)
}

/// Redeem a complete set of stable conditional tokens back to stable
public fun redeem_complete_set_stable<AssetType, StableType>(
    escrow: &mut TokenEscrow<AssetType, StableType>,
    mut tokens: vector<ConditionalToken>,
    _clock: &Clock,
    _ctx: &mut TxContext,
): Balance<StableType> {
    // Safety checks
    escrow.market_state.assert_not_finalized();
    assert_supplies_initialized(escrow);
    
    // Use the helper function to verify we have a complete set
    let amount = verify_token_set(escrow, &tokens, TOKEN_TYPE_STABLE);
    
    // Verify escrow has sufficient balance
    assert!(escrow.escrowed_stable.value() >= amount, EInsufficientBalance);
    
    // Burn all tokens - use the token's outcome to find the correct supply
    while (!tokens.is_empty()) {
        let token = tokens.pop_back();
        let outcome_idx = (token.outcome() as u64);
        let supply = &mut escrow.outcome_stable_supplies[outcome_idx];
        token::burn(token, supply, _clock, _ctx);
    };
    tokens.destroy_empty();
    
    // Return stable
    escrow.escrowed_stable.split(amount)
}

public fun new<AssetType, StableType>(
    market_state: MarketState,
    ctx: &mut TxContext,
): TokenEscrow<AssetType, StableType> {
    TokenEscrow {
        id: object::new(ctx),
        market_state,
        escrowed_asset: balance::zero(), // Initial liquidity goes directly to escrowed
        escrowed_stable: balance::zero(),
        outcome_asset_supplies: vector[],
        outcome_stable_supplies: vector[],
        outcome_lp_supplies: vector[],
        winning_pool_final_asset: 0,
        winning_pool_final_stable: 0,
        winning_lp_supply_at_finalization: 0,
        winning_lp_converted: 0,
    }
}

public fun register_supplies<AssetType, StableType>(
    escrow: &mut TokenEscrow<AssetType, StableType>,
    outcome_idx: u64,
    asset_supply: Supply,
    stable_supply: Supply,
    lp_supply: Supply,
) {
    let outcome_count = escrow.market_state.outcome_count();
    assert!(outcome_idx < outcome_count, EOutcomeOutOfBounds);
    assert!(escrow.outcome_asset_supplies.length() == outcome_idx, EIncorrectSequence);

    escrow.outcome_asset_supplies.push_back(asset_supply);
    escrow.outcome_stable_supplies.push_back(stable_supply);
    escrow.outcome_lp_supplies.push_back(lp_supply);
}

/// Deposits initial liquidity into the escrow and implements "differential minting" mechanism.
/// 
/// ## Differential Minting Economics
/// This function implements a critical economic mechanism called "differential minting" which maintains
/// the complete-set conservation invariant. When initial liquidity is deposited:
/// 
/// 1. The function calculates the maximum liquidity needed across all outcomes
/// 2. For outcomes that require less than the maximum liquidity, the difference is minted 
///    as conditional tokens and transferred to the liquidity provider (market activator)
/// 3. This ensures that the total value in the system remains conserved:
///    - Escrow Balance + Outstanding Conditional Tokens = Initial Deposit
/// 
/// ## Economic Rationale
/// The differential tokens represent the "unused" liquidity for specific outcomes. Since not all
/// outcomes need the maximum amount of liquidity, the differential tokens allow the liquidity
/// provider to reclaim this unused portion if needed, while still maintaining full collateralization.
/// 
/// ## Important Invariants
/// - The sum of AMM reserves plus conditional token supplies always equals the escrow balance
/// - Differential tokens are fully backed by the escrow and can be redeemed as part of a complete set
/// - This mechanism prevents value leakage while optimizing capital efficiency
/// 
/// ## Example
/// If outcome A needs 100 tokens and outcome B needs 80 tokens:
/// - Maximum needed: 100 tokens
/// - Escrow receives: 100 tokens  
/// - Outcome B differential: 20 conditional tokens minted to the liquidity provider
/// - These 20 tokens + 80 in the AMM = 100 total for outcome B
#[allow(lint(self_transfer))]
public fun deposit_initial_liquidity<AssetType, StableType>(
    escrow: &mut TokenEscrow<AssetType, StableType>,
    outcome_count: u64,
    asset_amounts: &vector<u64>,
    stable_amounts: &vector<u64>,
    initial_asset: Balance<AssetType>,
    initial_stable: Balance<StableType>,
    clock: &Clock,
    ctx: &mut TxContext,
) {
    let asset_amount = initial_asset.value();
    let stable_amount = initial_stable.value();
    let sender = ctx.sender();

    // 1. Add to escrow balances
    escrow.escrowed_asset.join(initial_asset);
    escrow.escrowed_stable.join(initial_stable);

    // 2. Calculate maximum amounts needed across outcomes with overflow protection
    let mut max_asset = 0u64;
    let mut max_stable = 0u64;
    let mut i = 0;
    while (i < outcome_count) {
        let asset_amt = asset_amounts[i];
        let stable_amt = stable_amounts[i];
        if (asset_amt > max_asset) { max_asset = asset_amt };
        if (stable_amt > max_stable) { max_stable = stable_amt };
        i = i + 1;
    };

    assert!(asset_amount == max_asset, EInsufficientAsset);
    assert!(stable_amount == max_stable, EInsufficientStable);

    // 3. Mint differential tokens for each outcome
    // DIFFERENTIAL MINTING: For outcomes that need less than the maximum liquidity,
    // we mint the difference as conditional tokens to the liquidity provider.
    // This maintains the invariant: AMM_reserves[i] + conditional_supply[i] = max_liquidity
    let escrow_id = object::id(escrow);
    i = 0;
    while (i < outcome_count) {
        let asset_amt = asset_amounts[i];
        let stable_amt = stable_amounts[i];

        // Mint differential asset tokens if this outcome needs less than max
        // These tokens represent the "unused" asset liquidity for this outcome
        if (asset_amt < max_asset) {
            let diff = max_asset - asset_amt;
            let asset_supply = &mut escrow.outcome_asset_supplies[i];
            let token = token::mint_with_escrow(
                &escrow.market_state,
                asset_supply,
                diff,
                sender,
                escrow_id,
                clock,
                ctx,
            );
            // Transfer differential tokens to the liquidity provider
            transfer::public_transfer(token, sender);
        };

        // Mint differential stable tokens if this outcome needs less than max
        // These tokens represent the "unused" stable liquidity for this outcome
        if (stable_amt < max_stable) {
            let diff = max_stable - stable_amt;
            let stable_supply = &mut escrow.outcome_stable_supplies[i];
            let token = token::mint_with_escrow(
                &escrow.market_state,
                stable_supply,
                diff,
                sender,
                escrow_id,
                clock,
                ctx,
            );
            // Transfer differential tokens to the liquidity provider
            transfer::public_transfer(token, sender);
        };

        i = i + 1;
    };

    // 4. INVARIANT CHECK: Verify conservation of value
    // For each outcome: AMM_reserves + minted_differential_tokens = max_liquidity
    // This ensures no value can be created or destroyed through the minting process
    verify_differential_minting_invariants(
        escrow,
        outcome_count,
        asset_amounts,
        stable_amounts,
        max_asset,
        max_stable
    );
    
    // 5. Emit event with deposit information showing final escrow balances
    event::emit(LiquidityDeposit {
        escrowed_asset: escrow.escrowed_asset.value(),  // Actual escrow balance after deposit
        escrowed_stable: escrow.escrowed_stable.value(), // Actual escrow balance after deposit
        asset_amount: asset_amount,  // Amount deposited
        stable_amount: stable_amount, // Amount deposited
    });
}

public fun remove_liquidity<AssetType, StableType>(
    escrow: &mut TokenEscrow<AssetType, StableType>,
    asset_amount: u64,
    stable_amount: u64,
    ctx: &mut TxContext,
): (Coin<AssetType>, Coin<StableType>) {
    // Changed return type

    // Verify there's enough liquidity to withdraw
    assert!(escrow.escrowed_asset.value() >= asset_amount, ENotEnoughLiquidity);
    assert!(escrow.escrowed_stable.value() >= stable_amount, ENotEnoughLiquidity);

    // Withdraw the liquidity into balances
    let asset_balance_out = escrow.escrowed_asset.split(asset_amount);
    let stable_balance_out = escrow.escrowed_stable.split(stable_amount);

    // Convert balances to coins
    let asset_coin_out = asset_balance_out.into_coin(ctx);
    let stable_coin_out = stable_balance_out.into_coin(ctx);

    // Emit event with withdrawal information (reflects state *after* split)
    event::emit(LiquidityWithdrawal {
        escrowed_asset: escrow.escrowed_asset.value(),
        escrowed_stable: escrow.escrowed_stable.value(),
        asset_amount: asset_amount, // Amount withdrawn
        stable_amount: stable_amount, // Amount withdrawn
    });

    // Return the coins instead of transferring
    (asset_coin_out, stable_coin_out)
}

public fun extract_stable_fees<AssetType, StableType>(
    escrow: &mut TokenEscrow<AssetType, StableType>,
    amount: u64,
): Balance<StableType> {
    escrow.market_state.assert_market_finalized();
    assert!(escrow.escrowed_stable.value() >= amount, ENotEnough);
    escrow.escrowed_stable.split(amount)
}

// === Private Functions ===

/// Check if supplies are properly initialized for all outcomes
fun assert_supplies_initialized<AssetType, StableType>(
    escrow: &TokenEscrow<AssetType, StableType>,
) {
    let outcome_count = escrow.market_state.outcome_count();
    assert!(
        escrow.outcome_asset_supplies.length() == outcome_count &&
                escrow.outcome_stable_supplies.length() == outcome_count &&
                escrow.outcome_lp_supplies.length() == outcome_count,
        ESuppliesNotInitialized,
    );
}

/// Helper function to verify tokens form a complete set and return the amount
fun verify_token_set<AssetType, StableType>(
    escrow: &TokenEscrow<AssetType, StableType>,
    tokens: &vector<ConditionalToken>,
    token_type: u8,
): u64 {
    // Get market details from escrow
    let market_id = escrow.market_state.market_id();
    let outcome_count = escrow.market_state.outcome_count();

    // Must have exactly one token per outcome
    assert!(tokens.length() == outcome_count, EIncorrectSequence);
    
    // Ensure tokens vector is not empty before accessing
    assert!(tokens.length() > 0, EIncorrectSequence);

    // Initialize outcomes_seen vector
    let mut outcomes_seen = vector[];
    // We still need to initialize the vector, but we can combine with the token validation
    let mut i = 0;
    while (i < outcome_count) {
        outcomes_seen.push_back(false);
        i = i + 1;
    };

    // Get amount from first token to verify consistency
    let first_token = &tokens[0];
    let amount = first_token.value();

    // Verify all tokens and mark outcomes as seen in a single pass
    i = 0;
    while (i < outcome_count) {
        let token = &tokens[i];

        // Verify all token properties comprehensively
        assert!(token.market_id() == market_id, EWrongMarket);
        assert!(token.asset_type() == token_type, EWrongTokenType);
        assert!(token.value() == amount, EInsufficientBalance);
        assert!(amount > 0, EZeroAmount);

        let outcome = token.outcome();
        let outcome_idx = (outcome as u64);

        // Verify outcome is valid and not seen before
        assert!(outcome_idx < outcome_count, EWrongOutcome);
        assert!(!outcomes_seen[outcome_idx], EWrongOutcome);

        // Mark outcome as seen
        *&mut outcomes_seen[outcome_idx] = true;
        i = i + 1;
    };

    // Ensure all outcomes are represented
    i = 0;
    while (i < outcome_count) {
        assert!(outcomes_seen[i], EWrongOutcome);
        i = i + 1;
    };

    amount
}



// Asset token redemption for winning outcome
/// Redeem winning outcome ASSET tokens after finalization
/// 
/// RESTRICTION: This function can ONLY be called AFTER market finalization.
/// Only ASSET/STABLE tokens from the WINNING outcome can be redeemed.
/// For conditional LP tokens, use convert_winning_lp_to_spot_lp() instead - they cannot be redeemed for underlying tokens.
public fun redeem_winning_tokens_asset<AssetType, StableType>(
    escrow: &mut TokenEscrow<AssetType, StableType>,
    token: ConditionalToken,
    clock: &Clock,
    ctx: &TxContext,
): Balance<AssetType> {
    // Verify market is finalized and get winning outcome
    escrow.market_state.assert_market_finalized();
    let winner = escrow.market_state.get_winning_outcome();
    assert_supplies_initialized(escrow);

    // Verify token matches winning outcome
    let winner_u8 = (winner as u8);
    assert!(token.outcome() == winner_u8, EWrongOutcome);
    assert!(token.market_id() == escrow.market_state.market_id(), EWrongMarket);
    assert!(token.asset_type() == TOKEN_TYPE_ASSET, EWrongTokenType);

    // Get token amount and burn token
    let amount = token.value();
    let winning_supply = &mut escrow.outcome_asset_supplies[winner];
    token.burn(winning_supply, clock, ctx);
    assert!(escrow.escrowed_asset.value() >= amount, EInsufficientBalance);
    // Emit redemption event
    event::emit(TokenRedemption {
        outcome: winner,
        token_type: TOKEN_TYPE_ASSET,
        amount: amount,
    });

    // Return amount from central asset balance
    escrow.escrowed_asset.split(amount)
}

// Stable token redemption for winning outcome
/// Redeem winning outcome STABLE tokens after finalization
/// 
/// RESTRICTION: This function can ONLY be called AFTER market finalization.
/// Only ASSET/STABLE tokens from the WINNING outcome can be redeemed.
/// For conditional LP tokens, use convert_winning_lp_to_spot_lp() instead - they cannot be redeemed for underlying tokens.
public fun redeem_winning_tokens_stable<AssetType, StableType>(
    escrow: &mut TokenEscrow<AssetType, StableType>,
    token: ConditionalToken,
    clock: &Clock,
    ctx: &TxContext,
): Balance<StableType> {
    // Verify market is finalized and get winning outcome
    escrow.market_state.assert_market_finalized();
    let winner = escrow.market_state.get_winning_outcome();
    assert_supplies_initialized(escrow);

    // Verify token matches winning outcome
    let winner_u8 = (winner as u8);
    assert!(token.outcome() == winner_u8, EWrongOutcome);
    assert!(token.market_id() == escrow.market_state.market_id(), EWrongMarket);
    assert!(token.asset_type() == TOKEN_TYPE_STABLE, EWrongTokenType);

    // Get token amount and burn token
    let amount = token.value();
    let winning_supply = &mut escrow.outcome_stable_supplies[winner];
    token.burn(winning_supply, clock, ctx);
    assert!(escrow.escrowed_stable.value() >= amount, EInsufficientBalance);
    // Emit redemption event
    event::emit(TokenRedemption {
        outcome: winner,
        token_type: TOKEN_TYPE_STABLE,
        amount: amount,
    });

    // Return amount from central stable balance
    escrow.escrowed_stable.split(amount)
}



/// ======= Swap Methods =========
public fun swap_token_asset_to_stable<AssetType, StableType>(
    escrow: &mut TokenEscrow<AssetType, StableType>,
    token_in: ConditionalToken,
    outcome_idx: u64,
    amount_out: u64,
    clock: &Clock,
    ctx: &mut TxContext,
): ConditionalToken {
    let ms = &escrow.market_state;
    ms.assert_trading_active();
    assert!(outcome_idx < ms.outcome_count(), EOutcomeOutOfBounds);

    let market_id = ms.market_id();
    assert!(token_in.market_id() == market_id, EWrongMarket);
    assert!(token_in.outcome() == (outcome_idx as u8), EWrongOutcome);
    assert!(token_in.asset_type() == TOKEN_TYPE_ASSET, EWrongTokenType);

    let escrow_id = object::id(escrow);
    
    let asset_supply = &mut escrow.outcome_asset_supplies[outcome_idx];
    token_in.burn(asset_supply, clock, ctx);

    let stable_supply = &mut escrow.outcome_stable_supplies[outcome_idx];
    let token = token::mint_with_escrow(
        ms,
        stable_supply,
        amount_out,
        ctx.sender(),
        escrow_id,
        clock,
        ctx,
    );
    token
}

public fun swap_token_stable_to_asset<AssetType, StableType>(
    escrow: &mut TokenEscrow<AssetType, StableType>,
    token_in: ConditionalToken,
    outcome_idx: u64,
    amount_out: u64,
    clock: &Clock,
    ctx: &mut TxContext,
): ConditionalToken {
    let ms = &escrow.market_state;
    ms.assert_trading_active();
    assert!(outcome_idx < ms.outcome_count(), EOutcomeOutOfBounds);

    let market_id = ms.market_id();
    assert!(token_in.market_id() == market_id, EWrongMarket);
    assert!(token_in.outcome() == (outcome_idx as u8), EWrongOutcome);
    assert!(token_in.asset_type() == TOKEN_TYPE_STABLE, EWrongTokenType);

    let escrow_id = object::id(escrow);
    
    let stable_supply = &mut escrow.outcome_stable_supplies[outcome_idx];
    token_in.burn(stable_supply, clock, ctx);

    let asset_supply = &mut escrow.outcome_asset_supplies[outcome_idx];
    let token = token::mint_with_escrow(
        ms,
        asset_supply,
        amount_out,
        ctx.sender(),
        escrow_id,
        clock,
        ctx,
    );
    token
}

/// Allows anyone to burn a conditional token associated with this escrow
/// if the market is finalized and the token's outcome is not the winning outcome.
public fun burn_unused_tokens<AssetType, StableType>(
    escrow: &mut TokenEscrow<AssetType, StableType>,
    mut tokens_to_burn: vector<ConditionalToken>,
    clock: &Clock,
    ctx: &TxContext,
) {
    // 1. Get Market State and verify it's finalized (check once)
    let market_state = &escrow.market_state; // Read-only borrow is sufficient for checks
    market_state.assert_market_finalized();
    assert_supplies_initialized(escrow); // Check once

    // 2. Get required information from market state (fetch once)
    let escrow_market_id = market_state.market_id();
    let winning_outcome = market_state.get_winning_outcome();
    let outcome_count = market_state.outcome_count();

    // 3. Iterate through the vector and burn eligible tokens
    while (!tokens_to_burn.is_empty()) {
        // Borrow mutably for pop_back
        let token = tokens_to_burn.pop_back();

        // a. Get token details
        let token_market_id = token.market_id();
        let token_outcome = token.outcome();
        let token_type = token.asset_type();
        let outcome_idx = (token_outcome as u64); // Index for supply vectors

        assert!(token_market_id == escrow_market_id, EWrongMarket);
        assert!(token_outcome != (winning_outcome as u8), EWrongOutcome);
        assert!(outcome_idx < outcome_count, EOutcomeOutOfBounds);

        // c. Get the appropriate supply AND burn the token within the correct branch
        if (token_type == TOKEN_TYPE_ASSET) {
            let supply_ref = &mut escrow.outcome_asset_supplies[outcome_idx];
            // burn consumes the token object
            token.burn(supply_ref, clock, ctx);
        } else if (token_type == TOKEN_TYPE_STABLE) {
            let supply_ref = &mut escrow.outcome_stable_supplies[outcome_idx];
            // burn consumes the token object
            token.burn(supply_ref, clock, ctx);
        } else if (token_type == TOKEN_TYPE_LP) {
            let supply_ref = &mut escrow.outcome_lp_supplies[outcome_idx];
            // burn consumes the token object
            token.burn(supply_ref, clock, ctx);
        } else {
            abort EWrongTokenType
        }
    };
    // 4. Destroy the now empty vector
    tokens_to_burn.destroy_empty();
}

// === LP Invariant Checking ===

/// Assert LP supply invariants for all operations
/// Called after minting, burning, or converting LP tokens
public fun assert_lp_supply_invariants<AssetType, StableType>(
    escrow: &TokenEscrow<AssetType, StableType>,
) {
    // If market is finalized, check conversion invariants
    if (escrow.market_state.is_finalized()) {
        // Total converted cannot exceed original winning supply
        assert!(
            escrow.winning_lp_converted <= escrow.winning_lp_supply_at_finalization,
            EOverflow
        );
        
        // Current winning LP supply + converted should equal original
        let winning_outcome = escrow.market_state.get_winning_outcome();
        let current_winning_supply = escrow.outcome_lp_supplies[winning_outcome].total_supply();
        assert!(
            current_winning_supply + escrow.winning_lp_converted == escrow.winning_lp_supply_at_finalization,
            EOverflow
        );
    };
    
    // Check that all LP supplies are non-negative (implicit through u64)
    // and that minting/burning operations maintain consistency
    let outcome_count = escrow.outcome_lp_supplies.length();
    let mut i = 0;
    while (i < outcome_count) {
        let supply = &escrow.outcome_lp_supplies[i];
        // Supply should always be >= 0 (guaranteed by u64 type)
        // Could add additional checks here if needed
        let _ = supply.total_supply();
        i = i + 1;
    };
}

// === View Functions ===

// Entry function that gets and emits the current escrow balances and supply information as an event
public entry fun get_escrow_balances_and_supply<AssetType, StableType>(
    escrow: &TokenEscrow<AssetType, StableType>,
    outcome: u64, // Added parameter
): (u64, u64, u64, u64) {
    // Changed return type to a tuple
    // Get current escrow balances
    let (escrowed_asset_balance, escrowed_stable_balance) = get_balances(escrow);
    let outcome_count = escrow.market_state.outcome_count();

    // Ensure the outcome index is valid
    assert!(outcome < outcome_count, EOutcomeOutOfBounds);
    // Ensure supplies were initialized
    assert_supplies_initialized(escrow);

    // Get the supply counts for the outcome directly
    let asset_supply_cap = &escrow.outcome_asset_supplies[outcome];
    let stable_supply_cap = &escrow.outcome_stable_supplies[outcome];

    let asset_total_supply = asset_supply_cap.total_supply();
    let stable_total_supply = stable_supply_cap.total_supply();

    // Return the tuple: (escrow_asset, escrow_stable, asset_supply, stable_supply)
    (escrowed_asset_balance, escrowed_stable_balance, asset_total_supply, stable_total_supply)
}

// === Package Functions ===

public fun get_balances<AssetType, StableType>(
    escrow: &TokenEscrow<AssetType, StableType>,
): (u64, u64) {
    (escrow.escrowed_asset.value(), escrow.escrowed_stable.value())
}

public fun get_market_state<AssetType, StableType>(
    escrow: &TokenEscrow<AssetType, StableType>,
): &MarketState {
    &escrow.market_state
}

public fun get_market_state_id<AssetType, StableType>(
    escrow: &TokenEscrow<AssetType, StableType>,
): ID {
    object::id(&escrow.market_state)
}

public fun get_market_state_mut<AssetType, StableType>(
    escrow: &mut TokenEscrow<AssetType, StableType>,
): &mut MarketState {
    &mut escrow.market_state
}

public fun get_stable_supply<AssetType, StableType>(
    escrow: &mut TokenEscrow<AssetType, StableType>,
    outcome_idx: u64,
): &mut Supply {
    &mut escrow.outcome_stable_supplies[outcome_idx]
}

public fun get_asset_supply<AssetType, StableType>(
    escrow: &mut TokenEscrow<AssetType, StableType>,
    outcome_idx: u64,
): &mut Supply {
    &mut escrow.outcome_asset_supplies[outcome_idx]
}

// === LP Token Finalization Functions ===

/// Convert winning outcome conditional LP tokens to spot LP tokens
/// 
/// SECURITY CRITICAL: This function maintains the invariant that:
/// 1. The proportion of LP ownership is preserved
/// 2. The total value in the system remains constant
/// 3. Each conditional LP token can only be converted once (enforced by burning)
/// 
/// INVARIANCE CHECK:
/// - Before: User owns X% of conditional LP supply for winning outcome
/// - After: User owns X% of the liquidity that was in that pool (now in spot)
/// 
/// The escrow tracks the final liquidity amounts that were extracted from the winning pool
/// during finalization. This ensures we can verify the conversion is correct.
/// 
/// IMPORTANT: This function:
/// - Can ONLY be called AFTER market finalization
/// - Can ONLY convert LP tokens from the WINNING outcome
/// - Is a simple 1:1 exchange: burns conditional LP tokens, mints spot LP tokens
/// - After finalization, NO conditional token operations are allowed - only this direct LP conversion
public fun convert_winning_lp_to_spot_lp<AssetType, StableType>(
    escrow: &mut TokenEscrow<AssetType, StableType>,
    spot_amm: &mut spot_amm::SpotAMM<AssetType, StableType>,
    conditional_lp_token: ConditionalToken,
    clock: &Clock,
    ctx: &mut TxContext,
): ID { // Returns the ID of the minted spot LP token
    // Step 1: Verify market is finalized
    assert!(escrow.market_state.is_finalized(), EMarketNotExpired);
    
    // Step 2: Verify this is the winning outcome
    let winning_outcome = escrow.market_state.get_winning_outcome();
    let token_outcome = conditional_lp_token.outcome();
    assert!((token_outcome as u64) == winning_outcome, EOutcomeOutOfBounds);
    
    // Step 3: Verify this is an LP token
    assert!(conditional_lp_token.asset_type() == TOKEN_TYPE_LP, ETokenTypeMismatch);
    
    let lp_amount = conditional_lp_token.value();
    assert!(lp_amount > 0, EZeroAmount);
    
    // Step 4: Get the LP supply for tracking
    let outcome_idx = (token_outcome as u64);
    let lp_supply = &escrow.outcome_lp_supplies[outcome_idx];
    
    // Step 5: This is a simple 1:1 exchange
    // Conditional LP tokens and spot LP tokens have the same amounts
    // since they represent the same liquidity shares
    
    // Step 7: INVARIANCE CHECK - Verify we haven't over-converted
    assert!(escrow.winning_lp_converted + lp_amount <= escrow.winning_lp_supply_at_finalization, EOverflow);
    
    // Step 8: INVARIANCE CHECK - Record state before burn
    let supply_before = lp_supply.total_supply();
    
    // Step 9: Burn the conditional LP token (this updates the supply)
    burn_single_conditional_token(escrow, conditional_lp_token, clock, ctx);
    
    // Step 10: INVARIANCE CHECK - Verify supply decreased correctly
    let supply_after = escrow.outcome_lp_supplies[outcome_idx].total_supply();
    assert!(supply_before - supply_after == lp_amount, EOverflow);
    
    // Step 11: Update conversion tracking
    escrow.winning_lp_converted = escrow.winning_lp_converted + lp_amount;
    
    // Step 12: INVARIANCE CHECK - Verify total conversions don't exceed original supply
    assert!(escrow.winning_lp_converted <= escrow.winning_lp_supply_at_finalization, EOverflow);
    
    // Step 13: Call spot AMM to mint spot LP tokens (1:1 exchange)
    // After finalization, conditional LP tokens cannot be redeemed for conditional tokens
    // They can ONLY be exchanged 1:1 for spot LP tokens
    let spot_lp_id = spot_amm::mint_lp_for_conversion(
        spot_amm,
        0, // not used - no conditional token redemption allowed
        0, // not used - no conditional token redemption allowed
        lp_amount, // 1:1 exchange - mint exact same amount of spot LP
        0, // not needed for 1:1 exchange
        escrow.market_state.market_id(),
        ctx
    );
    
    spot_lp_id
}

/// Track the final amounts that were in the winning pool before it was emptied
/// This is called during finalization when the pool is emptied
public fun record_winning_pool_final_amounts<AssetType, StableType>(
    escrow: &mut TokenEscrow<AssetType, StableType>,
    asset_amount: u64,
    stable_amount: u64,
) {
    // Store these amounts for LP conversion calculations
    escrow.winning_pool_final_asset = asset_amount;
    escrow.winning_pool_final_stable = stable_amount;
    
    // Also record the winning LP supply at finalization for invariant checking
    let winning_outcome = escrow.market_state.get_winning_outcome();
    let winning_lp_supply = &escrow.outcome_lp_supplies[winning_outcome];
    escrow.winning_lp_supply_at_finalization = winning_lp_supply.total_supply();
    
    // Reset converted counter
    escrow.winning_lp_converted = 0;
}

/// Get the final amounts that were in the winning pool
fun get_winning_pool_final_amounts<AssetType, StableType>(
    escrow: &TokenEscrow<AssetType, StableType>
): (u64, u64) {
    // Return the recorded amounts
    (escrow.winning_pool_final_asset, escrow.winning_pool_final_stable)
}


/// Burn losing outcome LP tokens
/// 
/// After finalization, LP tokens from losing outcomes have no value.
/// This function allows holders to burn these worthless tokens.
public fun burn_losing_lp_tokens<AssetType, StableType>(
    escrow: &mut TokenEscrow<AssetType, StableType>,
    conditional_lp_token: ConditionalToken,
    clock: &Clock,
    ctx: &mut TxContext,
) {
    // Verify market is finalized
    assert!(escrow.market_state.is_finalized(), EMarketNotExpired);
    
    // Verify this is NOT the winning outcome
    let winning_outcome = escrow.market_state.get_winning_outcome();
    let token_outcome = conditional_lp_token.outcome();
    assert!((token_outcome as u64) != winning_outcome, EOutcomeOutOfBounds);
    
    // Verify this is an LP token
    assert!(conditional_lp_token.asset_type() == TOKEN_TYPE_LP, ETokenTypeMismatch);
    
    // Burn the worthless LP token
    burn_single_conditional_token(escrow, conditional_lp_token, clock, ctx);
}

/// Batch burn multiple losing LP tokens
public fun burn_losing_lp_tokens_batch<AssetType, StableType>(
    escrow: &mut TokenEscrow<AssetType, StableType>,
    mut conditional_lp_tokens: vector<ConditionalToken>,
    clock: &Clock,
    ctx: &mut TxContext,
) {
    // Verify market is finalized once
    assert!(escrow.market_state.is_finalized(), EMarketNotExpired);
    let winning_outcome = escrow.market_state.get_winning_outcome();
    
    while (!conditional_lp_tokens.is_empty()) {
        let token = conditional_lp_tokens.pop_back();
        
        // Verify this is a losing outcome LP token
        let token_outcome = token.outcome();
        assert!((token_outcome as u64) != winning_outcome, EOutcomeOutOfBounds);
        assert!(token.asset_type() == TOKEN_TYPE_LP, ETokenTypeMismatch);
        
        // Burn the token
        burn_single_conditional_token(escrow, token, clock, ctx);
    };
    
    conditional_lp_tokens.destroy_empty();
}

/// Verify differential minting invariants
/// 
/// CRITICAL INVARIANTS:
/// 1. For each outcome: AMM_reserves + conditional_token_supply = max_liquidity
/// 2. Total escrow balance >= sum of all obligations (tokens + reserves)
/// 3. No value creation: escrowed_amount = max(needed_amounts)
/// 
/// This function ensures that the differential minting mechanism cannot be exploited
/// to create or destroy value. The invariants guarantee that:
/// - All conditional tokens are fully backed by escrow funds
/// - The optimization (minting differentials) doesn't break accounting
/// - Users can always redeem complete sets for the original deposit
fun verify_differential_minting_invariants<AssetType, StableType>(
    escrow: &TokenEscrow<AssetType, StableType>,
    outcome_count: u64,
    asset_amounts: &vector<u64>,
    stable_amounts: &vector<u64>,
    max_asset: u64,
    max_stable: u64,
) {
    let mut i = 0;
    while (i < outcome_count) {
        let asset_amt = asset_amounts[i];
        let stable_amt = stable_amounts[i];
        
        // Get the supply of minted differential tokens for this outcome
        let asset_supply = escrow.outcome_asset_supplies[i].total_supply();
        let stable_supply = escrow.outcome_stable_supplies[i].total_supply();
        
        // INVARIANT 1: AMM reserves + differential tokens = max liquidity
        // This ensures complete conservation of value
        let expected_asset_differential = if (asset_amt < max_asset) {
            max_asset - asset_amt
        } else {
            0
        };
        
        let expected_stable_differential = if (stable_amt < max_stable) {
            max_stable - stable_amt  
        } else {
            0
        };
        
        // The supply should match the expected differential
        // (Note: This check assumes this is the first deposit; for subsequent deposits
        // the invariant would be: new_supply - old_supply = expected_differential)
        assert!(
            asset_supply >= expected_asset_differential,
            EInvariantViolation
        );
        assert!(
            stable_supply >= expected_stable_differential,
            EInvariantViolation
        );
        
        // INVARIANT 2: Total obligations don't exceed escrow
        // AMM will receive asset_amt and stable_amt
        // Tokens minted are asset_supply and stable_supply
        // Both are backed by the escrow balance
        
        i = i + 1;
    };
    
    // INVARIANT 3: Escrow received exactly the maximum needed
    // This was already checked with the assertions:
    // assert!(asset_amount == max_asset, EInsufficientAsset);
    // assert!(stable_amount == max_stable, EInsufficientStable);
    
    // Additional safety check: Escrow balance >= max needed
    assert!(escrow.escrowed_asset.value() >= max_asset, EInvariantViolation);
    assert!(escrow.escrowed_stable.value() >= max_stable, EInvariantViolation);
}

/// Entry point for converting winning LP to spot LP tokens
/// 
/// After a proposal is finalized, holders of conditional LP tokens from the winning
/// outcome can convert them to spot LP tokens. The underlying liquidity has already
/// been transferred to the spot pool during finalization.
/// 
/// This is a simple 1:1 exchange - burn conditional LP, mint spot LP.
public entry fun convert_winning_lp_to_spot_claim_entry<AssetType, StableType>(
    escrow: &mut TokenEscrow<AssetType, StableType>,
    spot_amm: &mut spot_amm::SpotAMM<AssetType, StableType>,
    conditional_lp_token: ConditionalToken,
    clock: &Clock,
    ctx: &mut TxContext,
) {
    let spot_lp_id = convert_winning_lp_to_spot_lp(
        escrow,
        spot_amm,
        conditional_lp_token,
        clock,
        ctx
    );
    
    // Emit event with the conversion details
    event::emit(WinningLPConverted {
        market_id: escrow.market_state.market_id(),
        spot_lp_id,
        sender: ctx.sender(),
        timestamp: clock.timestamp_ms(),
    });
}

/// Entry point for burning losing LP tokens
public entry fun burn_losing_lp_tokens_entry<AssetType, StableType>(
    escrow: &mut TokenEscrow<AssetType, StableType>,
    conditional_lp_token: ConditionalToken,
    clock: &Clock,
    ctx: &mut TxContext,
) {
    burn_losing_lp_tokens(escrow, conditional_lp_token, clock, ctx);
}

// === Events for LP Finalization ===

public struct WinningLPConverted has copy, drop {
    market_id: ID,
    spot_lp_id: ID,  // ID of the newly minted spot LP token
    sender: address,
    timestamp: u64,
}

// === Test Functions ===

#[test_only]
/// Creates a complete set of tokens and returns specific token for testing
public fun create_asset_token_for_testing<AssetType, StableType>(
    escrow: &mut TokenEscrow<AssetType, StableType>,
    outcome_idx: u64,
    amount: u64,
    clock: &Clock,
    ctx: &mut TxContext,
): ConditionalToken {
    // First create all tokens using an existing function
    let mut tokens = mint_complete_set_asset(
        escrow,
        balance::create_for_testing<AssetType>(amount).into_coin(ctx),
        clock,
        ctx,
    );

    // Find and return the token for the requested outcome
    let outcome_count = tokens.length();
    let mut result_token = tokens.pop_back();

    // Process all other tokens
    let mut i = 0;
    while (i < outcome_count - 1) {
        let token = tokens.pop_back();
        let this_outcome = token.outcome();

        if (this_outcome == (outcome_idx as u8)) {
            // Swap if we found the requested token
            transfer::public_transfer(result_token, ctx.sender());
            result_token = token;
        } else {
            // Otherwise transfer to sender
            transfer::public_transfer(token, ctx.sender());
        };
        i = i + 1;
    };

    tokens.destroy_empty();
    result_token
}

#[test_only]
/// Creates a complete set of stable tokens and returns specific token for testing
public fun create_stable_token_for_testing<AssetType, StableType>(
    escrow: &mut TokenEscrow<AssetType, StableType>,
    outcome_idx: u64,
    amount: u64,
    clock: &Clock,
    ctx: &mut TxContext,
): ConditionalToken {
    // Same approach as asset token but for stable tokens
    let coin = balance::create_for_testing<StableType>(amount).into_coin(ctx);
    let mut tokens = mint_complete_set_stable(escrow, coin, clock, ctx);

    // Extract the token we want and return it
    let token = tokens.remove(outcome_idx);

    // Transfer the other tokens to the sender
    let token_count = tokens.length();
    let mut i = 0;
    while (i < token_count) {
        let t = tokens.pop_back();
        transfer::public_transfer(t, ctx.sender());
        i = i + 1;
    };
    tokens.destroy_empty();

    token
}
module futarchy_markets::conditional_token;

use futarchy_markets::market_state;
use sui::clock::Clock;
use sui::event;

// === Introduction ===
// This module implements conditional tokens for prediction markets.
// Conditional tokens represent claims on specific outcomes in a futarchy proposal.
//
// === Live-Flow Model Integration ===
// Conditional tokens are central to the live-flow liquidity model:
// - Each outcome has two token types: asset-based and stable-based
// - Tokens can only be minted in "complete sets" (all outcomes together)
// - Complete sets can be redeemed back to spot tokens at any time
// - This ensures conservation of value: 1 spot token = 1 complete set
//
// The key innovation is that these tokens trade in outcome-specific AMMs,
// while LPs interact only with spot tokens, with automatic conversion handled
// by the protocol.

// === Constants ===
const TOKEN_TYPE_ASSET: u8 = 0;
const TOKEN_TYPE_STABLE: u8 = 1;
const TOKEN_TYPE_LP: u8 = 2;

// === Errors ===
const EInvalidAssetType: u64 = 0; // Asset type must be 0 (asset), 1 (stable), or 2 (LP)
const EWrongMarket: u64 = 1; // Token doesn't belong to expected market
const EWrongTokenType: u64 = 2; // Wrong token type for operation
const EWrongOutcome: u64 = 3; // Token outcome doesn't match expected
const EZeroAmount: u64 = 4; // Amount must be greater than zero
const EInsufficientBalance: u64 = 5; // Insufficient token balance
const EEmptyVector: u64 = 6; // Vector is empty when it shouldn't be
const ENoTokenFound: u64 = 7; // Expected token not found in Option
const ENonzeroBalance: u64 = 8; // Token must have zero balance to destroy

// === Structs ===
/// Supply tracking object for a specific conditional token type.
/// Total supply is tracked to aid with testing, it is not a source of truth. Token balances are the source of truth.
public struct Supply has key, store {
    id: UID,
    market_id: ID,
    asset_type: u8,
    outcome: u8,
    total_supply: u64,
}

/// The conditional token representing a position in a prediction market
public struct ConditionalToken has key, store {
    id: UID,
    market_id: ID,
    asset_type: u8, // 0 for asset, 1 for stable, 2 for LP
    outcome: u8, // outcome index
    balance: u64,
    escrow_id: Option<ID>, // Optional escrow ID for auto-reclaim
}

// === Events ===
/// Event emitted when tokens are minted
public struct TokenMinted has copy, drop {
    id: ID,
    market_id: ID,
    asset_type: u8,
    outcome: u8,
    amount: u64,
    recipient: address,
    timestamp: u64,
}

/// Event emitted when tokens are burned
public struct TokenBurned has copy, drop {
    id: ID,
    market_id: ID,
    asset_type: u8,
    outcome: u8,
    amount: u64,
    sender: address,
    timestamp: u64,
}

/// Event emitted when a token is split
public struct TokenSplit has copy, drop {
    original_token_id: ID,
    new_token_id: ID,
    market_id: ID,
    asset_type: u8,
    outcome: u8,
    original_amount: u64,
    split_amount: u64,
    owner: address,
    timestamp: u64,
}

/// Event emitted when multiple tokens are merged
public struct TokenMergeMany has copy, drop {
    base_token_id: ID,
    merged_token_ids: vector<ID>,
    market_id: ID,
    asset_type: u8,
    outcome: u8,
    base_amount: u64,
    merged_amount: u64,
    owner: address,
    timestamp: u64,
}

// === Package Functions ===
/// Create a new supply tracker for a specific conditional token type
public fun new_supply(
    state: &market_state::MarketState,
    asset_type: u8,
    outcome: u8,
    ctx: &mut TxContext,
): Supply {
    // Verify authority and market state
    state.validate_outcome((outcome as u64));
    assert!(asset_type <= 2, EInvalidAssetType);

    Supply {
        id: object::new(ctx),
        market_id: state.market_id(),
        asset_type,
        outcome,
        total_supply: 0,
    }
}

/// Update the total supply by increasing or decreasing the amount
public fun update_supply(supply: &mut Supply, amount: u64, increase: bool) {
    assert!(amount > 0, EZeroAmount);
    if (increase) {
        supply.total_supply = supply.total_supply + amount;
    } else {
        assert!(supply.total_supply >= amount, EInsufficientBalance);
        supply.total_supply = supply.total_supply - amount;
    };
}

/// Destroys a ConditionalToken. The token's balance must be zero.
public fun destroy(token: ConditionalToken) {
    let ConditionalToken { id, market_id: _, asset_type: _, outcome: _, balance, escrow_id: _ } = token;
    assert!(balance == 0, ENonzeroBalance);
    id.delete();
}

/// Split a conditional token into two parts, transferring the split amount to a recipient
public fun split(
    token: &mut ConditionalToken,
    amount: u64,
    recipient: address,
    clock: &Clock, // new parameter
    ctx: &mut TxContext,
) {
    assert!(amount > 0, EZeroAmount);
    assert!(token.balance > amount, EInsufficientBalance);

    token.balance = token.balance - amount;

    let new_token = ConditionalToken {
        id: object::new(ctx),
        market_id: token.market_id,
        asset_type: token.asset_type,
        outcome: token.outcome,
        balance: amount,
        escrow_id: token.escrow_id,
    };

    // Emit split event
    event::emit(TokenSplit {
        original_token_id: token.id.to_inner(),
        new_token_id: object::id(&new_token),
        market_id: token.market_id,
        asset_type: token.asset_type,
        outcome: token.outcome,
        original_amount: token.balance,
        split_amount: amount,
        owner: recipient,
        timestamp: clock.timestamp_ms(),
    });

    transfer::transfer(new_token, recipient);
}

/// Split a conditional token and return the new token instead of transferring it
/// This is useful when the caller needs to process the split token further
public fun split_and_return(
    token: &mut ConditionalToken,
    amount: u64,
    clock: &Clock,
    ctx: &mut TxContext,
): ConditionalToken {
    assert!(amount > 0, EZeroAmount);
    assert!(token.balance > amount, EInsufficientBalance);

    token.balance = token.balance - amount;

    let new_token = ConditionalToken {
        id: object::new(ctx),
        market_id: token.market_id,
        asset_type: token.asset_type,
        outcome: token.outcome,
        balance: amount,
        escrow_id: token.escrow_id,
    };

    // Emit split event
    event::emit(TokenSplit {
        original_token_id: token.id.to_inner(),
        new_token_id: object::id(&new_token),
        market_id: token.market_id,
        asset_type: token.asset_type,
        outcome: token.outcome,
        original_amount: token.balance,
        split_amount: amount,
        owner: ctx.sender(),
        timestamp: clock.timestamp_ms(),
    });

    new_token
}

/// Split tokens for the sender
entry fun split_entry(
    token: &mut ConditionalToken,
    amount: u64,
    clock: &Clock,
    ctx: &mut TxContext,
) {
    let sender = ctx.sender();
    split(token, amount, sender, clock, ctx);
}

/// Merge multiple conditional tokens of the same type into the base token
public fun merge_many(
    base_token: &mut ConditionalToken,
    mut tokens: vector<ConditionalToken>,
    clock: &Clock,
    ctx: &TxContext,
) {
    assert!(!tokens.is_empty(), EEmptyVector);

    let mut total_merged_amount = 0;
    let mut token_ids = vector[];
    // Iterate by popping from the end - O(1) operation per element
    while (!tokens.is_empty()) {
        // Remove the last token from the vector
        let token = tokens.pop_back();
        // Verify token matches
        assert!(token.market_id == base_token.market_id, EWrongMarket);
        assert!(token.asset_type == base_token.asset_type, EWrongTokenType);
        assert!(token.outcome == base_token.outcome, EWrongOutcome);

        let merged_token_object_id = object::id(&token);

        let ConditionalToken {
            id,
            market_id: _,
            asset_type: _,
            outcome: _,
            balance,
            escrow_id: _,
        } = token;

        // Add to totals and the ID list
        token_ids.push_back(merged_token_object_id);
        total_merged_amount = total_merged_amount + balance;

        base_token.balance = base_token.balance + balance;
        id.delete();
    };

    // Emit merge event with all token IDs
    event::emit(TokenMergeMany {
        base_token_id: base_token.id.to_inner(),
        merged_token_ids: token_ids,
        market_id: base_token.market_id,
        asset_type: base_token.asset_type,
        outcome: base_token.outcome,
        base_amount: base_token.balance - total_merged_amount,
        merged_amount: total_merged_amount,
        owner: ctx.sender(),
        timestamp: clock.timestamp_ms(),
    });

    tokens.destroy_empty();
}

/// Merge multiple tokens for the sender
entry fun merge_many_entry(
    base_token: &mut ConditionalToken,
    tokens: vector<ConditionalToken>,
    clock: &Clock,
    ctx: &TxContext,
) {
    merge_many(base_token, tokens, clock, ctx);
}

/// Burn a conditional token and update the supply tracker
public fun burn(
    token: ConditionalToken,
    supply: &mut Supply,
    clock: &Clock,
    ctx: &TxContext,
) {
    // Verify token matches supply
    assert!(token.market_id == supply.market_id, EWrongMarket);
    assert!(token.asset_type == supply.asset_type, EWrongTokenType);
    assert!(token.outcome == supply.outcome, EWrongOutcome);

    let ConditionalToken {
        id,
        market_id,
        asset_type,
        outcome,
        balance,
        escrow_id: _,
    } = token;

    // Update supply
    update_supply(supply, balance, false);

    // Emit event
    event::emit(TokenBurned {
        id: id.to_inner(),
        market_id,
        asset_type,
        outcome,
        amount: balance,
        sender: ctx.sender(),
        timestamp: clock.timestamp_ms(),
    });

    // Clean up
    id.delete();
}

/// Mint new conditional tokens and update the supply tracker
public fun mint(
    state: &market_state::MarketState,
    supply: &mut Supply,
    amount: u64,
    recipient: address,
    clock: &Clock,
    ctx: &mut TxContext,
): ConditionalToken {
    // Verify market state and trading period
    market_state::assert_in_trading_or_pre_trading(state);
    assert!(amount > 0, EZeroAmount);

    assert!(state.market_id() == supply.market_id, EWrongMarket);
    // Update supply
    update_supply(supply, amount, true);

    // Create new token
    let token = ConditionalToken {
        id: object::new(ctx),
        market_id: supply.market_id,
        asset_type: supply.asset_type,
        outcome: supply.outcome,
        balance: amount,
        escrow_id: option::none(),
    };

    // Emit event
    event::emit(TokenMinted {
        id: object::id(&token),
        market_id: supply.market_id,
        asset_type: supply.asset_type,
        outcome: supply.outcome,
        amount,
        recipient,
        timestamp: clock.timestamp_ms(),
    });

    // Return token instead of transferring
    token
}

/// Extract a conditional token from an Option, asserting it exists
public fun extract(option: &mut Option<ConditionalToken>): ConditionalToken {
    assert!(option.is_some(), ENoTokenFound);
    let token = option.extract();
    token
}


// === View Functions ===

public fun market_id(token: &ConditionalToken): ID {
    token.market_id
}

public fun asset_type(token: &ConditionalToken): u8 {
    token.asset_type
}

public fun outcome(token: &ConditionalToken): u8 {
    token.outcome
}

public fun value(token: &ConditionalToken): u64 {
    token.balance
}

public fun escrow_id(token: &ConditionalToken): Option<ID> {
    token.escrow_id
}

public fun total_supply(supply: &Supply): u64 {
    supply.total_supply
}

// === Package Functions for Escrow Management ===

/// Set the escrow ID for a conditional token (can only be set once)
public fun set_escrow_id(token: &mut ConditionalToken, escrow_id: ID) {
    assert!(token.escrow_id.is_none(), 0); // Can only set once
    token.escrow_id = option::some(escrow_id);
}

/// Create a token with a specific escrow ID
public fun mint_with_escrow(
    state: &market_state::MarketState,
    supply: &mut Supply,
    amount: u64,
    recipient: address,
    escrow_id: ID,
    clock: &Clock,
    ctx: &mut TxContext,
): ConditionalToken {
    // Verify market state and trading period
    market_state::assert_in_trading_or_pre_trading(state);
    assert!(amount > 0, EZeroAmount);

    assert!(state.market_id() == supply.market_id, EWrongMarket);
    // Update supply
    update_supply(supply, amount, true);

    // Create new token with escrow ID
    let token = ConditionalToken {
        id: object::new(ctx),
        market_id: supply.market_id,
        asset_type: supply.asset_type,
        outcome: supply.outcome,
        balance: amount,
        escrow_id: option::some(escrow_id),
    };

    // Emit event
    event::emit(TokenMinted {
        id: object::id(&token),
        market_id: supply.market_id,
        asset_type: supply.asset_type,
        outcome: supply.outcome,
        amount,
        recipient,
        timestamp: clock.timestamp_ms(),
    });

    // Return token instead of transferring
    token
}

// === Test Functions ===

#[test_only]
/// Creates a ConditionalToken with specified values for testing purposes.
/// This function bypasses normal validation checks and is only available in test code.
public fun mint_for_testing(
    market_id: ID,
    asset_type: u8,
    outcome: u8,
    balance: u64,
    ctx: &mut TxContext,
): ConditionalToken {
    ConditionalToken {
        id: object::new(ctx),
        market_id,
        asset_type,
        outcome,
        balance,
        escrow_id: option::none(),
    }
}
/// ============================================================================
/// FUTARCHY ORACLE - WRITE-THROUGH TWAP FOR PREDICTION MARKETS
/// ============================================================================
/// 
/// PURPOSE: Core oracle for futarchy decision-making and proposal resolution
/// 
/// USED BY:
/// - Conditional AMMs during proposals (outcome evaluation)
/// - Proposal resolution (determining winners based on TWAP)
/// - SpotAMM for governance TWAP (base fair value)
/// - NOT for lending protocols (use ring_buffer_oracle instead)
/// 
/// KEY FEATURES:
/// - Write-through pattern (MUST update before reading)
/// - Price capping to prevent manipulation
/// - Complex window-based accumulation
/// - Designed specifically for futarchy mechanics
/// - Does NOT merge with ring buffer data (separate concerns)
/// 
/// BEHAVIOR:
/// - During proposals: Each conditional AMM maintains its own oracle
/// - After finalization: Winning outcome's TWAP fills gap in spot oracle
/// - Ring buffer handles continuous feeds, this handles governance
/// 
/// WHY IT EXISTS:
/// Futarchy needs precise, manipulation-resistant price discovery during
/// proposals. This oracle enforces atomic write-then-read to ensure prices
/// are always fresh and prevents time-based manipulation attacks.
/// The separation from ring_buffer_oracle ensures governance decisions
/// cannot be influenced by lending protocol requirements.
/// 
/// ============================================================================

module futarchy_markets::oracle;

use futarchy_one_shot_utils::math;
use futarchy_one_shot_utils::constants;
use std::u128;
use std::u64;
use sui::clock::Clock;
use sui::event;

// === Introduction ===
// Crankless Time Weighted Average Price (TWAP) Oracle

// === Constants ===
// Constants moved to constants module
// Using constants::twap_price_cap_window(), constants::one_week_ms(), constants::ppm_denominator()

// === Errors ===
const ETimestampRegression: u64 = 0;
const ETwapNotStarted: u64 = 1;
const EZeroPeriod: u64 = 2;
const EZeroInitialization: u64 = 3;
const EZeroStep: u64 = 4;
const ELongDelay: u64 = 5;
const EStaleTwap: u64 = 6;
const EOverflowVRamp: u64 = 7;
const EOverflowVFlat: u64 = 8;
const EOverflowSDevMag: u64 = 9;
const EOverflowBasePriceSumFinal: u64 = 10;
const EOverflowVSumPricesAdd: u64 = 11;
const EInternalTwapError: u64 = 12;
const ENoneFullWindowTwapDelay: u64 = 13;
const EMarketNotStarted: u64 = 14;
const EMarketAlreadyStarted: u64 = 15;
const EInvalidCapPpm: u64 = 16;
const EStepOverflow: u64 = 17;

// === Structs ===
public struct Oracle has key, store {
    id: UID,
    last_price: u128,
    last_timestamp: u64,
    total_cumulative_price: u256,
    // TWAP calculation fields - using u256 for overflow protection
    // Max TWAP accumulation is U256 Max ≈1.16 x 10^77
    // Max TWAP daily accumulation:
    //     Max price observation = u64::max_value!() x 1_000_000_000_000;
    //     Milliseconds a day (7 x 24 × 3,600 × 1,000) * max price observation
    //     Allows for 1.04×10 ^ 37 days of accumulation.
    last_window_end_cumulative_price: u256,
    last_window_end: u64,
    last_window_twap: u128,
    twap_start_delay: u64,
    // Reduces attacker advantage with surprise proposals
    twap_cap_step: u64,
    // Scaled relative maximum step size for TWAP calculations
    market_start_time: Option<u64>,
    twap_initialization_price: u128,
}

// === Events ===

public struct PriceEvent has copy, drop {
    last_price: u128,
}

// === Public Functions ===
public fun new_oracle(
    twap_initialization_price: u128,
    twap_start_delay: u64,
    twap_cap_ppm: u64,
    ctx: &mut TxContext,
): Oracle {
    assert!(twap_initialization_price > 0, EZeroInitialization);
    assert!(twap_cap_ppm > 0, EZeroStep);
    assert!(twap_cap_ppm <= constants::ppm_denominator(), EInvalidCapPpm);
    assert!(twap_start_delay < constants::one_week_ms(), ELongDelay); // One week in milliseconds
    assert!((twap_start_delay % constants::twap_price_cap_window()) == 0, ENoneFullWindowTwapDelay);
    
    // Calculate the absolute step from PPM and initialization price
    // Use checked multiplication to avoid overflow
    let step_u128 = if (twap_cap_ppm > 0 && twap_initialization_price > (u128::max_value!() / (twap_cap_ppm as u128))) {
        // Would overflow, use max u64 as step
        (u64::max_value!() as u128)
    } else {
        twap_initialization_price * (twap_cap_ppm as u128) / (constants::ppm_denominator() as u128)
    };
    assert!(step_u128 <= (std::u64::max_value!() as u128), EStepOverflow);
    let mut twap_cap_step = step_u128 as u64;
    // Ensure step is at least 1 to avoid division by zero
    if (twap_cap_step == 0) {
        twap_cap_step = 1;
    };

    Oracle {
        id: object::new(ctx),
        last_price: twap_initialization_price,
        last_timestamp: 0, // set to current time when trading starts
        total_cumulative_price: 0,
        last_window_end_cumulative_price: 0,
        last_window_end: 0, // set to current time when trading starts
        last_window_twap: twap_initialization_price,
        twap_start_delay: twap_start_delay,
        twap_cap_step: twap_cap_step,
        market_start_time: option::none(), // nullable so that TWAP is not valid if not properly initialized
        twap_initialization_price: twap_initialization_price,
    }
}

// === Private Functions ===
fun one_step_cap_price_change(twap_base: u128, new_price: u128, twap_cap_step: u64): u128 {
    if (new_price > twap_base) {
        // Cap upward movement: min(new_price, saturating_add(twap_base, max_change))
        u128::min(new_price, math::saturating_add(twap_base, (twap_cap_step as u128)))
    } else {
        // Cap downward movement: max(new_price, saturating_sub(twap_base, max_change))
        u128::max(new_price, math::saturating_sub(twap_base, (twap_cap_step as u128)))
    }
}

// Called before swaps, LP events and before reading TWAP
public fun write_observation(oracle: &mut Oracle, timestamp: u64, price: u128) {
    // Sanity time checks
    assert!(oracle.market_start_time.is_some(), EMarketNotStarted);
    let market_start_time_val = *oracle.market_start_time.borrow();
    assert!(timestamp >= oracle.last_timestamp, ETimestampRegression);

    let delay_threshold = market_start_time_val + oracle.twap_start_delay;
    // --- Case 0: No time has passed ---
    if (timestamp == oracle.last_timestamp) {
        // If last_price update is not needed here, just return.
        // twap_accumulate would also do nothing if called with 0 duration.
        return
    };

    // --- Case 1: Current observation interval is entirely BEFORE delay_threshold ---
    if (oracle.last_timestamp < delay_threshold && timestamp < delay_threshold) {
        twap_accumulate(oracle, timestamp, price);
        return
    };

    // --- Case 2: Current observation interval CROSSES (or starts at and goes beyond) delay_threshold ---
    if (oracle.last_timestamp <= delay_threshold && timestamp >= delay_threshold) {
        // Part A: Process segment up to delay_threshold.
        if (delay_threshold > oracle.last_timestamp) {
            twap_accumulate(oracle, delay_threshold, price);
        };

        // Part B: RESET accumulators and mark the true start of the accumulation period.
        oracle.total_cumulative_price = 0;
        oracle.last_window_end_cumulative_price = 0;
        oracle.last_window_end = delay_threshold;

        // Part C: Process segment from delay_threshold to current `timestamp`.
        // This uses the fresh accumulators.
        if (timestamp > delay_threshold) {
            // Ensure there's a duration for this segment
            // twap_accumulate will use oracle.last_timestamp (which is delay_threshold)
            twap_accumulate(oracle, timestamp, price);
        };
        return
    };

    // --- Case 3: Current observation interval is entirely AT or AFTER delay_threshold ---
    if (oracle.last_timestamp >= delay_threshold) {
        twap_accumulate(oracle, timestamp, price);
        return
    }
}

fun twap_accumulate(oracle: &mut Oracle, timestamp: u64, price: u128) {
    // --- Input Validation ---
    // Ensure timestamp is not regressing
    assert!(timestamp >= oracle.last_timestamp, ETimestampRegression);
    // Ensure initial state is consistent (last_timestamp should not be before the window end it relates to)
    // This is a pre-condition check, assuming the state was valid before this call.
    assert!(oracle.last_timestamp >= oracle.last_window_end, ETimestampRegression);

    // --- Handle Edge Case: No time passed ---
    let time_since_last_update = timestamp - oracle.last_timestamp;

    // --- Stage 1: Accumulate for the initial partial window segment ---
    // This segment starts at oracle.last_timestamp and ends at the first of:
    // 1. The next window boundary (relative to oracle.last_window_end).
    // 2. The final input timestamp.

    let diff_from_last_boundary = oracle.last_timestamp - oracle.last_window_end;
    let elapsed_in_current_segment = diff_from_last_boundary % constants::twap_price_cap_window();

    let time_to_next_boundary = constants::twap_price_cap_window() - elapsed_in_current_segment;

    let duration_stage1 = std::u64::min(
        time_to_next_boundary, // Limit by the time until the next window boundary
        time_since_last_update, // Limit by the total time available until the target timestamp
    );

    if (duration_stage1 > 0) {
        let end_timestamp_stage1 = oracle.last_timestamp + duration_stage1;
        intra_window_accumulation(
            oracle, // Passes mutable reference, state will be updated
            price,
            duration_stage1,
            end_timestamp_stage1, // This timestamp becomes the new oracle.last_timestamp
        );
        // After this call, oracle.last_timestamp is updated to end_timestamp_stage1.
        // If end_timestamp_stage1 hit a window boundary, oracle.last_window_end and TWAP state are also updated.
    };

    // --- Stage 2: Process all full windows that fit *after* Stage 1 ended ---
    // The starting point for these full windows is the current oracle.last_timestamp
    // (which is the end timestamp of the segment processed in Stage 1).

    let time_remaining_after_stage1 = timestamp - oracle.last_timestamp; // Use updated oracle.last_timestamp

    if (time_remaining_after_stage1 >= constants::twap_price_cap_window()) {
        let num_full_windows = time_remaining_after_stage1 / constants::twap_price_cap_window();

        // Calculate the end timestamp after processing these full windows.
        // Start from the *current* oracle.last_timestamp (end of Stage 1 segment).
        let end_timestamp_stage2 = oracle.last_timestamp + num_full_windows * constants::twap_price_cap_window();

        multi_full_window_accumulation(
            oracle, // Passes mutable reference, state will be updated
            price,
            num_full_windows,
            end_timestamp_stage2, // This timestamp becomes the new oracle.last_timestamp and oracle.last_window_end
        );
        // After this call, oracle.last_timestamp and oracle.last_window_end are updated to end_timestamp_stage2.
        // The oracle's TWAP state (last_window_twap, cumulative_price) is also updated for these full windows.
    };

    // --- Stage 3: Process any remaining partial window after Stage 2 ended ---
    // The starting point is the current oracle.last_timestamp
    // (which is the end timestamp of the segment processed in Stage 2, or Stage 1 if Stage 2 was skipped).

    let duration_stage3 = timestamp - oracle.last_timestamp; // Use updated oracle.last_timestamp

    // If duration_stage3 > 0, there is time left to accumulate up to the final timestamp.
    if (duration_stage3 > 0) {
        intra_window_accumulation(
            oracle, // Passes mutable reference, state will be updated
            price,
            duration_stage3,
            timestamp, // The end timestamp for this final segment is the target timestamp
        );
        // After this call, oracle.last_timestamp is updated to the final input timestamp.
        // If the final timestamp hits a window boundary, oracle.last_window_end and TWAP state are also updated.
    };
    assert!(oracle.last_timestamp == timestamp, EInternalTwapError); // Assuming an internal error code
}

fun intra_window_accumulation(
    oracle: &mut Oracle,
    price: u128,
    additional_time_to_include: u64,
    timestamp: u64,
) {
    let capped_price = one_step_cap_price_change(
        oracle.last_window_twap,
        price,
        oracle.twap_cap_step,
    );

    // Add accumulation for the partial period within the current (still open) window
    let scaled_price = (capped_price as u256);
    let price_contribution = scaled_price * (additional_time_to_include as u256);
    oracle.total_cumulative_price = oracle.total_cumulative_price + price_contribution;

    let time_since_last_window_end = timestamp - oracle.last_window_end;
    oracle.last_timestamp = timestamp;
    oracle.last_price = (scaled_price as u128);

    event::emit(PriceEvent {
        last_price: oracle.last_price,
    });

    if (time_since_last_window_end == constants::twap_price_cap_window()) {
        // Update last window data on window boundary
        oracle.last_window_end = timestamp;
        oracle.last_window_twap = (
            (
                (oracle.total_cumulative_price - oracle.last_window_end_cumulative_price) / (constants::twap_price_cap_window() as u256),
            ) as u128,
        );
        oracle.last_window_end_cumulative_price = oracle.total_cumulative_price
    }
}

fun multi_full_window_accumulation(
    oracle: &mut Oracle,
    price: u128,
    num_new_windows: u64, // N_W
    timestamp: u64,
) {
    // Notation: v_ = value, n_ = number/count, k_ = index, s_ = sum, g_ = gap
    // G_abs = |P - B|
    let g_abs: u128;
    if (price > oracle.last_window_twap) {
        g_abs = price - oracle.last_window_twap;
    } else {
        g_abs = oracle.last_window_twap - price;
    };

    let k_cap_idx_u128: u128;
    if (g_abs == 0) {
        k_cap_idx_u128 = 0;
    } else if (oracle.twap_cap_step == 0) {
        // If step is 0 (from very small PPM), treat as unlimited steps
        k_cap_idx_u128 = (u64::max_value!() as u128);
    } else {
        k_cap_idx_u128 = (g_abs - 1) / (oracle.twap_cap_step as u128) + 1;
    };

    let k_cap_idx: u64;
    if (k_cap_idx_u128 > (u64::max_value!() as u128)) {
        k_cap_idx = u64::max_value!();
    } else {
        k_cap_idx = k_cap_idx_u128 as u64;
    };

    let k_ramp_limit: u64;
    if (k_cap_idx == 0) {
        k_ramp_limit = 0;
    } else {
        k_ramp_limit = k_cap_idx - 1;
    };

    // N_ramp_terms = min(N_W, k_ramp_limit)
    let n_ramp_terms = std::u64::min(num_new_windows, k_ramp_limit); // n_ramp_terms is u64

    // V_ramp = \Delta_M * N_ramp_terms * (N_ramp_terms + 1) / 2
    let v_ramp: u128;
    if (n_ramp_terms == 0) {
        v_ramp = 0;
    } else {
        let nrt_u128 = n_ramp_terms as u128;
        let sum_indices_part: u128;
        // Calculate nrt_u128 * (nrt_u128 + 1) / 2 safely to avoid overflow.
        // Max nrt_u128 is std::u64::MAX (~2^64).
        // (nrt_u128/2) * (nrt_u128+1) OR ((nrt_u128+1)/2) * nrt_u128 will be ~2^63 * 2^64 = 2^127, which fits u128.
        if (nrt_u128 % 2 == 0) {
            sum_indices_part = (nrt_u128 / 2) * (nrt_u128 + 1);
        } else {
            sum_indices_part = ((nrt_u128 + 1) / 2) * nrt_u128;
        };

        // Check for overflow: delta_max_per_step * sum_indices_part
        if (
            sum_indices_part > 0 && (oracle.twap_cap_step as u128) > 0 && (oracle.twap_cap_step as u128) > u128::max_value!() / sum_indices_part
        ) {
            abort (EOverflowVRamp)
        };
        v_ramp = (oracle.twap_cap_step as u128) * sum_indices_part;
    };

    // V_flat = G_abs * (N_W - N_ramp_terms)
    let num_flat_terms = num_new_windows - n_ramp_terms; // u64
    let v_flat: u128;
    if (num_flat_terms == 0) {
        v_flat = 0;
    } else {
        let nft_u128 = num_flat_terms as u128;
        // Check for overflow: g_abs * nft_u128
        if (nft_u128 > 0 && g_abs > 0 && g_abs > u128::max_value!() / nft_u128) {
            abort (EOverflowVFlat)
        };
        v_flat = g_abs * nft_u128;
    };

    // S_dev_mag = V_ramp + V_flat
    // Check for overflow: v_ramp + v_flat
    if (v_ramp > u128::max_value!() - v_flat) {
        // Equivalent to v_ramp + v_flat > u128::max_value!()
        abort (EOverflowSDevMag)
    };
    let s_dev_mag = v_ramp + v_flat;

    // V_sum_prices = N_W * B + sign(P-B) * S_dev_mag
    let base_price_sum: u128;
    let nw_u128 = num_new_windows as u128;
    // Check for overflow: oracle.last_window_twap * nw_u128
    if (
        nw_u128 > 0 && oracle.last_window_twap > 0 && oracle.last_window_twap > u128::max_value!() / nw_u128
    ) {
        abort (EOverflowBasePriceSumFinal)
    };
    base_price_sum = oracle.last_window_twap * nw_u128;

    let v_sum_prices: u128;
    if (price >= oracle.last_window_twap) {
        // sign(P-B) is 0 or 1
        // Check for overflow: base_price_sum + s_dev_mag
        if (base_price_sum > u128::max_value!() - s_dev_mag) {
            abort (EOverflowVSumPricesAdd)
        };
        v_sum_prices = base_price_sum + s_dev_mag;
    } else {
        // sign(P-B) is -1
        // Since P'_i = B - dev_i, and we assume price (P) >= 0,
        // then P'_i >= 0 (as B - dev_i >= P >= 0).
        // So sum of P'_i (which is V_sum_prices) must be >= 0.
        // This also implies N_W * B >= S_dev_mag.
        // Thus, base_price_sum >= s_dev_mag, and subtraction will not underflow below zero.
        v_sum_prices = base_price_sum - s_dev_mag;
    };

    // P'_N_W = B + sign(P-B) * min(N_W * \Delta_M, G_abs)
    let p_n_w_effective: u128;

    // Calculate N_W * \Delta_M
    // delta_max_per_step is > 0 here. num_new_windows > 0.
    // No overflow possible: num_new_windows is u64, twap_cap_step is u64
    let nw_times_delta_m = (num_new_windows as u128) * (oracle.twap_cap_step as u128);

    let deviation_for_p_n_w = std::u128::min(nw_times_delta_m, g_abs);

    if (price >= oracle.last_window_twap) {
        p_n_w_effective = math::saturating_add(oracle.last_window_twap, deviation_for_p_n_w);
    } else {
        // price < oracle.last_window_twap
        p_n_w_effective = math::saturating_sub(oracle.last_window_twap, deviation_for_p_n_w);
    };

    oracle.last_timestamp = timestamp;
    oracle.last_window_end = timestamp;
    let cumulative_price_contribution = (v_sum_prices as u256) * (constants::twap_price_cap_window() as u256);
    oracle.last_window_end_cumulative_price =
        oracle.total_cumulative_price + cumulative_price_contribution;
    oracle.total_cumulative_price = oracle.total_cumulative_price + cumulative_price_contribution;
    oracle.last_price = p_n_w_effective;

    event::emit(PriceEvent {
        last_price: oracle.last_price,
    });

    oracle.last_window_twap = p_n_w_effective;
}

/// ARCHITECTURAL DECISION: Mutation-Required TWAP Oracle
/// 
/// This oracle REQUIRES write_observation() before get_twap() in the same transaction.
/// The assertion `current_time == oracle.last_timestamp` is INTENTIONAL.
/// 
/// Why this differs from read-only TWAP patterns:
/// - Stale prices are attack vectors, not features
/// - Interpolation adds complexity and manipulation surface  
/// - The AMM determines prices; the oracle just tracks them
/// - Every TWAP read MUST reflect current AMM state
/// 
/// This design makes it IMPOSSIBLE to:
/// ✗ Read stale/manipulated TWAPs
/// ✗ Forget to update before critical operations
/// ✗ Have price inconsistency within a transaction
/// 
/// This pattern differs from typical read-only oracles by design.
/// Serving stale TWAPs for "cleaner interfaces" is how protocols get exploited.
/// 
/// The AMM's get_twap() handles the update + read atomically. 
/// The oracle just validates freshness. This is correct.
public fun get_twap(oracle: &Oracle, clock: &Clock): u128 {
    assert!(oracle.market_start_time.is_some(), EMarketNotStarted);
    let market_start_time_val = *oracle.market_start_time.borrow();
    let current_time = clock.timestamp_ms();

    // REQUIRED: Caller must have called write_observation() in this same transaction
    // This ensures TWAP is always fresh and prevents stale price exploitation
    assert!(current_time == oracle.last_timestamp, EStaleTwap);

    // Time checks
    assert!(oracle.last_timestamp != 0, ETimestampRegression);
    assert!(current_time - market_start_time_val >= oracle.twap_start_delay, ETwapNotStarted);
    assert!(current_time >= market_start_time_val, ETimestampRegression);

    // Calculate period
    let period = ( current_time - market_start_time_val) - oracle.twap_start_delay;
    assert!(period > 0, EZeroPeriod);

    // Calculate TWAP - dividing cumulative price by period gives average price
    // Safe cast: For reasonable token prices over max 7-day proposals, 
    // TWAP will be far below u128::MAX (even 10^18 price × 7 days / period ≈ 10^15)
    let twap = (oracle.total_cumulative_price) / (period as u256);

    (twap as u128)
}

public fun set_oracle_start_time(oracle: &mut Oracle, market_start_time_param: u64) {
    // Prevent re-initialization
    assert!(oracle.market_start_time.is_none(), EMarketAlreadyStarted);

    oracle.market_start_time = option::some(market_start_time_param);
    oracle.last_window_end = market_start_time_param;
    oracle.last_timestamp = market_start_time_param;
}

// === View Functions ===
public fun last_price(oracle: &Oracle): u128 {
    oracle.last_price
}

public fun last_timestamp(oracle: &Oracle): u64 {
    oracle.last_timestamp
}

public fun config(oracle: &Oracle): (u64, u64) {
    (oracle.twap_start_delay, oracle.twap_cap_step)
}

public fun market_start_time(oracle: &Oracle): Option<u64> {
    oracle.market_start_time
}

public fun twap_initialization_price(oracle: &Oracle): u128 {
    oracle.twap_initialization_price
}

public fun total_cumulative_price(oracle: &Oracle): u256 {
    oracle.total_cumulative_price
}

public fun id(o: &Oracle): &UID {
    &o.id
}

// === Test Functions ===
#[test_only]
use std::debug;

#[test_only]
public fun debug_print_state(oracle: &Oracle) {
    debug::print(&b"Oracle State:");
    debug::print(&oracle.last_price);
    debug::print(&oracle.last_timestamp);
    debug::print(&oracle.total_cumulative_price);
}

#[test_only]
public fun debug_get_state(oracle: &Oracle): (u128, u64, u256) {
    (oracle.last_price, oracle.last_timestamp, oracle.total_cumulative_price)
}

#[test_only]
public fun test_oracle(ctx: &mut TxContext): Oracle {
    new_oracle(
        10000, // twap_initialization_price
        60_000, // twap_start_delay
        1000, // twap_cap_ppm (0.1% of initialization price)
        ctx,
    )
}

#[test_only]
public fun destroy_for_testing(oracle: Oracle) {
    let Oracle {
        id,
        last_price: _,
        last_timestamp: _,
        total_cumulative_price: _,
        last_window_end: _,
        last_window_end_cumulative_price: _,
        last_window_twap: _,
        twap_start_delay: _,
        twap_cap_step: _,
        market_start_time: _,
        twap_initialization_price: _,
    } = oracle;
    id.delete();
}

#[test_only]
public fun debug_get_window_twap(oracle: &Oracle): u128 {
    oracle.last_window_twap
}

#[test_only]
public fun is_twap_valid(oracle: &Oracle, min_period: u64, clock: &Clock): bool {
    let current_time = clock.timestamp_ms();
    current_time >= oracle.last_timestamp + min_period
}

#[test_only]
public fun debug_get_full_state(
    oracle: &Oracle,
): (
    u128, // last_price
    u64, // last_timestamp
    u256, // total_cumulative_price
    u256, // last_window_end_cumulative_price
    u64, // last_window_end
    u128, // last_window_twap
    Option<u64>, // market_start_time
    u128, // twap_initialization_price
    u64, // twap_start_delay
    u64, // twap_cap_step
) {
    (
        oracle.last_price,
        oracle.last_timestamp,
        oracle.total_cumulative_price,
        oracle.last_window_end_cumulative_price,
        oracle.last_window_end,
        oracle.last_window_twap,
        oracle.market_start_time,
        oracle.twap_initialization_price,
        oracle.twap_start_delay,
        oracle.twap_cap_step,
    )
}

#[test_only]
public fun set_last_timestamp_for_testing(oracle: &mut Oracle, new_last_timestamp: u64) {
    oracle.last_timestamp = new_last_timestamp;
}

#[test_only]
public fun set_last_window_end_for_testing(oracle: &mut Oracle, new_last_window_end: u64) {
    oracle.last_window_end = new_last_window_end;
}

#[test_only]
public fun set_last_window_twap_for_testing(oracle: &mut Oracle, new_last_window_twap: u128) {
    oracle.last_window_twap = new_last_window_twap;
}

#[test_only]
public fun set_cumulative_prices_for_testing(
    oracle: &mut Oracle,
    total_cumulative_price: u256,
    last_window_end_cumulative_price: u256,
) {
    oracle.total_cumulative_price = total_cumulative_price;
    oracle.last_window_end_cumulative_price = last_window_end_cumulative_price;
}

#[test_only]
public fun call_twap_accumulate_for_testing(oracle: &mut Oracle, timestamp: u64, price: u128) {
    twap_accumulate(oracle, timestamp, price);
}

#[test_only]
public fun get_last_window_end_cumulative_price_for_testing(oracle: &Oracle): u256 {
    oracle.last_window_end_cumulative_price
}

#[test_only]
public fun get_total_cumulative_price_for_testing(oracle: &Oracle): u256 {
    oracle.total_cumulative_price
}

#[test_only]
public fun get_last_window_end_for_testing(oracle: &Oracle): u64 {
    oracle.last_window_end
}

#[test_only]
public fun call_intra_window_accumulation_for_testing(
    oracle: &mut Oracle,
    price: u128,
    additional_time_to_include: u64,
    timestamp: u64,
) {
    intra_window_accumulation(
        oracle,
        price,
        additional_time_to_include,
        timestamp,
    );
}

#[test_only]
public fun call_multi_full_window_accumulation_for_testing(
    oracle: &mut Oracle,
    price: u128,
    num_new_windows: u64,
    timestamp: u64,
) {
    multi_full_window_accumulation(
        oracle,
        price,
        num_new_windows,
        timestamp,
    );
}
module futarchy_markets::swap;

use futarchy_markets::coin_escrow::TokenEscrow;
use futarchy_markets::conditional_token::ConditionalToken;
use futarchy_markets::liquidity_interact;
use futarchy_markets::market_state::MarketState;
use futarchy_markets::proposal::{Self, Proposal};
use sui::clock::Clock;
use sui::coin::Coin;

// === Introduction ===
// Defines entry methods for swaping and combining coins and conditional tokens

// === Errors ===
const EInvalidOutcome: u64 = 0;
const EWrongTokenType: u64 = 1;
const EWrongOutcome: u64 = 2;
const EInvalidState: u64 = 3;
const EMarketIdMismatch: u64 = 4;

// === Constants ===
const STATE_TRADING: u8 = 2; // Must match proposal.move STATE_TRADING

// === Helper Functions ===
/// Efficiently transfers all tokens in a vector to the recipient
fun transfer_tokens_to_recipient(mut tokens: vector<ConditionalToken>, recipient: address) {
    while (!tokens.is_empty()) {
        transfer::public_transfer(tokens.pop_back(), recipient);
    };
    tokens.destroy_empty();
}

// === Public Functions ===

public fun swap_asset_to_stable<AssetType, StableType>(
    proposal: &mut Proposal<AssetType, StableType>,
    escrow: &mut TokenEscrow<AssetType, StableType>,
    outcome_idx: u64,
    token_to_swap: ConditionalToken,
    min_amount_out: u64,
    clock: &Clock,
    ctx: &mut TxContext,
): ConditionalToken {
    assert!(proposal::market_state_id(proposal) == escrow.get_market_state_id(), EMarketIdMismatch);
    assert!(token_to_swap.asset_type() == 0, EWrongTokenType);
    let amount_in = token_to_swap.value();

    // Calculate the swap amount using AMM
    let amount_out = swap_asset_to_stable_internal(
        proposal,
        escrow.get_market_state(),
        outcome_idx,
        amount_in,
        min_amount_out,
        clock,
        ctx,
    );

    // Handle token swap atomically in escrow - tokens will be minted directly to sender
    let stable_token = escrow.swap_token_asset_to_stable(
        token_to_swap,
        outcome_idx,
        amount_out,
        clock,
        ctx,
    );

    liquidity_interact::assert_all_reserves_consistency(proposal, escrow);

    stable_token
}

public entry fun swap_asset_to_stable_entry<AssetType, StableType>(
    proposal: &mut Proposal<AssetType, StableType>,
    escrow: &mut TokenEscrow<AssetType, StableType>,
    outcome_idx: u64,
    token_to_swap: ConditionalToken,
    min_amount_out: u64,
    clock: &Clock,
    ctx: &mut TxContext,
) {
    let recipient = ctx.sender();
    let result_token = swap_asset_to_stable(
        proposal,
        escrow,
        outcome_idx,
        token_to_swap,
        min_amount_out,
        clock,
        ctx,
    );
    transfer::public_transfer(result_token, recipient);
}

public fun swap_stable_to_asset<AssetType, StableType>(
    proposal: &mut Proposal<AssetType, StableType>,
    escrow: &mut TokenEscrow<AssetType, StableType>,
    outcome_idx: u64,
    token_to_swap: ConditionalToken,
    min_amount_out: u64,
    clock: &Clock,
    ctx: &mut TxContext,
): ConditionalToken {
    assert!(proposal::market_state_id(proposal) == escrow.get_market_state_id(), EMarketIdMismatch);
    assert!(token_to_swap.asset_type() == 1, EWrongTokenType);
    let amount_in = token_to_swap.value();

    // Calculate the swap amount using AMM
    let amount_out = swap_stable_to_asset_internal(
        proposal,
        escrow.get_market_state(),
        outcome_idx,
        amount_in,
        min_amount_out,
        clock,
        ctx,
    );

    // Handle token swap atomically in escrow - tokens will be minted directly to sender
    let asset_token = escrow.swap_token_stable_to_asset(
        token_to_swap,
        outcome_idx,
        amount_out,
        clock,
        ctx,
    );

    liquidity_interact::assert_all_reserves_consistency(proposal, escrow);

    asset_token
}

public entry fun swap_stable_to_asset_entry<AssetType, StableType>(
    proposal: &mut Proposal<AssetType, StableType>,
    escrow: &mut TokenEscrow<AssetType, StableType>,
    outcome_idx: u64,
    token_to_swap: ConditionalToken,
    min_amount_out: u64,
    clock: &Clock,
    ctx: &mut TxContext,
) {
    let recipient = ctx.sender();
    let result_token = swap_stable_to_asset(
        proposal,
        escrow,
        outcome_idx,
        token_to_swap,
        min_amount_out,
        clock,
        ctx,
    );
    transfer::public_transfer(result_token, recipient);
}

/// Returns all tokens with swapped token at the end
public fun create_and_swap_stable_to_asset_with_existing<AssetType, StableType>(
    proposal: &mut Proposal<AssetType, StableType>,
    escrow: &mut TokenEscrow<AssetType, StableType>,
    outcome_idx: u64,
    existing_token: ConditionalToken,
    min_amount_out: u64,
    coin_in: Coin<StableType>,
    clock: &Clock,
    ctx: &mut TxContext,
): (vector<ConditionalToken>, ConditionalToken) {
    assert!(proposal::market_state_id(proposal) == escrow.get_market_state_id(), EMarketIdMismatch);
    let mut tokens = escrow.mint_complete_set_stable(coin_in, clock, ctx);

    assert!(outcome_idx < tokens.length(), EInvalidOutcome);
    let mut swap_token = tokens.remove(outcome_idx);

    // Merge existing token if present
    assert!(existing_token.outcome() == (outcome_idx as u8), EWrongOutcome);
    assert!(existing_token.asset_type() == 1, EWrongTokenType);
    assert!(existing_token.market_id() == escrow.get_market_state().market_id(), EMarketIdMismatch);

    // swap_token.outcome() is guaranteed to be outcome_idx since it came from tokens[outcome_idx]
    let mut existing_token_in_vector = vector[];
    existing_token_in_vector.push_back(existing_token);
    swap_token.merge_many(existing_token_in_vector, clock, ctx);

    // Swap the selected token
    let asset_token = swap_stable_to_asset(
        proposal,
        escrow,
        outcome_idx,
        swap_token,
        min_amount_out,
        clock,
        ctx,
    );

    // Add the swapped token to the end of the vector
    (tokens, asset_token)
}

#[allow(lint(self_transfer))]
public entry fun create_and_swap_stable_to_asset_with_existing_entry<AssetType, StableType>(
    proposal: &mut Proposal<AssetType, StableType>,
    escrow: &mut TokenEscrow<AssetType, StableType>,
    outcome_idx: u64,
    existing_token: ConditionalToken,
    min_amount_out: u64,
    coin_in: Coin<StableType>,
    clock: &Clock,
    ctx: &mut TxContext,
) {
    let (mut tokens, asset_token) = create_and_swap_stable_to_asset_with_existing(
        proposal,
        escrow,
        outcome_idx,
        existing_token,
        min_amount_out,
        coin_in,
        clock,
        ctx,
    );

    let recipient = ctx.sender();

    // Transfer all tokens to the recipient
    transfer_tokens_to_recipient(tokens, recipient);
    transfer::public_transfer(asset_token, recipient);
}

/// Returns all tokens with swapped token at the end
public fun create_and_swap_asset_to_stable_with_existing<AssetType, StableType>(
    proposal: &mut Proposal<AssetType, StableType>,
    escrow: &mut TokenEscrow<AssetType, StableType>,
    outcome_idx: u64,
    existing_token: ConditionalToken,
    min_amount_out: u64,
    coin_in: Coin<AssetType>,
    clock: &Clock,
    ctx: &mut TxContext,
): (vector<ConditionalToken>, ConditionalToken) {
    assert!(proposal::market_state_id(proposal) == escrow.get_market_state_id(), EMarketIdMismatch);
    let mut tokens = escrow.mint_complete_set_asset(coin_in, clock, ctx);

    assert!(outcome_idx < tokens.length(), EInvalidOutcome);
    let mut swap_token = tokens.remove(outcome_idx);

    assert!(existing_token.outcome() == (outcome_idx as u8), EWrongOutcome);
    assert!(existing_token.asset_type() == 0, EWrongTokenType);
    assert!(existing_token.market_id() == escrow.get_market_state().market_id(), EMarketIdMismatch);

    // swap_token.outcome() is guaranteed to be outcome_idx since it came from tokens[outcome_idx]
    let mut existing_token_in_vector = vector[];
    existing_token_in_vector.push_back(existing_token);
    swap_token.merge_many(existing_token_in_vector, clock, ctx);

    // Swap the selected token
    let stable_token = swap_asset_to_stable(
        proposal,
        escrow,
        outcome_idx,
        swap_token,
        min_amount_out,
        clock,
        ctx,
    );

    // Add the swapped token to the end of the vector
    (tokens, stable_token)
}

#[allow(lint(self_transfer))]
public entry fun create_and_swap_asset_to_stable_with_existing_entry<AssetType, StableType>(
    proposal: &mut Proposal<AssetType, StableType>,
    escrow: &mut TokenEscrow<AssetType, StableType>,
    outcome_idx: u64,
    existing_token: ConditionalToken,
    min_amount_out: u64,
    coin_in: Coin<AssetType>,
    clock: &Clock,
    ctx: &mut TxContext,
) {
    let (mut tokens, stable_token) = create_and_swap_asset_to_stable_with_existing(
        proposal,
        escrow,
        outcome_idx,
        existing_token,
        min_amount_out,
        coin_in,
        clock,
        ctx,
    );

    let recipient = ctx.sender();

    // Transfer all tokens to the recipient
    transfer_tokens_to_recipient(tokens, recipient);
    transfer::public_transfer(stable_token, recipient);
}

/// Returns all tokens with swapped token at the end
public fun create_and_swap_asset_to_stable<AssetType, StableType>(
    proposal: &mut Proposal<AssetType, StableType>,
    escrow: &mut TokenEscrow<AssetType, StableType>,
    outcome_idx: u64,
    min_amount_out: u64,
    coin_in: Coin<AssetType>,
    clock: &Clock,
    ctx: &mut TxContext,
): (vector<ConditionalToken>, ConditionalToken) {
    assert!(proposal::market_state_id(proposal) == escrow.get_market_state_id(), EMarketIdMismatch);
    let mut tokens = escrow.mint_complete_set_asset(coin_in, clock, ctx);

    assert!(outcome_idx < tokens.length(), EInvalidOutcome);
    let token_to_swap = tokens.remove(outcome_idx);

    // Swap the selected token
    let stable_token = swap_asset_to_stable(
        proposal,
        escrow,
        outcome_idx,
        token_to_swap,
        min_amount_out,
        clock,
        ctx,
    );

    // Add the swapped token to the end of the vector
    (tokens, stable_token)
}

#[allow(lint(self_transfer))]
public entry fun create_and_swap_asset_to_stable_entry<AssetType, StableType>(
    proposal: &mut Proposal<AssetType, StableType>,
    escrow: &mut TokenEscrow<AssetType, StableType>,
    outcome_idx: u64,
    min_amount_out: u64,
    coin_in: Coin<AssetType>,
    clock: &Clock,
    ctx: &mut TxContext,
) {
    let (mut tokens, stable_token) = create_and_swap_asset_to_stable(
        proposal,
        escrow,
        outcome_idx,
        min_amount_out,
        coin_in,
        clock,
        ctx,
    );

    let recipient = ctx.sender();

    // Transfer all tokens to the recipient
    transfer_tokens_to_recipient(tokens, recipient);
    transfer::public_transfer(stable_token, recipient);
}

/// Returns all tokens with swapped token at the end
public fun create_and_swap_stable_to_asset<AssetType, StableType>(
    proposal: &mut Proposal<AssetType, StableType>,
    escrow: &mut TokenEscrow<AssetType, StableType>,
    outcome_idx: u64,
    min_amount_out: u64,
    coin_in: Coin<StableType>,
    clock: &Clock,
    ctx: &mut TxContext,
): (vector<ConditionalToken>, ConditionalToken) {
    assert!(proposal::market_state_id(proposal) == escrow.get_market_state_id(), EMarketIdMismatch);
    let mut tokens = escrow.mint_complete_set_stable(coin_in, clock, ctx);

    assert!(outcome_idx < tokens.length(), EInvalidOutcome);
    let token_to_swap = tokens.remove(outcome_idx);

    // Swap the selected token
    let asset_token = swap_stable_to_asset(
        proposal,
        escrow,
        outcome_idx,
        token_to_swap,
        min_amount_out,
        clock,
        ctx,
    );

    // Add the swapped token to the end of the vector
    (tokens, asset_token)
}

#[allow(lint(self_transfer))]
public entry fun create_and_swap_stable_to_asset_entry<AssetType, StableType>(
    proposal: &mut Proposal<AssetType, StableType>,
    escrow: &mut TokenEscrow<AssetType, StableType>,
    outcome_idx: u64,
    min_amount_out: u64,
    coin_in: Coin<StableType>,
    clock: &Clock,
    ctx: &mut TxContext,
) {
    let (mut tokens, asset_token) = create_and_swap_stable_to_asset(
        proposal,
        escrow,
        outcome_idx,
        min_amount_out,
        coin_in,
        clock,
        ctx,
    );

    let recipient = ctx.sender();

    // Transfer all tokens to the recipient
    transfer_tokens_to_recipient(tokens, recipient);
    transfer::public_transfer(asset_token, recipient);
}

// === Private Functions ===

fun swap_asset_to_stable_internal<AssetType, StableType>(
    proposal: &mut Proposal<AssetType, StableType>,
    state: &MarketState,
    outcome_idx: u64,
    amount_in: u64,
    min_amount_out: u64,
    clock: &Clock,
    ctx: &TxContext,
): u64 {
    assert!(proposal::proposal_id(proposal) == state.market_id(), EMarketIdMismatch);

    assert!(outcome_idx < proposal::outcome_count(proposal), EInvalidOutcome);
    assert!(proposal::state(proposal) == STATE_TRADING, EInvalidState);

    let pool = proposal::get_pool_mut_by_outcome(proposal, (outcome_idx as u8));
    pool.swap_asset_to_stable(state, amount_in, min_amount_out, clock, ctx)
}

fun swap_stable_to_asset_internal<AssetType, StableType>(
    proposal: &mut Proposal<AssetType, StableType>,
    state: &MarketState,
    outcome_idx: u64,
    amount_in: u64,
    min_amount_out: u64,
    clock: &Clock,
    ctx: &TxContext,
): u64 {
    assert!(proposal::proposal_id(proposal) == state.market_id(), EMarketIdMismatch);
    assert!(outcome_idx < proposal::outcome_count(proposal), EInvalidOutcome);
    assert!(proposal::state(proposal) == STATE_TRADING, EInvalidState);

    let pool = proposal::get_pool_mut_by_outcome(proposal, (outcome_idx as u8));
    pool.swap_stable_to_asset(state, amount_in, min_amount_out, clock, ctx)
}
/// ============================================================================
/// RING BUFFER ORACLE - CONTINUOUS PRICE FEED FOR LENDING PROTOCOLS
/// ============================================================================
/// 
/// PURPOSE: Provides uninterrupted price feeds for external integrations
/// 
/// USED BY:
/// - Lending protocols (Compound, Aave style)
/// - Liquidation bots
/// - Price aggregators
/// - Minting actions (longest TWAP for security)
/// - Any protocol needing standard TWAP access
/// 
/// KEY FEATURES:
/// - Ring buffer with up to 65535 observations (~9 days)
/// - Updates on every swap/liquidity event
/// - Standard read-only TWAP queries (no write requirement)
/// - Flexible time windows (1 second to 9 days)
/// - Observation merging for proposal finalization
/// 
/// BEHAVIOR:
/// - SpotAMM: Continuously updated during normal trading
/// - ConditionalAMMs: Updated during proposals for each outcome
/// - During proposals: Spot reads from highest conditional (no storage)
/// - After finalization: Winning conditional's data merges into spot
/// 
/// WHY IT EXISTS:
/// Lending protocols expect continuous, queryable price feeds that work like
/// Uniswap V2/V3 oracles. This module provides that standard interface while
/// the futarchy oracle handles the specialized prediction market mechanics.
/// The ring buffer ensures lending protocols always have fresh prices, even
/// during proposals when liquidity moves to conditional markets.
/// 
/// INTEGRATION:
/// - Each SpotAMM has one for normal trading
/// - Each ConditionalAMM has one for proposal periods
/// - spot_oracle_interface combines them seamlessly
/// - merge_observations() consolidates winning data after finalization
/// 
/// ============================================================================

module futarchy_markets::ring_buffer_oracle;

use std::vector;
use sui::clock::Clock;
use futarchy_one_shot_utils::math;

// ============================================================================
// Constants
// ============================================================================

const MAX_OBSERVATIONS: u64 = 65535; // ~9 days at 12 second blocks
const PRICE_SCALE: u128 = 1_000_000_000_000; // 10^12 for precision
const MIN_UPDATE_INTERVAL_MS: u64 = 1000; // 1 second minimum between updates

// Errors
const ENotInitialized: u64 = 1;
const EInvalidWindow: u64 = 2;
const EInsufficientHistory: u64 = 3;
const EUpdateTooSoon: u64 = 4;

// ============================================================================
// Structs
// ============================================================================

/// Single price observation
public struct Observation has store, copy, drop {
    timestamp_ms: u64,
    cumulative_price: u256,  // Price × time accumulator
    price: u128,              // Spot price at observation
}

/// Ring buffer oracle used by AMMs
public struct RingBufferOracle has store {
    observations: vector<Observation>,
    current_index: u64,
    num_observations: u64,
    capacity: u64,
    last_update_ms: u64,
}

// ============================================================================
// Core Functions
// ============================================================================

/// Create new ring buffer oracle
public fun new(initial_capacity: u64): RingBufferOracle {
    let mut observations = vector::empty();
    let mut i = 0;
    while (i < initial_capacity) {
        observations.push_back(Observation {
            timestamp_ms: 0,
            cumulative_price: 0,
            price: 0,
        });
        i = i + 1;
    };
    
    RingBufferOracle {
        observations,
        current_index: 0,
        num_observations: 0,
        capacity: initial_capacity,
        last_update_ms: 0,
    }
}

/// Write new price observation
public fun write(
    oracle: &mut RingBufferOracle,
    price: u128,
    clock: &Clock,
) {
    let now = clock.timestamp_ms();
    
    // Prevent spam
    if (oracle.last_update_ms > 0) {
        assert!(now >= oracle.last_update_ms + MIN_UPDATE_INTERVAL_MS, EUpdateTooSoon);
    };
    
    // Calculate cumulative
    let new_cumulative = if (oracle.num_observations > 0) {
        let last = oracle.observations.borrow(oracle.current_index);
        let time_delta = now - last.timestamp_ms;
        last.cumulative_price + ((last.price as u256) * (time_delta as u256))
    } else {
        0
    };
    
    // Move to next slot
    let next_index = if (oracle.num_observations == 0) {
        0
    } else {
        (oracle.current_index + 1) % oracle.capacity
    };
    
    // Write observation
    *oracle.observations.borrow_mut(next_index) = Observation {
        timestamp_ms: now,
        cumulative_price: new_cumulative,
        price,
    };
    
    oracle.current_index = next_index;
    if (oracle.num_observations < oracle.capacity) {
        oracle.num_observations = oracle.num_observations + 1;
    };
    oracle.last_update_ms = now;
}

/// Get TWAP for any time window
public fun get_twap(
    oracle: &RingBufferOracle,
    seconds_ago: u64,
    clock: &Clock,
): u128 {
    assert!(oracle.num_observations > 0, ENotInitialized);
    
    let now = clock.timestamp_ms();
    let target_ms = now - (seconds_ago * 1000);
    
    // Find observations for TWAP calculation
    let (old_obs, new_obs) = find_observations_for_twap(oracle, target_ms, now);
    
    // Calculate TWAP
    let time_diff = new_obs.timestamp_ms - old_obs.timestamp_ms;
    if (time_diff == 0) {
        return new_obs.price
    };
    
    let cumulative_diff = new_obs.cumulative_price - old_obs.cumulative_price;
    ((cumulative_diff / (time_diff as u256)) as u128)
}

/// Get TWAP for lending (30 minutes standard)
public fun get_lending_twap(
    oracle: &RingBufferOracle,
    clock: &Clock,
): u128 {
    get_twap(oracle, 1800, clock) // 30 minutes
}

/// Get longest possible TWAP (for governance)
public fun get_longest_twap(
    oracle: &RingBufferOracle,
    clock: &Clock,
): u128 {
    if (oracle.num_observations == 0) {
        return PRICE_SCALE
    };
    
    // Find oldest observation
    let oldest_idx = if (oracle.num_observations < oracle.capacity) {
        0
    } else {
        (oracle.current_index + 1) % oracle.capacity
    };
    
    let oldest = oracle.observations.borrow(oldest_idx);
    let now = clock.timestamp_ms();
    let age_seconds = (now - oldest.timestamp_ms) / 1000;
    
    if (age_seconds > 0) {
        get_twap(oracle, age_seconds, clock)
    } else {
        oracle.observations.borrow(oracle.current_index).price
    }
}

// ============================================================================
// Helper Functions
// ============================================================================

/// Find observations for TWAP calculation
fun find_observations_for_twap(
    oracle: &RingBufferOracle,
    target_ms: u64,
    now_ms: u64,
): (Observation, Observation) {
    // Get newest observation
    let newest = *oracle.observations.borrow(oracle.current_index);
    
    // Handle single observation
    if (oracle.num_observations == 1) {
        return (newest, newest)
    };
    
    // Find oldest index
    let oldest_idx = if (oracle.num_observations < oracle.capacity) {
        0
    } else {
        (oracle.current_index + 1) % oracle.capacity
    };
    
    // Linear search for target (simple for Move)
    let mut before = *oracle.observations.borrow(oldest_idx);
    let mut i = 0;
    
    while (i < oracle.num_observations) {
        let idx = (oldest_idx + i) % oracle.capacity;
        let obs = *oracle.observations.borrow(idx);
        
        if (obs.timestamp_ms <= target_ms) {
            before = obs;
        } else {
            break
        };
        
        i = i + 1;
    };
    
    // Interpolate if needed
    if (before.timestamp_ms < target_ms && i < oracle.num_observations) {
        let after_idx = (oldest_idx + i) % oracle.capacity;
        let after = *oracle.observations.borrow(after_idx);
        
        // Interpolate to exact target time
        let time_before = target_ms - before.timestamp_ms;
        let interpolated_cumulative = before.cumulative_price + 
            ((before.price as u256) * (time_before as u256));
        
        before = Observation {
            timestamp_ms: target_ms,
            cumulative_price: interpolated_cumulative,
            price: before.price,
        };
    };
    
    // Add time since last observation for "now"
    let mut newest_adjusted = newest;
    if (newest.timestamp_ms < now_ms) {
        let time_since = now_ms - newest.timestamp_ms;
        newest_adjusted.cumulative_price = newest.cumulative_price + 
            ((newest.price as u256) * (time_since as u256));
        newest_adjusted.timestamp_ms = now_ms;
    };
    
    (before, newest_adjusted)
}

/// Check if sufficient history exists
public fun has_sufficient_history(
    oracle: &RingBufferOracle,
    seconds_required: u64,
    clock: &Clock,
): bool {
    if (oracle.num_observations == 0) {
        return false
    };
    
    let oldest_idx = if (oracle.num_observations < oracle.capacity) {
        0
    } else {
        (oracle.current_index + 1) % oracle.capacity
    };
    
    let oldest = oracle.observations.borrow(oldest_idx);
    let now = clock.timestamp_ms();
    
    (now - oldest.timestamp_ms) >= (seconds_required * 1000)
}

/// Get latest price
public fun get_latest_price(oracle: &RingBufferOracle): u128 {
    if (oracle.num_observations > 0) {
        oracle.observations.borrow(oracle.current_index).price
    } else {
        0
    }
}

/// Merge observations from source oracle into target oracle
/// Used when proposal finalizes to merge winning conditional's history into spot
public fun merge_observations(
    target: &mut RingBufferOracle,
    source: &RingBufferOracle,
    start_ms: u64,  // Start of period to merge
    end_ms: u64,    // End of period to merge
) {
    if (source.num_observations == 0) {
        return
    };
    
    // Find starting index in source
    let oldest_idx = if (source.num_observations < source.capacity) {
        0
    } else {
        (source.current_index + 1) % source.capacity
    };
    
    // Copy observations within time range
    let mut i = 0;
    while (i < source.num_observations) {
        let idx = (oldest_idx + i) % source.capacity;
        let obs = source.observations.borrow(idx);
        
        // Only merge observations within the proposal period
        if (obs.timestamp_ms >= start_ms && obs.timestamp_ms <= end_ms) {
            // Write to target (this handles cumulative calculation)
            write_with_timestamp(target, obs.price, obs.timestamp_ms);
        };
        
        i = i + 1;
    };
}

/// Internal write with specific timestamp (for merging)
fun write_with_timestamp(
    oracle: &mut RingBufferOracle,
    price: u128,
    timestamp_ms: u64,
) {
    // Calculate cumulative
    let new_cumulative = if (oracle.num_observations > 0) {
        let last = oracle.observations.borrow(oracle.current_index);
        if (timestamp_ms > last.timestamp_ms) {
            let time_delta = timestamp_ms - last.timestamp_ms;
            last.cumulative_price + ((last.price as u256) * (time_delta as u256))
        } else {
            // Skip if timestamp is not newer
            return
        }
    } else {
        0
    };
    
    // Move to next slot
    let next_index = if (oracle.num_observations == 0) {
        0
    } else {
        (oracle.current_index + 1) % oracle.capacity
    };
    
    // Write observation
    *oracle.observations.borrow_mut(next_index) = Observation {
        timestamp_ms,
        cumulative_price: new_cumulative,
        price,
    };
    
    oracle.current_index = next_index;
    if (oracle.num_observations < oracle.capacity) {
        oracle.num_observations = oracle.num_observations + 1;
    };
    oracle.last_update_ms = timestamp_ms;
}

// ============================================================================
// Test Functions
// ============================================================================

#[test_only]
/// Destroy oracle for testing
public fun destroy_for_testing(oracle: RingBufferOracle) {
    let RingBufferOracle {
        observations: _,
        current_index: _,
        num_observations: _,
        capacity: _,
        last_update_ms: _,
    } = oracle;
}module futarchy_markets::spot_conditional_router;

use futarchy_markets::swap;
use futarchy_markets::coin_escrow::{Self, TokenEscrow};
use futarchy_markets::conditional_token::ConditionalToken;
use futarchy_markets::proposal::Proposal;
use sui::coin::{Self, Coin};
use sui::clock::Clock;
use sui::transfer;
use sui::tx_context::TxContext;
use std::vector;

// Errors
const EMinOutNotMet: u64 = 1;
const EInvalidState: u64 = 2;
const EZeroAmount: u64 = 3;
const ESlippageTooHigh: u64 = 4;

/// Asset → Stable (spot exact-in)
/// Route: deposit ASSET → mint complete set of ASSET tokens →
///        swap each to STABLE in its outcome AMM → redeem STABLE complete set → STABLE coin.
#[allow(lint(self_transfer))]
public entry fun swap_spot_asset_to_spot_stable_exact_in<AssetType, StableType>(
    proposal: &mut Proposal<AssetType, StableType>,
    escrow: &mut TokenEscrow<AssetType, StableType>,
    asset_in: Coin<AssetType>,
    min_stable_out: u64,
    clock: &Clock,
    ctx: &mut TxContext,
) {
    // Disallow if market is finalized
    let market_state = escrow.get_market_state();
    assert!(!market_state.is_finalized(), EInvalidState);

    // 1) Mint complete set of ASSET conditional tokens
    let mut tokens = coin_escrow::mint_complete_set_asset(escrow, asset_in, clock, ctx);

    // Calculate per-leg minimum to prevent MEV attacks
    // Allow max 5% slippage per leg (95% of expected fair share)
    let num_outcomes = tokens.length();
    assert!(num_outcomes > 0, EZeroAmount);
    let per_leg_min = if (min_stable_out > 0 && num_outcomes > 0) {
        // Distribute minimum proportionally with 5% tolerance
        (min_stable_out * 95 / 100) / num_outcomes
    } else {
        0
    };

    // 2) Convert each token ASSET→STABLE via its outcome AMM
    let mut stable_tokens = vector::empty<ConditionalToken>();
    while (!tokens.is_empty()) {
        let t = tokens.pop_back();                     // take ownership
        let outcome_idx = (t.outcome() as u64);        // safe to rely on token metadata
        let s = swap::swap_asset_to_stable(
            proposal,
            escrow,
            outcome_idx,
            t,                                         // moved here
            per_leg_min,                               // MEV protection per swap
            clock,
            ctx
        );
        stable_tokens.push_back(s);
    };
    tokens.destroy_empty();

    // 3) Redeem STABLE complete set back to spot coin
    let balance_out = coin_escrow::redeem_complete_set_stable(escrow, stable_tokens, clock, ctx);
    let stable_out = coin::from_balance(balance_out, ctx);
    let out_amt = coin::value(&stable_out);
    assert!(out_amt >= min_stable_out, EMinOutNotMet);

    transfer::public_transfer(stable_out, ctx.sender());
}

/// Stable → Asset (spot exact-in)
/// Route: deposit STABLE → mint complete set of STABLE tokens →
///        swap each to ASSET in its outcome AMM → redeem ASSET complete set → ASSET coin.
#[allow(lint(self_transfer))]
public entry fun swap_spot_stable_to_spot_asset_exact_in<AssetType, StableType>(
    proposal: &mut Proposal<AssetType, StableType>,
    escrow: &mut TokenEscrow<AssetType, StableType>,
    stable_in: Coin<StableType>,
    min_asset_out: u64,
    clock: &Clock,
    ctx: &mut TxContext,
) {
    // Disallow if market is finalized
    let market_state = escrow.get_market_state();
    assert!(!market_state.is_finalized(), EInvalidState);

    // 1) Mint complete set of STABLE conditional tokens
    let mut tokens = coin_escrow::mint_complete_set_stable(escrow, stable_in, clock, ctx);

    // Calculate per-leg minimum to prevent MEV attacks
    let num_outcomes = tokens.length();
    assert!(num_outcomes > 0, EZeroAmount);
    let per_leg_min = if (min_asset_out > 0 && num_outcomes > 0) {
        // Distribute minimum proportionally with 5% tolerance
        (min_asset_out * 95 / 100) / num_outcomes
    } else {
        0
    };

    // 2) Convert each token STABLE→ASSET via its outcome AMM
    let mut asset_tokens = vector::empty<ConditionalToken>();
    while (!tokens.is_empty()) {
        let t = tokens.pop_back();
        let outcome_idx = (t.outcome() as u64);
        let a = swap::swap_stable_to_asset(
            proposal,
            escrow,
            outcome_idx,
            t,
            per_leg_min,                               // MEV protection per swap
            clock,
            ctx
        );
        asset_tokens.push_back(a);
    };
    tokens.destroy_empty();

    // 3) Redeem ASSET complete set back to spot coin
    let balance_out = coin_escrow::redeem_complete_set_asset(escrow, asset_tokens, clock, ctx);
    let asset_out = coin::from_balance(balance_out, ctx);
    let out_amt = coin::value(&asset_out);
    assert!(out_amt >= min_asset_out, EMinOutNotMet);

    transfer::public_transfer(asset_out, ctx.sender());
}module futarchy_markets::proposal;

use futarchy_markets::conditional_amm::{Self, LiquidityPool};
use futarchy_markets::coin_escrow::{Self, TokenEscrow};
use futarchy_markets::liquidity_initialize;
use futarchy_markets::market_state;
use std::ascii::String as AsciiString;
use std::string::String;
use std::type_name;
use std::option;
use std::vector;
use sui::balance::{Balance};
use sui::clock::Clock;
use sui::coin::{Coin};
use sui::event;

// === Introduction ===
// This defines the core proposal logic and details

// === Errors ===

const EInvalidAmount: u64 = 1;
const EInvalidState: u64 = 2;
const EAssetLiquidityTooLow: u64 = 4;
const EStableLiquidityTooLow: u64 = 5;
const EPoolNotFound: u64 = 6;
const EOutcomeOutOfBounds: u64 = 7;
const EInvalidOutcomeVectors: u64 = 8;
const ESpotTwapNotReady: u64 = 9;
const ETooManyOutcomes: u64 = 10;
const EInvalidOutcome: u64 = 11;
const ENotFinalized: u64 = 12;
const ETwapNotSet: u64 = 13;
const ETooManyActions: u64 = 14;

// === Constants ===

const STATE_PREMARKET: u8 = 0; // Proposal exists, outcomes can be added/mutated. No market yet.
const STATE_REVIEW: u8 = 1;    // Market is initialized and locked for review. Not yet trading.
const STATE_TRADING: u8 = 2;   // Market is live and trading.
const STATE_FINALIZED: u8 = 3; // Market has resolved.

// Outcome constants for TWAP calculation
const OUTCOME_ACCEPTED: u64 = 0;
const OUTCOME_REJECTED: u64 = 1;

// === Structs ===

/// Configuration for proposal timing and periods
public struct ProposalTiming has store {
    created_at: u64,
    market_initialized_at: Option<u64>,
    review_period_ms: u64,
    trading_period_ms: u64,
    last_twap_update: u64,
    twap_start_delay: u64,
}

/// Configuration for liquidity requirements
public struct LiquidityConfig has store {
    min_asset_liquidity: u64,
    min_stable_liquidity: u64,
    asset_amounts: vector<u64>,
    stable_amounts: vector<u64>,
    uses_dao_liquidity: bool,
}

/// TWAP (Time-Weighted Average Price) configuration
public struct TwapConfig has store {
    twap_prices: vector<u128>,
    twap_initial_observation: u128,
    twap_step_max: u64,
    twap_threshold: u64,
}

/// Outcome-related data
public struct OutcomeData has store {
    outcome_count: u64,
    outcome_messages: vector<String>,
    outcome_creators: vector<address>,
    intent_keys: vector<option::Option<String>>,
    actions_per_outcome: vector<u64>,
    winning_outcome: Option<u64>,
}

/// Core proposal object that owns AMM pools
public struct Proposal<phantom AssetType, phantom StableType> has key, store {
    id: UID,
    /// The logical ID of the proposal from the priority queue.
    queued_proposal_id: ID,
    state: u8,
    dao_id: ID,
    proposer: address, // The original proposer.
    liquidity_provider: Option<address>, // The user who provides liquidity (gets liquidity back).
    
    // Market-related fields
    supply_ids: Option<vector<ID>>,
    amm_pools: Option<vector<LiquidityPool>>,
    escrow_id: Option<ID>,
    market_state_id: Option<ID>,
    
    // Proposal content
    title: String,
    details: vector<String>,
    metadata: String,
    
    // Grouped configurations
    timing: ProposalTiming,
    liquidity_config: LiquidityConfig,
    twap_config: TwapConfig,
    outcome_data: OutcomeData,
    
    // Fee-related fields
    amm_total_fee_bps: u64,
    fee_escrow: Balance<StableType>,
    treasury_address: address,
}

/// A scoped witness proving that a particular (proposal, outcome) owned the intent key.
/// Only mintable by the module that has &mut Proposal and consumes the slot.
/// This prevents cross-proposal cancellation attacks.
public struct CancelWitness has drop {
    proposal: address,
    outcome_index: u64,
    key: String,
}

// Getter functions for CancelWitness (for use in cancel_losing_intent_scoped)
public fun cancel_witness_proposal(witness: &CancelWitness): address {
    witness.proposal
}

public fun cancel_witness_outcome_index(witness: &CancelWitness): u64 {
    witness.outcome_index
}

public fun cancel_witness_key(witness: &CancelWitness): String {
    witness.key
}

// === Events ===

public struct ProposalCreated has copy, drop {
    proposal_id: ID,
    dao_id: ID,
    proposer: address,
    outcome_count: u64,
    outcome_messages: vector<String>,
    created_at: u64,
    asset_type: AsciiString,
    stable_type: AsciiString,
    review_period_ms: u64,
    trading_period_ms: u64,
    title: String,
    metadata: String,
}

public struct ProposalMarketInitialized has copy, drop {
    proposal_id: ID,
    dao_id: ID,
    market_state_id: ID,
    escrow_id: ID,
    timestamp: u64,
}

public struct ProposalOutcomeMutated has copy, drop {
    proposal_id: ID,
    dao_id: ID,
    outcome_idx: u64,
    old_creator: address,
    new_creator: address,
    timestamp: u64,
}

public struct ProposalOutcomeAdded has copy, drop {
    proposal_id: ID,
    dao_id: ID,
    new_outcome_idx: u64,
    creator: address,
    timestamp: u64,
}

// === Public Functions ===

/// Creates all on-chain objects for a futarchy market when a proposal is activated from the queue.
/// This is the main entry point for creating a full proposal with market infrastructure.
#[allow(lint(share_owned))]
public fun initialize_market<AssetType, StableType>(
    // Proposal ID (generated when adding to queue)
    proposal_id: ID,
    // Market parameters from DAO
    dao_id: ID,
    review_period_ms: u64,
    trading_period_ms: u64,
    min_asset_liquidity: u64,
    min_stable_liquidity: u64,
    twap_start_delay: u64,
    twap_initial_observation: u128,
    twap_step_max: u64,
    twap_threshold: u64,
    amm_total_fee_bps: u64,
    max_outcomes: u64, // DAO's configured max outcomes
    treasury_address: address,
    // Proposal specific parameters
    title: String,
    metadata: String,
    initial_outcome_messages: vector<String>,
    initial_outcome_details: vector<String>,
    asset_coin: Coin<AssetType>,
    stable_coin: Coin<StableType>,
    proposer: address, // The original proposer from the queue
    uses_dao_liquidity: bool,
    fee_escrow: Balance<StableType>, // DAO fees if any
    intent_key_for_yes: Option<String>, // Intent key for YES outcome
    clock: &Clock,
    ctx: &mut TxContext,
): (ID, ID, u8) {

    // Create a new proposal UID
    let id = object::new(ctx);
    let actual_proposal_id = object::uid_to_inner(&id);
    let outcome_count = initial_outcome_messages.length();

    // Validate outcome count
    assert!(outcome_count == initial_outcome_details.length(), EInvalidOutcomeVectors);
    assert!(outcome_count <= max_outcomes, ETooManyOutcomes);

    // Liquidity is split evenly among all outcomes
    let total_asset_liquidity = asset_coin.value();
    let total_stable_liquidity = stable_coin.value();
    assert!(total_asset_liquidity > 0 && total_stable_liquidity > 0, EInvalidAmount);
    
    let asset_per_outcome = total_asset_liquidity / outcome_count;
    let stable_per_outcome = total_stable_liquidity / outcome_count;
    
    // Calculate remainders from integer division
    let asset_remainder = total_asset_liquidity % outcome_count;
    let stable_remainder = total_stable_liquidity % outcome_count;
    
    // Distribute liquidity evenly, with remainder going to first outcomes
    let mut initial_asset_amounts = vector::empty<u64>();
    let mut initial_stable_amounts = vector::empty<u64>();
    let mut i = 0;
    while (i < outcome_count) {
        // Add 1 extra token to first 'remainder' outcomes
        let asset_amount = if (i < asset_remainder) { asset_per_outcome + 1 } else { asset_per_outcome };
        let stable_amount = if (i < stable_remainder) { stable_per_outcome + 1 } else { stable_per_outcome };
        
        vector::push_back(&mut initial_asset_amounts, asset_amount);
        vector::push_back(&mut initial_stable_amounts, stable_amount);
        i = i + 1;
    };

    // Validate minimum liquidity requirements
    assert!(asset_per_outcome >= min_asset_liquidity, EAssetLiquidityTooLow);
    assert!(stable_per_outcome >= min_stable_liquidity, EStableLiquidityTooLow);

    // Initialize outcome creators to the original proposer
    let outcome_creators = vector::tabulate!(outcome_count, |_| proposer);

    // Create market state
    let market_state = market_state::new(
        actual_proposal_id,  // Use the actual proposal ID, not the parameter
        dao_id, 
        outcome_count, 
        initial_outcome_messages, 
        clock, 
        ctx
    );
    let market_state_id = object::id(&market_state);

    // Create escrow
    let mut escrow = coin_escrow::new<AssetType, StableType>(market_state, ctx);
    let escrow_id = object::id(&escrow);

    // Create AMM pools and initialize liquidity
    let mut asset_balance = asset_coin.into_balance();
    let mut stable_balance = stable_coin.into_balance();
    
    // Quantum liquidity: the same liquidity backs all outcomes conditionally
    // We only need the MAX amount across outcomes since they share the same underlying liquidity
    let mut max_asset = 0u64;
    let mut max_stable = 0u64;
    let mut j = 0;
    while (j < outcome_count) {
        let asset_amt = *initial_asset_amounts.borrow(j);
        let stable_amt = *initial_stable_amounts.borrow(j);
        if (asset_amt > max_asset) { max_asset = asset_amt };
        if (stable_amt > max_stable) { max_stable = stable_amt };
        j = j + 1;
    };
    
    // Extract the exact amount needed for quantum liquidity
    let asset_total = asset_balance.value();
    let stable_total = stable_balance.value();
    
    let asset_for_pool = if (asset_total > max_asset) {
        asset_balance.split(max_asset)
    } else {
        asset_balance.split(asset_total)
    };
    
    let stable_for_pool = if (stable_total > max_stable) {
        stable_balance.split(max_stable)
    } else {
        stable_balance.split(stable_total)
    };
    
    // Return excess to proposer if any
    if (asset_balance.value() > 0) {
        transfer::public_transfer(asset_balance.into_coin(ctx), proposer);
    } else {
        asset_balance.destroy_zero();
    };
    
    if (stable_balance.value() > 0) {
        transfer::public_transfer(stable_balance.into_coin(ctx), proposer);
    } else {
        stable_balance.destroy_zero();
    };
    
    let (_, amm_pools) = liquidity_initialize::create_outcome_markets(
        &mut escrow, 
        outcome_count, 
        initial_asset_amounts, 
        initial_stable_amounts,
        twap_start_delay, 
        twap_initial_observation, 
        twap_step_max,
        amm_total_fee_bps,
        asset_for_pool, 
        stable_for_pool, 
        clock, 
        ctx
    );

    // Create proposal object
    let proposal = Proposal<AssetType, StableType> {
        id,
        queued_proposal_id: proposal_id,
        state: STATE_REVIEW, // Start in REVIEW state since market is initialized
        dao_id,
        proposer,
        liquidity_provider: option::some(ctx.sender()), // The activator provides liquidity
        supply_ids: option::none(), // Will be set when escrow mints tokens
        amm_pools: option::some(amm_pools),
        escrow_id: option::some(escrow_id),
        market_state_id: option::some(market_state_id),
        title,
        details: initial_outcome_details,
        metadata,
        timing: ProposalTiming {
            created_at: clock.timestamp_ms(),
            market_initialized_at: option::some(clock.timestamp_ms()),
            review_period_ms,
            trading_period_ms,
            last_twap_update: 0,
            twap_start_delay,
        },
        liquidity_config: LiquidityConfig {
            min_asset_liquidity,
            min_stable_liquidity,
            asset_amounts: initial_asset_amounts,
            stable_amounts: initial_stable_amounts,
            uses_dao_liquidity,
        },
        twap_config: TwapConfig {
            twap_prices: vector::empty(),
            twap_initial_observation,
            twap_step_max,
            twap_threshold,
        },
        outcome_data: OutcomeData {
            outcome_count,
            outcome_messages: initial_outcome_messages,
            outcome_creators,
            intent_keys: vector::tabulate!(outcome_count, |_| option::none<String>()),
            actions_per_outcome: vector::tabulate!(outcome_count, |_| 0),
            winning_outcome: option::none(),
        },
        amm_total_fee_bps,
        fee_escrow,
        treasury_address,
    };

    event::emit(ProposalCreated {
        proposal_id: actual_proposal_id,
        dao_id,
        proposer,
        outcome_count,
        outcome_messages: initial_outcome_messages,
        created_at: clock.timestamp_ms(),
        asset_type: type_name::get<AssetType>().into_string(),
        stable_type: type_name::get<StableType>().into_string(),
        review_period_ms,
        trading_period_ms,
        title,
        metadata,
    });

    transfer::public_share_object(proposal);
    transfer::public_share_object(escrow);

    // Return the actual on-chain proposal ID, not the queue ID
    (actual_proposal_id, market_state_id, STATE_REVIEW)
}

// The create function has been removed as it's not used in production.
// All proposals are created through initialize_market which properly handles proposal IDs
// generated from the priority queue.

/// Create a PREMARKET proposal without market/escrow/liquidity.
/// This reserves the proposal "as next" without consuming DAO/proposer liquidity.
#[allow(lint(share_owned))]
public fun new_premarket<AssetType, StableType>(
    // Proposal ID originating from queue
    proposal_id_from_queue: ID,
    dao_id: ID,
    review_period_ms: u64,
    trading_period_ms: u64,
    min_asset_liquidity: u64,
    min_stable_liquidity: u64,
    twap_start_delay: u64,
    twap_initial_observation: u128,
    twap_step_max: u64,
    twap_threshold: u64,
    amm_total_fee_bps: u64,
    max_outcomes: u64, // DAO's configured max outcomes
    treasury_address: address,
    title: String,
    metadata: String,
    outcome_messages: vector<String>,
    outcome_details: vector<String>,
    proposer: address,
    uses_dao_liquidity: bool,
    fee_escrow: Balance<StableType>,
    intent_key_for_yes: Option<String>,
    clock: &Clock,
    ctx: &mut TxContext,
): ID {
    let id = object::new(ctx);
    let actual_proposal_id = object::uid_to_inner(&id);
    let outcome_count = outcome_messages.length();
    
    // Validate outcome count
    assert!(outcome_count <= max_outcomes, ETooManyOutcomes);
    
    let proposal = Proposal<AssetType, StableType> {
        id,
        queued_proposal_id: proposal_id_from_queue,
        state: STATE_PREMARKET,
        dao_id,
        proposer,
        liquidity_provider: option::none(),
        supply_ids: option::none(),
        amm_pools: option::none(),
        escrow_id: option::none(),
        market_state_id: option::none(),
        title,
        details: outcome_details,
        metadata,
        timing: ProposalTiming {
            created_at: clock.timestamp_ms(),
            market_initialized_at: option::none(),
            review_period_ms,
            trading_period_ms,
            last_twap_update: 0,
            twap_start_delay,
        },
        liquidity_config: LiquidityConfig {
            min_asset_liquidity,
            min_stable_liquidity,
            asset_amounts: vector::empty(),
            stable_amounts: vector::empty(),
            uses_dao_liquidity,
        },
        twap_config: TwapConfig {
            twap_prices: vector::empty(),
            twap_initial_observation,
            twap_step_max,
            twap_threshold,
        },
        outcome_data: OutcomeData {
            outcome_count,
            outcome_messages,
            outcome_creators: vector::tabulate!(outcome_count, |_| proposer),
            intent_keys: vector::tabulate!(outcome_count, |_| option::none<String>()),
            actions_per_outcome: vector::tabulate!(outcome_count, |_| 0),
            winning_outcome: option::none(),
        },
        amm_total_fee_bps,
        fee_escrow,
        treasury_address,
    };
    
    transfer::public_share_object(proposal);
    actual_proposal_id
}

/// Initialize market/escrow/AMMs for a PREMARKET proposal.
/// Consumes provided coins, sets state to REVIEW, and readies the market for the review timer.
#[allow(lint(share_owned, self_transfer))]
public fun initialize_market_from_premarket<AssetType, StableType>(
    proposal: &mut Proposal<AssetType, StableType>,
    asset_coin: Coin<AssetType>,
    stable_coin: Coin<StableType>,
    clock: &Clock,
    ctx: &mut TxContext,
): ID {
    assert!(proposal.state == STATE_PREMARKET, EInvalidState);
    
    // Evenly split liquidity across outcomes (same convention as initialize_market)
    let outcome_count = proposal.outcome_data.outcome_count;
    let total_asset_liquidity = asset_coin.value();
    let total_stable_liquidity = stable_coin.value();
    assert!(total_asset_liquidity > 0 && total_stable_liquidity > 0, EInvalidAmount);
    
    let asset_per = total_asset_liquidity / outcome_count;
    let stable_per = total_stable_liquidity / outcome_count;
    assert!(asset_per >= proposal.liquidity_config.min_asset_liquidity, EAssetLiquidityTooLow);
    assert!(stable_per >= proposal.liquidity_config.min_stable_liquidity, EStableLiquidityTooLow);
    
    let asset_remainder = total_asset_liquidity % outcome_count;
    let stable_remainder = total_stable_liquidity % outcome_count;
    
    let mut initial_asset_amounts = vector::empty<u64>();
    let mut initial_stable_amounts = vector::empty<u64>();
    let mut i = 0;
    while (i < outcome_count) {
        let a = if (i < asset_remainder) { asset_per + 1 } else { asset_per };
        let s = if (i < stable_remainder) { stable_per + 1 } else { stable_per };
        vector::push_back(&mut initial_asset_amounts, a);
        vector::push_back(&mut initial_stable_amounts, s);
        i = i + 1;
    };
    
    // Market state
    let ms = market_state::new(
        object::id(proposal),
        proposal.dao_id,
        proposal.outcome_data.outcome_count,
        proposal.outcome_data.outcome_messages,
        clock,
        ctx
    );
    let market_state_id = object::id(&ms);
    
    // Escrow
    let mut escrow = coin_escrow::new<AssetType, StableType>(ms, ctx);
    let escrow_id = object::id(&escrow);
    
    // Determine quantum liquidity amounts
    let mut asset_balance = asset_coin.into_balance();
    let mut stable_balance = stable_coin.into_balance();
    
    let mut max_asset = 0u64;
    let mut max_stable = 0u64;
    i = 0;
    while (i < outcome_count) {
        let a = *initial_asset_amounts.borrow(i);
        let s = *initial_stable_amounts.borrow(i);
        if (a > max_asset) { max_asset = a };
        if (s > max_stable) { max_stable = s };
        i = i + 1;
    };
    
    let asset_total = asset_balance.value();
    let stable_total = stable_balance.value();
    
    let asset_for_pool = if (asset_total > max_asset) {
        asset_balance.split(max_asset)
    } else {
        asset_balance.split(asset_total)
    };
    
    let stable_for_pool = if (stable_total > max_stable) {
        stable_balance.split(max_stable)
    } else {
        stable_balance.split(stable_total)
    };
    
    // Return any excess to liquidity provider (the activator who supplied coins)
    let sender = ctx.sender();
    if (asset_balance.value() > 0) {
        transfer::public_transfer(asset_balance.into_coin(ctx), sender);
    } else {
        asset_balance.destroy_zero();
    };
    
    if (stable_balance.value() > 0) {
        transfer::public_transfer(stable_balance.into_coin(ctx), sender);
    } else {
        stable_balance.destroy_zero();
    };
    
    // Create outcome markets
    let (_supply_ids, amm_pools) = liquidity_initialize::create_outcome_markets(
        &mut escrow,
        proposal.outcome_data.outcome_count,
        initial_asset_amounts,
        initial_stable_amounts,
        proposal.timing.twap_start_delay,
        proposal.twap_config.twap_initial_observation,
        proposal.twap_config.twap_step_max,
        proposal.amm_total_fee_bps,
        asset_for_pool,
        stable_for_pool,
        clock,
        ctx
    );
    
    // Update proposal's liquidity amounts
    proposal.liquidity_config.asset_amounts = initial_asset_amounts;
    proposal.liquidity_config.stable_amounts = initial_stable_amounts;
    
    // Initialize market fields: PREMARKET → REVIEW
    initialize_market_fields(
        proposal,
        market_state_id,
        escrow_id,
        amm_pools,
        clock.timestamp_ms(),
        sender
    );
    
    transfer::public_share_object(escrow);
    market_state_id
}

/// Adds a new outcome during the premarket phase.
/// max_outcomes: The DAO's configured maximum number of outcomes allowed
public fun add_outcome<AssetType, StableType>(
    proposal: &mut Proposal<AssetType, StableType>,
    message: String,
    detail: String,
    asset_amount: u64,
    stable_amount: u64,
    creator: address,
    max_outcomes: u64,
    clock: &Clock,
) {
    // Check that we're not exceeding the maximum number of outcomes
    assert!(proposal.outcome_data.outcome_count < max_outcomes, ETooManyOutcomes);
    
    proposal.outcome_data.outcome_messages.push_back(message);
    proposal.details.push_back(detail);
    proposal.liquidity_config.asset_amounts.push_back(asset_amount);
    proposal.liquidity_config.stable_amounts.push_back(stable_amount);
    proposal.outcome_data.outcome_creators.push_back(creator);
    
    // Initialize action count for new outcome
    proposal.outcome_data.actions_per_outcome.push_back(0);

    let new_idx = proposal.outcome_data.outcome_count;
    proposal.outcome_data.outcome_count = new_idx + 1;

    event::emit(ProposalOutcomeAdded {
        proposal_id: get_id(proposal),
        dao_id: get_dao_id(proposal),
        new_outcome_idx: new_idx,
        creator,
        timestamp: clock.timestamp_ms(),
    });
}

/// Initializes the market-related fields of the proposal.
public fun initialize_market_fields<AssetType, StableType>(
    proposal: &mut Proposal<AssetType, StableType>,
    market_state_id: ID,
    escrow_id: ID,
    amm_pools: vector<LiquidityPool>,
    // LP tracking moved to conditional tokens
    initialized_at: u64,
    liquidity_provider: address,
) {
    assert!(proposal.state == STATE_PREMARKET, EInvalidState);

    // Use option::fill to replace None with Some value
    option::fill(&mut proposal.market_state_id, market_state_id);
    option::fill(&mut proposal.escrow_id, escrow_id);
    option::fill(&mut proposal.amm_pools, amm_pools);
    // LP caps no longer needed - using conditional tokens
    option::fill(&mut proposal.timing.market_initialized_at, initialized_at);
    option::fill(&mut proposal.liquidity_provider, liquidity_provider);
    proposal.state = STATE_REVIEW; // Advance state to REVIEW
}

/// Emits the ProposalMarketInitialized event
public fun emit_market_initialized(
    proposal_id: ID,
    dao_id: ID,
    market_state_id: ID,
    escrow_id: ID,
    timestamp: u64,
) {
    event::emit(ProposalMarketInitialized {
        proposal_id,
        dao_id,
        market_state_id,
        escrow_id,
        timestamp,
    });
}

/// Takes the escrowed fee balance out of the proposal, leaving a zero balance behind.
public fun take_fee_escrow<AssetType, StableType>(
    proposal: &mut Proposal<AssetType, StableType>,
): Balance<StableType> {
    let fee_balance = &mut proposal.fee_escrow;
    let amount = fee_balance.value();
    sui::balance::split(fee_balance, amount)
}

/// Searches the proposal's liquidity pools for an oracle matching the target ID.
/// Returns a reference to that oracle; aborts if not found.
public fun get_twaps_for_proposal<AssetType, StableType>(
    proposal: &mut Proposal<AssetType, StableType>,
    clock: &Clock,
): vector<u128> {
    let pools = proposal.amm_pools.borrow_mut();
    let mut twaps = vector[];
    let mut i = 0;
    while (i < pools.length()) {
        let pool = &mut pools[i];
        let twap = pool.get_twap(clock);
        twaps.push_back(twap);
        i = i + 1;
    };
    twaps
}

// === Private Functions ===

fun get_pool_mut(pools: &mut vector<LiquidityPool>, outcome_idx: u8): &mut LiquidityPool {
    let mut i = 0;
    let len = pools.length();
    while (i < len) {
        let pool = &mut pools[i];
        if (pool.get_outcome_idx() == outcome_idx) {
            return pool
        };
        i = i + 1;
    };
    abort EPoolNotFound
}

// === View Functions ===

public fun is_finalized<AssetType, StableType>(proposal: &Proposal<AssetType, StableType>): bool {
    proposal.state == STATE_FINALIZED
}

public fun get_twap_prices<AssetType, StableType>(
    proposal: &Proposal<AssetType, StableType>,
): &vector<u128> {
    &proposal.twap_config.twap_prices
}

public fun get_last_twap_update<AssetType, StableType>(
    proposal: &Proposal<AssetType, StableType>,
): u64 {
    proposal.timing.last_twap_update
}

/// Get TWAP for a specific outcome by index
public fun get_twap_by_outcome<AssetType, StableType>(
    proposal: &Proposal<AssetType, StableType>,
    outcome_index: u64,
): u128 {
    // Add defensive checks
    assert!(proposal.state == STATE_FINALIZED, ENotFinalized);
    let twap_prices = &proposal.twap_config.twap_prices;
    assert!(!twap_prices.is_empty(), ETwapNotSet);
    assert!(outcome_index < twap_prices.length(), EOutcomeOutOfBounds);
    *twap_prices.borrow(outcome_index)
}

/// Get the TWAP of the winning outcome
public fun get_winning_twap<AssetType, StableType>(
    proposal: &Proposal<AssetType, StableType>,
): u128 {
    // Add defensive checks
    assert!(proposal.state == STATE_FINALIZED, ENotFinalized);
    assert!(proposal.outcome_data.winning_outcome.is_some(), EInvalidState);
    assert!(!proposal.twap_config.twap_prices.is_empty(), ETwapNotSet);
    let winning_outcome = *proposal.outcome_data.winning_outcome.borrow();
    get_twap_by_outcome(proposal, winning_outcome)
}

public fun state<AssetType, StableType>(proposal: &Proposal<AssetType, StableType>): u8 {
    proposal.state
}

public fun get_winning_outcome<AssetType, StableType>(
    proposal: &Proposal<AssetType, StableType>,
): u64 {
    assert!(proposal.outcome_data.winning_outcome.is_some(), EInvalidState);
    *proposal.outcome_data.winning_outcome.borrow()
}

/// Checks if winning outcome has been set
public fun is_winning_outcome_set<AssetType, StableType>(
    proposal: &Proposal<AssetType, StableType>,
): bool {
    proposal.outcome_data.winning_outcome.is_some()
}

/// Returns the treasury address where fees for failed proposals are sent.
public fun treasury_address<AssetType, StableType>(
    proposal: &Proposal<AssetType, StableType>,
): address {
    proposal.treasury_address
}

public fun get_id<AssetType, StableType>(proposal: &Proposal<AssetType, StableType>): ID {
    proposal.id.to_inner()
}

public fun escrow_id<AssetType, StableType>(proposal: &Proposal<AssetType, StableType>): ID {
    assert!(proposal.escrow_id.is_some(), EInvalidState);
    *proposal.escrow_id.borrow()
}

public fun market_state_id<AssetType, StableType>(proposal: &Proposal<AssetType, StableType>): ID {
    assert!(proposal.market_state_id.is_some(), EInvalidState);
    *proposal.market_state_id.borrow()
}

public fun get_market_initialized_at<AssetType, StableType>(proposal: &Proposal<AssetType, StableType>): u64 {
    assert!(proposal.timing.market_initialized_at.is_some(), EInvalidState);
    *proposal.timing.market_initialized_at.borrow()
}

public fun outcome_count<AssetType, StableType>(proposal: &Proposal<AssetType, StableType>): u64 {
    proposal.outcome_data.outcome_count
}

/// Alias for outcome_count for better readability
public fun get_num_outcomes<AssetType, StableType>(proposal: &Proposal<AssetType, StableType>): u64 {
    proposal.outcome_data.outcome_count
}

public fun proposer<AssetType, StableType>(proposal: &Proposal<AssetType, StableType>): address {
    proposal.proposer
}

public fun created_at<AssetType, StableType>(proposal: &Proposal<AssetType, StableType>): u64 {
    proposal.timing.created_at
}

public fun get_details<AssetType, StableType>(proposal: &Proposal<AssetType, StableType>): &vector<String> {
    &proposal.details
}

public fun get_metadata<AssetType, StableType>(
    proposal: &Proposal<AssetType, StableType>,
): &String {
    &proposal.metadata
}

public fun get_amm_pool_ids<AssetType, StableType>(
    proposal: &Proposal<AssetType, StableType>,
): vector<ID> {
    let mut ids = vector[];
    let mut i = 0;
    let pools = proposal.amm_pools.borrow();
    let len = pools.length();
    while (i < len) {
        let pool = &pools[i];
        ids.push_back(pool.get_id());
        i = i + 1;
    };
    ids
}

public fun get_pool_mut_by_outcome<AssetType, StableType>(
    proposal: &mut Proposal<AssetType, StableType>,
    outcome_idx: u8,
): &mut LiquidityPool {
    assert!((outcome_idx as u64) < proposal.outcome_data.outcome_count, EOutcomeOutOfBounds);
    let pools_mut = proposal.amm_pools.borrow_mut();
    get_pool_mut(pools_mut, outcome_idx)
}

public fun get_pool_by_outcome<AssetType, StableType>(
    proposal: &Proposal<AssetType, StableType>,
    outcome_idx: u8,
): &LiquidityPool {
    assert!((outcome_idx as u64) < proposal.outcome_data.outcome_count, EOutcomeOutOfBounds);
    let pools = proposal.amm_pools.borrow();
    let mut i = 0;
    let len = pools.length();
    while (i < len) {
        let pool = &pools[i];
        if (pool.get_outcome_idx() == outcome_idx) {
            return pool
        };
        i = i + 1;
    };
    abort EPoolNotFound
}

// LP caps no longer needed - using conditional tokens for LP

// Pool and LP cap getter no longer needed - using conditional tokens for LP

public fun get_state<AssetType, StableType>(proposal: &Proposal<AssetType, StableType>): u8 {
    proposal.state
}

public fun get_dao_id<AssetType, StableType>(proposal: &Proposal<AssetType, StableType>): ID {
    proposal.dao_id
}

public fun proposal_id<AssetType, StableType>(proposal: &Proposal<AssetType, StableType>): ID {
    proposal.id.to_inner()
}

public fun get_amm_pools<AssetType, StableType>(
    proposal: &Proposal<AssetType, StableType>,
): &vector<LiquidityPool> {
    proposal.amm_pools.borrow()
}

public fun get_amm_pools_mut<AssetType, StableType>(
    proposal: &mut Proposal<AssetType, StableType>,
): &mut vector<LiquidityPool> {
    proposal.amm_pools.borrow_mut()
}

public fun get_created_at<AssetType, StableType>(proposal: &Proposal<AssetType, StableType>): u64 {
    proposal.timing.created_at
}

public fun get_review_period_ms<AssetType, StableType>(
    proposal: &Proposal<AssetType, StableType>,
): u64 {
    proposal.timing.review_period_ms
}

public fun get_trading_period_ms<AssetType, StableType>(
    proposal: &Proposal<AssetType, StableType>,
): u64 {
    proposal.timing.trading_period_ms
}

public fun get_twap_threshold<AssetType, StableType>(
    proposal: &Proposal<AssetType, StableType>,
): u64 {
    proposal.twap_config.twap_threshold
}

public fun get_twap_start_delay<AssetType, StableType>(proposal: &Proposal<AssetType, StableType>): u64 {
    proposal.timing.twap_start_delay
}

public fun get_twap_initial_observation<AssetType, StableType>(proposal: &Proposal<AssetType, StableType>): u128 {
    proposal.twap_config.twap_initial_observation
}

public fun get_twap_step_max<AssetType, StableType>(proposal: &Proposal<AssetType, StableType>): u64 {
    proposal.twap_config.twap_step_max
}

public fun uses_dao_liquidity<AssetType, StableType>(proposal: &Proposal<AssetType, StableType>): bool {
    proposal.liquidity_config.uses_dao_liquidity
}

public fun get_amm_total_fee_bps<AssetType, StableType>(
    proposal: &Proposal<AssetType, StableType>,
): u64 {
    proposal.amm_total_fee_bps
}


/// Returns the parameters needed to initialize the market after the premarket phase.
public fun get_market_init_params<AssetType, StableType>(proposal: &Proposal<AssetType, StableType>): (u64, &vector<String>, &vector<u64>, &vector<u64>) {
    (
        proposal.outcome_data.outcome_count,
        &proposal.outcome_data.outcome_messages,
        &proposal.liquidity_config.asset_amounts,
        &proposal.liquidity_config.stable_amounts,
    )
}

// === Package Functions ===

/// Advances the proposal state based on elapsed time
/// Transitions from REVIEW to TRADING when review period ends
/// Returns true if state was changed
public fun advance_state<AssetType, StableType>(
    proposal: &mut Proposal<AssetType, StableType>,
    escrow: &mut TokenEscrow<AssetType, StableType>,
    clock: &Clock,
): bool {
    let current_time = clock.timestamp_ms();
    // Use market_initialized_at for timing calculations instead of created_at
    // This ensures premarket proposals get proper review/trading periods after initialization
    let base_timestamp = if (proposal.timing.market_initialized_at.is_some()) {
        *proposal.timing.market_initialized_at.borrow()
    } else {
        // Fallback to created_at if market not initialized (shouldn't happen in normal flow)
        proposal.timing.created_at
    };
    
    // Check if we should transition from REVIEW to TRADING
    if (proposal.state == STATE_REVIEW) {
        let review_end = base_timestamp + proposal.timing.review_period_ms;
        if (current_time >= review_end) {
            proposal.state = STATE_TRADING;
            
            // Start trading in the market state
            let market = coin_escrow::get_market_state_mut(escrow);
            market_state::start_trading(market, proposal.timing.trading_period_ms, clock);
            
            // Set oracle start time for all pools when trading begins
            let pools = proposal.amm_pools.borrow_mut();
            let mut i = 0;
            while (i < pools.length()) {
                let pool = &mut pools[i];
                conditional_amm::set_oracle_start_time(pool, market);
                i = i + 1;
            };
            
            return true
        };
    };
    
    // Check if we should transition from TRADING to ended
    if (proposal.state == STATE_TRADING) {
        let trading_end = base_timestamp + proposal.timing.review_period_ms + proposal.timing.trading_period_ms;
        if (current_time >= trading_end) {
            // End trading in the market state
            let market = coin_escrow::get_market_state_mut(escrow);
            if (market_state::is_trading_active(market)) {
                market_state::end_trading(market, clock);
            };
            // Note: Full finalization requires calculating winner and is done separately
            return true
        };
    };
    
    false
}

public fun set_state<AssetType, StableType>(
    proposal: &mut Proposal<AssetType, StableType>,
    new_state: u8,
) {
    proposal.state = new_state;
}

public fun set_twap_prices<AssetType, StableType>(
    proposal: &mut Proposal<AssetType, StableType>,
    twap_prices: vector<u128>,
) {
    proposal.twap_config.twap_prices = twap_prices;
}

public fun set_last_twap_update<AssetType, StableType>(
    proposal: &mut Proposal<AssetType, StableType>,
    timestamp: u64,
) {
    proposal.timing.last_twap_update = timestamp;
}

public fun set_winning_outcome<AssetType, StableType>(
    proposal: &mut Proposal<AssetType, StableType>,
    outcome: u64,
) {
    proposal.outcome_data.winning_outcome = option::some(outcome);
}

/// Finalize the proposal with the winning outcome computed on-chain
/// This combines computing the winner from TWAP, setting the winning outcome and updating state atomically
/// @deprecated Use proposal_lifecycle::finalize_proposal_market instead - this version lacks critical intent cleanup
#[test_only]
public fun finalize_proposal<AssetType, StableType>(
    proposal: &mut Proposal<AssetType, StableType>,
    escrow: &mut TokenEscrow<AssetType, StableType>,
    clock: &Clock,
) {
    // Ensure we're in a state that can be finalized
    assert!(proposal.state == STATE_TRADING || proposal.state == STATE_REVIEW, EInvalidState);
    
    // If still in trading, end trading first
    if (proposal.state == STATE_TRADING) {
        let market = coin_escrow::get_market_state_mut(escrow);
        if (market_state::is_trading_active(market)) {
            market_state::end_trading(market, clock);
        };
    };
    
    // Critical fix: Compute the winning outcome on-chain from TWAP prices
    // Get TWAP prices from all pools
    let twap_prices = get_twaps_for_proposal(proposal, clock);
    
    // For a simple YES/NO proposal, compare the YES TWAP to the threshold
    let winning_outcome = if (twap_prices.length() >= 2) {
        let yes_twap = *twap_prices.borrow(OUTCOME_ACCEPTED);
        let threshold = get_twap_threshold(proposal);
        
        // If YES TWAP exceeds threshold, YES wins
        if (yes_twap > (threshold as u128)) {
            OUTCOME_ACCEPTED
        } else {
            OUTCOME_REJECTED
        }
    } else {
        // For single-outcome or other configs, default to first outcome
        // This should be revisited based on your specific requirements
        0
    };
    
    // Set the winning outcome
    proposal.outcome_data.winning_outcome = option::some(winning_outcome);
    
    // Update state to finalized
    proposal.state = STATE_FINALIZED;
    
    // Finalize the market state
    let market = coin_escrow::get_market_state_mut(escrow);
    market_state::finalize(market, winning_outcome, clock);
}

public fun get_outcome_creators<AssetType, StableType>(proposal: &Proposal<AssetType, StableType>): &vector<address> {
    &proposal.outcome_data.outcome_creators
}

public fun get_liquidity_provider<AssetType, StableType>(proposal: &Proposal<AssetType, StableType>): Option<address> {
    proposal.liquidity_provider
}

public fun get_proposer<AssetType, StableType>(proposal: &Proposal<AssetType, StableType>): address {
    proposal.proposer
}

public fun get_outcome_messages<AssetType, StableType>(proposal: &Proposal<AssetType, StableType>): &vector<String> {
    &proposal.outcome_data.outcome_messages
}

/// Get the intent key for a specific outcome
public fun get_intent_key_for_outcome<AssetType, StableType>(
    proposal: &Proposal<AssetType, StableType>,
    outcome_index: u64
): &option::Option<String> {
    vector::borrow(&proposal.outcome_data.intent_keys, outcome_index)
}


/// Take (move out) the intent key for a specific outcome and clear the slot.
public fun take_intent_key_for_outcome<AssetType, StableType>(
    proposal: &mut Proposal<AssetType, StableType>,
    outcome_index: u64
): option::Option<String> {
    assert!(outcome_index < proposal.outcome_data.outcome_count, EOutcomeOutOfBounds);
    let slot = vector::borrow_mut(&mut proposal.outcome_data.intent_keys, outcome_index);
    let old_value = *slot;
    *slot = option::none();
    old_value
}

/// Mint a scoped cancel witness by taking (moving) the key out of the slot.
/// Returns None if no key was set for that outcome.
/// This witness can only be created once per (proposal, outcome) pair.
public fun make_cancel_witness<AssetType, StableType>(
    proposal: &mut Proposal<AssetType, StableType>,
    outcome_index: u64
): option::Option<CancelWitness> {
    assert!(outcome_index < proposal.outcome_data.outcome_count, EOutcomeOutOfBounds);
    let addr = object::uid_to_address(&proposal.id);
    let mut key_opt = take_intent_key_for_outcome(proposal, outcome_index);
    if (option::is_some(&key_opt)) {
        let key = option::extract(&mut key_opt);
        option::some(CancelWitness { proposal: addr, outcome_index, key })
    } else {
        option::none<CancelWitness>()
    }
}

/// Set the intent key for a specific outcome and track action count
/// Handles replacement if an intent key already exists
public fun set_intent_key_for_outcome<AssetType, StableType>(
    proposal: &mut Proposal<AssetType, StableType>,
    outcome_index: u64,
    intent_key: String,
    num_actions: u64,
    max_actions_per_outcome: u64,
) {
    assert!(outcome_index < proposal.outcome_data.outcome_count, EOutcomeOutOfBounds);
    
    let key_slot = vector::borrow_mut(&mut proposal.outcome_data.intent_keys, outcome_index);
    let action_count = vector::borrow_mut(&mut proposal.outcome_data.actions_per_outcome, outcome_index);
    
    // Calculate new count for this outcome
    let mut new_outcome_count = *action_count;
    
    if (option::is_some(key_slot)) {
        // Replacing existing intent - reset count
        new_outcome_count = 0;
    };
    
    new_outcome_count = new_outcome_count + num_actions;
    
    // Check outcome limit only
    assert!(new_outcome_count <= max_actions_per_outcome, ETooManyActions);
    
    // Set the intent key and update count
    *key_slot = option::some(intent_key);
    *action_count = new_outcome_count;
}


/// Check if an outcome has an intent key
public fun has_intent_key<AssetType, StableType>(
    proposal: &Proposal<AssetType, StableType>,
    outcome_index: u64
): bool {
    assert!(outcome_index < proposal.outcome_data.outcome_count, EOutcomeOutOfBounds);
    option::is_some(vector::borrow(&proposal.outcome_data.intent_keys, outcome_index))
}

/// Get the number of actions for a specific outcome
public fun get_actions_for_outcome<AssetType, StableType>(
    proposal: &Proposal<AssetType, StableType>,
    outcome_index: u64
): u64 {
    assert!(outcome_index < proposal.outcome_data.outcome_count, EOutcomeOutOfBounds);
    *vector::borrow(&proposal.outcome_data.actions_per_outcome, outcome_index)
}

/// Clear the intent key for an outcome and reset action count
public fun clear_intent_key_for_outcome<AssetType, StableType>(
    proposal: &mut Proposal<AssetType, StableType>,
    outcome_index: u64,
) {
    assert!(outcome_index < proposal.outcome_data.outcome_count, EOutcomeOutOfBounds);
    
    let key_slot = vector::borrow_mut(&mut proposal.outcome_data.intent_keys, outcome_index);
    let action_count = vector::borrow_mut(&mut proposal.outcome_data.actions_per_outcome, outcome_index);
    
    if (option::is_some(key_slot)) {
        // Clear the intent key
        *key_slot = option::none();
        
        // Reset this outcome's action count
        *action_count = 0;
    };
}


/// Emits the ProposalOutcomeMutated event
public fun emit_outcome_mutated(
    proposal_id: ID,
    dao_id: ID,
    outcome_idx: u64,
    old_creator: address,
    new_creator: address,
    timestamp: u64,
) {
    event::emit(ProposalOutcomeMutated {
        proposal_id,
        dao_id,
        outcome_idx,
        old_creator,
        new_creator,
        timestamp,
    });
}

public fun set_outcome_creator<AssetType, StableType>(
    proposal: &mut Proposal<AssetType, StableType>,
    outcome_idx: u64,
    creator: address,
) {
    assert!(outcome_idx < proposal.outcome_data.outcome_count, EOutcomeOutOfBounds);
    let creator_ref = vector::borrow_mut(&mut proposal.outcome_data.outcome_creators, outcome_idx);
    *creator_ref = creator;
}

public fun get_details_mut<AssetType, StableType>(proposal: &mut Proposal<AssetType, StableType>): &mut vector<String> {
    &mut proposal.details
}


// === Test Functions ===

#[test_only]
/// Create a minimal proposal for testing
public fun new_for_testing<AssetType, StableType>(
    dao_id: address,
    proposer: address,
    liquidity_provider: Option<address>,
    title: String,
    metadata: String,
    outcome_messages: vector<String>,
    outcome_details: vector<String>,
    outcome_creators: vector<address>,
    outcome_count: u8,
    review_period_ms: u64,
    trading_period_ms: u64,
    min_asset_liquidity: u64,
    min_stable_liquidity: u64,
    twap_start_delay: u64,
    twap_initial_observation: u128,
    twap_step_max: u64,
    twap_threshold: u64,
    amm_total_fee_bps: u64,
    winning_outcome: Option<u64>,
    fee_escrow: Balance<StableType>,
    treasury_address: address,
    intent_keys: vector<option::Option<String>>,
    ctx: &mut TxContext
): Proposal<AssetType, StableType> {
    Proposal {
        id: object::new(ctx),
        dao_id: object::id_from_address(dao_id),
        queued_proposal_id: object::id_from_address(@0x0),
        state: STATE_PREMARKET,
        proposer,
        liquidity_provider,
        supply_ids: option::none(),
        amm_pools: option::none(),
        escrow_id: option::none(),
        market_state_id: option::none(),
        title,
        details: outcome_details,
        metadata,
        timing: ProposalTiming {
            created_at: 0,
            market_initialized_at: option::none(),
            review_period_ms,
            trading_period_ms,
            last_twap_update: 0,
            twap_start_delay,
        },
        liquidity_config: LiquidityConfig {
            min_asset_liquidity,
            min_stable_liquidity,
            asset_amounts: vector::empty(),
            stable_amounts: vector::empty(),
            uses_dao_liquidity: false,
        },
        twap_config: TwapConfig {
            twap_prices: vector::empty(),
            twap_initial_observation,
            twap_step_max,
            twap_threshold,
        },
        outcome_data: OutcomeData {
            outcome_count: outcome_count as u64,
            outcome_messages,
            outcome_creators,
            intent_keys,
            actions_per_outcome: vector::tabulate!(outcome_count as u64, |_| 0),
            winning_outcome,
        },
        amm_total_fee_bps,
        fee_escrow,
        treasury_address,
    }
}

#[test_only]
/// Gets a mutable reference to the token escrow of the proposal
public fun test_get_coin_escrow<AssetType, StableType>(
    escrow: &mut coin_escrow::TokenEscrow<AssetType, StableType>,
): &mut coin_escrow::TokenEscrow<AssetType, StableType> {
    escrow
}

#[test_only]
/// Gets the market state through the token escrow
public fun test_get_market_state<AssetType, StableType>(
    escrow: &coin_escrow::TokenEscrow<AssetType, StableType>,
): &market_state::MarketState {
    escrow.get_market_state()
}


// === Additional View Functions ===

/// Get proposal ID
public fun id<AssetType, StableType>(proposal: &Proposal<AssetType, StableType>): ID {
    object::id(proposal)
}

/// Get proposal address (for testing)
public fun id_address<AssetType, StableType>(proposal: &Proposal<AssetType, StableType>): address {
    object::uid_to_address(&proposal.id)
}
module futarchy_markets::fee;

use std::ascii::String as AsciiString;
use std::type_name;
use sui::balance::{Self, Balance};
use sui::clock::Clock;
use sui::coin::{Self, Coin};
use sui::dynamic_field;
use sui::event;
use sui::sui::SUI;
use std::u64;
use sui::table::{Self, Table};
use sui::transfer::{public_share_object, public_transfer};

// === Introduction ===
// Manages all fees earnt by the protocol. It is also the interface for admin fee withdrawal

// === Errors ===
const EInvalidPayment: u64 = 0;
const EStableTypeNotFound: u64 = 1;
const EBadWitness: u64 = 2;
const ERecurringFeeNotDue: u64 = 3;
const EWrongStableTypeForFee: u64 = 4;
const EInsufficientTreasuryBalance: u64 = 5;
const EArithmeticOverflow: u64 = 6;
const EInvalidAdminCap: u64 = 7;
const EInvalidRecoveryFee: u64 = 9;
const EFeeExceedsHardCap: u64 = 10;

// === Constants ===
const DEFAULT_DAO_CREATION_FEE: u64 = 10_000;
const DEFAULT_PROPOSAL_CREATION_FEE_PER_OUTCOME: u64 = 1000;
const DEFAULT_VERIFICATION_FEE: u64 = 10_000; // Default fee for level 1
const MONTHLY_FEE_PERIOD_MS: u64 = 2_592_000_000; // 30 days
const FEE_UPDATE_DELAY_MS: u64 = 15_552_000_000; // 6 months (180 days)
const MAX_FEE_COLLECTION_PERIOD_MS: u64 = 7_776_000_000; // 90 days (3 months) - max retroactive collection
// Remove ABSOLUTE_MAX_MONTHLY_FEE in V3 this is jsut here to build up trust
// Dont want to limit fee as platform gets more mature
const ABSOLUTE_MAX_MONTHLY_FEE: u64 = 10_000_000_000; // 10,000 USDC (6 decimals)

// === Structs ===

public struct FEE has drop {}

public struct FeeManager has key, store {
    id: UID,
    admin_cap_id: ID,
    dao_creation_fee: u64,
    proposal_creation_fee_per_outcome: u64,
    verification_fees: Table<u8, u64>, // Dynamic table mapping level -> fee
    dao_monthly_fee: u64,
    pending_dao_monthly_fee: Option<u64>,
    pending_fee_effective_timestamp: Option<u64>,
    sui_balance: Balance<SUI>,
    recovery_fee: u64,  // Fee for dead-man switch recovery
}

public struct FeeAdminCap has key, store {
    id: UID,
}

/// Tracks fee collection history for each DAO
public struct DaoFeeRecord has store {
    last_collection_timestamp: u64,
    total_collected: u64,
    last_fee_rate: u64,  // Fee rate at last collection to prevent retroactive increases
}

// === Events ===
public struct FeesWithdrawn has copy, drop {
    amount: u64,
    recipient: address,
    timestamp: u64,
}

public struct DAOCreationFeeUpdated has copy, drop {
    old_fee: u64,
    new_fee: u64,
    admin: address,
    timestamp: u64,
}

public struct ProposalCreationFeeUpdated has copy, drop {
    old_fee: u64,
    new_fee_per_outcome: u64,
    admin: address,
    timestamp: u64,
}

public struct VerificationFeeUpdated has copy, drop {
    level: u8,
    old_fee: u64,
    new_fee: u64,
    admin: address,
    timestamp: u64,
}

public struct VerificationLevelAdded has copy, drop {
    level: u8,
    fee: u64,
    admin: address,
    timestamp: u64,
}

public struct VerificationLevelRemoved has copy, drop {
    level: u8,
    admin: address,
    timestamp: u64,
}

public struct DAOCreationFeeCollected has copy, drop {
    amount: u64,
    payer: address,
    timestamp: u64,
}

public struct ProposalCreationFeeCollected has copy, drop {
    amount: u64,
    payer: address,
    timestamp: u64,
}

public struct VerificationFeeCollected has copy, drop {
    level: u8,
    amount: u64,
    payer: address,
    timestamp: u64,
}

public struct StableFeesCollected has copy, drop {
    amount: u64,
    stable_type: AsciiString,
    proposal_id: ID,
    timestamp: u64,
}

public struct StableFeesWithdrawn has copy, drop {
    amount: u64,
    stable_type: AsciiString,
    recipient: address,
    timestamp: u64,
}

public struct DaoMonthlyFeeUpdated has copy, drop {
    old_fee: u64,
    new_fee: u64,
    admin: address,
    timestamp: u64,
}

public struct DaoMonthlyFeePending has copy, drop {
    current_fee: u64,
    pending_fee: u64,
    effective_timestamp: u64,
    admin: address,
    timestamp: u64,
}

public struct DaoPlatformFeeCollected has copy, drop {
    dao_id: ID,
    amount: u64,
    stable_type: AsciiString,
    collector: address,
    timestamp: u64,
}

public struct RecoveryFeeUpdated has copy, drop {
    old_fee: u64,
    new_fee: u64,
    admin: address,
    timestamp: u64,
}

public struct RecoveryRequested has copy, drop {
    dao_id: ID,
    council_id: ID,
    fee: u64,
    requester: address,
    timestamp: u64,
}

public struct RecoveryExecuted has copy, drop {
    dao_id: ID,
    new_council_id: ID,
    timestamp: u64,
}

// === Public Functions ===
fun init(witness: FEE, ctx: &mut TxContext) {
    // Verify that the witness is valid and one-time only.
    assert!(sui::types::is_one_time_witness(&witness), EBadWitness);

    let fee_admin_cap = FeeAdminCap {
        id: object::new(ctx),
    };
    
    let mut verification_fees = table::new<u8, u64>(ctx);
    // Start with just level 1 by default
    table::add(&mut verification_fees, 1, DEFAULT_VERIFICATION_FEE);
    
    let fee_manager = FeeManager {
        id: object::new(ctx),
        admin_cap_id: object::id(&fee_admin_cap),
        dao_creation_fee: DEFAULT_DAO_CREATION_FEE,
        proposal_creation_fee_per_outcome: DEFAULT_PROPOSAL_CREATION_FEE_PER_OUTCOME,
        verification_fees,
        dao_monthly_fee: 10_000_000, // e.g. 10 of a 6-decimal stable coin
        pending_dao_monthly_fee: option::none(),
        pending_fee_effective_timestamp: option::none(),
        sui_balance: balance::zero<SUI>(),
        recovery_fee: 5_000_000_000, // 5 SUI default (~$5k equivalent)
    };

    public_share_object(fee_manager);
    public_transfer(fee_admin_cap, ctx.sender());

    // Consuming the witness ensures one-time initialization.
    let _ = witness;
}

// === Package Functions ===
// Generic internal fee collection function
fun deposit_payment(fee_manager: &mut FeeManager, fee_amount: u64, payment: Coin<SUI>): u64 {
    // Verify payment
    let payment_amount = payment.value();
    assert!(payment_amount == fee_amount, EInvalidPayment);

    // Process payment
    let paid_balance = payment.into_balance();
    fee_manager.sui_balance.join(paid_balance);
    return payment_amount
    // Event emission will be handled by specific wrappers
}

// Function to collect DAO creation fee
public fun deposit_dao_creation_payment(
    fee_manager: &mut FeeManager,
    payment: Coin<SUI>,
    clock: &Clock,
    ctx: &TxContext,
) {
    let fee_amount = fee_manager.dao_creation_fee;

    let payment_amount = deposit_payment(fee_manager, fee_amount, payment);

    // Emit event
    event::emit(DAOCreationFeeCollected {
        amount: payment_amount,
        payer: ctx.sender(),
        timestamp: clock.timestamp_ms(),
    });
}


// Function to collect proposal creation fee
public fun deposit_proposal_creation_payment(
    fee_manager: &mut FeeManager,
    payment: Coin<SUI>,
    outcome_count: u64,
    clock: &Clock,
    ctx: &TxContext,
) {
    // Use u128 arithmetic to prevent overflow
    let fee_amount_u128 = (fee_manager.proposal_creation_fee_per_outcome as u128) * (outcome_count as u128);
    
    // Check that result fits in u64
    assert!(fee_amount_u128 <= (u64::max_value!() as u128), EArithmeticOverflow); // u64::max_value()
    let fee_amount = (fee_amount_u128 as u64);

    // deposit_payment asserts the payment amount is exactly the fee_amount
    let payment_amount = deposit_payment(fee_manager, fee_amount, payment);

    // Emit event
    event::emit(ProposalCreationFeeCollected {
        amount: payment_amount,
        payer: ctx.sender(),
        timestamp: clock.timestamp_ms(),
    });
}


// Function to collect recovery fee for dead-man switch
public fun deposit_recovery_payment(
    fee_manager: &mut FeeManager,
    dao_id: ID,
    council_id: ID,
    payment: Coin<SUI>,
    clock: &Clock,
    ctx: &TxContext,
) {
    let fee_due = fee_manager.recovery_fee;
    assert!(payment.value() == fee_due, EInvalidPayment);
    let bal = payment.into_balance();
    fee_manager.sui_balance.join(bal);
    event::emit(RecoveryRequested {
        dao_id,
        council_id,
        fee: fee_due,
        requester: ctx.sender(),
        timestamp: clock.timestamp_ms(),
    });
}

// Function to collect verification fee for a specific level
public fun deposit_verification_payment(
    fee_manager: &mut FeeManager,
    payment: Coin<SUI>,
    verification_level: u8,
    clock: &Clock,
    ctx: &TxContext,
) {
    assert!(table::contains(&fee_manager.verification_fees, verification_level), EInvalidPayment);
    let fee_amount = *table::borrow(&fee_manager.verification_fees, verification_level);
    let payment_amount = deposit_payment(fee_manager, fee_amount, payment);

    // Emit event
    event::emit(VerificationFeeCollected {
        level: verification_level,
        amount: payment_amount,
        payer: ctx.sender(),
        timestamp: clock.timestamp_ms(),
    });
}

// === Admin Functions ===
// Admin function to withdraw fees
public entry fun withdraw_all_fees(
    fee_manager: &mut FeeManager,
    admin_cap: &FeeAdminCap,
    clock: &Clock,
    ctx: &mut TxContext,
) {
    // Verify the admin cap belongs to this fee manager
    assert!(object::id(admin_cap) == fee_manager.admin_cap_id, EInvalidAdminCap);
    let amount = fee_manager.sui_balance.value();
    let sender = ctx.sender();

    let withdrawal = fee_manager.sui_balance.split(amount).into_coin(ctx);

    event::emit(FeesWithdrawn {
        amount,
        recipient: sender,
        timestamp: clock.timestamp_ms(),
    });

    public_transfer(withdrawal, sender);
}

// Admin function to update DAO creation fee
public entry fun update_dao_creation_fee(
    fee_manager: &mut FeeManager,
    admin_cap: &FeeAdminCap,
    new_fee: u64,
    clock: &Clock,
    ctx: &mut TxContext,
) {
    assert!(object::id(admin_cap) == fee_manager.admin_cap_id, EInvalidAdminCap);
    let old_fee = fee_manager.dao_creation_fee;
    fee_manager.dao_creation_fee = new_fee;

    event::emit(DAOCreationFeeUpdated {
        old_fee,
        new_fee,
        admin: ctx.sender(),
        timestamp: clock.timestamp_ms(),
    });
}

// Admin function to update proposal creation fee
public entry fun update_proposal_creation_fee(
    fee_manager: &mut FeeManager,
    admin_cap: &FeeAdminCap,
    new_fee_per_outcome: u64,
    clock: &Clock,
    ctx: &mut TxContext,
) {
    assert!(object::id(admin_cap) == fee_manager.admin_cap_id, EInvalidAdminCap);
    let old_fee = fee_manager.proposal_creation_fee_per_outcome;
    fee_manager.proposal_creation_fee_per_outcome = new_fee_per_outcome;

    event::emit(ProposalCreationFeeUpdated {
        old_fee,
        new_fee_per_outcome,
        admin: ctx.sender(),
        timestamp: clock.timestamp_ms(),
    });
}

// Admin function to add a new verification level
public entry fun add_verification_level(
    fee_manager: &mut FeeManager,
    admin_cap: &FeeAdminCap,
    level: u8,
    fee: u64,
    clock: &Clock,
    ctx: &mut TxContext,
) {
    assert!(object::id(admin_cap) == fee_manager.admin_cap_id, EInvalidAdminCap);
    assert!(!table::contains(&fee_manager.verification_fees, level), EInvalidPayment);
    
    table::add(&mut fee_manager.verification_fees, level, fee);
    
    event::emit(VerificationLevelAdded {
        level,
        fee,
        admin: ctx.sender(),
        timestamp: clock.timestamp_ms(),
    });
}

// Admin function to remove a verification level
public entry fun remove_verification_level(
    fee_manager: &mut FeeManager,
    admin_cap: &FeeAdminCap,
    level: u8,
    clock: &Clock,
    ctx: &mut TxContext,
) {
    assert!(object::id(admin_cap) == fee_manager.admin_cap_id, EInvalidAdminCap);
    assert!(table::contains(&fee_manager.verification_fees, level), EInvalidPayment);
    
    table::remove(&mut fee_manager.verification_fees, level);
    
    event::emit(VerificationLevelRemoved {
        level,
        admin: ctx.sender(),
        timestamp: clock.timestamp_ms(),
    });
}

// Admin function to update verification fee for a specific level
public entry fun update_verification_fee(
    fee_manager: &mut FeeManager,
    admin_cap: &FeeAdminCap,
    level: u8,
    new_fee: u64,
    clock: &Clock,
    ctx: &mut TxContext,
) {
    assert!(object::id(admin_cap) == fee_manager.admin_cap_id, EInvalidAdminCap);
    assert!(table::contains(&fee_manager.verification_fees, level), EInvalidPayment);
    
    let old_fee = *table::borrow(&fee_manager.verification_fees, level);
    *table::borrow_mut(&mut fee_manager.verification_fees, level) = new_fee;

    event::emit(VerificationFeeUpdated {
        level,
        old_fee,
        new_fee,
        admin: ctx.sender(),
        timestamp: clock.timestamp_ms(),
    });
}

// Admin function to update recovery fee
public entry fun update_recovery_fee(
    fee_manager: &mut FeeManager,
    admin_cap: &FeeAdminCap,
    new_fee: u64,
    clock: &Clock,
    ctx: &TxContext,
) {
    assert!(object::id(admin_cap) == fee_manager.admin_cap_id, EInvalidAdminCap);
    let old_fee = fee_manager.recovery_fee;
    fee_manager.recovery_fee = new_fee;
    event::emit(RecoveryFeeUpdated {
        old_fee,
        new_fee,
        admin: ctx.sender(),
        timestamp: clock.timestamp_ms(),
    });
}

// View function for recovery fee
public fun get_recovery_fee(fee_manager: &FeeManager): u64 {
    fee_manager.recovery_fee
}

// Function removed to avoid circular dependency with treasury module
// This functionality should be moved to a separate module

/// Collect platform fee from a DAO's vault with 3-month retroactive limit
/// IMPORTANT: Uses the fee rate from when periods were incurred, not current rate
public fun collect_dao_platform_fee<StableType: drop>(
    fee_manager: &mut FeeManager,
    dao_id: ID,
    clock: &Clock,
    ctx: &mut TxContext,
): (u64, u64) { // Returns (fee_amount, periods_collected)
    let current_time = clock.timestamp_ms();
    
    // Apply pending fee if due (before we calculate anything)
    apply_pending_fee_if_due(fee_manager, clock);
    
    // Get current fee rate
    let current_fee_rate = fee_manager.dao_monthly_fee;
    
    // Get or create fee record for this DAO
    let record_key = dao_id;
    let (last_collection, last_rate, is_new) = if (dynamic_field::exists_(&fee_manager.id, record_key)) {
        let record: &DaoFeeRecord = dynamic_field::borrow(&fee_manager.id, record_key);
        (record.last_collection_timestamp, record.last_fee_rate, false)
    } else {
        // First time collecting from this DAO - initialize with current rate
        let new_record = DaoFeeRecord {
            last_collection_timestamp: current_time,
            total_collected: 0,
            last_fee_rate: current_fee_rate,
        };
        dynamic_field::add(&mut fee_manager.id, record_key, new_record);
        return (0, 0) // No retroactive fees on first collection
    };
    
    // Calculate how many periods we can collect
    let time_since_last = if (current_time > last_collection) {
        current_time - last_collection
    } else {
        0
    };
    
    // Cap at 3 months max
    let collectible_time = if (time_since_last > MAX_FEE_COLLECTION_PERIOD_MS) {
        MAX_FEE_COLLECTION_PERIOD_MS
    } else {
        time_since_last
    };
    
    // Calculate number of monthly periods to collect
    let periods_to_collect = collectible_time / MONTHLY_FEE_PERIOD_MS;
    
    if (periods_to_collect == 0) {
        return (0, 0)
    };
    
    // CRITICAL: Use the LOWER of last rate or current rate to prevent retroactive increases
    // DAOs benefit from fee decreases immediately but are protected from increases
    let fee_per_period = if (last_rate < current_fee_rate) {
        last_rate  // Protect DAO from retroactive fee increases
    } else {
        current_fee_rate  // Allow DAO to benefit from fee decreases
    };
    
    let total_fee = fee_per_period * periods_to_collect;
    
    // Update the record with new timestamp and current rate for future collections
    let record: &mut DaoFeeRecord = dynamic_field::borrow_mut(&mut fee_manager.id, record_key);
    record.last_collection_timestamp = current_time;
    record.total_collected = record.total_collected + total_fee;
    record.last_fee_rate = current_fee_rate;  // Store current rate for next time
    
    (total_fee, periods_to_collect)
}

public fun deposit_dao_platform_fee<StableType: drop>(
    fee_manager: &mut FeeManager,
    fee_coin: Coin<StableType>,
    dao_id: ID,
    clock: &Clock,
    ctx: &mut TxContext,
) {
    let amount = fee_coin.value();
    let stable_type_str = type_name::get<StableType>().into_string();
    
    deposit_stable_fees(fee_manager, fee_coin.into_balance(), dao_id, clock);
    
    // Emit platform fee collection event
    event::emit(DaoPlatformFeeCollected {
        dao_id,
        amount,
        stable_type: stable_type_str,
        collector: ctx.sender(),
        timestamp: clock.timestamp_ms(),
    });
}

/// Collect DAO platform fee with admin-approved discount
/// Admin can collect any amount between 0 and the full fee owed
public fun collect_dao_platform_fee_with_discount<StableType: drop>(
    fee_manager: &mut FeeManager,
    admin_cap: &FeeAdminCap,
    dao_id: ID,
    discount_amount: u64, // Amount to discount from the full fee
    clock: &Clock,
    ctx: &mut TxContext,
): (u64, u64) { // Returns (actual_fee_charged, periods_collected)
    // Verify admin cap
    assert!(fee_manager.admin_cap_id == object::id(admin_cap), EInvalidAdminCap);
    
    // Calculate the full fee owed
    let (full_fee, periods) = collect_dao_platform_fee<StableType>(fee_manager, dao_id, clock, ctx);
    
    // Apply discount (ensure we don't go negative)
    let actual_fee = if (discount_amount >= full_fee) {
        0 // Full discount (free)
    } else {
        full_fee - discount_amount
    };
    
    (actual_fee, periods)
}

public entry fun update_dao_monthly_fee(
    fee_manager: &mut FeeManager,
    admin_cap: &FeeAdminCap,
    new_fee: u64,
    clock: &Clock,
    ctx: &mut TxContext,
) {
    assert!(object::id(admin_cap) == fee_manager.admin_cap_id, EInvalidAdminCap);
    
    // V2 Hard cap enforcement - prevents excessive fees while protocol matures
    assert!(new_fee <= ABSOLUTE_MAX_MONTHLY_FEE, EFeeExceedsHardCap);
    
    let current_fee = fee_manager.dao_monthly_fee;
    let effective_timestamp = clock.timestamp_ms() + FEE_UPDATE_DELAY_MS;
    
    // Set the pending fee
    fee_manager.pending_dao_monthly_fee = option::some(new_fee);
    fee_manager.pending_fee_effective_timestamp = option::some(effective_timestamp);

    event::emit(DaoMonthlyFeePending {
        current_fee,
        pending_fee: new_fee,
        effective_timestamp,
        admin: ctx.sender(),
        timestamp: clock.timestamp_ms(),
    });
}

/// Apply pending fee if the delay period has passed
public fun apply_pending_fee_if_due(
    fee_manager: &mut FeeManager,
    clock: &Clock,
) {
    if (fee_manager.pending_dao_monthly_fee.is_some() && 
        fee_manager.pending_fee_effective_timestamp.is_some()) {
        
        let effective_timestamp = *fee_manager.pending_fee_effective_timestamp.borrow();
        
        if (clock.timestamp_ms() >= effective_timestamp) {
            let old_fee = fee_manager.dao_monthly_fee;
            let new_fee = *fee_manager.pending_dao_monthly_fee.borrow();
            
            // Apply the pending fee
            fee_manager.dao_monthly_fee = new_fee;
            
            // Clear pending fee data
            fee_manager.pending_dao_monthly_fee = option::none();
            fee_manager.pending_fee_effective_timestamp = option::none();
            
            event::emit(DaoMonthlyFeeUpdated {
                old_fee,
                new_fee,
                admin: @0x0, // System update, no specific admin
                timestamp: clock.timestamp_ms(),
            });
        }
    }
}

// === AMM Fees ===

// Structure to store stable coin balance information
public struct StableCoinBalance<phantom T> has store {
    balance: Balance<T>,
}

public struct StableFeeRegistry<phantom T> has copy, drop, store {}

// Modified stable fees storage with more structure
public fun deposit_stable_fees<StableType>(
    fee_manager: &mut FeeManager,
    fees: Balance<StableType>,
    proposal_id: ID,
    clock: &Clock,
) {
    let amount = fees.value();

    if (
        dynamic_field::exists_with_type<
            StableFeeRegistry<StableType>,
            StableCoinBalance<StableType>,
        >(&fee_manager.id, StableFeeRegistry<StableType> {})
    ) {
        let fee_balance_wrapper = dynamic_field::borrow_mut<
            StableFeeRegistry<StableType>,
            StableCoinBalance<StableType>,
        >(&mut fee_manager.id, StableFeeRegistry<StableType> {});
        fee_balance_wrapper.balance.join(fees);
    } else {
        let balance_wrapper = StableCoinBalance<StableType> {
            balance: fees,
        };
        dynamic_field::add(&mut fee_manager.id, StableFeeRegistry<StableType> {}, balance_wrapper);
    };

    let type_name = type_name::get<StableType>();
    let type_str = type_name.into_string();
    // Emit collection event
    event::emit(StableFeesCollected {
        amount,
        stable_type: type_str,
        proposal_id,
        timestamp: clock.timestamp_ms(),
    });
}

public entry fun withdraw_stable_fees<StableType>(
    fee_manager: &mut FeeManager,
    admin_cap: &FeeAdminCap,
    clock: &Clock,
    ctx: &mut TxContext,
) {
    // Verify the admin cap belongs to this fee manager
    assert!(object::id(admin_cap) == fee_manager.admin_cap_id, EInvalidAdminCap);
    
    // Check if the stable type exists in the registry
    if (!dynamic_field::exists_with_type<
            StableFeeRegistry<StableType>,
            StableCoinBalance<StableType>,
        >(
            &fee_manager.id,
            StableFeeRegistry<StableType> {},
        )
    ) {
        // No fees of this type have been collected, nothing to withdraw
        return
    };

    let fee_balance_wrapper = dynamic_field::borrow_mut<
        StableFeeRegistry<StableType>,
        StableCoinBalance<StableType>,
    >(&mut fee_manager.id, StableFeeRegistry<StableType> {});
    let amount = fee_balance_wrapper.balance.value();

    if (amount > 0) {
        let withdrawn = fee_balance_wrapper.balance.split(amount);
        let coin = withdrawn.into_coin(ctx);

        let type_name = type_name::get<StableType>();
        let type_str = type_name.into_string();
        // Emit withdrawal event
        event::emit(StableFeesWithdrawn {
            amount,
            stable_type: type_str,
            recipient: ctx.sender(),
            timestamp: clock.timestamp_ms(),
        });

        // Transfer to sender
        public_transfer(coin, ctx.sender());
    }
}

// === View Functions ===
public fun get_dao_creation_fee(fee_manager: &FeeManager): u64 {
    fee_manager.dao_creation_fee
}

public fun get_proposal_creation_fee_per_outcome(fee_manager: &FeeManager): u64 {
    fee_manager.proposal_creation_fee_per_outcome
}

public fun get_verification_fee_for_level(fee_manager: &FeeManager, level: u8): u64 {
    assert!(table::contains(&fee_manager.verification_fees, level), EInvalidPayment);
    *table::borrow(&fee_manager.verification_fees, level)
}

public fun has_verification_level(fee_manager: &FeeManager, level: u8): bool {
    table::contains(&fee_manager.verification_fees, level)
}

public fun get_dao_monthly_fee(fee_manager: &FeeManager): u64 {
    fee_manager.dao_monthly_fee
}

public fun get_pending_dao_monthly_fee(fee_manager: &FeeManager): Option<u64> {
    fee_manager.pending_dao_monthly_fee
}

public fun get_pending_fee_effective_timestamp(fee_manager: &FeeManager): Option<u64> {
    fee_manager.pending_fee_effective_timestamp
}

public fun get_sui_balance(fee_manager: &FeeManager): u64 {
    fee_manager.sui_balance.value()
}

public fun get_stable_fee_balance<StableType>(fee_manager: &FeeManager): u64 {
    if (
        dynamic_field::exists_with_type<
            StableFeeRegistry<StableType>,
            StableCoinBalance<StableType>,
        >(&fee_manager.id, StableFeeRegistry<StableType> {})
    ) {
        let balance_wrapper = dynamic_field::borrow<
            StableFeeRegistry<StableType>,
            StableCoinBalance<StableType>,
        >(&fee_manager.id, StableFeeRegistry<StableType> {});
        balance_wrapper.balance.value()
    } else {
        0
    }
}

/// Get the hard cap for monthly fees (V2 safety limit)
public fun get_max_monthly_fee_cap(): u64 {
    ABSOLUTE_MAX_MONTHLY_FEE
}

// ======== Test Functions ========
#[test_only]
public fun create_fee_manager_for_testing(ctx: &mut TxContext) {
    let admin_cap = FeeAdminCap {
        id: object::new(ctx),
    };
    
    let mut verification_fees = table::new<u8, u64>(ctx);
    // Start with just level 1 by default
    table::add(&mut verification_fees, 1, DEFAULT_VERIFICATION_FEE);
    
    let fee_manager = FeeManager {
        id: object::new(ctx),
        admin_cap_id: object::id(&admin_cap),
        dao_creation_fee: DEFAULT_DAO_CREATION_FEE,
        proposal_creation_fee_per_outcome: DEFAULT_PROPOSAL_CREATION_FEE_PER_OUTCOME,
        verification_fees,
        dao_monthly_fee: 10_000_000, // e.g. 10 of a 6-decimal stable coin
        pending_dao_monthly_fee: option::none(),
        pending_fee_effective_timestamp: option::none(),
        sui_balance: balance::zero<SUI>(),
        recovery_fee: 5_000_000_000, // 5 SUI default
    };

    public_share_object(fee_manager);
    public_transfer(admin_cap, ctx.sender());
}
module futarchy_markets::spot_conditional_quoter;

use std::option::Option;
use futarchy_markets::conditional_amm::{Self, LiquidityPool};
use futarchy_markets::proposal::{Self, Proposal};
use futarchy_markets::coin_escrow::TokenEscrow;
use futarchy_markets::market_state::MarketState;
use futarchy_markets::spot_amm::{Self, SpotAMM};
use sui::clock::Clock;

// === Introduction ===
// This module provides quote functionality for spot token swaps through conditional AMMs.
// It simulates the routing process to provide accurate quotes without executing trades.
//
// Key features:
// - Provides accurate quotes for spot-to-spot swaps through conditional AMMs
// - Accounts for complete set minting/redemption costs
// - Simulates the full routing path without state changes
// - Returns both output amounts and price impact information

// === Errors ===
const EInvalidOutcome: u64 = 0;
const EZeroAmount: u64 = 1;
const EMarketNotActive: u64 = 2;
const EInsufficientLiquidity: u64 = 3;

// === Structs ===

/// Quote result for a spot swap
public struct SpotQuote has copy, drop {
    /// The expected output amount
    amount_out: u64,
    /// The effective price (amount_out / amount_in scaled by 1e9)
    effective_price: u64,
    /// The price impact percentage (scaled by 1e4, so 100 = 1%)
    price_impact_bps: u64,
    /// The outcome being traded through
    outcome: u64,
    /// Whether this is asset->stable (true) or stable->asset (false)
    is_asset_to_stable: bool,
}

/// Detailed quote with breakdown
public struct DetailedSpotQuote has copy, drop {
    /// Basic quote information
    quote: SpotQuote,
    /// Amount of conditional tokens created
    conditional_tokens_created: u64,
    /// Amount of conditional tokens that would be returned as excess
    excess_conditional_tokens: u64,
    /// The spot price before the trade
    spot_price_before: u64,
    /// The spot price after the trade
    spot_price_after: u64,
}

// === Public View Functions ===

/// Get a quote for swapping spot asset to spot stable through a specific outcome
public fun quote_spot_asset_to_stable<AssetType, StableType>(
    proposal: &Proposal<AssetType, StableType>,
    escrow: &TokenEscrow<AssetType, StableType>,
    outcome_idx: u64,
    amount_in: u64,
    clock: &Clock,
): SpotQuote {
    // Validate inputs
    assert!(amount_in > 0, EZeroAmount);
    assert!(outcome_idx < proposal.outcome_count(), EInvalidOutcome);
    
    // Verify market is active
    let market_state = escrow.get_market_state();
    assert!(market_state.is_trading_active(), EMarketNotActive);
    
    // Step 1: Complete set minting creates amount_in of each conditional token
    let conditional_asset_amount = amount_in;
    
    // Step 2: Get the AMM for this outcome
    let amm = proposal.get_pool_by_outcome((outcome_idx as u8));
    
    // Step 3: Calculate swap output for asset -> stable
    let stable_out = conditional_amm::quote_swap_asset_to_stable(
        amm,
        conditional_asset_amount
    );
    
    // Step 4: Complete set redemption would give us stable_out spot tokens
    // (other outcomes would have excess conditional tokens returned)
    
    // Calculate effective price (scaled by 1e9 for precision)
    let effective_price = if (amount_in > 0) {
        (stable_out as u128) * 1_000_000_000 / (amount_in as u128)
    } else {
        0
    };
    
    // Calculate price impact
    let (asset_reserve, stable_reserve) = conditional_amm::get_reserves(amm);
    let spot_price_before = if (asset_reserve > 0) {
        (stable_reserve as u128) * 1_000_000_000 / (asset_reserve as u128)
    } else {
        0
    };
    
    let price_impact_bps = calculate_price_impact(
        spot_price_before as u64,
        effective_price as u64
    );
    
    SpotQuote {
        amount_out: stable_out,
        effective_price: effective_price as u64,
        price_impact_bps,
        outcome: outcome_idx,
        is_asset_to_stable: true,
    }
}

/// Get a quote for swapping spot stable to spot asset through a specific outcome
public fun quote_spot_stable_to_asset<AssetType, StableType>(
    proposal: &Proposal<AssetType, StableType>,
    escrow: &TokenEscrow<AssetType, StableType>,
    outcome_idx: u64,
    amount_in: u64,
    clock: &Clock,
): SpotQuote {
    // Validate inputs
    assert!(amount_in > 0, EZeroAmount);
    assert!(outcome_idx < proposal.outcome_count(), EInvalidOutcome);
    
    // Verify market is active
    let market_state = escrow.get_market_state();
    assert!(market_state.is_trading_active(), EMarketNotActive);
    
    // Step 1: Complete set minting creates amount_in of each conditional token
    let conditional_stable_amount = amount_in;
    
    // Step 2: Get the AMM for this outcome
    let amm = proposal.get_pool_by_outcome((outcome_idx as u8));
    
    // Step 3: Calculate swap output for stable -> asset
    let asset_out = conditional_amm::quote_swap_stable_to_asset(
        amm,
        conditional_stable_amount
    );
    
    // Step 4: Complete set redemption would give us asset_out spot tokens
    
    // Calculate effective price (scaled by 1e9 for precision)
    let effective_price = if (amount_in > 0) {
        (asset_out as u128) * 1_000_000_000 / (amount_in as u128)
    } else {
        0
    };
    
    // Calculate price impact
    let (asset_reserve, stable_reserve) = conditional_amm::get_reserves(amm);
    let spot_price_before = if (stable_reserve > 0) {
        (asset_reserve as u128) * 1_000_000_000 / (stable_reserve as u128)
    } else {
        0
    };
    
    let price_impact_bps = calculate_price_impact(
        spot_price_before as u64,
        effective_price as u64
    );
    
    SpotQuote {
        amount_out: asset_out,
        effective_price: effective_price as u64,
        price_impact_bps,
        outcome: outcome_idx,
        is_asset_to_stable: false,
    }
}

/// Get a detailed quote with additional information
public fun quote_spot_asset_to_stable_detailed<AssetType, StableType>(
    proposal: &Proposal<AssetType, StableType>,
    escrow: &TokenEscrow<AssetType, StableType>,
    outcome_idx: u64,
    amount_in: u64,
    clock: &Clock,
): DetailedSpotQuote {
    // Get basic quote
    let quote = quote_spot_asset_to_stable(
        proposal,
        escrow,
        outcome_idx,
        amount_in,
        clock
    );
    
    // Get AMM for detailed calculations
    let amm = proposal.get_pool_by_outcome((outcome_idx as u8));
    let (asset_reserve_before, stable_reserve_before) = conditional_amm::get_reserves(amm);
    
    // Calculate reserves after trade
    let asset_reserve_after = asset_reserve_before + amount_in;
    let stable_reserve_after = stable_reserve_before - quote.amount_out;
    
    // Calculate spot prices
    let spot_price_before = if (asset_reserve_before > 0) {
        (stable_reserve_before as u128) * 1_000_000_000 / (asset_reserve_before as u128)
    } else {
        0
    };
    
    let spot_price_after = if (asset_reserve_after > 0) {
        (stable_reserve_after as u128) * 1_000_000_000 / (asset_reserve_after as u128)
    } else {
        0
    };
    
    // Calculate excess tokens (all non-traded outcomes)
    let outcome_count = proposal.outcome_count();
    let excess_conditional_tokens = (outcome_count - 1) * amount_in;
    
    DetailedSpotQuote {
        quote,
        conditional_tokens_created: outcome_count * amount_in,
        excess_conditional_tokens,
        spot_price_before: spot_price_before as u64,
        spot_price_after: spot_price_after as u64,
    }
}

/// Get a detailed quote for stable to asset swap
public fun quote_spot_stable_to_asset_detailed<AssetType, StableType>(
    proposal: &Proposal<AssetType, StableType>,
    escrow: &TokenEscrow<AssetType, StableType>,
    outcome_idx: u64,
    amount_in: u64,
    clock: &Clock,
): DetailedSpotQuote {
    // Get basic quote
    let quote = quote_spot_stable_to_asset(
        proposal,
        escrow,
        outcome_idx,
        amount_in,
        clock
    );
    
    // Get AMM for detailed calculations
    let amm = proposal.get_pool_by_outcome((outcome_idx as u8));
    let (asset_reserve_before, stable_reserve_before) = conditional_amm::get_reserves(amm);
    
    // Calculate reserves after trade
    let stable_reserve_after = stable_reserve_before + amount_in;
    let asset_reserve_after = asset_reserve_before - quote.amount_out;
    
    // Calculate spot prices
    let spot_price_before = if (stable_reserve_before > 0) {
        (asset_reserve_before as u128) * 1_000_000_000 / (stable_reserve_before as u128)
    } else {
        0
    };
    
    let spot_price_after = if (stable_reserve_after > 0) {
        (asset_reserve_after as u128) * 1_000_000_000 / (stable_reserve_after as u128)
    } else {
        0
    };
    
    // Calculate excess tokens
    let outcome_count = proposal.outcome_count();
    let excess_conditional_tokens = (outcome_count - 1) * amount_in;
    
    DetailedSpotQuote {
        quote,
        conditional_tokens_created: outcome_count * amount_in,
        excess_conditional_tokens,
        spot_price_before: spot_price_before as u64,
        spot_price_after: spot_price_after as u64,
    }
}

/// Find the best outcome to route a spot asset to stable swap through
public fun find_best_asset_to_stable_route<AssetType, StableType>(
    proposal: &Proposal<AssetType, StableType>,
    escrow: &TokenEscrow<AssetType, StableType>,
    amount_in: u64,
    clock: &Clock,
): (u64, SpotQuote) {
    assert!(amount_in > 0, EZeroAmount);
    
    let outcome_count = proposal.outcome_count();
    assert!(outcome_count > 0, EInvalidOutcome);
    
    let mut best_outcome = 0;
    let mut best_quote = quote_spot_asset_to_stable(
        proposal,
        escrow,
        0,
        amount_in,
        clock
    );
    
    let mut i = 1;
    while (i < outcome_count) {
        let quote = quote_spot_asset_to_stable(
            proposal,
            escrow,
            i,
            amount_in,
            clock
        );
        
        if (quote.amount_out > best_quote.amount_out) {
            best_outcome = i;
            best_quote = quote;
        };
        
        i = i + 1;
    };
    
    (best_outcome, best_quote)
}

/// Find the best outcome to route a spot stable to asset swap through
public fun find_best_stable_to_asset_route<AssetType, StableType>(
    proposal: &Proposal<AssetType, StableType>,
    escrow: &TokenEscrow<AssetType, StableType>,
    amount_in: u64,
    clock: &Clock,
): (u64, SpotQuote) {
    assert!(amount_in > 0, EZeroAmount);
    
    let outcome_count = proposal.outcome_count();
    assert!(outcome_count > 0, EInvalidOutcome);
    
    let mut best_outcome = 0;
    let mut best_quote = quote_spot_stable_to_asset(
        proposal,
        escrow,
        0,
        amount_in,
        clock
    );
    
    let mut i = 1;
    while (i < outcome_count) {
        let quote = quote_spot_stable_to_asset(
            proposal,
            escrow,
            i,
            amount_in,
            clock
        );
        
        if (quote.amount_out > best_quote.amount_out) {
            best_outcome = i;
            best_quote = quote;
        };
        
        i = i + 1;
    };
    
    (best_outcome, best_quote)
}

// === Helper Functions ===

/// Calculate price impact in basis points
fun calculate_price_impact(price_before: u64, effective_price: u64): u64 {
    if (price_before == 0) {
        return 0
    };
    
    let diff = if (effective_price > price_before) {
        effective_price - price_before
    } else {
        price_before - effective_price
    };
    
    // Calculate impact as basis points (1 bp = 0.01%)
    let impact = (diff as u128) * 10000 / (price_before as u128);
    impact as u64
}

// === Accessor Functions ===

public fun get_amount_out(quote: &SpotQuote): u64 {
    quote.amount_out
}

public fun get_effective_price(quote: &SpotQuote): u64 {
    quote.effective_price
}

public fun get_price_impact_bps(quote: &SpotQuote): u64 {
    quote.price_impact_bps
}

public fun get_outcome(quote: &SpotQuote): u64 {
    quote.outcome
}

public fun is_asset_to_stable(quote: &SpotQuote): bool {
    quote.is_asset_to_stable
}

public fun get_conditional_tokens_created(detailed: &DetailedSpotQuote): u64 {
    detailed.conditional_tokens_created
}

public fun get_excess_conditional_tokens(detailed: &DetailedSpotQuote): u64 {
    detailed.excess_conditional_tokens
}

public fun get_spot_price_before(detailed: &DetailedSpotQuote): u64 {
    detailed.spot_price_before
}

public fun get_spot_price_after(detailed: &DetailedSpotQuote): u64 {
    detailed.spot_price_after
}

// === Oracle Price Functions ===

/// Get combined oracle price from spot AMM
/// Uses get_twap_mut to ensure TWAP is up-to-date
public fun get_combined_oracle_price<AssetType, StableType>(
    spot_pool: &mut SpotAMM<AssetType, StableType>,
    clock: &Clock,
): u128 {
    // Return the spot AMM TWAP
    spot_amm::get_twap_mut(spot_pool, clock)
}

/// Check if a price meets a threshold condition
public fun check_price_threshold(
    price: u128,
    threshold: u128,
    is_above_threshold: bool,
): bool {
    if (is_above_threshold) {
        price >= threshold
    } else {
        price <= threshold
    }
}

/// Check if proposals can be created based on TWAP readiness
public fun can_create_proposal<AssetType, StableType>(
    spot_pool: &SpotAMM<AssetType, StableType>,
    clock: &Clock,
): bool {
    spot_amm::is_twap_ready(spot_pool, clock)
}

/// Get time until proposals are allowed (returns 0 if ready)
public fun time_until_proposals_allowed<AssetType, StableType>(
    spot_pool: &SpotAMM<AssetType, StableType>,
    clock: &Clock,
): u64 {
    // Check if TWAP is ready
    if (spot_amm::is_twap_ready(spot_pool, clock)) {
        return 0
    };
    
    // Calculate remaining time (simplified - assumes 3 days needed)
    259_200_000 // Return 3 days in ms as placeholder
}

/// Get initialization price for conditional AMMs
public fun get_initialization_price<AssetType, StableType>(
    spot_pool: &SpotAMM<AssetType, StableType>,
    clock: &Clock,
): u128 {
    spot_amm::get_twap_for_conditional_amm(spot_pool, clock)
}module futarchy_markets::liquidity_interact;

use futarchy_markets::conditional_amm;
use futarchy_markets::coin_escrow::{Self, TokenEscrow};
use futarchy_markets::conditional_token::ConditionalToken;
use futarchy_markets::fee::FeeManager;
use futarchy_markets::proposal::Proposal;
use sui::balance::Balance;
use sui::clock::Clock;
use sui::coin::{Self, Coin};
use sui::event;

// === Introduction ===
// Methods to interact with AMM liquidity and escrow balances

// === Errors ===
const EInvalidOutcome: u64 = 0;
const EInvalidLiquidityTransfer: u64 = 1;
const EWrongOutcome: u64 = 2;
const EInvalidState: u64 = 3;
const EMarketIdMismatch: u64 = 4;
const EAssetReservesMismatch: u64 = 5;
const EStableReservesMismatch: u64 = 6;

// === Events ===
public struct ProtocolFeesCollected has copy, drop {
    proposal_id: ID,
    winning_outcome: u64,
    fee_amount: u64,
    timestamp_ms: u64,
}

// === Helper Functions ===
/// Efficiently transfers all tokens in a vector to the recipient
fun transfer_tokens_to_recipient(mut tokens: vector<ConditionalToken>, recipient: address) {
    while (!tokens.is_empty()) {
        transfer::public_transfer(tokens.pop_back(), recipient);
    };
    tokens.destroy_empty();
}

/// Empties the winning AMM pool and transfers the underlying liquidity to the original provider.
/// Called internally by `advance_stage` when a user-funded proposal finalizes.
public fun empty_amm_and_return_to_provider<AssetType, StableType>(
    proposal: &mut Proposal<AssetType, StableType>,
    escrow: &mut TokenEscrow<AssetType, StableType>,
    ctx: &mut TxContext,
) {
    assert!(proposal.is_finalized(), EInvalidState);
    assert!(!proposal.uses_dao_liquidity(), EInvalidState);

    // Validate that proposal and escrow belong to the same market
    let market_id = proposal.market_state_id();
    let escrow_market_id = escrow.get_market_state_id();
    assert!(market_id == escrow_market_id, EMarketIdMismatch);
    let market_state = escrow.get_market_state();
    let winning_outcome = proposal.get_winning_outcome();
    market_state.assert_market_finalized();

    let pool = proposal.get_pool_mut_by_outcome((winning_outcome as u8));
    let (asset_out, stable_out) = pool.empty_all_amm_liquidity(ctx);
    
    // Record the final amounts for LP conversion invariance
    coin_escrow::record_winning_pool_final_amounts(escrow, asset_out, stable_out);

    let (asset_coin, stable_coin) = escrow.remove_liquidity(asset_out, stable_out, ctx);
    
    let provider = *proposal.get_liquidity_provider().borrow();
    transfer::public_transfer(asset_coin, provider);
    transfer::public_transfer(stable_coin, provider);

    assert_winning_reserves_consistency(proposal, escrow);
}

/// Empties the winning AMM pool and returns the liquidity.
/// Called internally by `advance_stage` when a DAO-funded proposal finalizes.
/// Returns the asset and stable coins for the DAO to handle (e.g., deposit to vault).
public fun empty_amm_and_return_to_dao<AssetType, StableType>(
    proposal: &mut Proposal<AssetType, StableType>,
    escrow: &mut TokenEscrow<AssetType, StableType>,
    ctx: &mut TxContext,
): (Coin<AssetType>, Coin<StableType>) {
    assert!(proposal.is_finalized(), EInvalidState);
    assert!(proposal.uses_dao_liquidity(), EInvalidState);

    let market_id = proposal.market_state_id();
    let escrow_market_id = escrow.get_market_state_id();
    assert!(market_id == escrow_market_id, EMarketIdMismatch);
    escrow.get_market_state().assert_market_finalized();

    let winning_outcome = proposal.get_winning_outcome();
    let pool = proposal.get_pool_mut_by_outcome((winning_outcome as u8));
    let (asset_out, stable_out) = pool.empty_all_amm_liquidity(ctx);
    
    // Record the final amounts for LP conversion invariance
    coin_escrow::record_winning_pool_final_amounts(escrow, asset_out, stable_out);

    let (asset_coin, stable_coin) = escrow.remove_liquidity(asset_out, stable_out, ctx);
    
    // Return coins for the caller to handle (deposit to vault, add to spot pool, etc.)
    (asset_coin, stable_coin)
}

public fun assert_all_reserves_consistency<AssetType, StableType>(
    proposal: &Proposal<AssetType, StableType>,
    escrow: &TokenEscrow<AssetType, StableType>,
) {
    // Get outcome count
    let outcome_count = proposal.outcome_count();

    // Get escrow balances
    let (escrow_asset, escrow_stable) = escrow.get_balances();

    // Check each outcome
    let mut i = 0;
    while (i < outcome_count) {
        // Get pool for this outcome
        let pool = &proposal.get_amm_pools()[i];

        // Get reserves and fees
        let (amm_asset, amm_stable) = pool.get_reserves();
        let protocol_fees = pool.get_protocol_fees();

        // Get token supplies
        let (_, _, asset_supply, stable_supply) = escrow.get_escrow_balances_and_supply(
            i,
        );

        assert!(amm_asset + asset_supply == escrow_asset, EAssetReservesMismatch);

        // Verify stable equation: AMM stable reserves + protocol fees + stable token supply = escrow stable
        // Protocol fees are explicitly collected and held outside the AMM's stable reserve.
        // Note: protocol_fees are tracked separately in pool.protocol_fees and are NOT included in amm_stable
        assert!(
            amm_stable + protocol_fees + stable_supply == escrow_stable,
            EStableReservesMismatch,
        );

        i = i + 1;
    };
}

public fun assert_winning_reserves_consistency<AssetType, StableType>(
    proposal: &Proposal<AssetType, StableType>,
    escrow: &TokenEscrow<AssetType, StableType>,
) {
    let winning_outcome = proposal.get_winning_outcome();

    // Get escrow balances
    let (escrow_asset, escrow_stable) = escrow.get_balances();

    // Get pool for this outcome
    let pool = &proposal.get_amm_pools()[winning_outcome];

    // Get reserves and fees
    let (amm_asset, amm_stable) = pool.get_reserves();
    let protocol_fees = pool.get_protocol_fees();

    // Get token supplies
    let (_, _, asset_supply, stable_supply) = escrow.get_escrow_balances_and_supply(
        winning_outcome,
    );

    assert!(amm_asset + asset_supply == escrow_asset, EAssetReservesMismatch);

    // Verify stable equation: AMM stable reserves + protocol fees + stable token supply = escrow stable
    // Note: protocol_fees are tracked separately in pool.protocol_fees and are NOT included in amm_stable
    assert!(amm_stable + protocol_fees + stable_supply == escrow_stable, EStableReservesMismatch);
}

/// Wrapper for redeeming winning stable tokens.
public entry fun redeem_winning_tokens_stable_entry<AssetType, StableType>(
    proposal: &Proposal<AssetType, StableType>, // Added
    escrow: &mut TokenEscrow<AssetType, StableType>,
    token: ConditionalToken,
    clock: &Clock,
    ctx: &mut TxContext,
) {
    let balance_out = escrow.redeem_winning_tokens_stable(token, clock, ctx);

    assert_winning_reserves_consistency(proposal, escrow);

    let coin_out = coin::from_balance(balance_out, ctx);
    transfer::public_transfer(coin_out, ctx.sender());
}

/// Wrapper for minting a complete set of asset tokens.
public entry fun mint_complete_set_asset_entry<AssetType, StableType>(
    proposal: &Proposal<AssetType, StableType>, // Added
    escrow: &mut TokenEscrow<AssetType, StableType>,
    coin_in: Coin<AssetType>,
    clock: &Clock,
    ctx: &mut TxContext,
) {
    let tokens_out = escrow.mint_complete_set_asset(coin_in, clock, ctx);

    // Assert consistency
    assert_all_reserves_consistency(proposal, escrow);

    transfer_tokens_to_recipient(tokens_out, ctx.sender());
}

/// Wrapper for minting a complete set of stable tokens.
public entry fun mint_complete_set_stable_entry<AssetType, StableType>(
    proposal: &Proposal<AssetType, StableType>, // Added
    escrow: &mut TokenEscrow<AssetType, StableType>,
    coin_in: Coin<StableType>,
    clock: &Clock,
    ctx: &mut TxContext,
) {
    let tokens_out = escrow.mint_complete_set_stable(coin_in, clock, ctx);

    assert_all_reserves_consistency(proposal, escrow);

    transfer_tokens_to_recipient(tokens_out, ctx.sender());
}

/// Wrapper for redeeming a complete set of asset tokens.
public entry fun redeem_complete_set_asset_entry<AssetType, StableType>(
    proposal: &Proposal<AssetType, StableType>, // Added
    escrow: &mut TokenEscrow<AssetType, StableType>,
    tokens: vector<ConditionalToken>,
    clock: &Clock,
    ctx: &mut TxContext,
) {
    // Call the underlying package function from coin_escrow
    let balance_out = escrow.redeem_complete_set_asset(tokens, clock, ctx);

    // Assert consistency
    assert_all_reserves_consistency(proposal, escrow);

    // Handle result (transfer coin)
    let coin_out = coin::from_balance(balance_out, ctx);
    transfer::public_transfer(coin_out, ctx.sender());
}

/// Wrapper for redeeming a complete set of stable tokens.
public entry fun redeem_complete_set_stable_entry<AssetType, StableType>(
    proposal: &Proposal<AssetType, StableType>, // Added
    escrow: &mut TokenEscrow<AssetType, StableType>,
    tokens: vector<ConditionalToken>,
    clock: &Clock,
    ctx: &mut TxContext,
) {
    let balance_out = escrow.redeem_complete_set_stable(tokens, clock, ctx);

    assert_all_reserves_consistency(proposal, escrow);

    // Handle result (transfer coin)
    let coin_out = coin::from_balance(balance_out, ctx);
    transfer::public_transfer(coin_out, ctx.sender());
}

public entry fun redeem_winning_tokens_asset_entry<AssetType, StableType>(
    proposal: &Proposal<AssetType, StableType>, // Added
    escrow: &mut TokenEscrow<AssetType, StableType>,
    token: ConditionalToken,
    clock: &Clock,
    ctx: &mut TxContext,
) {
    let balance_out = escrow.redeem_winning_tokens_asset(token, clock, ctx);

    // Pass ctx only if the assert function requires it
    assert_winning_reserves_consistency(proposal, escrow);

    // Handle result (transfer coin)
    let coin_out = coin::from_balance(balance_out, ctx);
    transfer::public_transfer(coin_out, ctx.sender());
}

// === AMM Liquidity Management Entry Points ===

/// Add liquidity to an AMM pool for a specific outcome
/// Takes asset and stable conditional tokens and returns LP tokens
public entry fun add_liquidity_entry<AssetType, StableType>(
    proposal: &mut Proposal<AssetType, StableType>,
    escrow: &mut TokenEscrow<AssetType, StableType>,
    outcome_idx: u64,
    asset_in: ConditionalToken,
    stable_in: ConditionalToken,
    min_lp_out: u64,
    clock: &Clock,
    ctx: &mut TxContext,
) {
    // Verify market state consistency
    assert!(proposal.market_state_id() == escrow.get_market_state_id(), EMarketIdMismatch);
    assert!(!proposal.is_finalized(), EInvalidState);
    
    // Verify tokens match the pool's outcome
    assert!(asset_in.market_id() == proposal.market_state_id(), EMarketIdMismatch);
    assert!(stable_in.market_id() == proposal.market_state_id(), EMarketIdMismatch);
    assert!(asset_in.outcome() == (outcome_idx as u8), EWrongOutcome);
    assert!(stable_in.outcome() == (outcome_idx as u8), EWrongOutcome);
    assert!(asset_in.asset_type() == 0, EInvalidState); // Must be asset token
    assert!(stable_in.asset_type() == 1, EInvalidState); // Must be stable token
    
    let asset_amount = asset_in.value();
    let stable_amount = stable_in.value();
    
    // Burn the conditional tokens (they'll be absorbed into the pool)
    escrow.burn_single_conditional_token(asset_in, clock, ctx);
    escrow.burn_single_conditional_token(stable_in, clock, ctx);
    
    // Get the pool for this outcome
    let pool = proposal.get_pool_mut_by_outcome((outcome_idx as u8));
    
    // Add liquidity through the AMM (only calculations and reserve updates)
    let lp_amount = conditional_amm::add_liquidity_proportional(
        pool,
        asset_amount,
        stable_amount,
        min_lp_out,
        clock,
        ctx
    );
    
    // Mint LP tokens
    let lp_token = escrow.mint_single_conditional_token(
        2, // TOKEN_TYPE_LP
        (outcome_idx as u8),
        lp_amount,
        ctx.sender(),
        clock,
        ctx
    );
    
    // Assert consistency after operation
    assert_all_reserves_consistency(proposal, escrow);
    
    // Transfer LP token to the sender
    transfer::public_transfer(lp_token, ctx.sender());
}

/// Remove liquidity from an AMM pool proportionally
/// Takes LP tokens and returns asset and stable conditional tokens
public entry fun remove_liquidity_entry<AssetType, StableType>(
    proposal: &mut Proposal<AssetType, StableType>,
    escrow: &mut TokenEscrow<AssetType, StableType>,
    outcome_idx: u64,
    lp_token: ConditionalToken,
    min_asset_out: u64,
    min_stable_out: u64,
    clock: &Clock,
    ctx: &mut TxContext,
) {
    // Verify market state consistency
    assert!(proposal.market_state_id() == escrow.get_market_state_id(), EMarketIdMismatch);
    assert!(!proposal.is_finalized(), EInvalidState);
    
    // Verify LP token is for the correct outcome and market
    assert!(lp_token.market_id() == proposal.market_state_id(), EMarketIdMismatch);
    assert!(lp_token.outcome() == (outcome_idx as u8), EWrongOutcome);
    assert!(lp_token.asset_type() == 2, EInvalidState); // Must be LP token
    
    let lp_amount = lp_token.value();
    
    // Burn the LP token
    escrow.burn_single_conditional_token(lp_token, clock, ctx);
    
    // Get the pool for this outcome
    let pool = proposal.get_pool_mut_by_outcome((outcome_idx as u8));
    
    // Remove liquidity through the AMM (only calculations and reserve updates)
    let (asset_amount, stable_amount) = conditional_amm::remove_liquidity_proportional(
        pool,
        lp_amount,
        clock,
        ctx
    );
    
    // Verify slippage protection
    assert!(asset_amount >= min_asset_out, EInvalidState);
    assert!(stable_amount >= min_stable_out, EInvalidState);
    
    // Mint the asset and stable tokens
    let asset_token = escrow.mint_single_conditional_token(
        0, // TOKEN_TYPE_ASSET
        (outcome_idx as u8),
        asset_amount,
        ctx.sender(),
        clock,
        ctx
    );
    
    let stable_token = escrow.mint_single_conditional_token(
        1, // TOKEN_TYPE_STABLE
        (outcome_idx as u8),
        stable_amount,
        ctx.sender(),
        clock,
        ctx
    );
    
    // Assert consistency after operation
    assert_all_reserves_consistency(proposal, escrow);
    
    // Transfer tokens to the sender
    transfer::public_transfer(asset_token, ctx.sender());
    transfer::public_transfer(stable_token, ctx.sender());
}

public fun redeem_winning_tokens_stable<AssetType, StableType>(
    proposal: &Proposal<AssetType, StableType>, // Read-only needed for assertion & checks
    escrow: &mut TokenEscrow<AssetType, StableType>,
    token: ConditionalToken,
    clock: &Clock,
    ctx: &mut TxContext, // Still needed for coin_escrow call
): Balance<StableType> {
    // Pre-checks using proposal state
    assert!(proposal.is_finalized(), EInvalidState);
    let winning_outcome = proposal.get_winning_outcome();
    assert!(token.outcome() == (winning_outcome as u8), EWrongOutcome);

    // Call the core logic in coin_escrow
    let balance_out = escrow.redeem_winning_tokens_stable(token, clock, ctx);

    assert_winning_reserves_consistency(proposal, escrow);

    // Return the result
    balance_out
}

/// Redeems a winning asset token after the market has finalized.
/// Returns the Balance<AssetType> for use in PTBs.
public fun redeem_winning_tokens_asset<AssetType, StableType>(
    proposal: &Proposal<AssetType, StableType>, // Read-only needed for assertion & checks
    escrow: &mut TokenEscrow<AssetType, StableType>,
    token: ConditionalToken,
    clock: &Clock,
    ctx: &mut TxContext, // Still needed for coin_escrow call
): Balance<AssetType> {
    // Pre-checks using proposal state
    assert!(proposal.is_finalized(), EInvalidState);
    let winning_outcome = proposal.get_winning_outcome();
    assert!(token.outcome() == (winning_outcome as u8), EWrongOutcome);

    // Call the core logic in coin_escrow
    let balance_out = escrow.redeem_winning_tokens_asset(token, clock, ctx);

    assert_winning_reserves_consistency(proposal, escrow);

    // Return the result
    balance_out
}

/// Mints a complete set of asset tokens by depositing the base asset.
/// Returns the vector<ConditionalToken> for use in PTBs.
public fun mint_complete_set_asset<AssetType, StableType>(
    proposal: &Proposal<AssetType, StableType>, // Read-only needed for assertion
    escrow: &mut TokenEscrow<AssetType, StableType>,
    coin_in: Coin<AssetType>,
    clock: &Clock,
    ctx: &mut TxContext, // Still needed for coin_escrow call
): vector<ConditionalToken> {
    // Optional pre-checks using proposal state
    assert!(!proposal.is_finalized(), EInvalidState);

    // Call the core logic in coin_escrow
    let tokens_out = escrow.mint_complete_set_asset(coin_in, clock, ctx);

    assert_all_reserves_consistency(proposal, escrow);

    // Return the result
    tokens_out
}

/// Mints a complete set of stable tokens by depositing the stable coin.
/// Returns the vector<ConditionalToken> for use in PTBs.
public fun mint_complete_set_stable<AssetType, StableType>(
    proposal: &Proposal<AssetType, StableType>, // Read-only needed for assertion
    escrow: &mut TokenEscrow<AssetType, StableType>,
    coin_in: Coin<StableType>,
    clock: &Clock,
    ctx: &mut TxContext, // Still needed for coin_escrow call
): vector<ConditionalToken> {
    // Optional pre-checks using proposal state
    assert!(!proposal.is_finalized(), EInvalidState);

    // Call the core logic in coin_escrow
    let tokens_out = escrow.mint_complete_set_stable(coin_in, clock, ctx);

    assert_all_reserves_consistency(proposal, escrow);

    // Return the result
    tokens_out
}

/// Redeems a complete set of asset tokens for the base asset.
/// Returns the Balance<AssetType> for use in PTBs.
public fun redeem_complete_set_asset<AssetType, StableType>(
    proposal: &Proposal<AssetType, StableType>, // Read-only needed for assertion
    escrow: &mut TokenEscrow<AssetType, StableType>,
    tokens: vector<ConditionalToken>, // Consumed by the call
    clock: &Clock,
    ctx: &mut TxContext, // Still needed for coin_escrow call
): Balance<AssetType> {
    // Optional pre-checks using proposal state
    assert!(!proposal.is_finalized(), EInvalidState);

    // Call the core logic in coin_escrow
    let balance_out = escrow.redeem_complete_set_asset(tokens, clock, ctx);

    assert_all_reserves_consistency(proposal, escrow);

    // Return the result
    balance_out
}

/// Redeems a complete set of stable tokens for the stable coin.
/// Returns the Balance<StableType> for use in PTBs.
public fun redeem_complete_set_stable<AssetType, StableType>(
    proposal: &Proposal<AssetType, StableType>, // Read-only needed for assertion
    escrow: &mut TokenEscrow<AssetType, StableType>,
    tokens: vector<ConditionalToken>, // Consumed by the call
    clock: &Clock,
    ctx: &mut TxContext, // Still needed for coin_escrow call
): Balance<StableType> {
    // Optional pre-checks using proposal state
    assert!(!proposal.is_finalized(), EInvalidState);

    // Call the core logic in coin_escrow
    let balance_out = escrow.redeem_complete_set_stable(tokens, clock, ctx);

    // Assert consistency AFTER the operation
    assert_all_reserves_consistency(proposal, escrow);

    // Return the result
    balance_out
}

public entry fun burn_unused_tokens_entry<AssetType, StableType>(
    proposal: &Proposal<AssetType, StableType>, // Read-only for checks and assert
    escrow: &mut TokenEscrow<AssetType, StableType>, // Mutable for burning
    tokens_to_burn: vector<ConditionalToken>, // Consumed by the call
    clock: &Clock,
    ctx: &mut TxContext,
) {
    // 1. Pre-check: Ensure the proposal (and thus market) is finalized
    // This aligns with the check inside coin_escrow::burn_unused_tokens
    assert!(proposal.is_finalized(), EInvalidState);

    // 2. Call the package-private burn function in coin_escrow
    // This function will handle all individual token checks and burning.
    escrow.burn_unused_tokens(
        tokens_to_burn, // The vector is consumed here
        clock,
        ctx,
    );

    // 3. Assert reserve consistency for the winning outcome AFTER burning
    // Burning non-winning tokens should not affect the winning outcome's
    // reserves or its supply, so this check should pass if the state was
    // consistent before the call.
    assert_winning_reserves_consistency(proposal, escrow);
}

public fun collect_protocol_fees<AssetType, StableType>(
    proposal: &mut Proposal<AssetType, StableType>,
    escrow: &mut TokenEscrow<AssetType, StableType>,
    fee_manager: &mut FeeManager,
    clock: &Clock,
) {
    // Can only collect fees if the proposal is finalized
    assert!(proposal.is_finalized(), EInvalidState);
    assert!(proposal.is_winning_outcome_set(), EInvalidState);

    assert!(escrow.get_market_state_id() == proposal.market_state_id(), EInvalidState);

    let winning_outcome = proposal.get_winning_outcome();
    let winning_pool = proposal.get_pool_mut_by_outcome((winning_outcome as u8));
    let protocol_fee_amount = winning_pool.get_protocol_fees();

    if (protocol_fee_amount > 0) {
        // Reset fees in the pool
        winning_pool.reset_protocol_fees();

        // Extract the fees from escrow
        let fee_balance = escrow.extract_stable_fees<AssetType, StableType>(
            protocol_fee_amount,
        );

        // Deposit to fee manager
        fee_manager.deposit_stable_fees<StableType>(
            fee_balance,
            proposal.get_id(),
            clock,
        );

        assert_winning_reserves_consistency(proposal, escrow);

        // Emit event
        event::emit(ProtocolFeesCollected {
            proposal_id: proposal.get_id(),
            winning_outcome,
            fee_amount: protocol_fee_amount,
            timestamp_ms: clock.timestamp_ms(),
        });
    }
}

#[test_only]
public fun get_liquidity_for_proposal<AssetType, StableType>(
    proposal: &Proposal<AssetType, StableType>,
): vector<u64> {
    let pools = proposal.get_amm_pools();
    let mut liquidity = vector[];
    let mut i = 0;
    while (i < pools.length()) {
        let pool = &pools[i];
        let (asset, stable) = pool.get_reserves();
        liquidity.push_back(asset);
        liquidity.push_back(stable);
        i = i + 1;
    };
    liquidity
}
/// ============================================================================
/// SPOT AMM WITH BASE FAIR VALUE TWAP - CRITICAL ARCHITECTURE NOTES
/// ============================================================================
/// 
/// This is a specialized spot AMM designed for Hanson-style futarchy with quantum
/// liquidity splitting. The TWAP here serves as the "base fair value" price for
/// internal protocol functions like founder token minting based on price targets.
/// 
/// KEY ARCHITECTURAL DECISIONS:
/// 
/// 1. QUANTUM LIQUIDITY MODEL (Hanson Futarchy)
///    - When a proposal uses DAO liquidity, 1 spot dollar becomes 1 conditional 
///      dollar in EACH outcome (not split, but quantum - exists in all states)
///    - Spot pool becomes COMPLETELY EMPTY during these proposals
///    - Only the highest-priced conditional market determines the winner
/// 
/// 2. TWAP CONTINUITY ACROSS TRANSITIONS
///    The spot TWAP must maintain continuity even when liquidity moves to conditional AMMs:
///    
///    Timeline example:
///    [Spot Active: N seconds] → [Proposal Live: M seconds] → [Spot Active Again]
///    
///    - N could be >> M (spot active much longer than proposal)
///    - M could be >> N (long proposal, short spot history)
///    - We don't know relative durations in advance
/// 
/// 3. LOCKING MECHANISM
///    When proposal starts:
///    - Spot pool is LOCKED (last_proposal_usage timestamp set)
///    - No TWAP updates allowed while locked
///    - All liquidity moves to conditional AMMs
///    
///    During proposal (spot locked):
///    - get_twap() reads from WINNING conditional AMM (highest price)
///    - Adds conditional TWAP for the missing time period
///    - Maintains continuous price history
///    
///    When proposal ends:
///    - Winning conditional's TWAP fills the gap in spot history
///    - Pool unlocks and resumes normal operation
///    - Liquidity returns from winning conditional
/// 
/// 4. TWAP CALCULATION LOGIC
///    
///    Normal operation (no active proposal):
///    - Standard rolling 3-day window
///    - Accumulates price × time
///    - Updates on swaps and liquidity events
///    
///    During live proposal:
///    - Spot accumulator frozen at proposal start time
///    - get_twap() adds: winning_conditional_twap × time_since_proposal_start
///    - Returns combined TWAP over full window
///    
///    After proposal (hot path):
///    - fill_twap_gap_from_proposal() writes: winning_twap × proposal_duration
///    - Adds to window_cumulative_price permanently
///    - Resumes from winning conditional's final price
/// 
/// 5. NOT FOR EXTERNAL PROTOCOLS
///    This TWAP is NOT suitable for:
///    - Lending protocols (need continuous updates)
///    - External price oracles (too specialized)
///    - High-frequency trading (updates only on major events)
///    
///    It IS designed for:
///    - Founder token minting based on price milestones
///    - Long-term protocol health metrics
///    - Base fair value for protocol decisions
/// 
/// 6. SECURITY CONSIDERATIONS
///    - Manipulation requires attacking the WINNING conditional market
///    - Historical segments cannot be modified after writing
///    - Lock prevents TWAP updates during proposals (no double-counting)
///    - Window sliding uses last_window_twap (stable reference) not current price
/// 
/// ============================================================================

module futarchy_markets::spot_amm;

use std::option::{Self, Option};
use std::vector::{Self};
use sui::balance::{Self, Balance};
use sui::coin::{Self, Coin};
use sui::object::{Self, UID, ID};
use sui::transfer;
use sui::tx_context::{Self, TxContext};
use sui::clock::{Self, Clock};
use sui::event;
use futarchy_one_shot_utils::math;
use futarchy_markets::ring_buffer_oracle::{Self, RingBufferOracle};
use futarchy_markets::conditional_amm;
use futarchy_one_shot_utils::constants;

// Basic errors
const EZeroAmount: u64 = 1;
const EInsufficientLiquidity: u64 = 2;
const ESlippageExceeded: u64 = 3;
const EInvalidFee: u64 = 4;
const EOverflow: u64 = 5;
const EImbalancedLiquidity: u64 = 6;
const ENotInitialized: u64 = 7;
const EAlreadyInitialized: u64 = 8;
const ETwapNotReady: u64 = 9;
const EPoolLockedForProposal: u64 = 10;

// MAX_FEE_BPS moved to constants module
const MINIMUM_LIQUIDITY: u64 = 1000;

// TWAP constants
const THREE_DAYS_MS: u64 = 259_200_000; // 3 days in milliseconds (3 * 24 * 60 * 60 * 1000)
const PRICE_SCALE: u128 = 1_000_000_000_000; // 10^12 for price precision

/// Historical price segment from conditional AMMs
public struct PriceSegment has store, drop, copy {
    start_timestamp: u64,
    end_timestamp: u64,
    cumulative_price: u256,  // Cumulative price over this segment
    avg_price: u128,          // Average price for quick access
}

/// Simple spot AMM for <AssetType, StableType> with dual oracle system
public struct SpotAMM<phantom AssetType, phantom StableType> has key, store {
    id: UID,
    asset_reserve: Balance<AssetType>,
    stable_reserve: Balance<StableType>,
    lp_supply: u64,
    fee_bps: u64,
    // Ring buffer oracle for lending protocols (continuous updates)
    ring_buffer_oracle: RingBufferOracle,
    // Base fair value TWAP oracle fields - maintains rolling 3-day window
    initialized_at: Option<u64>,
    last_price: u128,
    last_timestamp: u64,
    // Rolling 3-day window accumulator (resets every update)
    window_start_timestamp: u64,      // Timestamp exactly 3 days ago
    // The TWAP of the last completed full price window. More stable than last_price for estimations.
    last_window_twap: u128,
    window_cumulative_price: u256,    // Cumulative price over the 3-day window
    // Historical segments from conditional AMMs (used when DAO liquidity was in proposals)
    historical_segments: vector<PriceSegment>,
    // Track when DAO liquidity was last used in a proposal
    last_proposal_usage: Option<u64>,
}

/// Spot LP token
public struct SpotLP<phantom AssetType, phantom StableType> has key, store {
    id: UID,
    amount: u64,
}

/// Event emitted when spot price updates
public struct SpotPriceUpdate has copy, drop {
    pool_id: ID,
    price: u128,
    timestamp: u64,
    asset_reserve: u64,
    stable_reserve: u64,
}

/// Event emitted when TWAP is updated
public struct SpotTwapUpdate has copy, drop {
    pool_id: ID,
    twap: u128,
    window_start: u64,
    window_end: u64,
}

/// Create a new pool (simple Uniswap V2 style)
public fun new<AssetType, StableType>(fee_bps: u64, ctx: &mut TxContext): SpotAMM<AssetType, StableType> {
    assert!(fee_bps <= constants::max_fee_bps(), EInvalidFee);
    SpotAMM<AssetType, StableType> {
        id: object::new(ctx),
        asset_reserve: balance::zero<AssetType>(),
        stable_reserve: balance::zero<StableType>(),
        lp_supply: 0,
        fee_bps,
        // Ring buffer oracle for lending
        ring_buffer_oracle: ring_buffer_oracle::new(1440), // 24 hours of observations at 1 per minute
        // TWAP fields initially unset
        initialized_at: option::none(),
        last_price: 0,
        last_timestamp: 0,
        window_start_timestamp: 0,
        last_window_twap: 0,
        window_cumulative_price: 0,
        historical_segments: vector::empty(),
        last_proposal_usage: option::none(),
    }
}

/// Initialize TWAP oracle when first liquidity is added
fun initialize_twap<AssetType, StableType>(
    pool: &mut SpotAMM<AssetType, StableType>,
    clock: &Clock,
) {
    assert!(pool.initialized_at.is_none(), EAlreadyInitialized);
    let now = clock.timestamp_ms();
    pool.initialized_at = option::some(now);
    pool.last_timestamp = now;
    pool.window_start_timestamp = now;
    pool.window_cumulative_price = 0;
    
    // Calculate initial price from reserves
    let price = calculate_spot_price(
        pool.asset_reserve.value(),
        pool.stable_reserve.value()
    );
    pool.last_price = price;
    pool.last_window_twap = price; // Initialize with current price as best estimate
}

/// Update TWAP oracle on price changes (maintains rolling 3-day window)
fun update_twap<AssetType, StableType>(
    pool: &mut SpotAMM<AssetType, StableType>,
    clock: &Clock,
) {
    assert!(pool.initialized_at.is_some(), ENotInitialized);
    let now = clock.timestamp_ms();
    
    // Skip if no time has passed
    if (now == pool.last_timestamp) return;
    
    // Update ring buffer oracle for lending protocols
    let current_price = calculate_spot_price(
        pool.asset_reserve.value(),
        pool.stable_reserve.value()
    );
    ring_buffer_oracle::write(&mut pool.ring_buffer_oracle, current_price, clock);
    
    // Accumulate price for the elapsed time BEFORE updating the window
    // This ensures we capture the price impact over the time period
    let time_elapsed = now - pool.last_timestamp;
    let price_time = (pool.last_price as u256) * (time_elapsed as u256);
    pool.window_cumulative_price = pool.window_cumulative_price + price_time;
    
    // Update the rolling window accumulator
    update_rolling_window(pool, now);
    
    // Update current price
    let new_price = calculate_spot_price(
        pool.asset_reserve.value(),
        pool.stable_reserve.value()
    );
    pool.last_price = new_price;
    pool.last_timestamp = now;
    
    // Emit price update event
    event::emit(SpotPriceUpdate {
        pool_id: object::id(pool),
        price: new_price,
        timestamp: now,
        asset_reserve: pool.asset_reserve.value(),
        stable_reserve: pool.stable_reserve.value(),
    });
}

/// Update the rolling 3-day window accumulator
fun update_rolling_window<AssetType, StableType>(
    pool: &mut SpotAMM<AssetType, StableType>,
    now: u64,
) {
    // Check if we need to slide the window forward
    let window_age = now - pool.window_start_timestamp;
    
    if (window_age > THREE_DAYS_MS) {
        // Window is older than 3 days, need to slide it forward
        let new_window_start = now - THREE_DAYS_MS;
        
        // Calculate how much to remove from the accumulator
        // (the part that's now outside the 3-day window)
        let time_to_remove = new_window_start - pool.window_start_timestamp;
        
        // SECURITY FIX: Use the stable TWAP instead of current price for estimation
        // This prevents manipulation where an attacker could corrupt the TWAP
        // by manipulating the current price just before a window slide
        let price_to_remove = (pool.last_window_twap as u256) * (time_to_remove as u256);
        
        // Slide the window: remove old data, keep only last 3 days
        if (pool.window_cumulative_price > price_to_remove) {
            pool.window_cumulative_price = pool.window_cumulative_price - price_to_remove;
        } else {
            // Fallback: if removal would underflow (extreme volatility case),
            // reset to current price * 3 days as baseline
            pool.window_cumulative_price = (pool.last_price as u256) * (THREE_DAYS_MS as u256);
        };
        
        pool.window_start_timestamp = new_window_start;
    };
    
    // Update the last_window_twap with current window average for next time
    // This keeps our stable reference price fresh
    let window_duration = if (window_age > THREE_DAYS_MS) { 
        THREE_DAYS_MS 
    } else { 
        window_age 
    };
    
    if (window_duration > 0) {
        pool.last_window_twap = (pool.window_cumulative_price / (window_duration as u256)) as u128;
    };
}

/// Calculate spot price (stable per asset) with scaling
fun calculate_spot_price(asset_reserve: u64, stable_reserve: u64): u128 {
    if (asset_reserve == 0) return 0;
    
    // Price = stable_reserve / asset_reserve * PRICE_SCALE
    ((stable_reserve as u128) * PRICE_SCALE) / (asset_reserve as u128)
}

/// Add liquidity (entry)
public entry fun add_liquidity<AssetType, StableType>(
    pool: &mut SpotAMM<AssetType, StableType>,
    asset_in: Coin<AssetType>,
    stable_in: Coin<StableType>,
    min_lp_out: u64,
    clock: &Clock,
    ctx: &mut TxContext,
) {
    let a = asset_in.value();
    let s = stable_in.value();
    assert!(a > 0 && s > 0, EZeroAmount);

    let minted = if (pool.lp_supply == 0) {
        let prod = (a as u128) * (s as u128);
        let root_u128 = math::sqrt_u128(prod);
        assert!(root_u128 <= (std::u64::max_value!() as u128), EOverflow);
        let root = root_u128 as u64;
        assert!(root > MINIMUM_LIQUIDITY, EInsufficientLiquidity);
        // Lock MINIMUM_LIQUIDITY permanently to prevent rounding attacks
        pool.lp_supply = root;  // FIX: Set to total root amount, not just minimum
        
        // Initialize TWAP oracle on first liquidity
        pool.asset_reserve.join(asset_in.into_balance());
        pool.stable_reserve.join(stable_in.into_balance());
        initialize_twap(pool, clock);
        
        root - MINIMUM_LIQUIDITY  // Return minted amount minus locked liquidity
    } else {
        // Update TWAP before liquidity change
        update_twap(pool, clock);
        
        // For subsequent deposits, calculate LP tokens based on proportional contribution
        let from_a = math::mul_div_to_64(a, pool.lp_supply, pool.asset_reserve.value());
        let from_s = math::mul_div_to_64(s, pool.lp_supply, pool.stable_reserve.value());
        
        // Enforce balanced deposits with 1% tolerance to prevent value extraction
        let max_delta = if (from_a > from_s) {
            from_a - from_s
        } else {
            from_s - from_a
        };
        let avg = (from_a + from_s) / 2;
        assert!(max_delta <= avg / 100, EImbalancedLiquidity); // Max 1% imbalance
        
        // Add liquidity to reserves
        pool.asset_reserve.join(asset_in.into_balance());
        pool.stable_reserve.join(stable_in.into_balance());
        
        // Use minimum to be conservative
        math::min(from_a, from_s)
    };
    assert!(minted >= min_lp_out, ESlippageExceeded);

    pool.lp_supply = pool.lp_supply + minted;

    let lp = SpotLP<AssetType, StableType> { id: object::new(ctx), amount: minted };
    transfer::public_transfer(lp, ctx.sender());
}

/// Remove liquidity (entry)
public entry fun remove_liquidity<AssetType, StableType>(
    pool: &mut SpotAMM<AssetType, StableType>,
    lp: SpotLP<AssetType, StableType>,
    min_asset_out: u64,
    min_stable_out: u64,
    clock: &Clock,
    ctx: &mut TxContext,
) {
    // Update TWAP before liquidity change
    if (pool.initialized_at.is_some()) {
        update_twap(pool, clock);
    };
    let SpotLP { id, amount } = lp;
    id.delete();
    assert!(amount > 0, EZeroAmount);
    assert!(pool.lp_supply > MINIMUM_LIQUIDITY, EInsufficientLiquidity);

    let a = math::mul_div_to_64(amount, pool.asset_reserve.value(), pool.lp_supply);
    let s = math::mul_div_to_64(amount, pool.stable_reserve.value(), pool.lp_supply);
    assert!(a >= min_asset_out, ESlippageExceeded);
    assert!(s >= min_stable_out, ESlippageExceeded);

    pool.lp_supply = pool.lp_supply - amount;
    let a_out = coin::from_balance(pool.asset_reserve.split(a), ctx);
    let s_out = coin::from_balance(pool.stable_reserve.split(s), ctx);
    transfer::public_transfer(a_out, ctx.sender());
    transfer::public_transfer(s_out, ctx.sender());
}

/// Swap asset for stable (simple Uniswap V2 style)
public entry fun swap_asset_for_stable<AssetType, StableType>(
    pool: &mut SpotAMM<AssetType, StableType>,
    asset_in: Coin<AssetType>,
    min_stable_out: u64,
    clock: &Clock,
    ctx: &mut TxContext,
) {
    assert!(pool.initialized_at.is_some(), ENotInitialized);
    update_twap(pool, clock);
    
    let amount_in = asset_in.value();
    assert!(amount_in > 0, EZeroAmount);
    
    // Apply fee
    let amount_after_fee = amount_in - (math::mul_div_to_64(amount_in, pool.fee_bps, constants::max_fee_bps()));
    
    // Calculate output using constant product formula (x * y = k)
    let asset_reserve = pool.asset_reserve.value();
    let stable_reserve = pool.stable_reserve.value();
    let stable_out = math::mul_div_to_64(
        amount_after_fee,
        stable_reserve,
        asset_reserve + amount_after_fee
    );
    assert!(stable_out >= min_stable_out, ESlippageExceeded);
    assert!(stable_out < stable_reserve, EInsufficientLiquidity);
    
    // Update reserves
    pool.asset_reserve.join(asset_in.into_balance());
    let stable_coin = coin::from_balance(pool.stable_reserve.split(stable_out), ctx);
    transfer::public_transfer(stable_coin, ctx.sender());
}

/// Swap stable for asset (simple Uniswap V2 style)
public entry fun swap_stable_for_asset<AssetType, StableType>(
    pool: &mut SpotAMM<AssetType, StableType>,
    stable_in: Coin<StableType>,
    min_asset_out: u64,
    clock: &Clock,
    ctx: &mut TxContext,
) {
    assert!(pool.initialized_at.is_some(), ENotInitialized);
    update_twap(pool, clock);
    
    let amount_in = stable_in.value();
    assert!(amount_in > 0, EZeroAmount);
    
    // Apply fee
    let amount_after_fee = amount_in - (math::mul_div_to_64(amount_in, pool.fee_bps, constants::max_fee_bps()));
    
    // Calculate output using constant product formula (x * y = k)
    let asset_reserve = pool.asset_reserve.value();
    let stable_reserve = pool.stable_reserve.value();
    let asset_out = math::mul_div_to_64(
        amount_after_fee,
        asset_reserve,
        stable_reserve + amount_after_fee
    );
    assert!(asset_out >= min_asset_out, ESlippageExceeded);
    assert!(asset_out < asset_reserve, EInsufficientLiquidity);
    
    // Update reserves
    pool.stable_reserve.join(stable_in.into_balance());
    let asset_coin = coin::from_balance(pool.asset_reserve.split(asset_out), ctx);
    transfer::public_transfer(asset_coin, ctx.sender());
}

/// ---- Conversion hook used by coin_escrow during LP conversion (no balance movement here) ----
/// Returns the ID of the minted spot LP token (the LP is transferred to the sender).
public fun mint_lp_for_conversion<AssetType, StableType>(
    pool: &mut SpotAMM<AssetType, StableType>,
    _asset_amount: u64,
    _stable_amount: u64,
    lp_amount_to_mint: u64,
    _total_lp_supply_at_finalization: u64,
    _market_id: ID,
    ctx: &mut TxContext,
): ID {
    assert!(lp_amount_to_mint > 0, EZeroAmount);
    pool.lp_supply = pool.lp_supply + lp_amount_to_mint;
    let lp = SpotLP<AssetType, StableType> { id: object::new(ctx), amount: lp_amount_to_mint };
    let lp_id = object::id(&lp);
    transfer::public_transfer(lp, ctx.sender());
    lp_id
}

// === View Functions ===

public fun get_lp_amount<AssetType, StableType>(lp: &SpotLP<AssetType, StableType>): u64 {
    lp.amount
}

/// Get current spot price
public fun get_spot_price<AssetType, StableType>(pool: &SpotAMM<AssetType, StableType>): u128 {
    calculate_spot_price(
        pool.asset_reserve.value(),
        pool.stable_reserve.value()
    )
}

/// Get current TWAP with automatic update (requires mutable reference)
public fun get_twap_mut<AssetType, StableType>(
    pool: &mut SpotAMM<AssetType, StableType>,
    clock: &Clock,
): u128 {
    assert!(pool.initialized_at.is_some(), ENotInitialized);
    let init_time = *pool.initialized_at.borrow();
    let now = clock.timestamp_ms();
    
    // Require at least 3 days of trading before TWAP is valid
    assert!(now >= init_time + THREE_DAYS_MS, ETwapNotReady);
    
    // First, accumulate any pending price updates since last timestamp
    // This is crucial for cases where get_twap_mut is called without prior updates
    if (now > pool.last_timestamp) {
        let time_elapsed = now - pool.last_timestamp;
        let price_time = (pool.last_price as u256) * (time_elapsed as u256);
        pool.window_cumulative_price = pool.window_cumulative_price + price_time;
        pool.last_timestamp = now;
    };
    
    // IMPORTANT: Update the rolling window to current time
    // This ensures we always have the most recent 3-day average
    update_rolling_window(pool, now);
    
    // Calculate the exact 3-day TWAP
    let window_duration = now - pool.window_start_timestamp;
    
    if (window_duration >= THREE_DAYS_MS) {
        // We have a full 3-day window
        (pool.window_cumulative_price / (THREE_DAYS_MS as u256)) as u128
    } else {
        // Window is less than 3 days (shouldn't happen after init period)
        // Use actual duration for accuracy
        if (window_duration > 0) {
            (pool.window_cumulative_price / (window_duration as u256)) as u128
        } else {
            pool.last_price
        }
    }
}

/// Get current TWAP with live conditional integration
/// During proposals: adds winning conditional's TWAP for missing time
/// Normal operation: returns standard spot TWAP
public fun get_twap<AssetType, StableType>(
    pool: &SpotAMM<AssetType, StableType>,
    winning_conditional_twap: Option<u128>, // Pass Some(twap) if proposal is live, None otherwise
    clock: &Clock,
): u128 {
    assert!(pool.initialized_at.is_some(), ENotInitialized);
    let init_time = *pool.initialized_at.borrow();
    let now = clock.timestamp_ms();
    
    // Require at least 3 days of trading before TWAP is valid
    assert!(now >= init_time + THREE_DAYS_MS, ETwapNotReady);
    
    // If proposal is live and we have winning conditional TWAP, integrate it
    if (pool.last_proposal_usage.is_some() && winning_conditional_twap.is_some()) {
        let proposal_start = *pool.last_proposal_usage.borrow();
        let conditional_twap = *winning_conditional_twap.borrow();
        
        // Calculate spot TWAP up to proposal start
        let spot_duration = proposal_start - pool.window_start_timestamp;
        let spot_cumulative = pool.window_cumulative_price; // Frozen at proposal start
        
        // Calculate conditional contribution for time since proposal started
        let gap_duration = now - proposal_start;
        let gap_contribution = (conditional_twap as u256) * (gap_duration as u256);
        
        // Combine spot and conditional portions
        let total_cumulative = spot_cumulative + gap_contribution;
        let total_duration = now - pool.window_start_timestamp;
        
        // Handle rolling window
        let effective_duration = if (total_duration > THREE_DAYS_MS) {
            THREE_DAYS_MS
        } else {
            total_duration
        };
        
        if (effective_duration > 0) {
            (total_cumulative / (effective_duration as u256)) as u128
        } else {
            conditional_twap
        }
    } else {
        // No active proposal - return normal spot TWAP
        // Calculate what the cumulative would be if updated to now
        let time_since_last_update = now - pool.last_timestamp;
        let projected_cumulative = pool.window_cumulative_price + 
            ((pool.last_price as u256) * (time_since_last_update as u256));
        
        // Calculate window duration
        let window_age = now - pool.window_start_timestamp;
        let effective_duration = if (window_age > THREE_DAYS_MS) {
            THREE_DAYS_MS // Cap at 3 days
        } else {
            window_age
        };
        
        if (effective_duration > 0) {
            (projected_cumulative / (effective_duration as u256)) as u128
        } else {
            pool.last_price
        }
    }
}

/// Get TWAP for conditional AMM initialization
/// This is used when transitioning from spot trading to proposal trading
public fun get_twap_for_conditional_amm<AssetType, StableType>(
    pool: &SpotAMM<AssetType, StableType>,
    clock: &Clock,
): u128 {
    // If 3-day TWAP is ready, use it; otherwise use spot price
    if (pool.initialized_at.is_some()) {
        let init_time = *pool.initialized_at.borrow();
        let now = clock.timestamp_ms();
        
        if (now >= init_time + THREE_DAYS_MS) {
            // Calculate TWAP from rolling window
            let window_duration = now - pool.window_start_timestamp;
            if (window_duration > 0 && pool.window_cumulative_price > 0) {
                let effective_duration = if (window_duration > THREE_DAYS_MS) {
                    THREE_DAYS_MS
                } else {
                    window_duration
                };
                return (pool.window_cumulative_price / (effective_duration as u256)) as u128
            }
        }
    };
    
    // Fall back to spot price if TWAP not ready
    // This allows proposals before 3-day TWAP is available
    get_spot_price(pool)
}

/// Check if TWAP oracle is ready (has been running for at least 3 days)
public fun is_twap_ready<AssetType, StableType>(
    pool: &SpotAMM<AssetType, StableType>,
    clock: &Clock,
): bool {
    if (pool.initialized_at.is_none()) return false;
    
    let init_time = *pool.initialized_at.borrow();
    let now = clock.timestamp_ms();
    // Require 3 full days of price data for valid TWAP
    now >= init_time + THREE_DAYS_MS
}

/// Check if pool is locked for a proposal
public fun is_locked_for_proposal<AssetType, StableType>(
    pool: &SpotAMM<AssetType, StableType>
): bool {
    pool.last_proposal_usage.is_some()
}

/// Get ring buffer oracle reference (for spot_oracle_interface)
public fun get_ring_buffer_oracle<AssetType, StableType>(
    pool: &SpotAMM<AssetType, StableType>
): &RingBufferOracle {
    &pool.ring_buffer_oracle
}

/// Get longest possible TWAP for governance/minting
/// This uses the ring buffer oracle which has continuous history
public fun get_longest_twap_for_minting<AssetType, StableType>(
    pool: &SpotAMM<AssetType, StableType>,
    clock: &Clock,
): u128 {
    ring_buffer_oracle::get_longest_twap(&pool.ring_buffer_oracle, clock)
}

/// Get pool reserves
public fun get_reserves<AssetType, StableType>(
    pool: &SpotAMM<AssetType, StableType>
): (u64, u64) {
    (pool.asset_reserve.value(), pool.stable_reserve.value())
}

/// Get pool state including TWAP data
public fun get_pool_state<AssetType, StableType>(
    pool: &SpotAMM<AssetType, StableType>
): (u64, u64, u64, u128, u128, u64, Option<u64>) {
    (
        pool.asset_reserve.value(),
        pool.stable_reserve.value(),
        pool.lp_supply,
        pool.last_price,
        pool.last_window_twap,
        pool.window_start_timestamp,
        pool.initialized_at
    )
}

/// Update TWAP with a specific price (for transitions between spot and conditional)
public fun update_twap_with_price<AssetType, StableType>(
    pool: &mut SpotAMM<AssetType, StableType>,
    price: u128,
    clock: &Clock,
) {
    assert!(pool.initialized_at.is_some(), ENotInitialized);
    let now = clock.timestamp_ms();
    
    // Update the rolling window with the new price
    update_rolling_window(pool, now);
    
    // Set the new price
    pool.last_price = price;
    pool.last_timestamp = now;
    
    // Emit price update event
    event::emit(SpotPriceUpdate {
        pool_id: object::id(pool),
        price,
        timestamp: now,
        asset_reserve: pool.asset_reserve.value(),
        stable_reserve: pool.stable_reserve.value(),
    });
}

// === Conditional TWAP Integration ===

/// Write the winning conditional AMM's TWAP to fill the gap when liquidity was in proposals
/// This is called when a proposal that used DAO liquidity is finalized
public fun write_conditional_twap<AssetType, StableType>(
    pool: &mut SpotAMM<AssetType, StableType>,
    proposal_start: u64,   // When liquidity moved to conditional
    proposal_end: u64,     // When proposal finalized
    conditional_twap: u128, // TWAP from winning conditional AMM
    clock: &Clock,
) {
    // Calculate cumulative price for this period using the conditional TWAP
    let duration = proposal_end - proposal_start;
    let cumulative_price = (conditional_twap as u256) * (duration as u256);
    
    // Create a segment with the conditional AMM's TWAP data
    let segment = PriceSegment {
        start_timestamp: proposal_start,
        end_timestamp: proposal_end,
        cumulative_price,
        avg_price: conditional_twap,
    };
    
    // Add to historical segments
    pool.historical_segments.push_back(segment);
    
    // Clean up old segments (keep only last 3 days worth)
    let now = clock.timestamp_ms();
    let cutoff = if (now > THREE_DAYS_MS) {
        now - THREE_DAYS_MS
    } else {
        0
    };
    
    let mut i = 0;
    while (i < pool.historical_segments.length()) {
        let segment = pool.historical_segments.borrow(i);
        if (segment.end_timestamp < cutoff) {
            pool.historical_segments.swap_remove(i);
        } else {
            i = i + 1;
        };
    };
}

/// Mark when DAO liquidity moves to a proposal
/// This records the timestamp for later TWAP integration
public fun mark_liquidity_to_proposal<AssetType, StableType>(
    pool: &mut SpotAMM<AssetType, StableType>,
    clock: &Clock,
) {
    // Update TWAP one last time before liquidity moves to proposal
    if (pool.initialized_at.is_some()) {
        update_twap(pool, clock);
    };
    // Record when liquidity moved to proposal (for TWAP integration later)
    pool.last_proposal_usage = option::some(clock.timestamp_ms());
}

/// Merge winning conditional's ring buffer observations into spot after proposal finalizes
/// This ensures continuous price history for lending protocols
public fun merge_winning_conditional_oracle<AssetType, StableType>(
    pool: &mut SpotAMM<AssetType, StableType>,
    winning_conditional: &conditional_amm::LiquidityPool,
    proposal_start_ms: u64,
    proposal_end_ms: u64,
) {
    // Get the winning conditional's ring buffer oracle
    let conditional_oracle = conditional_amm::get_ring_buffer_oracle(winning_conditional);
    
    // Merge observations from the proposal period into spot's ring buffer
    ring_buffer_oracle::merge_observations(
        &mut pool.ring_buffer_oracle,
        conditional_oracle,
        proposal_start_ms,
        proposal_end_ms,
    );
}

/// Fill TWAP gap when proposal finalizes (hot path)
/// This is called when a proposal ends and we need to fill the gap in spot TWAP
/// with the winning conditional AMM's TWAP
public fun fill_twap_gap_from_proposal<AssetType, StableType>(
    pool: &mut SpotAMM<AssetType, StableType>,
    winning_conditional_twap: u128,
    winning_conditional_price: u128,
    clock: &Clock,
) {
    let now = clock.timestamp_ms();
    
    // Only fill gap if pool was locked for proposal
    if (pool.last_proposal_usage.is_some()) {
        let proposal_start = *pool.last_proposal_usage.borrow();
        let gap_duration = now - proposal_start;
        
        // Fill the gap in spot TWAP with winning conditional's TWAP
        if (gap_duration > 0) {
            let gap_contribution = (winning_conditional_twap as u256) * (gap_duration as u256);
            
            // Add to the spot's cumulative window
            pool.window_cumulative_price = pool.window_cumulative_price + gap_contribution;
            
            // Also write to historical segments for long-term tracking
            let segment = PriceSegment {
                start_timestamp: proposal_start,
                end_timestamp: now,
                cumulative_price: gap_contribution,
                avg_price: winning_conditional_twap,
            };
            pool.historical_segments.push_back(segment);
        };
        
        // Update timestamps and price to reflect filled gap
        pool.last_timestamp = now;
        pool.last_price = winning_conditional_price; // Resume from winning price
        pool.last_window_twap = winning_conditional_twap; // Update stable reference
        
        // Unlock the pool - clear proposal lock
        pool.last_proposal_usage = option::none();
    };
}

/// Get TWAP including conditional AMM prices when liquidity was in proposals
/// This provides continuous TWAP by using conditional prices during proposal periods
public fun get_twap_with_conditionals<AssetType, StableType>(
    pool: &SpotAMM<AssetType, StableType>,
    clock: &Clock,
): u128 {
    let now = clock.timestamp_ms();
    
    // If liquidity is currently in a proposal, we can't compute full TWAP yet
    // Return last known TWAP or price
    if (pool.last_proposal_usage.is_some()) {
        return pool.last_price
    };
    
    // Calculate the time range we need (last 3 days)
    let window_start = if (now > THREE_DAYS_MS) {
        now - THREE_DAYS_MS
    } else {
        0
    };
    
    let mut total_cumulative: u256 = 0;
    let mut total_duration: u64 = 0;
    
    // Process historical segments (conditional TWAP periods)
    let mut i = 0;
    let mut last_segment_end: u64 = 0;
    
    while (i < pool.historical_segments.length()) {
        let segment = pool.historical_segments.borrow(i);
        
        // Check if this segment overlaps with our 3-day window
        if (segment.end_timestamp > window_start && segment.start_timestamp < now) {
            let overlap_start = if (segment.start_timestamp > window_start) {
                segment.start_timestamp
            } else {
                window_start
            };
            
            let overlap_end = if (segment.end_timestamp < now) {
                segment.end_timestamp
            } else {
                now
            };
            
            let overlap_duration = overlap_end - overlap_start;
            
            // Add conditional TWAP contribution
            total_cumulative = total_cumulative + ((segment.avg_price as u256) * (overlap_duration as u256));
            total_duration = total_duration + overlap_duration;
            
            // Track the end of last segment
            if (segment.end_timestamp > last_segment_end) {
                last_segment_end = segment.end_timestamp;
            };
        };
        i = i + 1;
    };
    
    // Add spot TWAP for periods after the last conditional segment
    if (now > last_segment_end) {
        let spot_start = if (last_segment_end > window_start) {
            last_segment_end
        } else {
            if (pool.window_start_timestamp > window_start) {
                pool.window_start_timestamp
            } else {
                window_start
            }
        };
        
        let spot_duration = now - spot_start;
        if (spot_duration > 0 && pool.window_cumulative_price > 0) {
            // Add current spot window contribution
            let time_since_update = now - pool.last_timestamp;
            let projected_cumulative = pool.window_cumulative_price + 
                ((pool.last_price as u256) * (time_since_update as u256));
            
            // Scale to the actual spot duration we're using
            let spot_contribution = if (pool.window_start_timestamp == spot_start) {
                projected_cumulative
            } else {
                // Approximate by using average price
                let avg_spot_price = if ((now - pool.window_start_timestamp) > 0) {
                    (projected_cumulative / ((now - pool.window_start_timestamp) as u256)) as u128
                } else {
                    pool.last_price
                };
                (avg_spot_price as u256) * (spot_duration as u256)
            };
            
            total_cumulative = total_cumulative + spot_contribution;
            total_duration = total_duration + spot_duration;
        };
    };
    
    // Calculate final TWAP
    if (total_duration > 0) {
        (total_cumulative / (total_duration as u256)) as u128
    } else {
        pool.last_price
    }
}
/// ============================================================================
/// SPOT ORACLE INTERFACE - UNIFIED ACCESS POINT FOR ALL PRICE QUERIES
/// ============================================================================
/// 
/// PURPOSE: Single interface that abstracts away futarchy complexity
/// 
/// USED BY:
/// - Lending protocols that need continuous prices
/// - Governance actions that need long-term TWAPs
/// - Any external protocol integrating with the DAO token
/// 
/// KEY FEATURES:
/// - Automatically switches between spot and conditional oracles
/// - Hides proposal state from external consumers
/// - Provides both short (lending) and long (governance) windows
/// - Never returns empty/null - always has a price
/// 
/// WHY IT EXISTS:
/// External protocols shouldn't need to understand futarchy mechanics.
/// This interface makes our complex oracle system look like a standard
/// Uniswap oracle to the outside world. Lending protocols can integrate
/// without knowing about proposals, conditional AMMs, or quantum liquidity.
/// 
/// HOW IT WORKS:
/// - Normal times: Reads from spot's ring_buffer_oracle
/// - During proposals: Reads from winning conditional's ring_buffer_oracle
/// - Seamless transition with no gaps in price feed
/// 
/// ============================================================================

module futarchy_markets::spot_oracle_interface;

use sui::clock::Clock;
use futarchy_markets::ring_buffer_oracle::{Self, RingBufferOracle};
use futarchy_markets::spot_amm::SpotAMM;
use futarchy_markets::conditional_amm::LiquidityPool;
use std::vector;

// ============================================================================
// Constants
// ============================================================================

const LENDING_WINDOW_SECONDS: u64 = 1800; // 30 minutes standard
const GOVERNANCE_MAX_WINDOW: u64 = 777600; // 9 days maximum

// Errors
const ENoOracles: u64 = 1;
const ESpotLocked: u64 = 2;

// ============================================================================
// Public Functions for Lending Protocols
// ============================================================================

/// Get TWAP for lending protocols (continuous, 30-minute window)
/// This ALWAYS returns a value, even during proposals
/// During proposals: reads from highest conditional (but doesn't store)
/// After finalization: reads from spot (which has merged winning data)
public fun get_lending_twap<AssetType, StableType>(
    spot_pool: &SpotAMM<AssetType, StableType>,
    conditional_pools: &vector<LiquidityPool>,
    clock: &Clock,
): u128 {
    // Check if spot is locked for proposal
    if (spot_pool.is_locked_for_proposal()) {
        // READ from highest priced conditional (no storage in spot)
        // This is temporary - winner can change until finalization
        get_highest_conditional_twap(conditional_pools, LENDING_WINDOW_SECONDS, clock)
    } else {
        // Get TWAP from spot's ring buffer (includes merged history)
        ring_buffer_oracle::get_lending_twap(spot_pool.get_ring_buffer_oracle(), clock)
    }
}

/// Get custom window TWAP (for protocols that need different windows)
public fun get_twap_custom_window<AssetType, StableType>(
    spot_pool: &SpotAMM<AssetType, StableType>,
    conditional_pools: &vector<LiquidityPool>,
    seconds: u64,
    clock: &Clock,
): u128 {
    if (spot_pool.is_locked_for_proposal()) {
        get_highest_conditional_twap(conditional_pools, seconds, clock)
    } else {
        ring_buffer_oracle::get_twap(spot_pool.get_ring_buffer_oracle(), seconds, clock)
    }
}

/// Get instantaneous price (1 second TWAP)
public fun get_spot_price<AssetType, StableType>(
    spot_pool: &SpotAMM<AssetType, StableType>,
    conditional_pools: &vector<LiquidityPool>,
    clock: &Clock,
): u128 {
    if (spot_pool.is_locked_for_proposal()) {
        get_highest_conditional_price(conditional_pools)
    } else {
        ring_buffer_oracle::get_latest_price(spot_pool.get_ring_buffer_oracle())
    }
}

// ============================================================================
// Public Functions for Governance/Minting
// ============================================================================

/// Get longest possible TWAP for governance decisions and token minting
/// Uses base fair value from spot AMM (includes historical stitching)
public fun get_governance_twap<AssetType, StableType>(
    spot_pool: &SpotAMM<AssetType, StableType>,
    conditional_pools: &vector<LiquidityPool>,
    clock: &Clock,
): u128 {
    // For governance, we want the base fair value TWAP
    // This includes historical segments from past proposals
    if (spot_pool.is_locked_for_proposal()) {
        // During proposal, add conditional contribution
        let winning_conditional = get_highest_conditional_twap(
            conditional_pools,
            GOVERNANCE_MAX_WINDOW,
            clock
        );
        // This would integrate with spot's base fair value calculation
        spot_pool.get_twap(option::some(winning_conditional), clock)
    } else {
        // Use spot's longest TWAP
        ring_buffer_oracle::get_longest_twap(spot_pool.get_ring_buffer_oracle(), clock)
    }
}

// ============================================================================
// Helper Functions
// ============================================================================

/// Get highest TWAP from conditional pools
fun get_highest_conditional_twap(
    pools: &vector<LiquidityPool>,
    seconds: u64,
    clock: &Clock,
): u128 {
    assert!(!pools.is_empty(), ENoOracles);
    
    let mut highest_twap = 0u128;
    let mut i = 0;
    
    while (i < pools.length()) {
        let pool = pools.borrow(i);
        let twap = ring_buffer_oracle::get_twap(pool.get_ring_buffer_oracle(), seconds, clock);
        if (twap > highest_twap) {
            highest_twap = twap;
        };
        i = i + 1;
    };
    
    highest_twap
}

/// Get highest current price from conditional pools
fun get_highest_conditional_price(pools: &vector<LiquidityPool>): u128 {
    assert!(!pools.is_empty(), ENoOracles);
    
    let mut highest_price = 0u128;
    let mut i = 0;
    
    while (i < pools.length()) {
        let pool = pools.borrow(i);
        let price = ring_buffer_oracle::get_latest_price(pool.get_ring_buffer_oracle());
        if (price > highest_price) {
            highest_price = price;
        };
        i = i + 1;
    };
    
    highest_price
}

/// Check if TWAP is available for a given window
public fun is_twap_available<AssetType, StableType>(
    spot_pool: &SpotAMM<AssetType, StableType>,
    conditional_pools: &vector<LiquidityPool>,
    seconds: u64,
    clock: &Clock,
): bool {
    if (spot_pool.is_locked_for_proposal()) {
        // Check conditionals
        if (conditional_pools.is_empty()) {
            return false
        };
        let pool = conditional_pools.borrow(0);
        ring_buffer_oracle::has_sufficient_history(pool.get_ring_buffer_oracle(), seconds, clock)
    } else {
        // Check spot
        ring_buffer_oracle::has_sufficient_history(spot_pool.get_ring_buffer_oracle(), seconds, clock)
    }
}

// ============================================================================
// Integration Examples for Lending Protocols
// ============================================================================

/// Example: How a lending protocol would use this
/// 
/// ```move
/// // In lending protocol
/// let price = spot_oracle_interface::get_lending_twap(
///     &spot_pool,
///     &conditional_pools,
///     clock
/// );
/// 
/// // Use price for collateral valuation, liquidations, etc.
/// ```
/// 
/// The lending protocol doesn't need to know about:
/// - Futarchy proposals
/// - Conditional AMMs
/// - Quantum liquidity
/// - Lock states
/// 
/// It just gets a continuous price feed that never stops./// Simplified spot liquidity pool for use with Account<FutarchyConfig>
/// This module provides a basic AMM pool that doesn't depend on the DAO structure
module futarchy_markets::account_spot_pool;

// === Imports ===
use std::option::{Self, Option};
use sui::{
    balance::{Self, Balance},
    coin::{Self, Coin},
    object::{Self, UID},
    transfer,
    event,
};
use futarchy_one_shot_utils::{
    math,
};

// === Errors ===
const EInsufficientLiquidity: u64 = 1;
const EZeroAmount: u64 = 2;
const ESlippageExceeded: u64 = 3;
const EInvalidFee: u64 = 4;
const EPoolNotInitialized: u64 = 5;

// === Constants ===
const MAX_FEE_BPS: u64 = 10000; // 100%
const MINIMUM_LIQUIDITY: u64 = 1000;

// === Structs ===

/// A simple spot liquidity pool for trading between two assets
public struct AccountSpotPool<phantom AssetType, phantom StableType> has key, store {
    id: UID,
    /// Asset token reserves
    asset_reserve: Balance<AssetType>,
    /// Stable token reserves
    stable_reserve: Balance<StableType>,
    /// Total LP token supply
    lp_supply: u64,
    /// Trading fee in basis points
    fee_bps: u64,
    /// Minimum liquidity locked (for first LP)
    minimum_liquidity: u64,
}

/// LP token for the pool
public struct LPToken<phantom AssetType, phantom StableType> has key, store {
    id: UID,
    /// Amount of LP tokens
    amount: u64,
}

/// Result of a swap operation
public struct SwapResult<phantom T> has drop {
    /// Output amount
    amount_out: u64,
    /// Fee amount
    fee_amount: u64,
}

// === Events ===

public struct PoolCreated<phantom AssetType, phantom StableType> has copy, drop {
    pool_id: ID,
    fee_bps: u64,
}

public struct LiquidityAdded<phantom AssetType, phantom StableType> has copy, drop {
    pool_id: ID,
    asset_amount: u64,
    stable_amount: u64,
    lp_minted: u64,
}

public struct LiquidityRemoved<phantom AssetType, phantom StableType> has copy, drop {
    pool_id: ID,
    asset_amount: u64,
    stable_amount: u64,
    lp_burned: u64,
}

public struct Swap<phantom AssetType, phantom StableType> has copy, drop {
    pool_id: ID,
    is_asset_to_stable: bool,
    amount_in: u64,
    amount_out: u64,
    fee: u64,
}

// === Public Functions ===

/// Create a new spot pool
public fun new<AssetType, StableType>(
    fee_bps: u64,
    ctx: &mut TxContext,
): AccountSpotPool<AssetType, StableType> {
    assert!(fee_bps <= MAX_FEE_BPS, EInvalidFee);
    
    let id = object::new(ctx);
    let pool_id = object::uid_to_inner(&id);
    
    event::emit(PoolCreated<AssetType, StableType> {
        pool_id,
        fee_bps,
    });
    
    AccountSpotPool {
        id,
        asset_reserve: balance::zero<AssetType>(),
        stable_reserve: balance::zero<StableType>(),
        lp_supply: 0,
        fee_bps,
        minimum_liquidity: MINIMUM_LIQUIDITY,
    }
}

/// Share the pool object
#[allow(lint(custom_state_change, share_owned))]
public fun share<AssetType, StableType>(pool: AccountSpotPool<AssetType, StableType>) {
    transfer::share_object(pool);
}

/// Add liquidity to the pool
public entry fun add_liquidity<AssetType, StableType>(
    pool: &mut AccountSpotPool<AssetType, StableType>,
    asset_coin: Coin<AssetType>,
    stable_coin: Coin<StableType>,
    min_lp_out: u64,
    ctx: &mut TxContext,
) {
    let asset_amount = asset_coin.value();
    let stable_amount = stable_coin.value();
    
    assert!(asset_amount > 0 && stable_amount > 0, EZeroAmount);
    
    let lp_minted = if (pool.lp_supply == 0) {
        // First liquidity provider
        // Calculate initial LP as sqrt(asset * stable)
        let product = (asset_amount as u128) * (stable_amount as u128);
        let initial_lp = math::sqrt_u128(product) as u64;
        assert!(initial_lp > pool.minimum_liquidity, EInsufficientLiquidity);
        
        // Lock minimum liquidity
        pool.lp_supply = pool.minimum_liquidity;
        initial_lp - pool.minimum_liquidity
    } else {
        // Calculate proportional LP tokens
        // Calculate LP tokens based on ratio of added liquidity to existing reserves
        let asset_ratio = math::mul_div_to_64(asset_amount, pool.lp_supply, pool.asset_reserve.value());
        let stable_ratio = math::mul_div_to_64(stable_amount, pool.lp_supply, pool.stable_reserve.value());
        
        // Use the minimum ratio to maintain pool ratio
        math::min(asset_ratio, stable_ratio)
    };
    
    assert!(lp_minted >= min_lp_out, ESlippageExceeded);
    
    // Update reserves
    pool.asset_reserve.join(asset_coin.into_balance());
    pool.stable_reserve.join(stable_coin.into_balance());
    pool.lp_supply = pool.lp_supply + lp_minted;
    
    // Mint LP tokens
    let lp_token = LPToken<AssetType, StableType> {
        id: object::new(ctx),
        amount: lp_minted,
    };
    
    transfer::public_transfer(lp_token, ctx.sender());
    
    event::emit(LiquidityAdded<AssetType, StableType> {
        pool_id: object::id(pool),
        asset_amount,
        stable_amount,
        lp_minted,
    });
}

/// Add liquidity and return LP token (for use in actions)
public fun add_liquidity_and_return<AssetType, StableType>(
    pool: &mut AccountSpotPool<AssetType, StableType>,
    asset_coin: Coin<AssetType>,
    stable_coin: Coin<StableType>,
    min_lp_out: u64,
    ctx: &mut TxContext,
): LPToken<AssetType, StableType> {
    let asset_amount = asset_coin.value();
    let stable_amount = stable_coin.value();
    
    assert!(asset_amount > 0 && stable_amount > 0, EZeroAmount);
    
    let lp_minted = if (pool.lp_supply == 0) {
        // First liquidity provider
        let product = (asset_amount as u128) * (stable_amount as u128);
        let initial_lp = math::sqrt_u128(product) as u64;
        assert!(initial_lp > pool.minimum_liquidity, EInsufficientLiquidity);
        
        // Lock minimum liquidity
        pool.lp_supply = pool.minimum_liquidity;
        initial_lp - pool.minimum_liquidity
    } else {
        // Calculate proportional LP tokens
        let asset_ratio = math::mul_div_to_64(asset_amount, pool.lp_supply, pool.asset_reserve.value());
        let stable_ratio = math::mul_div_to_64(stable_amount, pool.lp_supply, pool.stable_reserve.value());
        math::min(asset_ratio, stable_ratio)
    };
    
    assert!(lp_minted >= min_lp_out, ESlippageExceeded);
    
    // Update reserves
    pool.asset_reserve.join(asset_coin.into_balance());
    pool.stable_reserve.join(stable_coin.into_balance());
    pool.lp_supply = pool.lp_supply + lp_minted;
    
    // Create and return LP token
    let lp_token = LPToken<AssetType, StableType> {
        id: object::new(ctx),
        amount: lp_minted,
    };
    
    event::emit(LiquidityAdded<AssetType, StableType> {
        pool_id: object::id(pool),
        asset_amount,
        stable_amount,
        lp_minted,
    });
    
    lp_token
}

/// Remove liquidity and return coins (for use in actions)
public fun remove_liquidity_and_return<AssetType, StableType>(
    pool: &mut AccountSpotPool<AssetType, StableType>,
    lp_token: LPToken<AssetType, StableType>,
    min_asset_out: u64,
    min_stable_out: u64,
    ctx: &mut TxContext,
): (Coin<AssetType>, Coin<StableType>) {
    let LPToken { id, amount: lp_amount } = lp_token;
    id.delete();
    
    assert!(lp_amount > 0, EZeroAmount);
    assert!(pool.lp_supply > pool.minimum_liquidity, EInsufficientLiquidity);
    
    // Calculate proportional share
    let asset_amount = math::mul_div_to_64(lp_amount, pool.asset_reserve.value(), pool.lp_supply);
    let stable_amount = math::mul_div_to_64(lp_amount, pool.stable_reserve.value(), pool.lp_supply);
    
    assert!(asset_amount >= min_asset_out, ESlippageExceeded);
    assert!(stable_amount >= min_stable_out, ESlippageExceeded);
    
    // Update state
    pool.lp_supply = pool.lp_supply - lp_amount;
    
    // Create coins
    let asset_out = coin::from_balance(
        pool.asset_reserve.split(asset_amount),
        ctx
    );
    let stable_out = coin::from_balance(
        pool.stable_reserve.split(stable_amount),
        ctx
    );
    
    event::emit(LiquidityRemoved<AssetType, StableType> {
        pool_id: object::id(pool),
        asset_amount,
        stable_amount,
        lp_burned: lp_amount,
    });
    
    (asset_out, stable_out)
}

/// Remove liquidity from the pool
public entry fun remove_liquidity<AssetType, StableType>(
    pool: &mut AccountSpotPool<AssetType, StableType>,
    lp_token: LPToken<AssetType, StableType>,
    min_asset_out: u64,
    min_stable_out: u64,
    ctx: &mut TxContext,
) {
    let LPToken { id, amount: lp_amount } = lp_token;
    id.delete();
    
    assert!(lp_amount > 0, EZeroAmount);
    assert!(pool.lp_supply > pool.minimum_liquidity, EInsufficientLiquidity);
    
    // Calculate proportional share
    // Calculate proportional assets to return
    let asset_amount = math::mul_div_to_64(lp_amount, pool.asset_reserve.value(), pool.lp_supply);
    let stable_amount = math::mul_div_to_64(lp_amount, pool.stable_reserve.value(), pool.lp_supply);
    
    assert!(asset_amount >= min_asset_out, ESlippageExceeded);
    assert!(stable_amount >= min_stable_out, ESlippageExceeded);
    
    // Update state
    pool.lp_supply = pool.lp_supply - lp_amount;
    
    // Transfer tokens
    let asset_out = coin::from_balance(
        pool.asset_reserve.split(asset_amount),
        ctx
    );
    let stable_out = coin::from_balance(
        pool.stable_reserve.split(stable_amount),
        ctx
    );
    
    transfer::public_transfer(asset_out, ctx.sender());
    transfer::public_transfer(stable_out, ctx.sender());
    
    event::emit(LiquidityRemoved<AssetType, StableType> {
        pool_id: object::id(pool),
        asset_amount,
        stable_amount,
        lp_burned: lp_amount,
    });
}

/// Swap asset for stable
public entry fun swap_asset_to_stable<AssetType, StableType>(
    pool: &mut AccountSpotPool<AssetType, StableType>,
    asset_in: Coin<AssetType>,
    min_stable_out: u64,
    ctx: &mut TxContext,
) {
    let amount_in = asset_in.value();
    assert!(amount_in > 0, EZeroAmount);
    
    let (amount_out, fee) = calculate_output(
        amount_in,
        pool.asset_reserve.value(),
        pool.stable_reserve.value(),
        pool.fee_bps
    );
    
    assert!(amount_out >= min_stable_out, ESlippageExceeded);
    assert!(amount_out <= pool.stable_reserve.value(), EInsufficientLiquidity);
    
    // Update reserves
    pool.asset_reserve.join(asset_in.into_balance());
    
    // Send output
    let stable_out = coin::from_balance(
        pool.stable_reserve.split(amount_out),
        ctx
    );
    transfer::public_transfer(stable_out, ctx.sender());
    
    event::emit(Swap<AssetType, StableType> {
        pool_id: object::id(pool),
        is_asset_to_stable: true,
        amount_in,
        amount_out,
        fee,
    });
}

/// Swap stable for asset
public entry fun swap_stable_to_asset<AssetType, StableType>(
    pool: &mut AccountSpotPool<AssetType, StableType>,
    stable_in: Coin<StableType>,
    min_asset_out: u64,
    ctx: &mut TxContext,
) {
    let amount_in = stable_in.value();
    assert!(amount_in > 0, EZeroAmount);
    
    let (amount_out, fee) = calculate_output(
        amount_in,
        pool.stable_reserve.value(),
        pool.asset_reserve.value(),
        pool.fee_bps
    );
    
    assert!(amount_out >= min_asset_out, ESlippageExceeded);
    assert!(amount_out <= pool.asset_reserve.value(), EInsufficientLiquidity);
    
    // Update reserves
    pool.stable_reserve.join(stable_in.into_balance());
    
    // Send output
    let asset_out = coin::from_balance(
        pool.asset_reserve.split(amount_out),
        ctx
    );
    transfer::public_transfer(asset_out, ctx.sender());
    
    event::emit(Swap<AssetType, StableType> {
        pool_id: object::id(pool),
        is_asset_to_stable: false,
        amount_in,
        amount_out,
        fee,
    });
}

// === View Functions ===

/// Get pool reserves
public fun get_reserves<AssetType, StableType>(
    pool: &AccountSpotPool<AssetType, StableType>
): (u64, u64) {
    (pool.asset_reserve.value(), pool.stable_reserve.value())
}

/// Get spot price (asset per stable)
public fun get_spot_price<AssetType, StableType>(
    pool: &AccountSpotPool<AssetType, StableType>
): u128 {
    if (pool.asset_reserve.value() == 0) {
        0
    } else {
        // Price = stable_reserve / asset_reserve * 10^9 for precision
        ((pool.stable_reserve.value() as u128) * 1_000_000_000) / (pool.asset_reserve.value() as u128)
    }
}

/// Get pool ID
public fun pool_id<AssetType, StableType>(
    pool: &AccountSpotPool<AssetType, StableType>
): ID {
    object::id(pool)
}

/// Get LP supply
public fun lp_supply<AssetType, StableType>(
    pool: &AccountSpotPool<AssetType, StableType>
): u64 {
    pool.lp_supply
}

/// Get fee in basis points
public fun fee_bps<AssetType, StableType>(
    pool: &AccountSpotPool<AssetType, StableType>
): u64 {
    pool.fee_bps
}

// === Internal Functions ===

/// Calculate output amount for a swap
fun calculate_output(
    amount_in: u64,
    reserve_in: u64,
    reserve_out: u64,
    fee_bps: u64,
): (u64, u64) {
    // Calculate fee
    // Calculate fee amount
    let fee_amount = math::mul_div_to_64(amount_in, fee_bps, 10000);
    let amount_in_after_fee = amount_in - fee_amount;
    
    // Calculate output using constant product formula
    // amount_out = (amount_in_after_fee * reserve_out) / (reserve_in + amount_in_after_fee)
    // Use mul_div_to_64 to calculate output amount
    let amount_out = math::mul_div_to_64(amount_in_after_fee, reserve_out, reserve_in + amount_in_after_fee);
    
    (amount_out, fee_amount)
}

// === LP Token Functions ===

/// Get LP token amount
public fun lp_token_amount<AssetType, StableType>(
    token: &LPToken<AssetType, StableType>
): u64 {
    token.amount
}

/// Merge two LP tokens and return the result
public fun merge_lp_tokens<AssetType, StableType>(
    token1: LPToken<AssetType, StableType>,
    token2: LPToken<AssetType, StableType>,
    ctx: &mut TxContext,
): LPToken<AssetType, StableType> {
    let LPToken { id: id1, amount: amount1 } = token1;
    let LPToken { id: id2, amount: amount2 } = token2;
    
    id1.delete();
    id2.delete();
    
    LPToken<AssetType, StableType> {
        id: object::new(ctx),
        amount: amount1 + amount2,
    }
}

/// Merge two LP tokens (entry function)
public entry fun merge_lp_tokens_entry<AssetType, StableType>(
    token1: LPToken<AssetType, StableType>,
    token2: LPToken<AssetType, StableType>,
    ctx: &mut TxContext,
) {
    let merged = merge_lp_tokens(token1, token2, ctx);
    transfer::public_transfer(merged, ctx.sender());
}

/// Split an LP token and return both parts
public fun split_lp_token<AssetType, StableType>(
    token: LPToken<AssetType, StableType>,
    split_amount: u64,
    ctx: &mut TxContext,
): (LPToken<AssetType, StableType>, LPToken<AssetType, StableType>) {
    let LPToken { id, amount } = token;
    id.delete();
    
    assert!(split_amount > 0 && split_amount < amount, EZeroAmount);
    
    let token1 = LPToken<AssetType, StableType> {
        id: object::new(ctx),
        amount: split_amount,
    };
    
    let token2 = LPToken<AssetType, StableType> {
        id: object::new(ctx),
        amount: amount - split_amount,
    };
    
    (token1, token2)
}

/// Split an LP token (entry function)
public entry fun split_lp_token_entry<AssetType, StableType>(
    token: LPToken<AssetType, StableType>,
    split_amount: u64,
    ctx: &mut TxContext,
) {
    let (token1, token2) = split_lp_token(token, split_amount, ctx);
    transfer::public_transfer(token1, ctx.sender());
    transfer::public_transfer(token2, ctx.sender());
}

// === LP Token Recovery Functions ===
// These functions allow DAOs to recover LP tokens that were sent to the account address

/// Get information about an LP token
public fun lp_token_info<AssetType, StableType>(
    token: &LPToken<AssetType, StableType>
): (ID, u64) {
    (object::id(token), token.amount)
}