// Copyright (c) Mysten Labs, Inc.
// SPDX-License-Identifier: Apache-2.0

/// Public-facing interface for the package.
module deepbook::pool;

use deepbook::{
    account::Account,
    balance_manager::{Self, BalanceManager, TradeProof, DeepBookReferral},
    big_vector::BigVector,
    book::{Self, Book},
    constants,
    deep_price::{Self, DeepPrice, OrderDeepPrice, emit_deep_price_added},
    ewma::{init_ewma_state, EWMAState},
    math,
    order::Order,
    order_info::{Self, OrderInfo},
    registry::{DeepbookAdminCap, Registry},
    state::{Self, State},
    vault::{Self, Vault, FlashLoan}
};
use std::type_name;
use sui::{
    balance::{Self, Balance},
    clock::Clock,
    coin::{Self, Coin},
    dynamic_field as df,
    event,
    vec_set::{Self, VecSet},
    versioned::{Self, Versioned}
};
use token::deep::{DEEP, ProtectedTreasury};

use fun df::add as UID.add;
use fun df::borrow as UID.borrow;
use fun df::borrow_mut as UID.borrow_mut;
use fun df::exists_ as UID.exists_;

// === Errors ===
const EInvalidFee: u64 = 1;
const ESameBaseAndQuote: u64 = 2;
const EInvalidTickSize: u64 = 3;
const EInvalidLotSize: u64 = 4;
const EInvalidMinSize: u64 = 5;
const EInvalidQuantityIn: u64 = 6;
const EIneligibleReferencePool: u64 = 7;
const EInvalidOrderBalanceManager: u64 = 9;
const EIneligibleTargetPool: u64 = 10;
const EPackageVersionDisabled: u64 = 11;
const EMinimumQuantityOutNotMet: u64 = 12;
const EInvalidStake: u64 = 13;
const EPoolNotRegistered: u64 = 14;
const EPoolCannotBeBothWhitelistedAndStable: u64 = 15;
const EInvalidReferralBPS: u64 = 16;

// === Structs ===
public struct Pool<phantom BaseAsset, phantom QuoteAsset> has key {
    id: UID,
    inner: Versioned,
}

public struct PoolInner<phantom BaseAsset, phantom QuoteAsset> has store {
    allowed_versions: VecSet<u64>,
    pool_id: ID,
    book: Book,
    state: State,
    vault: Vault<BaseAsset, QuoteAsset>,
    deep_price: DeepPrice,
    registered_pool: bool,
}

public struct PoolCreated<phantom BaseAsset, phantom QuoteAsset> has copy, drop, store {
    pool_id: ID,
    taker_fee: u64,
    maker_fee: u64,
    tick_size: u64,
    lot_size: u64,
    min_size: u64,
    whitelisted_pool: bool,
    treasury_address: address,
}

public struct BookParamsUpdated<phantom BaseAsset, phantom QuoteAsset> has copy, drop, store {
    pool_id: ID,
    tick_size: u64,
    lot_size: u64,
    min_size: u64,
    timestamp: u64,
}

public struct DeepBurned<phantom BaseAsset, phantom QuoteAsset> has copy, drop, store {
    pool_id: ID,
    deep_burned: u64,
}

public struct ReferralRewards<phantom BaseAsset, phantom QuoteAsset> has store {
    additional_bps: u64,
    base: Balance<BaseAsset>,
    quote: Balance<QuoteAsset>,
    deep: Balance<DEEP>,
}

public struct ReferralClaimedEvent<phantom BaseAsset, phantom QuoteAsset> has copy, drop, store {
    referral_id: ID,
    owner: address,
    base_amount: u64,
    quote_amount: u64,
    deep_amount: u64,
}

// === Public-Mutative Functions * POOL CREATION * ===
/// Create a new pool. The pool is registered in the registry.
/// Checks are performed to ensure the tick size, lot size,
/// and min size are valid.
/// The creation fee is transferred to the treasury address.
/// Returns the id of the pool created
public fun create_permissionless_pool<BaseAsset, QuoteAsset>(
    registry: &mut Registry,
    tick_size: u64,
    lot_size: u64,
    min_size: u64,
    creation_fee: Coin<DEEP>,
    ctx: &mut TxContext,
): ID {
    assert!(creation_fee.value() == constants::pool_creation_fee(), EInvalidFee);
    let base_type = type_name::with_defining_ids<BaseAsset>();
    let quote_type = type_name::with_defining_ids<QuoteAsset>();
    let whitelisted_pool = false;
    let stable_pool = registry.is_stablecoin(base_type) && registry.is_stablecoin(quote_type);

    create_pool<BaseAsset, QuoteAsset>(
        registry,
        tick_size,
        lot_size,
        min_size,
        creation_fee,
        whitelisted_pool,
        stable_pool,
        ctx,
    )
}

// === Public-Mutative Functions * EXCHANGE * ===
/// Place a limit order. Quantity is in base asset terms.
/// For current version pay_with_deep must be true, so the fee will be paid with
/// DEEP tokens.
public fun place_limit_order<BaseAsset, QuoteAsset>(
    self: &mut Pool<BaseAsset, QuoteAsset>,
    balance_manager: &mut BalanceManager,
    trade_proof: &TradeProof,
    client_order_id: u64,
    order_type: u8,
    self_matching_option: u8,
    price: u64,
    quantity: u64,
    is_bid: bool,
    pay_with_deep: bool,
    expire_timestamp: u64,
    clock: &Clock,
    ctx: &TxContext,
): OrderInfo {
    self.place_order_int(
        balance_manager,
        trade_proof,
        client_order_id,
        order_type,
        self_matching_option,
        price,
        quantity,
        is_bid,
        pay_with_deep,
        expire_timestamp,
        clock,
        false,
        ctx,
    )
}

/// Place a market order. Quantity is in base asset terms. Calls
/// place_limit_order with
/// a price of MAX_PRICE for bids and MIN_PRICE for asks. Any quantity not
/// filled is cancelled.
public fun place_market_order<BaseAsset, QuoteAsset>(
    self: &mut Pool<BaseAsset, QuoteAsset>,
    balance_manager: &mut BalanceManager,
    trade_proof: &TradeProof,
    client_order_id: u64,
    self_matching_option: u8,
    quantity: u64,
    is_bid: bool,
    pay_with_deep: bool,
    clock: &Clock,
    ctx: &TxContext,
): OrderInfo {
    self.place_order_int(
        balance_manager,
        trade_proof,
        client_order_id,
        constants::immediate_or_cancel(),
        self_matching_option,
        if (is_bid) constants::max_price() else constants::min_price(),
        quantity,
        is_bid,
        pay_with_deep,
        clock.timestamp_ms(),
        clock,
        true,
        ctx,
    )
}

/// Swap exact base quantity without needing a `balance_manager`.
/// DEEP quantity can be overestimated. Returns three `Coin` objects:
/// base, quote, and deep. Some base quantity may be left over, if the
/// input quantity is not divisible by lot size.
public fun swap_exact_base_for_quote<BaseAsset, QuoteAsset>(
    self: &mut Pool<BaseAsset, QuoteAsset>,
    base_in: Coin<BaseAsset>,
    deep_in: Coin<DEEP>,
    min_quote_out: u64,
    clock: &Clock,
    ctx: &mut TxContext,
): (Coin<BaseAsset>, Coin<QuoteAsset>, Coin<DEEP>) {
    let quote_in = coin::zero(ctx);

    self.swap_exact_quantity(
        base_in,
        quote_in,
        deep_in,
        min_quote_out,
        clock,
        ctx,
    )
}

/// Swap exact quote quantity without needing a `balance_manager`.
/// DEEP quantity can be overestimated. Returns three `Coin` objects:
/// base, quote, and deep. Some quote quantity may be left over if the
/// input quantity is not divisible by lot size.
public fun swap_exact_quote_for_base<BaseAsset, QuoteAsset>(
    self: &mut Pool<BaseAsset, QuoteAsset>,
    quote_in: Coin<QuoteAsset>,
    deep_in: Coin<DEEP>,
    min_base_out: u64,
    clock: &Clock,
    ctx: &mut TxContext,
): (Coin<BaseAsset>, Coin<QuoteAsset>, Coin<DEEP>) {
    let base_in = coin::zero(ctx);

    self.swap_exact_quantity(
        base_in,
        quote_in,
        deep_in,
        min_base_out,
        clock,
        ctx,
    )
}

/// Swap exact quantity without needing a balance_manager.
public fun swap_exact_quantity<BaseAsset, QuoteAsset>(
    self: &mut Pool<BaseAsset, QuoteAsset>,
    base_in: Coin<BaseAsset>,
    quote_in: Coin<QuoteAsset>,
    deep_in: Coin<DEEP>,
    min_out: u64,
    clock: &Clock,
    ctx: &mut TxContext,
): (Coin<BaseAsset>, Coin<QuoteAsset>, Coin<DEEP>) {
    let mut base_quantity = base_in.value();
    let quote_quantity = quote_in.value();
    let taker_fee = self.load_inner().state.governance().trade_params().taker_fee();
    let input_fee_rate = math::mul(
        taker_fee,
        constants::fee_penalty_multiplier(),
    );
    assert!((base_quantity > 0) != (quote_quantity > 0), EInvalidQuantityIn);

    let pay_with_deep = deep_in.value() > 0;
    let is_bid = quote_quantity > 0;
    if (is_bid) {
        (base_quantity, _, _) = if (pay_with_deep) {
            self.get_quantity_out(0, quote_quantity, clock)
        } else {
            self.get_quantity_out_input_fee(0, quote_quantity, clock)
        }
    } else {
        if (!pay_with_deep) {
            base_quantity =
                math::div(
                    base_quantity,
                    constants::float_scaling() + input_fee_rate,
                );
        }
    };
    base_quantity = base_quantity - base_quantity % self.load_inner().book.lot_size();
    if (base_quantity < self.load_inner().book.min_size()) {
        return (base_in, quote_in, deep_in)
    };

    let mut temp_balance_manager = balance_manager::new(ctx);
    let trade_proof = temp_balance_manager.generate_proof_as_owner(ctx);
    temp_balance_manager.deposit(base_in, ctx);
    temp_balance_manager.deposit(quote_in, ctx);
    temp_balance_manager.deposit(deep_in, ctx);

    self.place_market_order(
        &mut temp_balance_manager,
        &trade_proof,
        0,
        constants::self_matching_allowed(),
        base_quantity,
        is_bid,
        pay_with_deep,
        clock,
        ctx,
    );

    let base_out = temp_balance_manager.withdraw_all<BaseAsset>(ctx);
    let quote_out = temp_balance_manager.withdraw_all<QuoteAsset>(ctx);
    let deep_out = temp_balance_manager.withdraw_all<DEEP>(ctx);

    if (is_bid) {
        assert!(base_out.value() >= min_out, EMinimumQuantityOutNotMet);
    } else {
        assert!(quote_out.value() >= min_out, EMinimumQuantityOutNotMet);
    };

    temp_balance_manager.delete();

    (base_out, quote_out, deep_out)
}

/// Modifies an order given order_id and new_quantity.
/// New quantity must be less than the original quantity and more
/// than the filled quantity. Order must not have already expired.
public fun modify_order<BaseAsset, QuoteAsset>(
    self: &mut Pool<BaseAsset, QuoteAsset>,
    balance_manager: &mut BalanceManager,
    trade_proof: &TradeProof,
    order_id: u128,
    new_quantity: u64,
    clock: &Clock,
    ctx: &TxContext,
) {
    let previous_quantity = self.get_order(order_id).quantity();

    let self = self.load_inner_mut();
    let (cancel_quantity, order) = self
        .book
        .modify_order(order_id, new_quantity, clock.timestamp_ms());
    assert!(order.balance_manager_id() == balance_manager.id(), EInvalidOrderBalanceManager);
    let (settled, owed) = self
        .state
        .process_modify(
            balance_manager.id(),
            cancel_quantity,
            order,
            self.pool_id,
            ctx,
        );
    self.vault.settle_balance_manager(settled, owed, balance_manager, trade_proof);

    order.emit_order_modified(
        self.pool_id,
        previous_quantity,
        ctx.sender(),
        clock.timestamp_ms(),
    );
}

/// Cancel an order. The order must be owned by the balance_manager.
/// The order is removed from the book and the balance_manager's open orders.
/// The balance_manager's balance is updated with the order's remaining
/// quantity.
/// Order canceled event is emitted.
public fun cancel_order<BaseAsset, QuoteAsset>(
    self: &mut Pool<BaseAsset, QuoteAsset>,
    balance_manager: &mut BalanceManager,
    trade_proof: &TradeProof,
    order_id: u128,
    clock: &Clock,
    ctx: &TxContext,
) {
    let self = self.load_inner_mut();
    let mut order = self.book.cancel_order(order_id);
    assert!(order.balance_manager_id() == balance_manager.id(), EInvalidOrderBalanceManager);
    let (settled, owed) = self
        .state
        .process_cancel(&mut order, balance_manager.id(), self.pool_id, ctx);
    self.vault.settle_balance_manager(settled, owed, balance_manager, trade_proof);

    order.emit_order_canceled(
        self.pool_id,
        ctx.sender(),
        clock.timestamp_ms(),
    );
}

/// Cancel multiple orders within a vector. The orders must be owned by the
/// balance_manager.
/// The orders are removed from the book and the balance_manager's open orders.
/// Order canceled events are emitted.
/// If any order fails to cancel, no orders will be cancelled.
public fun cancel_orders<BaseAsset, QuoteAsset>(
    self: &mut Pool<BaseAsset, QuoteAsset>,
    balance_manager: &mut BalanceManager,
    trade_proof: &TradeProof,
    order_ids: vector<u128>,
    clock: &Clock,
    ctx: &TxContext,
) {
    let mut i = 0;
    let num_orders = order_ids.length();
    while (i < num_orders) {
        let order_id = order_ids[i];
        self.cancel_order(balance_manager, trade_proof, order_id, clock, ctx);
        i = i + 1;
    }
}

/// Cancel all open orders placed by the balance manager in the pool.
public fun cancel_all_orders<BaseAsset, QuoteAsset>(
    self: &mut Pool<BaseAsset, QuoteAsset>,
    balance_manager: &mut BalanceManager,
    trade_proof: &TradeProof,
    clock: &Clock,
    ctx: &TxContext,
) {
    let inner = self.load_inner_mut();
    let mut open_orders = vector[];
    if (inner.state.account_exists(balance_manager.id())) {
        open_orders = inner.state.account(balance_manager.id()).open_orders().into_keys();
    };

    let mut i = 0;
    let num_orders = open_orders.length();
    while (i < num_orders) {
        let order_id = open_orders[i];
        self.cancel_order(balance_manager, trade_proof, order_id, clock, ctx);
        i = i + 1;
    }
}

/// Withdraw settled amounts to the `balance_manager`.
public fun withdraw_settled_amounts<BaseAsset, QuoteAsset>(
    self: &mut Pool<BaseAsset, QuoteAsset>,
    balance_manager: &mut BalanceManager,
    trade_proof: &TradeProof,
) {
    let self = self.load_inner_mut();
    let (settled, owed) = self.state.withdraw_settled_amounts(balance_manager.id());
    self.vault.settle_balance_manager(settled, owed, balance_manager, trade_proof);
}

// === Public-Mutative Functions * GOVERNANCE * ===
/// Stake DEEP tokens to the pool. The balance_manager must have enough DEEP
/// tokens.
/// The balance_manager's data is updated with the staked amount.
public fun stake<BaseAsset, QuoteAsset>(
    self: &mut Pool<BaseAsset, QuoteAsset>,
    balance_manager: &mut BalanceManager,
    trade_proof: &TradeProof,
    amount: u64,
    ctx: &TxContext,
) {
    assert!(amount > 0, EInvalidStake);
    let self = self.load_inner_mut();
    let (settled, owed) = self.state.process_stake(self.pool_id, balance_manager.id(), amount, ctx);
    self.vault.settle_balance_manager(settled, owed, balance_manager, trade_proof);
}

/// Unstake DEEP tokens from the pool. The balance_manager must have enough
/// staked DEEP tokens.
/// The balance_manager's data is updated with the unstaked amount.
/// Balance is transferred to the balance_manager immediately.
public fun unstake<BaseAsset, QuoteAsset>(
    self: &mut Pool<BaseAsset, QuoteAsset>,
    balance_manager: &mut BalanceManager,
    trade_proof: &TradeProof,
    ctx: &TxContext,
) {
    let self = self.load_inner_mut();
    let (settled, owed) = self.state.process_unstake(self.pool_id, balance_manager.id(), ctx);
    self.vault.settle_balance_manager(settled, owed, balance_manager, trade_proof);
}

/// Submit a proposal to change the taker fee, maker fee, and stake required.
/// The balance_manager must have enough staked DEEP tokens to participate.
/// Each balance_manager can only submit one proposal per epoch.
/// If the maximum proposal is reached, the proposal with the lowest vote is
/// removed.
/// If the balance_manager has less voting power than the lowest voted proposal,
/// the proposal is not added.
public fun submit_proposal<BaseAsset, QuoteAsset>(
    self: &mut Pool<BaseAsset, QuoteAsset>,
    balance_manager: &mut BalanceManager,
    trade_proof: &TradeProof,
    taker_fee: u64,
    maker_fee: u64,
    stake_required: u64,
    ctx: &TxContext,
) {
    let self = self.load_inner_mut();
    balance_manager.validate_proof(trade_proof);
    self
        .state
        .process_proposal(
            self.pool_id,
            balance_manager.id(),
            taker_fee,
            maker_fee,
            stake_required,
            ctx,
        );
}

/// Vote on a proposal. The balance_manager must have enough staked DEEP tokens
/// to participate.
/// Full voting power of the balance_manager is used.
/// Voting for a new proposal will remove the vote from the previous proposal.
public fun vote<BaseAsset, QuoteAsset>(
    self: &mut Pool<BaseAsset, QuoteAsset>,
    balance_manager: &mut BalanceManager,
    trade_proof: &TradeProof,
    proposal_id: ID,
    ctx: &TxContext,
) {
    let self = self.load_inner_mut();
    balance_manager.validate_proof(trade_proof);
    self.state.process_vote(self.pool_id, balance_manager.id(), proposal_id, ctx);
}

/// Claim the rewards for the balance_manager. The balance_manager must have
/// rewards to claim.
/// The balance_manager's data is updated with the claimed rewards.
public fun claim_rebates<BaseAsset, QuoteAsset>(
    self: &mut Pool<BaseAsset, QuoteAsset>,
    balance_manager: &mut BalanceManager,
    trade_proof: &TradeProof,
    ctx: &TxContext,
) {
    let self = self.load_inner_mut();
    let (settled, owed) = self
        .state
        .process_claim_rebates<BaseAsset, QuoteAsset>(
            self.pool_id,
            balance_manager,
            ctx,
        );
    self.vault.settle_balance_manager(settled, owed, balance_manager, trade_proof);
}

// === Public-Mutative Functions * FLASHLOAN * ===
/// Borrow base assets from the Pool. A hot potato is returned,
/// forcing the borrower to return the assets within the same transaction.
public fun borrow_flashloan_base<BaseAsset, QuoteAsset>(
    self: &mut Pool<BaseAsset, QuoteAsset>,
    base_amount: u64,
    ctx: &mut TxContext,
): (Coin<BaseAsset>, FlashLoan) {
    let self = self.load_inner_mut();
    self.vault.borrow_flashloan_base(self.pool_id, base_amount, ctx)
}

/// Borrow quote assets from the Pool. A hot potato is returned,
/// forcing the borrower to return the assets within the same transaction.
public fun borrow_flashloan_quote<BaseAsset, QuoteAsset>(
    self: &mut Pool<BaseAsset, QuoteAsset>,
    quote_amount: u64,
    ctx: &mut TxContext,
): (Coin<QuoteAsset>, FlashLoan) {
    let self = self.load_inner_mut();
    self.vault.borrow_flashloan_quote(self.pool_id, quote_amount, ctx)
}

/// Return the flashloaned base assets to the Pool.
/// FlashLoan object will only be unwrapped if the assets are returned,
/// otherwise the transaction will fail.
public fun return_flashloan_base<BaseAsset, QuoteAsset>(
    self: &mut Pool<BaseAsset, QuoteAsset>,
    coin: Coin<BaseAsset>,
    flash_loan: FlashLoan,
) {
    let self = self.load_inner_mut();
    self.vault.return_flashloan_base(self.pool_id, coin, flash_loan);
}

/// Return the flashloaned quote assets to the Pool.
/// FlashLoan object will only be unwrapped if the assets are returned,
/// otherwise the transaction will fail.
public fun return_flashloan_quote<BaseAsset, QuoteAsset>(
    self: &mut Pool<BaseAsset, QuoteAsset>,
    coin: Coin<QuoteAsset>,
    flash_loan: FlashLoan,
) {
    let self = self.load_inner_mut();
    self.vault.return_flashloan_quote(self.pool_id, coin, flash_loan);
}

// === Public-Mutative Functions * OPERATIONAL * ===

/// Adds a price point along with a timestamp to the deep price.
/// Allows for the calculation of deep price per base asset.
public fun add_deep_price_point<BaseAsset, QuoteAsset, ReferenceBaseAsset, ReferenceQuoteAsset>(
    target_pool: &mut Pool<BaseAsset, QuoteAsset>,
    reference_pool: &Pool<ReferenceBaseAsset, ReferenceQuoteAsset>,
    clock: &Clock,
) {
    assert!(
        reference_pool.whitelisted() && reference_pool.registered_pool(),
        EIneligibleReferencePool,
    );
    let reference_pool_price = reference_pool.mid_price(clock);

    let target_pool = target_pool.load_inner_mut();
    let reference_base_type = type_name::with_defining_ids<ReferenceBaseAsset>();
    let reference_quote_type = type_name::with_defining_ids<ReferenceQuoteAsset>();
    let target_base_type = type_name::with_defining_ids<BaseAsset>();
    let target_quote_type = type_name::with_defining_ids<QuoteAsset>();
    let deep_type = type_name::with_defining_ids<DEEP>();
    let timestamp = clock.timestamp_ms();

    assert!(
        reference_base_type == deep_type || reference_quote_type == deep_type,
        EIneligibleTargetPool,
    );

    let reference_deep_is_base = reference_base_type == deep_type;
    let reference_other_type = if (reference_deep_is_base) {
        reference_quote_type
    } else {
        reference_base_type
    };
    let reference_other_is_target_base = reference_other_type == target_base_type;
    let reference_other_is_target_quote = reference_other_type == target_quote_type;
    assert!(
        reference_other_is_target_base || reference_other_is_target_quote,
        EIneligibleTargetPool,
    );

    // For DEEP/USDC pool, reference_deep_is_base is true, DEEP per USDC is
    // reference_pool_price
    // For USDC/DEEP pool, reference_deep_is_base is false, USDC per DEEP is
    // reference_pool_price
    let deep_per_reference_other_price = if (reference_deep_is_base) {
        math::div(1_000_000_000, reference_pool_price)
    } else {
        reference_pool_price
    };

    // For USDC/SUI pool, reference_other_is_target_base is true, add price
    // point to deep per base
    // For SUI/USDC pool, reference_other_is_target_base is false, add price
    // point to deep per quote
    target_pool
        .deep_price
        .add_price_point(
            deep_per_reference_other_price,
            timestamp,
            reference_other_is_target_base,
        );
    emit_deep_price_added(
        deep_per_reference_other_price,
        timestamp,
        reference_other_is_target_base,
        reference_pool.load_inner().pool_id,
        target_pool.pool_id,
    );
}

/// Burns DEEP tokens from the pool. Amount to burn is within history
public fun burn_deep<BaseAsset, QuoteAsset>(
    self: &mut Pool<BaseAsset, QuoteAsset>,
    treasury_cap: &mut ProtectedTreasury,
    ctx: &mut TxContext,
): u64 {
    let self = self.load_inner_mut();
    let balance_to_burn = self.state.history_mut().reset_balance_to_burn();
    let deep_to_burn = self.vault.withdraw_deep_to_burn(balance_to_burn).into_coin(ctx);
    let amount_burned = deep_to_burn.value();
    token::deep::burn(treasury_cap, deep_to_burn);

    event::emit(DeepBurned<BaseAsset, QuoteAsset> {
        pool_id: self.pool_id,
        deep_burned: amount_burned,
    });

    amount_burned
}

/// Mint a DeepBookReferral and set the additional bps for the referral.
public fun mint_referral<BaseAsset, QuoteAsset>(
    self: &mut Pool<BaseAsset, QuoteAsset>,
    additional_bps: u64,
    ctx: &mut TxContext,
) {
    assert!(additional_bps <= constants::referral_max_bps(), EInvalidReferralBPS);
    assert!(additional_bps % constants::referral_multiple() == 0, EInvalidReferralBPS);
    let _ = self.load_inner();
    let referral_id = balance_manager::mint_referral(ctx);
    self
        .id
        .add(
            referral_id,
            ReferralRewards<BaseAsset, QuoteAsset> {
                additional_bps,
                base: balance::zero(),
                quote: balance::zero(),
                deep: balance::zero(),
            },
        );
}

/// Update the additional bps for the referral.
public fun update_referral_bps<BaseAsset, QuoteAsset>(
    self: &mut Pool<BaseAsset, QuoteAsset>,
    referral: &DeepBookReferral,
    additional_bps: u64,
) {
    assert!(additional_bps <= constants::referral_max_bps(), EInvalidReferralBPS);
    assert!(additional_bps % constants::referral_multiple() == 0, EInvalidReferralBPS);
    let _ = self.load_inner();
    let referral_id = object::id(referral);
    let referral_rewards: &mut ReferralRewards<BaseAsset, QuoteAsset> = self
        .id
        .borrow_mut(referral_id);
    referral_rewards.additional_bps = additional_bps;
}

/// Claim the rewards for the referral.
public fun claim_referral_rewards<BaseAsset, QuoteAsset>(
    self: &mut Pool<BaseAsset, QuoteAsset>,
    referral: &DeepBookReferral,
    ctx: &mut TxContext,
): (Coin<BaseAsset>, Coin<QuoteAsset>, Coin<DEEP>) {
    let _ = self.load_inner();
    referral.assert_referral_owner(ctx);
    let referral_id = object::id(referral);
    let referral_rewards: &mut ReferralRewards<BaseAsset, QuoteAsset> = self
        .id
        .borrow_mut(referral_id);
    let base = referral_rewards.base.withdraw_all().into_coin(ctx);
    let quote = referral_rewards.quote.withdraw_all().into_coin(ctx);
    let deep = referral_rewards.deep.withdraw_all().into_coin(ctx);

    event::emit(ReferralClaimedEvent<BaseAsset, QuoteAsset> {
        referral_id,
        owner: ctx.sender(),
        base_amount: base.value(),
        quote_amount: quote.value(),
        deep_amount: deep.value(),
    });

    (base, quote, deep)
}

// === Public-Mutative Functions * ADMIN * ===
/// Create a new pool. The pool is registered in the registry.
/// Checks are performed to ensure the tick size, lot size, and min size are
/// valid.
/// Returns the id of the pool created
public fun create_pool_admin<BaseAsset, QuoteAsset>(
    registry: &mut Registry,
    tick_size: u64,
    lot_size: u64,
    min_size: u64,
    whitelisted_pool: bool,
    stable_pool: bool,
    _cap: &DeepbookAdminCap,
    ctx: &mut TxContext,
): ID {
    let creation_fee = coin::zero(ctx);
    create_pool<BaseAsset, QuoteAsset>(
        registry,
        tick_size,
        lot_size,
        min_size,
        creation_fee,
        whitelisted_pool,
        stable_pool,
        ctx,
    )
}

/// Unregister a pool in case it needs to be redeployed.
public fun unregister_pool_admin<BaseAsset, QuoteAsset>(
    self: &mut Pool<BaseAsset, QuoteAsset>,
    registry: &mut Registry,
    _cap: &DeepbookAdminCap,
) {
    let self = self.load_inner_mut();
    assert!(self.registered_pool, EPoolNotRegistered);
    self.registered_pool = false;
    registry.unregister_pool<BaseAsset, QuoteAsset>();
}

/// Takes the registry and updates the allowed version within pool
/// Only admin can update the allowed versions
/// This function does not have version restrictions
public fun update_allowed_versions<BaseAsset, QuoteAsset>(
    self: &mut Pool<BaseAsset, QuoteAsset>,
    registry: &Registry,
    _cap: &DeepbookAdminCap,
) {
    let allowed_versions = registry.allowed_versions();
    let inner: &mut PoolInner<BaseAsset, QuoteAsset> = self.inner.load_value_mut();
    inner.allowed_versions = allowed_versions;
}

/// Takes the registry and updates the allowed version within pool
/// Permissionless equivalent of `update_allowed_versions`
/// This function does not have version restrictions
public fun update_pool_allowed_versions<BaseAsset, QuoteAsset>(
    self: &mut Pool<BaseAsset, QuoteAsset>,
    registry: &Registry,
) {
    let allowed_versions = registry.allowed_versions();
    let inner: &mut PoolInner<BaseAsset, QuoteAsset> = self.inner.load_value_mut();
    inner.allowed_versions = allowed_versions;
}

/// Adjust the tick size of the pool. Only admin can adjust the tick size.
public fun adjust_tick_size_admin<BaseAsset, QuoteAsset>(
    self: &mut Pool<BaseAsset, QuoteAsset>,
    new_tick_size: u64,
    _cap: &DeepbookAdminCap,
    clock: &Clock,
) {
    let self = self.load_inner_mut();
    assert!(new_tick_size > 0, EInvalidTickSize);
    assert!(math::is_power_of_ten(new_tick_size), EInvalidTickSize);
    self.book.set_tick_size(new_tick_size);

    event::emit(BookParamsUpdated<BaseAsset, QuoteAsset> {
        pool_id: self.pool_id,
        tick_size: self.book.tick_size(),
        lot_size: self.book.lot_size(),
        min_size: self.book.min_size(),
        timestamp: clock.timestamp_ms(),
    });
}

/// Adjust and lot size and min size of the pool. New lot size must be smaller
/// than current lot size. Only admin can adjust the min size and lot size.
public fun adjust_min_lot_size_admin<BaseAsset, QuoteAsset>(
    self: &mut Pool<BaseAsset, QuoteAsset>,
    new_lot_size: u64,
    new_min_size: u64,
    _cap: &DeepbookAdminCap,
    clock: &Clock,
) {
    let self = self.load_inner_mut();
    let lot_size = self.book.lot_size();
    assert!(new_lot_size > 0, EInvalidLotSize);
    assert!(lot_size % new_lot_size == 0, EInvalidLotSize);
    assert!(math::is_power_of_ten(new_lot_size), EInvalidLotSize);
    assert!(new_min_size > 0, EInvalidMinSize);
    assert!(new_min_size % new_lot_size == 0, EInvalidMinSize);
    assert!(math::is_power_of_ten(new_min_size), EInvalidMinSize);
    self.book.set_lot_size(new_lot_size);
    self.book.set_min_size(new_min_size);

    event::emit(BookParamsUpdated<BaseAsset, QuoteAsset> {
        pool_id: self.pool_id,
        tick_size: self.book.tick_size(),
        lot_size: self.book.lot_size(),
        min_size: self.book.min_size(),
        timestamp: clock.timestamp_ms(),
    });
}

/// Enable the EWMA state for the pool. This allows the pool to use
/// the EWMA state for volatility calculations and additional taker fees.
public fun enable_ewma_state<BaseAsset, QuoteAsset>(
    self: &mut Pool<BaseAsset, QuoteAsset>,
    _cap: &DeepbookAdminCap,
    enable: bool,
    clock: &Clock,
    ctx: &mut TxContext,
) {
    let _ = self.load_inner_mut();
    let ewma_state = self.update_ewma_state(clock, ctx);
    if (enable) {
        ewma_state.enable();
    } else {
        ewma_state.disable();
    }
}

/// Set the EWMA parameters for the pool.
/// Only admin can set the parameters.
public fun set_ewma_params<BaseAsset, QuoteAsset>(
    self: &mut Pool<BaseAsset, QuoteAsset>,
    _cap: &DeepbookAdminCap,
    alpha: u64,
    z_score_threshold: u64,
    additional_taker_fee: u64,
    clock: &Clock,
    ctx: &mut TxContext,
) {
    let _ = self.load_inner_mut();
    let ewma_state = self.update_ewma_state(clock, ctx);
    ewma_state.set_alpha(alpha);
    ewma_state.set_z_score_threshold(z_score_threshold);
    ewma_state.set_additional_taker_fee(additional_taker_fee);
}

// === Public-View Functions ===
/// Accessor to check if the pool is whitelisted.
public fun whitelisted<BaseAsset, QuoteAsset>(self: &Pool<BaseAsset, QuoteAsset>): bool {
    self.load_inner().state.governance().whitelisted()
}

/// Accessor to check if the pool is a stablecoin pool.
public fun stable_pool<BaseAsset, QuoteAsset>(self: &Pool<BaseAsset, QuoteAsset>): bool {
    self.load_inner().state.governance().stable()
}

public fun registered_pool<BaseAsset, QuoteAsset>(self: &Pool<BaseAsset, QuoteAsset>): bool {
    self.load_inner().registered_pool
}

/// Dry run to determine the quote quantity out for a given base quantity.
/// Uses DEEP token as fee.
public fun get_quote_quantity_out<BaseAsset, QuoteAsset>(
    self: &Pool<BaseAsset, QuoteAsset>,
    base_quantity: u64,
    clock: &Clock,
): (u64, u64, u64) {
    self.get_quantity_out(base_quantity, 0, clock)
}

/// Dry run to determine the base quantity out for a given quote quantity.
/// Uses DEEP token as fee.
public fun get_base_quantity_out<BaseAsset, QuoteAsset>(
    self: &Pool<BaseAsset, QuoteAsset>,
    quote_quantity: u64,
    clock: &Clock,
): (u64, u64, u64) {
    self.get_quantity_out(0, quote_quantity, clock)
}

/// Dry run to determine the quote quantity out for a given base quantity.
/// Uses input token as fee.
public fun get_quote_quantity_out_input_fee<BaseAsset, QuoteAsset>(
    self: &Pool<BaseAsset, QuoteAsset>,
    base_quantity: u64,
    clock: &Clock,
): (u64, u64, u64) {
    self.get_quantity_out_input_fee(base_quantity, 0, clock)
}

/// Dry run to determine the base quantity out for a given quote quantity.
/// Uses input token as fee.
public fun get_base_quantity_out_input_fee<BaseAsset, QuoteAsset>(
    self: &Pool<BaseAsset, QuoteAsset>,
    quote_quantity: u64,
    clock: &Clock,
): (u64, u64, u64) {
    self.get_quantity_out_input_fee(0, quote_quantity, clock)
}

/// Dry run to determine the quantity out for a given base or quote quantity.
/// Only one out of base or quote quantity should be non-zero.
/// Returns the (base_quantity_out, quote_quantity_out, deep_quantity_required)
/// Uses DEEP token as fee.
public fun get_quantity_out<BaseAsset, QuoteAsset>(
    self: &Pool<BaseAsset, QuoteAsset>,
    base_quantity: u64,
    quote_quantity: u64,
    clock: &Clock,
): (u64, u64, u64) {
    let whitelist = self.whitelisted();
    let self = self.load_inner();
    let params = self.state.governance().trade_params();
    let taker_fee = params.taker_fee();
    let deep_price = self.deep_price.get_order_deep_price(whitelist);
    self
        .book
        .get_quantity_out(
            base_quantity,
            quote_quantity,
            taker_fee,
            deep_price,
            self.book.lot_size(),
            true,
            clock.timestamp_ms(),
        )
}

/// Dry run to determine the quantity out for a given base or quote quantity.
/// Only one out of base or quote quantity should be non-zero.
/// Returns the (base_quantity_out, quote_quantity_out, deep_quantity_required)
/// Uses input token as fee.
public fun get_quantity_out_input_fee<BaseAsset, QuoteAsset>(
    self: &Pool<BaseAsset, QuoteAsset>,
    base_quantity: u64,
    quote_quantity: u64,
    clock: &Clock,
): (u64, u64, u64) {
    let self = self.load_inner();
    let params = self.state.governance().trade_params();
    let taker_fee = params.taker_fee();
    let deep_price = self.deep_price.empty_deep_price();
    self
        .book
        .get_quantity_out(
            base_quantity,
            quote_quantity,
            taker_fee,
            deep_price,
            self.book.lot_size(),
            false,
            clock.timestamp_ms(),
        )
}

/// Returns the mid price of the pool.
public fun mid_price<BaseAsset, QuoteAsset>(
    self: &Pool<BaseAsset, QuoteAsset>,
    clock: &Clock,
): u64 {
    self.load_inner().book.mid_price(clock.timestamp_ms())
}

/// Returns the order_id for all open order for the balance_manager in the pool.
public fun account_open_orders<BaseAsset, QuoteAsset>(
    self: &Pool<BaseAsset, QuoteAsset>,
    balance_manager: &BalanceManager,
): VecSet<u128> {
    let self = self.load_inner();

    if (!self.state.account_exists(balance_manager.id())) {
        return vec_set::empty()
    };

    self.state.account(balance_manager.id()).open_orders()
}

/// Returns the (price_vec, quantity_vec) for the level2 order book.
/// The price_low and price_high are inclusive, all orders within the range are
/// returned.
/// is_bid is true for bids and false for asks.
public fun get_level2_range<BaseAsset, QuoteAsset>(
    self: &Pool<BaseAsset, QuoteAsset>,
    price_low: u64,
    price_high: u64,
    is_bid: bool,
    clock: &Clock,
): (vector<u64>, vector<u64>) {
    self
        .load_inner()
        .book
        .get_level2_range_and_ticks(
            price_low,
            price_high,
            constants::max_u64(),
            is_bid,
            clock.timestamp_ms(),
        )
}

/// Returns the (price_vec, quantity_vec) for the level2 order book.
/// Ticks are the maximum number of ticks to return starting from best bid and
/// best ask.
/// (bid_price, bid_quantity, ask_price, ask_quantity) are returned as 4
/// vectors.
/// The price vectors are sorted in descending order for bids and ascending
/// order for asks.
public fun get_level2_ticks_from_mid<BaseAsset, QuoteAsset>(
    self: &Pool<BaseAsset, QuoteAsset>,
    ticks: u64,
    clock: &Clock,
): (vector<u64>, vector<u64>, vector<u64>, vector<u64>) {
    let self = self.load_inner();
    let (bid_price, bid_quantity) = self
        .book
        .get_level2_range_and_ticks(
            constants::min_price(),
            constants::max_price(),
            ticks,
            true,
            clock.timestamp_ms(),
        );
    let (ask_price, ask_quantity) = self
        .book
        .get_level2_range_and_ticks(
            constants::min_price(),
            constants::max_price(),
            ticks,
            false,
            clock.timestamp_ms(),
        );

    (bid_price, bid_quantity, ask_price, ask_quantity)
}

/// Get all balances held in this pool.
public fun vault_balances<BaseAsset, QuoteAsset>(
    self: &Pool<BaseAsset, QuoteAsset>,
): (u64, u64, u64) {
    self.load_inner().vault.balances()
}

/// Get the ID of the pool given the asset types.
public fun get_pool_id_by_asset<BaseAsset, QuoteAsset>(registry: &Registry): ID {
    registry.get_pool_id<BaseAsset, QuoteAsset>()
}

/// Get the Order struct
public fun get_order<BaseAsset, QuoteAsset>(
    self: &Pool<BaseAsset, QuoteAsset>,
    order_id: u128,
): Order {
    self.load_inner().book.get_order(order_id)
}

/// Get multiple orders given a vector of order_ids.
public fun get_orders<BaseAsset, QuoteAsset>(
    self: &Pool<BaseAsset, QuoteAsset>,
    order_ids: vector<u128>,
): vector<Order> {
    let mut orders = vector[];
    let mut i = 0;
    let num_orders = order_ids.length();
    while (i < num_orders) {
        let order_id = order_ids[i];
        orders.push_back(self.get_order(order_id));
        i = i + 1;
    };

    orders
}

/// Return a copy of all orders that are in the book for this account.
public fun get_account_order_details<BaseAsset, QuoteAsset>(
    self: &Pool<BaseAsset, QuoteAsset>,
    balance_manager: &BalanceManager,
): vector<Order> {
    let acct_open_orders = self.account_open_orders(balance_manager).into_keys();

    self.get_orders(acct_open_orders)
}

/// Return the DEEP price for the pool.
public fun get_order_deep_price<BaseAsset, QuoteAsset>(
    self: &Pool<BaseAsset, QuoteAsset>,
): OrderDeepPrice {
    let whitelist = self.whitelisted();
    let self = self.load_inner();

    self.deep_price.get_order_deep_price(whitelist)
}

/// Returns the deep required for an order if it's taker or maker given quantity
/// and price
/// Does not account for discounted taker fees
/// Returns (deep_required_taker, deep_required_maker)
public fun get_order_deep_required<BaseAsset, QuoteAsset>(
    self: &Pool<BaseAsset, QuoteAsset>,
    base_quantity: u64,
    price: u64,
): (u64, u64) {
    let order_deep_price = self.get_order_deep_price();
    let self = self.load_inner();
    let maker_fee = self.state.governance().trade_params().maker_fee();
    let taker_fee = self.state.governance().trade_params().taker_fee();
    let deep_quantity = order_deep_price
        .fee_quantity(
            base_quantity,
            math::mul(base_quantity, price),
            true,
        )
        .deep();

    (math::mul(taker_fee, deep_quantity), math::mul(maker_fee, deep_quantity))
}

/// Returns the locked balance for the balance_manager in the pool
/// Returns (base_quantity, quote_quantity, deep_quantity)
public fun locked_balance<BaseAsset, QuoteAsset>(
    self: &Pool<BaseAsset, QuoteAsset>,
    balance_manager: &BalanceManager,
): (u64, u64, u64) {
    let account_orders = self.get_account_order_details(balance_manager);
    let self = self.load_inner();
    if (!self.state.account_exists(balance_manager.id())) {
        return (0, 0, 0)
    };

    let mut base_quantity = 0;
    let mut quote_quantity = 0;
    let mut deep_quantity = 0;

    account_orders.do_ref!(|order| {
        let maker_fee = self.state.history().historic_maker_fee(order.epoch());
        let locked_balance = order.locked_balance(maker_fee);
        base_quantity = base_quantity + locked_balance.base();
        quote_quantity = quote_quantity + locked_balance.quote();
        deep_quantity = deep_quantity + locked_balance.deep();
    });

    let settled_balances = self.state.account(balance_manager.id()).settled_balances();
    base_quantity = base_quantity + settled_balances.base();
    quote_quantity = quote_quantity + settled_balances.quote();
    deep_quantity = deep_quantity + settled_balances.deep();

    (base_quantity, quote_quantity, deep_quantity)
}

/// Returns the trade params for the pool.
public fun pool_trade_params<BaseAsset, QuoteAsset>(
    self: &Pool<BaseAsset, QuoteAsset>,
): (u64, u64, u64) {
    let self = self.load_inner();
    let trade_params = self.state.governance().trade_params();
    let taker_fee = trade_params.taker_fee();
    let maker_fee = trade_params.maker_fee();
    let stake_required = trade_params.stake_required();

    (taker_fee, maker_fee, stake_required)
}

/// Returns the currently leading trade params for the next epoch for the pool
public fun pool_trade_params_next<BaseAsset, QuoteAsset>(
    self: &Pool<BaseAsset, QuoteAsset>,
): (u64, u64, u64) {
    let self = self.load_inner();
    let trade_params = self.state.governance().next_trade_params();
    let taker_fee = trade_params.taker_fee();
    let maker_fee = trade_params.maker_fee();
    let stake_required = trade_params.stake_required();

    (taker_fee, maker_fee, stake_required)
}

/// Returns the tick size, lot size, and min size for the pool.
public fun pool_book_params<BaseAsset, QuoteAsset>(
    self: &Pool<BaseAsset, QuoteAsset>,
): (u64, u64, u64) {
    let self = self.load_inner();
    let tick_size = self.book.tick_size();
    let lot_size = self.book.lot_size();
    let min_size = self.book.min_size();

    (tick_size, lot_size, min_size)
}

public fun account<BaseAsset, QuoteAsset>(
    self: &Pool<BaseAsset, QuoteAsset>,
    balance_manager: &BalanceManager,
): Account {
    let self = self.load_inner();

    *self.state.account(balance_manager.id())
}

/// Returns the quorum needed to pass proposal in the current epoch
public fun quorum<BaseAsset, QuoteAsset>(self: &Pool<BaseAsset, QuoteAsset>): u64 {
    self.load_inner().state.governance().quorum()
}

public fun id<BaseAsset, QuoteAsset>(self: &Pool<BaseAsset, QuoteAsset>): ID {
    self.load_inner().pool_id
}

// === Public-Package Functions ===
public(package) fun create_pool<BaseAsset, QuoteAsset>(
    registry: &mut Registry,
    tick_size: u64,
    lot_size: u64,
    min_size: u64,
    creation_fee: Coin<DEEP>,
    whitelisted_pool: bool,
    stable_pool: bool,
    ctx: &mut TxContext,
): ID {
    assert!(tick_size > 0, EInvalidTickSize);
    assert!(math::is_power_of_ten(tick_size), EInvalidTickSize);
    assert!(lot_size >= 1000, EInvalidLotSize);
    assert!(math::is_power_of_ten(lot_size), EInvalidLotSize);
    assert!(min_size > 0, EInvalidMinSize);
    assert!(min_size % lot_size == 0, EInvalidMinSize);
    assert!(math::is_power_of_ten(min_size), EInvalidMinSize);
    assert!(!(whitelisted_pool && stable_pool), EPoolCannotBeBothWhitelistedAndStable);
    assert!(
        type_name::with_defining_ids<BaseAsset>() != type_name::with_defining_ids<QuoteAsset>(),
        ESameBaseAndQuote,
    );

    let pool_id = object::new(ctx);
    let pool_inner = PoolInner<BaseAsset, QuoteAsset> {
        allowed_versions: registry.allowed_versions(),
        pool_id: pool_id.to_inner(),
        book: book::empty(tick_size, lot_size, min_size, ctx),
        state: state::empty(whitelisted_pool, stable_pool, ctx),
        vault: vault::empty(),
        deep_price: deep_price::empty(),
        registered_pool: true,
    };
    let params = pool_inner.state.governance().trade_params();
    let taker_fee = params.taker_fee();
    let maker_fee = params.maker_fee();
    let treasury_address = registry.treasury_address();
    let pool = Pool<BaseAsset, QuoteAsset> {
        id: pool_id,
        inner: versioned::create(constants::current_version(), pool_inner, ctx),
    };
    let pool_id = object::id(&pool);
    registry.register_pool<BaseAsset, QuoteAsset>(pool_id);
    event::emit(PoolCreated<BaseAsset, QuoteAsset> {
        pool_id,
        taker_fee,
        maker_fee,
        tick_size,
        lot_size,
        min_size,
        whitelisted_pool,
        treasury_address,
    });

    transfer::public_transfer(creation_fee, treasury_address);
    transfer::share_object(pool);

    pool_id
}

public(package) fun bids<BaseAsset, QuoteAsset>(
    self: &PoolInner<BaseAsset, QuoteAsset>,
): &BigVector<Order> {
    self.book.bids()
}

public(package) fun asks<BaseAsset, QuoteAsset>(
    self: &PoolInner<BaseAsset, QuoteAsset>,
): &BigVector<Order> {
    self.book.asks()
}

public(package) fun load_inner<BaseAsset, QuoteAsset>(
    self: &Pool<BaseAsset, QuoteAsset>,
): &PoolInner<BaseAsset, QuoteAsset> {
    let inner: &PoolInner<BaseAsset, QuoteAsset> = self.inner.load_value();
    let package_version = constants::current_version();
    assert!(inner.allowed_versions.contains(&package_version), EPackageVersionDisabled);

    inner
}

public(package) fun load_inner_mut<BaseAsset, QuoteAsset>(
    self: &mut Pool<BaseAsset, QuoteAsset>,
): &mut PoolInner<BaseAsset, QuoteAsset> {
    let inner: &mut PoolInner<BaseAsset, QuoteAsset> = self.inner.load_value_mut();
    let package_version = constants::current_version();
    assert!(inner.allowed_versions.contains(&package_version), EPackageVersionDisabled);

    inner
}

// === Private Functions ===
fun place_order_int<BaseAsset, QuoteAsset>(
    self: &mut Pool<BaseAsset, QuoteAsset>,
    balance_manager: &mut BalanceManager,
    trade_proof: &TradeProof,
    client_order_id: u64,
    order_type: u8,
    self_matching_option: u8,
    price: u64,
    quantity: u64,
    is_bid: bool,
    pay_with_deep: bool,
    expire_timestamp: u64,
    clock: &Clock,
    market_order: bool,
    ctx: &TxContext,
): OrderInfo {
    let whitelist = self.whitelisted();
    self.update_ewma_state(clock, ctx);
    let ewma_state = self.load_ewma_state();
    let order_info = {
        let pool_inner = self.load_inner_mut();

        let order_deep_price = if (pay_with_deep) {
            pool_inner.deep_price.get_order_deep_price(whitelist)
        } else {
            pool_inner.deep_price.empty_deep_price()
        };

        let mut order_info = order_info::new(
            pool_inner.pool_id,
            balance_manager.id(),
            client_order_id,
            ctx.sender(),
            order_type,
            self_matching_option,
            price,
            quantity,
            is_bid,
            pay_with_deep,
            ctx.epoch(),
            expire_timestamp,
            order_deep_price,
            market_order,
            clock.timestamp_ms(),
        );
        pool_inner.book.create_order(&mut order_info, clock.timestamp_ms());
        let (settled, owed) = pool_inner
            .state
            .process_create(
                &mut order_info,
                &ewma_state,
                pool_inner.pool_id,
                ctx,
            );
        pool_inner.vault.settle_balance_manager(settled, owed, balance_manager, trade_proof);
        order_info.emit_order_info();
        order_info.emit_orders_filled(clock.timestamp_ms());

        order_info
    };

    self.process_referral_fees<BaseAsset, QuoteAsset>(
        &order_info,
        balance_manager,
        trade_proof,
    );

    order_info
}

fun process_referral_fees<BaseAsset, QuoteAsset>(
    self: &mut Pool<BaseAsset, QuoteAsset>,
    order_info: &OrderInfo,
    balance_manager: &mut BalanceManager,
    trade_proof: &TradeProof,
) {
    let referral_id = balance_manager::get_referral_id(balance_manager);
    if (referral_id.is_some()) {
        let referral_id = referral_id.destroy_some();
        let referral_rewards: &mut ReferralRewards<BaseAsset, QuoteAsset> = self
            .id
            .borrow_mut(referral_id);
        let referral_bps = referral_rewards.additional_bps;
        let multiplier = math::div(referral_bps, order_info.taker_fee());
        let referral_fee = math::mul(order_info.paid_fees(), multiplier);
        if (order_info.fee_is_deep()) {
            referral_rewards
                .deep
                .join(balance_manager.withdraw_with_proof(trade_proof, referral_fee, false));
        } else if (order_info.is_bid()) {
            referral_rewards
                .base
                .join(balance_manager.withdraw_with_proof(trade_proof, referral_fee, false));
        } else {
            referral_rewards
                .quote
                .join(balance_manager.withdraw_with_proof(trade_proof, referral_fee, false));
        }
    };
}

fun update_ewma_state<BaseAsset, QuoteAsset>(
    self: &mut Pool<BaseAsset, QuoteAsset>,
    clock: &Clock,
    ctx: &TxContext,
): &mut EWMAState {
    if (!self.id.exists_(constants::ewma_df_key())) {
        self.id.add(constants::ewma_df_key(), init_ewma_state(ctx));
    };

    let ewma_state: &mut EWMAState = self
        .id
        .borrow_mut(
            constants::ewma_df_key(),
        );
    ewma_state.update(clock, ctx);

    ewma_state
}

fun load_ewma_state<BaseAsset, QuoteAsset>(self: &Pool<BaseAsset, QuoteAsset>): EWMAState {
    *self.id.borrow(constants::ewma_df_key())
}
// Copyright (c) Mysten Labs, Inc.
// SPDX-License-Identifier: Apache-2.0

/// The BalanceManager is a shared object that holds all of the balances for different assets. A combination of `BalanceManager` and
/// `TradeProof` are passed into a pool to perform trades. A `TradeProof` can be generated in two ways: by the
/// owner directly, or by any `TradeCap` owner. The owner can generate a `TradeProof` without the risk of
/// equivocation. The `TradeCap` owner, due to it being an owned object, risks equivocation when generating
/// a `TradeProof`. Generally, a high frequency trading engine will trade as the default owner.
module deepbook::balance_manager;

use deepbook::constants;
use std::type_name::{Self, TypeName};
use sui::{
    bag::{Self, Bag},
    balance::{Self, Balance},
    coin::Coin,
    dynamic_field as df,
    event,
    object::id_from_bytes,
    vec_set::{Self, VecSet}
};

use fun df::borrow as UID.borrow;
use fun df::exists_ as UID.exists_;
use fun df::remove_if_exists as UID.remove_if_exists;
use fun df::add as UID.add;

// === Errors ===
const EInvalidOwner: u64 = 0;
const EInvalidTrader: u64 = 1;
const EInvalidProof: u64 = 2;
const EBalanceManagerBalanceTooLow: u64 = 3;
const EMaxCapsReached: u64 = 4;
const ECapNotInList: u64 = 5;
const EInvalidReferralOwner: u64 = 6;

// === Constants ===
const MAX_TRADE_CAPS: u64 = 1000;

// === Structs ===
/// A shared object that is passed into pools for placing orders.
public struct BalanceManager has key, store {
    id: UID,
    owner: address,
    balances: Bag,
    allow_listed: VecSet<ID>,
}

/// Event emitted when a new balance_manager is created.
public struct BalanceManagerEvent has copy, drop {
    balance_manager_id: ID,
    owner: address,
}

/// Event emitted when a deposit or withdrawal occurs.
public struct BalanceEvent has copy, drop {
    balance_manager_id: ID,
    asset: TypeName,
    amount: u64,
    deposit: bool,
}

/// Balance identifier.
public struct BalanceKey<phantom T> has copy, drop, store {}

/// Owners of a `TradeCap` need to get a `TradeProof` to trade across pools in a single PTB (drops after).
public struct TradeCap has key, store {
    id: UID,
    balance_manager_id: ID,
}

/// `DepositCap` is used to deposit funds to a balance_manager by a non-owner.
public struct DepositCap has key, store {
    id: UID,
    balance_manager_id: ID,
}

/// WithdrawCap is used to withdraw funds from a balance_manager by a non-owner.
public struct WithdrawCap has key, store {
    id: UID,
    balance_manager_id: ID,
}

public struct DeepBookReferral has key, store {
    id: UID,
    owner: address,
}

public struct DeepBookReferralCreatedEvent has copy, drop {
    referral_id: ID,
    owner: address,
}

public struct DeepBookReferralSetEvent has copy, drop {
    referral_id: ID,
    balance_manager_id: ID,
}

/// BalanceManager owner and `TradeCap` owners can generate a `TradeProof`.
/// `TradeProof` is used to validate the balance_manager when trading on DeepBook.
public struct TradeProof has drop {
    balance_manager_id: ID,
    trader: address,
}

// === Public-Mutative Functions ===
public fun new(ctx: &mut TxContext): BalanceManager {
    let id = object::new(ctx);
    event::emit(BalanceManagerEvent {
        balance_manager_id: id.to_inner(),
        owner: ctx.sender(),
    });

    BalanceManager {
        id,
        owner: ctx.sender(),
        balances: bag::new(ctx),
        allow_listed: vec_set::empty(),
    }
}

#[deprecated(note = b"This function is deprecated, use `new_with_custom_owner` instead.")]
public fun new_with_owner(_ctx: &mut TxContext, _owner: address): BalanceManager {
    abort 1337
}

/// Create a new balance manager with an owner.
public fun new_with_custom_owner(owner: address, ctx: &mut TxContext): BalanceManager {
    let id = object::new(ctx);
    event::emit(BalanceManagerEvent {
        balance_manager_id: id.to_inner(),
        owner,
    });

    BalanceManager {
        id,
        owner,
        balances: bag::new(ctx),
        allow_listed: vec_set::empty(),
    }
}

public fun new_with_custom_owner_and_caps(
    owner: address,
    ctx: &mut TxContext,
): (BalanceManager, DepositCap, WithdrawCap, TradeCap) {
    let mut balance_manager = new_with_custom_owner(owner, ctx);

    let deposit_cap = mint_deposit_cap_internal(&mut balance_manager, ctx);
    let withdraw_cap = mint_withdraw_cap_internal(&mut balance_manager, ctx);
    let trade_cap = mint_trade_cap_internal(&mut balance_manager, ctx);

    (balance_manager, deposit_cap, withdraw_cap, trade_cap)
}

/// Set the referral for the balance manager.
public fun set_referral(
    balance_manager: &mut BalanceManager,
    referral: &DeepBookReferral,
    trade_cap: &TradeCap,
) {
    balance_manager.validate_trader(trade_cap);
    let _: Option<ID> = balance_manager.id.remove_if_exists(constants::referral_df_key());
    balance_manager.id.add(constants::referral_df_key(), referral.id.to_inner());

    event::emit(DeepBookReferralSetEvent {
        referral_id: referral.id.to_inner(),
        balance_manager_id: balance_manager.id.to_inner(),
    });
}

/// Unset the referral for the balance manager.
public fun unset_referral(balance_manager: &mut BalanceManager, trade_cap: &TradeCap) {
    balance_manager.validate_trader(trade_cap);
    let _: Option<ID> = balance_manager.id.remove_if_exists(constants::referral_df_key());

    event::emit(DeepBookReferralSetEvent {
        referral_id: id_from_bytes(b""),
        balance_manager_id: balance_manager.id.to_inner(),
    });
}

/// Returns the balance of a Coin in a balance manager.
public fun balance<T>(balance_manager: &BalanceManager): u64 {
    let key = BalanceKey<T> {};
    if (!balance_manager.balances.contains(key)) {
        0
    } else {
        let acc_balance: &Balance<T> = &balance_manager.balances[key];
        acc_balance.value()
    }
}

/// Mint a `TradeCap`, only owner can mint a `TradeCap`.
public fun mint_trade_cap(balance_manager: &mut BalanceManager, ctx: &mut TxContext): TradeCap {
    balance_manager.validate_owner(ctx);
    balance_manager.mint_trade_cap_internal(ctx)
}

/// Mint a `DepositCap`, only owner can mint.
public fun mint_deposit_cap(balance_manager: &mut BalanceManager, ctx: &mut TxContext): DepositCap {
    balance_manager.validate_owner(ctx);
    balance_manager.mint_deposit_cap_internal(ctx)
}

/// Mint a `WithdrawCap`, only owner can mint.
public fun mint_withdraw_cap(
    balance_manager: &mut BalanceManager,
    ctx: &mut TxContext,
): WithdrawCap {
    balance_manager.validate_owner(ctx);
    balance_manager.mint_withdraw_cap_internal(ctx)
}

/// Revoke a `TradeCap`. Only the owner can revoke a `TradeCap`.
/// Can also be used to revoke `DepositCap` and `WithdrawCap`.
public fun revoke_trade_cap(
    balance_manager: &mut BalanceManager,
    trade_cap_id: &ID,
    ctx: &TxContext,
) {
    balance_manager.validate_owner(ctx);

    assert!(balance_manager.allow_listed.contains(trade_cap_id), ECapNotInList);
    balance_manager.allow_listed.remove(trade_cap_id);
}

/// Generate a `TradeProof` by the owner. The owner does not require a capability
/// and can generate TradeProofs without the risk of equivocation.
public fun generate_proof_as_owner(
    balance_manager: &mut BalanceManager,
    ctx: &TxContext,
): TradeProof {
    balance_manager.validate_owner(ctx);

    TradeProof {
        balance_manager_id: object::id(balance_manager),
        trader: ctx.sender(),
    }
}

/// Generate a `TradeProof` with a `TradeCap`.
/// Risk of equivocation since `TradeCap` is an owned object.
public fun generate_proof_as_trader(
    balance_manager: &mut BalanceManager,
    trade_cap: &TradeCap,
    ctx: &TxContext,
): TradeProof {
    balance_manager.validate_trader(trade_cap);

    TradeProof {
        balance_manager_id: object::id(balance_manager),
        trader: ctx.sender(),
    }
}

/// Deposit funds to a balance manager. Only owner can call this directly.
public fun deposit<T>(balance_manager: &mut BalanceManager, coin: Coin<T>, ctx: &mut TxContext) {
    balance_manager.emit_balance_event(
        type_name::with_defining_ids<T>(),
        coin.value(),
        true,
    );

    let proof = balance_manager.generate_proof_as_owner(ctx);
    balance_manager.deposit_with_proof(&proof, coin.into_balance());
}

/// Deposit funds into a balance manager by a `DepositCap` owner.
public fun deposit_with_cap<T>(
    balance_manager: &mut BalanceManager,
    deposit_cap: &DepositCap,
    coin: Coin<T>,
    ctx: &TxContext,
) {
    balance_manager.emit_balance_event(
        type_name::with_defining_ids<T>(),
        coin.value(),
        true,
    );

    let proof = balance_manager.generate_proof_as_depositor(deposit_cap, ctx);
    balance_manager.deposit_with_proof(&proof, coin.into_balance());
}

/// Withdraw funds from a balance manager by a `WithdrawCap` owner.
public fun withdraw_with_cap<T>(
    balance_manager: &mut BalanceManager,
    withdraw_cap: &WithdrawCap,
    withdraw_amount: u64,
    ctx: &mut TxContext,
): Coin<T> {
    let proof = balance_manager.generate_proof_as_withdrawer(
        withdraw_cap,
        ctx,
    );
    let coin = balance_manager.withdraw_with_proof(&proof, withdraw_amount, false).into_coin(ctx);
    balance_manager.emit_balance_event(
        type_name::with_defining_ids<T>(),
        coin.value(),
        false,
    );

    coin
}

/// Withdraw funds from a balance_manager. Only owner can call this directly.
/// If withdraw_all is true, amount is ignored and full balance withdrawn.
/// If withdraw_all is false, withdraw_amount will be withdrawn.
public fun withdraw<T>(
    balance_manager: &mut BalanceManager,
    withdraw_amount: u64,
    ctx: &mut TxContext,
): Coin<T> {
    let proof = generate_proof_as_owner(balance_manager, ctx);
    let coin = balance_manager.withdraw_with_proof(&proof, withdraw_amount, false).into_coin(ctx);
    balance_manager.emit_balance_event(
        type_name::with_defining_ids<T>(),
        coin.value(),
        false,
    );

    coin
}

public fun withdraw_all<T>(balance_manager: &mut BalanceManager, ctx: &mut TxContext): Coin<T> {
    let proof = generate_proof_as_owner(balance_manager, ctx);
    let coin = balance_manager.withdraw_with_proof(&proof, 0, true).into_coin(ctx);
    balance_manager.emit_balance_event(
        type_name::with_defining_ids<T>(),
        coin.value(),
        false,
    );

    coin
}

public fun validate_proof(balance_manager: &BalanceManager, proof: &TradeProof) {
    assert!(object::id(balance_manager) == proof.balance_manager_id, EInvalidProof);
}

/// Returns the owner of the balance_manager.
public fun owner(balance_manager: &BalanceManager): address {
    balance_manager.owner
}

/// Returns the owner of the balance_manager.
public fun id(balance_manager: &BalanceManager): ID {
    balance_manager.id.to_inner()
}

// === Public-Package Functions ===
/// Mint a `DeepBookReferral` and share it.
public(package) fun mint_referral(ctx: &mut TxContext): ID {
    let id = object::new(ctx);
    let referral_id = id.to_inner();
    let referral = DeepBookReferral {
        id,
        owner: ctx.sender(),
    };

    event::emit(DeepBookReferralCreatedEvent {
        referral_id,
        owner: ctx.sender(),
    });

    transfer::share_object(referral);

    referral_id
}

/// Get the referral id from the balance manager.
public(package) fun get_referral_id(balance_manager: &BalanceManager): Option<ID> {
    let ref_key = constants::referral_df_key();
    if (!balance_manager.id.exists_(ref_key)) {
        return option::none()
    };
    let referral_id: &ID = balance_manager.id.borrow(ref_key);

    option::some(*referral_id)
}

public(package) fun assert_referral_owner(referral: &DeepBookReferral, ctx: &TxContext) {
    assert!(ctx.sender() == referral.owner, EInvalidReferralOwner);
}

/// Deposit funds to a balance_manager. Pool will call this to deposit funds.
public(package) fun deposit_with_proof<T>(
    balance_manager: &mut BalanceManager,
    proof: &TradeProof,
    to_deposit: Balance<T>,
) {
    balance_manager.validate_proof(proof);

    let key = BalanceKey<T> {};

    if (balance_manager.balances.contains(key)) {
        let balance: &mut Balance<T> = &mut balance_manager.balances[key];
        balance.join(to_deposit);
    } else {
        balance_manager.balances.add(key, to_deposit);
    }
}

/// Generate a `TradeProof` by a `DepositCap` owner.
public(package) fun generate_proof_as_depositor(
    balance_manager: &BalanceManager,
    deposit_cap: &DepositCap,
    ctx: &TxContext,
): TradeProof {
    balance_manager.validate_deposit_cap(deposit_cap);

    TradeProof {
        balance_manager_id: object::id(balance_manager),
        trader: ctx.sender(),
    }
}

/// Generate a `TradeProof` by a `WithdrawCap` owner.
public(package) fun generate_proof_as_withdrawer(
    balance_manager: &BalanceManager,
    withdraw_cap: &WithdrawCap,
    ctx: &TxContext,
): TradeProof {
    balance_manager.validate_withdraw_cap(withdraw_cap);

    TradeProof {
        balance_manager_id: object::id(balance_manager),
        trader: ctx.sender(),
    }
}

/// Withdraw funds from a balance_manager. Pool will call this to withdraw funds.
public(package) fun withdraw_with_proof<T>(
    balance_manager: &mut BalanceManager,
    proof: &TradeProof,
    withdraw_amount: u64,
    withdraw_all: bool,
): Balance<T> {
    balance_manager.validate_proof(proof);

    let key = BalanceKey<T> {};
    let key_exists = balance_manager.balances.contains(key);
    if (withdraw_all) {
        if (key_exists) {
            balance_manager.balances.remove(key)
        } else {
            balance::zero()
        }
    } else {
        assert!(key_exists, EBalanceManagerBalanceTooLow);
        let acc_balance: &mut Balance<T> = &mut balance_manager.balances[key];
        let acc_value = acc_balance.value();
        assert!(acc_value >= withdraw_amount, EBalanceManagerBalanceTooLow);
        if (withdraw_amount == acc_value) {
            balance_manager.balances.remove(key)
        } else {
            acc_balance.split(withdraw_amount)
        }
    }
}

/// Deletes a balance_manager.
/// This is used for deleting temporary balance_managers for direct swap with pool.
public(package) fun delete(balance_manager: BalanceManager) {
    let BalanceManager {
        id,
        owner: _,
        balances,
        allow_listed: _,
    } = balance_manager;

    id.delete();
    balances.destroy_empty();
}

public(package) fun trader(trade_proof: &TradeProof): address {
    trade_proof.trader
}

public(package) fun emit_balance_event(
    balance_manager: &BalanceManager,
    asset: TypeName,
    amount: u64,
    deposit: bool,
) {
    event::emit(BalanceEvent {
        balance_manager_id: balance_manager.id(),
        asset,
        amount,
        deposit,
    });
}

// === Private Functions ===
fun mint_trade_cap_internal(balance_manager: &mut BalanceManager, ctx: &mut TxContext): TradeCap {
    assert!(balance_manager.allow_listed.length() < MAX_TRADE_CAPS, EMaxCapsReached);

    let id = object::new(ctx);
    balance_manager.allow_listed.insert(id.to_inner());

    TradeCap {
        id,
        balance_manager_id: object::id(balance_manager),
    }
}

fun mint_deposit_cap_internal(
    balance_manager: &mut BalanceManager,
    ctx: &mut TxContext,
): DepositCap {
    assert!(balance_manager.allow_listed.length() < MAX_TRADE_CAPS, EMaxCapsReached);

    let id = object::new(ctx);
    balance_manager.allow_listed.insert(id.to_inner());

    DepositCap {
        id,
        balance_manager_id: object::id(balance_manager),
    }
}

fun mint_withdraw_cap_internal(
    balance_manager: &mut BalanceManager,
    ctx: &mut TxContext,
): WithdrawCap {
    assert!(balance_manager.allow_listed.length() < MAX_TRADE_CAPS, EMaxCapsReached);

    let id = object::new(ctx);
    balance_manager.allow_listed.insert(id.to_inner());

    WithdrawCap {
        id,
        balance_manager_id: object::id(balance_manager),
    }
}

fun validate_owner(balance_manager: &BalanceManager, ctx: &TxContext) {
    assert!(ctx.sender() == balance_manager.owner(), EInvalidOwner);
}

fun validate_trader(balance_manager: &BalanceManager, trade_cap: &TradeCap) {
    assert!(balance_manager.allow_listed.contains(object::borrow_id(trade_cap)), EInvalidTrader);
}

fun validate_deposit_cap(balance_manager: &BalanceManager, deposit_cap: &DepositCap) {
    assert!(balance_manager.allow_listed.contains(object::borrow_id(deposit_cap)), EInvalidTrader);
}

fun validate_withdraw_cap(balance_manager: &BalanceManager, withdraw_cap: &WithdrawCap) {
    assert!(balance_manager.allow_listed.contains(object::borrow_id(withdraw_cap)), EInvalidTrader);
}
// Copyright (c) Mysten Labs, Inc.
// SPDX-License-Identifier: Apache-2.0

/// The Exponentially Weighted Moving Average (EWMA) state for DeepBook
/// This state is used to calculate the smoothed mean and variance of gas prices
/// and apply a penalty to taker fees based on the Z-score of the current gas price
/// relative to the smoothed mean and variance.
/// The state is enabled by default and can be configured with different parameters.
module deepbook::ewma;

use deepbook::{constants, math};
use sui::clock::Clock;

/// The EWMA state structure
/// It contains the smoothed mean, variance, alpha, Z-score threshold,
/// additional taker fee, and whether the state is enabled.
public struct EWMAState has copy, drop, store {
    mean: u64,
    variance: u64,
    alpha: u64,
    z_score_threshold: u64,
    additional_taker_fee: u64,
    last_updated_timestamp: u64,
    enabled: bool,
}

public(package) fun init_ewma_state(ctx: &TxContext): EWMAState {
    let gas_price = ctx.gas_price() * constants::float_scaling();

    EWMAState {
        mean: gas_price,
        variance: 0,
        alpha: constants::default_ewma_alpha(),
        z_score_threshold: constants::default_z_score_threshold(),
        additional_taker_fee: constants::default_additional_taker_fee(),
        last_updated_timestamp: 0,
        enabled: false,
    }
}

/// Updates the EWMA state with the current gas price
/// It calculates the new mean and variance based on the current gas price
/// and the previous mean and variance using the EWMA formula.
/// The alpha parameter controls the weight of the current gas price in the calculation.
/// The mean and variance are updated in the state.
public(package) fun update(self: &mut EWMAState, clock: &Clock, ctx: &TxContext) {
    let current_timestamp = clock.timestamp_ms();
    if (current_timestamp == self.last_updated_timestamp) {
        return
    };
    self.last_updated_timestamp = current_timestamp;

    let alpha = self.alpha;
    let one_minute_alpha = constants::float_scaling() - alpha;
    let gas_price = ctx.gas_price() * constants::float_scaling();

    let mean_new = math::mul(alpha, gas_price) + math::mul(one_minute_alpha, self.mean);

    let diff = if (gas_price > mean_new) {
        gas_price - mean_new
    } else {
        mean_new - gas_price
    };
    let diff_squared = math::mul(diff, diff);

    let variance_new = if (self.variance == 0) {
        diff_squared
    } else {
        math::mul(self.variance, one_minute_alpha) + math::mul(alpha, diff_squared)
    };

    self.mean = mean_new;
    self.variance = variance_new;
}

/// Returns the Z-score of the current gas price relative to the smoothed mean and variance.
/// The Z-score is calculated as the difference between the current gas price and the mean,
/// divided by the standard deviation (square root of variance).
public(package) fun z_score(self: &EWMAState, ctx: &TxContext): u64 {
    if (self.variance == 0) {
        return 0
    };

    let gas_price = ctx.gas_price() * constants::float_scaling();
    let diff = if (gas_price > self.mean) {
        gas_price - self.mean
    } else {
        self.mean - gas_price
    };

    let std_dev = math::sqrt(self.variance, constants::float_scaling());
    let z = math::div(diff, std_dev);

    z
}

/// Sets the alpha value for the EWMA state. Admin only.
public(package) fun set_alpha(self: &mut EWMAState, alpha: u64) {
    self.alpha = alpha;
}

/// Sets the Z-score threshold for the EWMA state. Admin only.
public(package) fun set_z_score_threshold(self: &mut EWMAState, threshold: u64) {
    self.z_score_threshold = threshold;
}

/// Sets the additional taker fee for the EWMA state. Admin only.
public(package) fun set_additional_taker_fee(self: &mut EWMAState, fee: u64) {
    self.additional_taker_fee = fee;
}

/// Enables the EWMA state. Admin only.
public(package) fun enable(self: &mut EWMAState) {
    self.enabled = true;
}

/// Disables the EWMA state. Admin only.
public(package) fun disable(self: &mut EWMAState) {
    self.enabled = false;
}

/// Applies the taker penalty based on the Z-score of the current gas price.
/// If the gas price is below the mean, the taker fee is not applied.
public(package) fun apply_taker_penalty(self: &EWMAState, taker_fee: u64, ctx: &TxContext): u64 {
    if (!self.enabled || ctx.gas_price() < self.mean) {
        return taker_fee
    };

    let z_score = self.z_score(ctx);
    if (z_score > self.z_score_threshold) {
        taker_fee + self.additional_taker_fee
    } else {
        taker_fee
    }
}

public(package) fun mean(self: &EWMAState): u64 {
    self.mean
}

public(package) fun variance(self: &EWMAState): u64 {
    self.variance
}

public(package) fun alpha(self: &EWMAState): u64 {
    self.alpha
}

public(package) fun z_score_threshold(self: &EWMAState): u64 {
    self.z_score_threshold
}

public(package) fun additional_taker_fee(self: &EWMAState): u64 {
    self.additional_taker_fee
}

public(package) fun enabled(self: &EWMAState): bool {
    self.enabled
}

public(package) fun last_updated_timestamp(self: &EWMAState): u64 {
    self.last_updated_timestamp
}
// Copyright (c) Mysten Labs, Inc.
// SPDX-License-Identifier: Apache-2.0

/// Account module manages the account data for each user.
module deepbook::account;

use deepbook::{balances::{Self, Balances}, fill::Fill};
use sui::vec_set::{Self, VecSet};

// === Structs ===
/// Account data that is updated every epoch.
/// One Account struct per BalanceManager object.
public struct Account has copy, drop, store {
    epoch: u64,
    open_orders: VecSet<u128>,
    taker_volume: u128,
    maker_volume: u128,
    active_stake: u64,
    inactive_stake: u64,
    created_proposal: bool,
    voted_proposal: Option<ID>,
    unclaimed_rebates: Balances,
    settled_balances: Balances,
    owed_balances: Balances,
}

// === Public-View Functions ===
public fun open_orders(self: &Account): VecSet<u128> {
    self.open_orders
}

public fun taker_volume(self: &Account): u128 {
    self.taker_volume
}

public fun maker_volume(self: &Account): u128 {
    self.maker_volume
}

public fun total_volume(self: &Account): u128 {
    self.taker_volume + self.maker_volume
}

public fun active_stake(self: &Account): u64 {
    self.active_stake
}

public fun inactive_stake(self: &Account): u64 {
    self.inactive_stake
}

public fun created_proposal(self: &Account): bool {
    self.created_proposal
}

public fun voted_proposal(self: &Account): Option<ID> {
    self.voted_proposal
}

public fun settled_balances(self: &Account): Balances {
    self.settled_balances
}

// === Public-Package Functions ===
public(package) fun empty(ctx: &TxContext): Account {
    Account {
        epoch: ctx.epoch(),
        open_orders: vec_set::empty(),
        taker_volume: 0,
        maker_volume: 0,
        active_stake: 0,
        inactive_stake: 0,
        created_proposal: false,
        voted_proposal: option::none(),
        unclaimed_rebates: balances::empty(),
        settled_balances: balances::empty(),
        owed_balances: balances::empty(),
    }
}

/// Update the account data for the new epoch.
/// Returns the previous epoch, maker volume, and active stake.
public(package) fun update(self: &mut Account, ctx: &TxContext): (u64, u128, u64) {
    if (self.epoch == ctx.epoch()) return (0, 0, 0);

    let prev_epoch = self.epoch;
    let prev_maker_volume = self.maker_volume;
    let prev_active_stake = self.active_stake;

    self.epoch = ctx.epoch();
    self.maker_volume = 0;
    self.taker_volume = 0;
    self.active_stake = self.active_stake + self.inactive_stake;
    self.inactive_stake = 0;
    self.created_proposal = false;
    self.voted_proposal = option::none();

    (prev_epoch, prev_maker_volume, prev_active_stake)
}

/// Given a fill, update the account balances and volumes as the maker.
public(package) fun process_maker_fill(self: &mut Account, fill: &Fill) {
    let settled_balances = fill.get_settled_maker_quantities();
    self.settled_balances.add_balances(settled_balances);
    if (!fill.expired()) {
        self.maker_volume = self.maker_volume + (fill.base_quantity() as u128);
    };
    if (fill.expired() || fill.completed()) {
        self.open_orders.remove(&fill.maker_order_id());
    }
}

public(package) fun add_taker_volume(self: &mut Account, volume: u64) {
    self.taker_volume = self.taker_volume + (volume as u128);
}

/// Set the voted proposal for the account and return the
/// previous proposal.
public(package) fun set_voted_proposal(self: &mut Account, proposal: Option<ID>): Option<ID> {
    let prev_proposal = self.voted_proposal;
    self.voted_proposal = proposal;

    prev_proposal
}

public(package) fun set_created_proposal(self: &mut Account, created: bool) {
    self.created_proposal = created;
}

public(package) fun add_settled_balances(self: &mut Account, balances: Balances) {
    self.settled_balances.add_balances(balances);
}

public(package) fun add_owed_balances(self: &mut Account, balances: Balances) {
    self.owed_balances.add_balances(balances);
}

/// Settle the account balances. Returns the settled and
/// owed balances by this account. Vault uses these values
/// to perform any necessary transfers.
public(package) fun settle(self: &mut Account): (Balances, Balances) {
    let settled = self.settled_balances.reset();
    let owed = self.owed_balances.reset();

    (settled, owed)
}

public(package) fun add_rebates(self: &mut Account, rebates: Balances) {
    self.unclaimed_rebates.add_balances(rebates);
}

public(package) fun claim_rebates(self: &mut Account): Balances {
    let rebate_amount = self.unclaimed_rebates;
    self.settled_balances.add_balances(self.unclaimed_rebates);
    self.unclaimed_rebates.reset();

    rebate_amount
}

public(package) fun add_order(self: &mut Account, order_id: u128) {
    self.open_orders.insert(order_id);
}

public(package) fun remove_order(self: &mut Account, order_id: u128) {
    self.open_orders.remove(&order_id)
}

public(package) fun add_stake(self: &mut Account, stake: u64): (u64, u64) {
    let stake_before = self.active_stake + self.inactive_stake;
    self.inactive_stake = self.inactive_stake + stake;
    self.owed_balances.add_deep(stake);

    (stake_before, self.active_stake + self.inactive_stake)
}

public(package) fun remove_stake(self: &mut Account) {
    let stake_before = self.active_stake + self.inactive_stake;
    self.active_stake = 0;
    self.inactive_stake = 0;
    self.voted_proposal = option::none();
    self.settled_balances.add_deep(stake_before);
}

// === Test Functions ===
#[test_only]
public fun owed_balances(self: &Account): Balances {
    self.owed_balances
}
// Copyright (c) Mysten Labs, Inc.
// SPDX-License-Identifier: Apache-2.0

/// Governance module handles the governance of the `Pool` that it's attached
/// to.
/// Users with non zero stake can create proposals and vote on them. Winning
/// proposals are used to set the trade parameters for the next epoch.
module deepbook::governance;

use deepbook::{constants, math, trade_params::{Self, TradeParams}};
use sui::{event, vec_map::{Self, VecMap}};

// === Errors ===
const EInvalidMakerFee: u64 = 1;
const EInvalidTakerFee: u64 = 2;
const EProposalDoesNotExist: u64 = 3;
const EMaxProposalsReachedNotEnoughVotes: u64 = 4;
const EWhitelistedPoolCannotChange: u64 = 5;

// === Constants ===
const FEE_MULTIPLE: u64 = 1000; // 0.01 basis points
const MIN_TAKER_STABLE: u64 = 10000; // 0.1 basis points
const MAX_TAKER_STABLE: u64 = 100000; // 1 basis points
const MIN_MAKER_STABLE: u64 = 0;
const MAX_MAKER_STABLE: u64 = 50000; // 0.5 basis points
const MIN_TAKER_VOLATILE: u64 = 100000; // 1 basis points
const MAX_TAKER_VOLATILE: u64 = 1000000; // 10 basis points
const MIN_MAKER_VOLATILE: u64 = 0;
const MAX_MAKER_VOLATILE: u64 = 500000; // 5 basis points
const MAX_PROPOSALS: u64 = 100;
const VOTING_POWER_THRESHOLD: u64 = 100_000_000_000; // 100k deep

// === Structs ===
/// `Proposal` struct that holds the parameters of a proposal and its current
/// total votes.
public struct Proposal has copy, drop, store {
    taker_fee: u64,
    maker_fee: u64,
    stake_required: u64,
    votes: u64,
}

/// Details of a pool. This is refreshed every epoch by the first
/// `State` action against this pool.
public struct Governance has store {
    /// Tracks refreshes.
    epoch: u64,
    /// If Pool is whitelisted.
    whitelisted: bool,
    /// If Pool is stable or volatile.
    stable: bool,
    /// List of proposals for the current epoch.
    proposals: VecMap<ID, Proposal>,
    /// Trade parameters for the current epoch.
    trade_params: TradeParams,
    /// Trade parameters for the next epoch.
    next_trade_params: TradeParams,
    /// All voting power from the current stakes.
    voting_power: u64,
    /// Quorum for the current epoch.
    quorum: u64,
}

/// Event emitted when trade parameters are updated.
public struct TradeParamsUpdateEvent has copy, drop {
    taker_fee: u64,
    maker_fee: u64,
    stake_required: u64,
}

// === Public-Package Functions ===
public(package) fun empty(whitelisted: bool, stable_pool: bool, ctx: &TxContext): Governance {
    let default_taker = if (whitelisted) {
        0
    } else if (stable_pool) {
        MAX_TAKER_STABLE
    } else {
        MAX_TAKER_VOLATILE
    };
    let default_maker = if (whitelisted) {
        0
    } else if (stable_pool) {
        MAX_MAKER_STABLE
    } else {
        MAX_MAKER_VOLATILE
    };
    Governance {
        epoch: ctx.epoch(),
        whitelisted,
        stable: stable_pool,
        proposals: vec_map::empty(),
        trade_params: trade_params::new(
            default_taker,
            default_maker,
            constants::default_stake_required(),
        ),
        next_trade_params: trade_params::new(
            default_taker,
            default_maker,
            constants::default_stake_required(),
        ),
        voting_power: 0,
        quorum: 0,
    }
}

public(package) fun whitelisted(self: &Governance): bool {
    self.whitelisted
}

public(package) fun stable(self: &Governance): bool {
    self.stable
}

public(package) fun quorum(self: &Governance): u64 {
    self.quorum
}

/// Update the governance state. This is called at the start of every epoch.
public(package) fun update(self: &mut Governance, ctx: &TxContext) {
    let epoch = ctx.epoch();
    if (self.epoch == epoch) return;

    self.epoch = epoch;
    self.quorum = math::mul(self.voting_power, constants::half());
    self.proposals = vec_map::empty();
    self.trade_params = self.next_trade_params;

    event::emit(TradeParamsUpdateEvent {
        taker_fee: self.trade_params.taker_fee(),
        maker_fee: self.trade_params.maker_fee(),
        stake_required: self.trade_params.stake_required(),
    });
}

/// Add a new proposal to governance.
/// Check if proposer already voted, if so will give error.
/// If proposer has not voted, and there are already MAX_PROPOSALS proposals,
/// remove the proposal with the lowest votes if it has less votes than the
/// voting power.
/// Validation of the account adding is done in `State`.
public(package) fun add_proposal(
    self: &mut Governance,
    taker_fee: u64,
    maker_fee: u64,
    stake_required: u64,
    stake_amount: u64,
    balance_manager_id: ID,
) {
    assert!(!self.whitelisted, EWhitelistedPoolCannotChange);
    assert!(taker_fee % FEE_MULTIPLE == 0, EInvalidTakerFee);
    assert!(maker_fee % FEE_MULTIPLE == 0, EInvalidMakerFee);

    if (self.stable) {
        assert!(taker_fee >= MIN_TAKER_STABLE && taker_fee <= MAX_TAKER_STABLE, EInvalidTakerFee);
        assert!(maker_fee >= MIN_MAKER_STABLE && maker_fee <= MAX_MAKER_STABLE, EInvalidMakerFee);
    } else {
        assert!(
            taker_fee >= MIN_TAKER_VOLATILE && taker_fee <= MAX_TAKER_VOLATILE,
            EInvalidTakerFee,
        );
        assert!(
            maker_fee >= MIN_MAKER_VOLATILE && maker_fee <= MAX_MAKER_VOLATILE,
            EInvalidMakerFee,
        );
    };

    let voting_power = stake_to_voting_power(stake_amount);
    if (self.proposals.length() == MAX_PROPOSALS) {
        self.remove_lowest_proposal(voting_power);
    };

    let new_proposal = new_proposal(taker_fee, maker_fee, stake_required);
    self.proposals.insert(balance_manager_id, new_proposal);
}

/// Vote on a proposal. Validation of the account and stake is done in `State`.
/// If `from_proposal_id` is some, the account is removing their vote from that
/// proposal.
/// If `to_proposal_id` is some, the account is voting for that proposal.
public(package) fun adjust_vote(
    self: &mut Governance,
    from_proposal_id: Option<ID>,
    to_proposal_id: Option<ID>,
    stake_amount: u64,
) {
    let votes = stake_to_voting_power(stake_amount);

    if (
        from_proposal_id.is_some() && self
            .proposals
            .contains(from_proposal_id.borrow())
    ) {
        let proposal = &mut self.proposals[from_proposal_id.borrow()];
        proposal.votes = proposal.votes - votes;
        if (proposal.votes + votes > self.quorum && proposal.votes < self.quorum) {
            self.next_trade_params = self.trade_params;
        };
    };

    to_proposal_id.do_ref!(|proposal_id| {
        assert!(self.proposals.contains(proposal_id), EProposalDoesNotExist);

        let proposal = &mut self.proposals[proposal_id];
        proposal.votes = proposal.votes + votes;
        if (proposal.votes > self.quorum) {
            self.next_trade_params = proposal.to_trade_params();
        };
    });
}

/// Adjust the total voting power by adding and removing stake. For example, if
/// an account's
/// stake goes from 2000 to 3000, then `stake_before` is 2000 and `stake_after`
/// is 3000.
/// Validation of inputs done in `State`.
public(package) fun adjust_voting_power(
    self: &mut Governance,
    stake_before: u64,
    stake_after: u64,
) {
    self.voting_power =
        self.voting_power +
        stake_to_voting_power(stake_after) -
        stake_to_voting_power(stake_before);
}

public(package) fun trade_params(self: &Governance): TradeParams {
    self.trade_params
}

public(package) fun next_trade_params(self: &Governance): TradeParams {
    self.next_trade_params
}

// === Private Functions ===
/// Convert stake to voting power.
fun stake_to_voting_power(stake: u64): u64 {
    let mut voting_power = stake.min(VOTING_POWER_THRESHOLD);
    if (stake > VOTING_POWER_THRESHOLD) {
        voting_power =
            voting_power + math::sqrt(stake, constants::deep_unit()) -
            math::sqrt(VOTING_POWER_THRESHOLD, constants::deep_unit());
    };

    voting_power
}

fun new_proposal(taker_fee: u64, maker_fee: u64, stake_required: u64): Proposal {
    Proposal { taker_fee, maker_fee, stake_required, votes: 0 }
}

/// Remove the proposal with the lowest votes if it has less votes than the
/// voting power.
/// If there are multiple proposals with the same lowest votes, the latest one
/// is removed.
fun remove_lowest_proposal(self: &mut Governance, voting_power: u64) {
    let mut removal_id = option::none();
    let mut cur_lowest_votes = constants::max_u64();
    let (keys, values) = self.proposals.into_keys_values();

    self.proposals.length().do!(|i| {
        let proposal_votes = values[i].votes;
        if (proposal_votes < voting_power && proposal_votes <= cur_lowest_votes) {
            removal_id = option::some(keys[i]);
            cur_lowest_votes = proposal_votes;
        };
    });

    assert!(removal_id.is_some(), EMaxProposalsReachedNotEnoughVotes);
    self.proposals.remove(removal_id.borrow());
}

fun to_trade_params(proposal: &Proposal): TradeParams {
    trade_params::new(
        proposal.taker_fee,
        proposal.maker_fee,
        proposal.stake_required,
    )
}

// === Test Functions ===
#[test_only]
public fun voting_power(self: &Governance): u64 {
    self.voting_power
}

#[test_only]
public fun proposals(self: &Governance): VecMap<ID, Proposal> {
    self.proposals
}

#[test_only]
public fun votes(proposal: &Proposal): u64 {
    proposal.votes
}

#[test_only]
public fun params(proposal: &Proposal): (u64, u64, u64) {
    (proposal.taker_fee, proposal.maker_fee, proposal.stake_required)
}
// Copyright (c) Mysten Labs, Inc.
// SPDX-License-Identifier: Apache-2.0

/// State module represents the current state of the pool. It maintains all
/// the accounts, history, and governance information. It also processes all
/// the transactions and updates the state accordingly.
module deepbook::state;

use deepbook::{
    account::{Self, Account},
    balance_manager::BalanceManager,
    balances::{Self, Balances},
    constants,
    ewma::EWMAState,
    fill::Fill,
    governance::{Self, Governance},
    history::{Self, History},
    math,
    order::Order,
    order_info::OrderInfo
};
use std::type_name;
use sui::{event, table::{Self, Table}};
use token::deep::DEEP;

// === Errors ===
const ENoStake: u64 = 1;
const EMaxOpenOrders: u64 = 2;
const EAlreadyProposed: u64 = 3;

// === Structs ===
public struct State has store {
    accounts: Table<ID, Account>,
    history: History,
    governance: Governance,
}

public struct StakeEvent has copy, drop {
    pool_id: ID,
    balance_manager_id: ID,
    epoch: u64,
    amount: u64,
    stake: bool,
}

public struct ProposalEvent has copy, drop {
    pool_id: ID,
    balance_manager_id: ID,
    epoch: u64,
    taker_fee: u64,
    maker_fee: u64,
    stake_required: u64,
}

public struct VoteEvent has copy, drop {
    pool_id: ID,
    balance_manager_id: ID,
    epoch: u64,
    from_proposal_id: Option<ID>,
    to_proposal_id: ID,
    stake: u64,
}

public struct RebateEventV2 has copy, drop {
    pool_id: ID,
    balance_manager_id: ID,
    epoch: u64,
    claim_amount: Balances,
}

#[allow(unused_field)]
public struct RebateEvent has copy, drop {
    pool_id: ID,
    balance_manager_id: ID,
    epoch: u64,
    claim_amount: u64,
}

public(package) fun empty(whitelisted: bool, stable_pool: bool, ctx: &mut TxContext): State {
    let governance = governance::empty(
        whitelisted,
        stable_pool,
        ctx,
    );
    let trade_params = governance.trade_params();
    let history = history::empty(trade_params, ctx.epoch(), ctx);

    State { history, governance, accounts: table::new(ctx) }
}

/// Up until this point, an OrderInfo object has been created and potentially
/// filled. The OrderInfo object contains all of the necessary information to
/// update the state of the pool. This includes the volumes for the taker and
/// potentially multiple makers.
/// First, fills are iterated and processed, updating the appropriate user's
/// volumes. Funds are settled for those makers. Then, the taker's trading fee
/// is calculated and the taker's volumes are updated. Finally, the taker's
/// balances are settled.
public(package) fun process_create(
    self: &mut State,
    order_info: &mut OrderInfo,
    ewma_state: &EWMAState,
    pool_id: ID,
    ctx: &TxContext,
): (Balances, Balances) {
    self.governance.update(ctx);
    self.history.update(self.governance.trade_params(), pool_id, ctx);
    let fills = order_info.fills_ref();
    self.process_fills(fills, ctx);

    self.update_account(order_info.balance_manager_id(), ctx);
    let account = &mut self.accounts[order_info.balance_manager_id()];
    let account_volume = account.total_volume();
    let account_stake = account.active_stake();

    // avg exucuted price for taker
    let avg_executed_price = if (order_info.executed_quantity() > 0) {
        math::div(
            order_info.cumulative_quote_quantity(),
            order_info.executed_quantity(),
        )
    } else {
        0
    };
    let account_volume_in_deep = order_info
        .order_deep_price()
        .deep_quantity_u128(
            account_volume,
            math::mul_u128(account_volume, avg_executed_price as u128),
        );

    // taker fee will always be calculated as 0 for whitelisted pools by
    // default, as account_volume_in_deep is 0
    let taker_fee = self
        .governance
        .trade_params()
        .taker_fee_for_user(account_stake, account_volume_in_deep);
    let taker_fee = ewma_state.apply_taker_penalty(taker_fee, ctx);
    let maker_fee = self.governance.trade_params().maker_fee();

    if (order_info.order_inserted()) {
        assert!(account.open_orders().length() < constants::max_open_orders(), EMaxOpenOrders);
        account.add_order(order_info.order_id());
    };
    account.add_taker_volume(order_info.executed_quantity());

    let (mut settled, mut owed) = order_info.calculate_partial_fill_balances(
        taker_fee,
        maker_fee,
    );
    let (old_settled, old_owed) = account.settle();
    self.history.add_total_fees_collected(order_info.paid_fees_balances());
    settled.add_balances(old_settled);
    owed.add_balances(old_owed);

    (settled, owed)
}

public(package) fun withdraw_settled_amounts(
    self: &mut State,
    balance_manager_id: ID,
): (Balances, Balances) {
    if (self.accounts.contains(balance_manager_id)) {
        let account = &mut self.accounts[balance_manager_id];

        account.settle()
    } else {
        (balances::empty(), balances::empty())
    }
}

/// Update account settled balances and volumes.
/// Remove order from account orders.
public(package) fun process_cancel(
    self: &mut State,
    order: &mut Order,
    balance_manager_id: ID,
    pool_id: ID,
    ctx: &TxContext,
): (Balances, Balances) {
    self.governance.update(ctx);
    self.history.update(self.governance.trade_params(), pool_id, ctx);
    self.update_account(balance_manager_id, ctx);
    order.set_canceled();

    let epoch = order.epoch();
    let maker_fee = self.history.historic_maker_fee(epoch);
    let balances = order.calculate_cancel_refund(maker_fee, option::none());

    let account = &mut self.accounts[balance_manager_id];
    account.remove_order(order.order_id());
    account.add_settled_balances(balances);

    account.settle()
}

/// Given the modified quantity, update account settled balances and volumes.
public(package) fun process_modify(
    self: &mut State,
    balance_manager_id: ID,
    cancel_quantity: u64,
    order: &Order,
    pool_id: ID,
    ctx: &TxContext,
): (Balances, Balances) {
    self.governance.update(ctx);
    self.history.update(self.governance.trade_params(), pool_id, ctx);
    self.update_account(balance_manager_id, ctx);

    let epoch = order.epoch();
    let maker_fee = self.history.historic_maker_fee(epoch);
    let balances = order.calculate_cancel_refund(
        maker_fee,
        option::some(cancel_quantity),
    );

    self.accounts[balance_manager_id].add_settled_balances(balances);

    self.accounts[balance_manager_id].settle()
}

/// Process stake transaction. Add stake to account and update governance.
public(package) fun process_stake(
    self: &mut State,
    pool_id: ID,
    balance_manager_id: ID,
    new_stake: u64,
    ctx: &TxContext,
): (Balances, Balances) {
    self.governance.update(ctx);
    self.history.update(self.governance.trade_params(), pool_id, ctx);
    self.update_account(balance_manager_id, ctx);

    let (stake_before, stake_after) = self.accounts[balance_manager_id].add_stake(new_stake);
    self.governance.adjust_voting_power(stake_before, stake_after);
    event::emit(StakeEvent {
        pool_id,
        balance_manager_id,
        epoch: ctx.epoch(),
        amount: new_stake,
        stake: true,
    });

    self.accounts[balance_manager_id].settle()
}

/// Process unstake transaction.
/// Remove stake from account and update governance.
public(package) fun process_unstake(
    self: &mut State,
    pool_id: ID,
    balance_manager_id: ID,
    ctx: &TxContext,
): (Balances, Balances) {
    self.governance.update(ctx);
    self.history.update(self.governance.trade_params(), pool_id, ctx);
    self.update_account(balance_manager_id, ctx);

    let account = &mut self.accounts[balance_manager_id];
    let active_stake = account.active_stake();
    let inactive_stake = account.inactive_stake();
    let voted_proposal = account.voted_proposal();
    account.remove_stake();
    self.governance.adjust_voting_power(active_stake + inactive_stake, 0);
    self.governance.adjust_vote(voted_proposal, option::none(), active_stake);
    event::emit(StakeEvent {
        pool_id,
        balance_manager_id,
        epoch: ctx.epoch(),
        amount: active_stake + inactive_stake,
        stake: false,
    });

    account.settle()
}

/// Process proposal transaction. Add proposal to governance and update account.
public(package) fun process_proposal(
    self: &mut State,
    pool_id: ID,
    balance_manager_id: ID,
    taker_fee: u64,
    maker_fee: u64,
    stake_required: u64,
    ctx: &TxContext,
) {
    self.governance.update(ctx);
    self.history.update(self.governance.trade_params(), pool_id, ctx);
    self.update_account(balance_manager_id, ctx);
    let account = &mut self.accounts[balance_manager_id];
    let stake = account.active_stake();
    let proposal_created = account.created_proposal();

    assert!(stake > 0, ENoStake);
    assert!(!proposal_created, EAlreadyProposed);
    account.set_created_proposal(true);

    self
        .governance
        .add_proposal(
            taker_fee,
            maker_fee,
            stake_required,
            stake,
            balance_manager_id,
        );
    self.process_vote(pool_id, balance_manager_id, balance_manager_id, ctx);

    event::emit(ProposalEvent {
        pool_id,
        balance_manager_id,
        epoch: ctx.epoch(),
        taker_fee,
        maker_fee,
        stake_required,
    });
}

/// Process vote transaction. Update account voted proposal and governance.
public(package) fun process_vote(
    self: &mut State,
    pool_id: ID,
    balance_manager_id: ID,
    proposal_id: ID,
    ctx: &TxContext,
) {
    self.governance.update(ctx);
    self.history.update(self.governance.trade_params(), pool_id, ctx);
    self.update_account(balance_manager_id, ctx);

    let account = &mut self.accounts[balance_manager_id];
    assert!(account.active_stake() > 0, ENoStake);

    let prev_proposal = account.set_voted_proposal(option::some(proposal_id));
    self
        .governance
        .adjust_vote(
            prev_proposal,
            option::some(proposal_id),
            account.active_stake(),
        );

    event::emit(VoteEvent {
        pool_id,
        balance_manager_id,
        epoch: ctx.epoch(),
        from_proposal_id: prev_proposal,
        to_proposal_id: proposal_id,
        stake: account.active_stake(),
    });
}

/// Process claim rebates transaction.
/// Update account rebates and settle balances.
public(package) fun process_claim_rebates<BaseAsset, QuoteAsset>(
    self: &mut State,
    pool_id: ID,
    balance_manager: &BalanceManager,
    ctx: &TxContext,
): (Balances, Balances) {
    let balance_manager_id = balance_manager.id();
    self.governance.update(ctx);
    self.history.update(self.governance.trade_params(), pool_id, ctx);
    self.update_account(balance_manager_id, ctx);

    let account = &mut self.accounts[balance_manager_id];
    let claim_amount = account.claim_rebates();
    event::emit(RebateEventV2 {
        pool_id,
        balance_manager_id,
        epoch: ctx.epoch(),
        claim_amount,
    });
    balance_manager.emit_balance_event(
        type_name::with_defining_ids<DEEP>(),
        claim_amount.deep(),
        true,
    );
    balance_manager.emit_balance_event(
        type_name::with_defining_ids<BaseAsset>(),
        claim_amount.base(),
        true,
    );
    balance_manager.emit_balance_event(
        type_name::with_defining_ids<QuoteAsset>(),
        claim_amount.quote(),
        true,
    );

    account.settle()
}

public(package) fun governance(self: &State): &Governance {
    &self.governance
}

public(package) fun governance_mut(self: &mut State, ctx: &TxContext): &mut Governance {
    self.governance.update(ctx);

    &mut self.governance
}

public(package) fun account_exists(self: &State, balance_manager_id: ID): bool {
    self.accounts.contains(balance_manager_id)
}

public(package) fun account(self: &State, balance_manager_id: ID): &Account {
    &self.accounts[balance_manager_id]
}

public(package) fun history_mut(self: &mut State): &mut History {
    &mut self.history
}

public(package) fun history(self: &State): &History {
    &self.history
}

// === Private Functions ===
/// Process fills for all makers. Update maker accounts and history.
fun process_fills(self: &mut State, fills: &mut vector<Fill>, ctx: &TxContext) {
    let mut i = 0;
    let num_fills = fills.length();
    while (i < num_fills) {
        let fill = &mut fills[i];
        let maker = fill.balance_manager_id();
        self.update_account(maker, ctx);
        let account = &mut self.accounts[maker];
        account.process_maker_fill(fill);

        let base_volume = fill.base_quantity();
        let quote_volume = fill.quote_quantity();
        let historic_maker_fee = self.history.historic_maker_fee(fill.maker_epoch());
        let maker_is_bid = !fill.taker_is_bid();
        let mut fee_quantity = fill
            .maker_deep_price()
            .fee_quantity(base_volume, quote_volume, maker_is_bid);

        fee_quantity.mul(historic_maker_fee);

        if (!fill.expired()) {
            fill.set_fill_maker_fee(&fee_quantity);
            self.history.add_volume(base_volume, account.active_stake());
            self.history.add_total_fees_collected(fee_quantity);
        } else {
            account.add_settled_balances(fee_quantity);
        };

        i = i + 1;
    };
}

/// If account doesn't exist, create it. Update account volumes and rebates.
fun update_account(self: &mut State, balance_manager_id: ID, ctx: &TxContext) {
    if (!self.accounts.contains(balance_manager_id)) {
        self.accounts.add(balance_manager_id, account::empty(ctx));
    };

    let account = &mut self.accounts[balance_manager_id];
    let (prev_epoch, maker_volume, active_stake) = account.update(ctx);
    if (prev_epoch > 0 && maker_volume > 0 && active_stake > 0) {
        let rebates = self.history.calculate_rebate_amount(prev_epoch, maker_volume, active_stake);
        account.add_rebates(rebates);
    }
}
// Copyright (c) Mysten Labs, Inc.
// SPDX-License-Identifier: Apache-2.0

/// `Balances` represents the three assets make up a pool: base, quote, and
/// deep. Whenever funds are moved, they are moved in the form of `Balances`.
module deepbook::balances;

use deepbook::math;

// === Structs ===
public struct Balances has copy, drop, store {
    base: u64,
    quote: u64,
    deep: u64,
}

// === Public-Package Functions ===
public(package) fun empty(): Balances {
    Balances { base: 0, quote: 0, deep: 0 }
}

public(package) fun new(base: u64, quote: u64, deep: u64): Balances {
    Balances { base: base, quote: quote, deep: deep }
}

public(package) fun reset(balances: &mut Balances): Balances {
    let old = *balances;
    balances.base = 0;
    balances.quote = 0;
    balances.deep = 0;

    old
}

public(package) fun add_balances(balances: &mut Balances, other: Balances) {
    balances.base = balances.base + other.base;
    balances.quote = balances.quote + other.quote;
    balances.deep = balances.deep + other.deep;
}

public(package) fun add_base(balances: &mut Balances, base: u64) {
    balances.base = balances.base + base;
}

public(package) fun add_quote(balances: &mut Balances, quote: u64) {
    balances.quote = balances.quote + quote;
}

public(package) fun add_deep(balances: &mut Balances, deep: u64) {
    balances.deep = balances.deep + deep;
}

public(package) fun base(balances: &Balances): u64 {
    balances.base
}

public(package) fun quote(balances: &Balances): u64 {
    balances.quote
}

public(package) fun deep(balances: &Balances): u64 {
    balances.deep
}

public(package) fun mul(balances: &mut Balances, factor: u64) {
    balances.base = math::mul(balances.base, factor);
    balances.quote = math::mul(balances.quote, factor);
    balances.deep = math::mul(balances.deep, factor);
}

public(package) fun non_zero_value(balances: &Balances): u64 {
    if (balances.base > 0) {
        balances.base
    } else if (balances.quote > 0) {
        balances.quote
    } else {
        balances.deep
    }
}
// Copyright (c) Mysten Labs, Inc.
// SPDX-License-Identifier: Apache-2.0

/// TradeParams module contains the trade parameters for a trading pair.
module deepbook::trade_params;

// === Structs ===
public struct TradeParams has copy, drop, store {
    taker_fee: u64,
    maker_fee: u64,
    stake_required: u64,
}

// === Public-Package Functions ===
public(package) fun new(taker_fee: u64, maker_fee: u64, stake_required: u64): TradeParams {
    TradeParams { taker_fee, maker_fee, stake_required }
}

public(package) fun maker_fee(trade_params: &TradeParams): u64 {
    trade_params.maker_fee
}

public(package) fun taker_fee(trade_params: &TradeParams): u64 {
    trade_params.taker_fee
}

/// Returns the taker fee for a user based on the active stake and volume in deep.
/// Taker fee is halved if user has enough stake and volume.
public(package) fun taker_fee_for_user(
    self: &TradeParams,
    active_stake: u64,
    volume_in_deep: u128,
): u64 {
    if (
        active_stake >= self.stake_required &&
        volume_in_deep >= (self.stake_required as u128)
    ) {
        self.taker_fee / 2
    } else {
        self.taker_fee
    }
}

public(package) fun stake_required(trade_params: &TradeParams): u64 {
    trade_params.stake_required
}
// Copyright (c) Mysten Labs, Inc.
// SPDX-License-Identifier: Apache-2.0

/// History module tracks the volume data for the current epoch and past epochs.
/// It also tracks past trade params. Past maker fees are used to calculate
/// fills for old orders. The historic median is used to calculate rebates and
/// burns.
module deepbook::history;

use deepbook::{balances::{Self, Balances}, constants, math, trade_params::TradeParams};
use sui::{event, table::{Self, Table}};

// === Errors ===
const EHistoricVolumesNotFound: u64 = 0;

// === Structs ===
/// `Volumes` represents volume data for a single epoch.
/// Using flashloans on a whitelisted pool, assuming 1_000_000 * 1_000_000_000
/// in volume per trade, at 1 trade per millisecond, the total volume can reach
/// 1_000_000 * 1_000_000_000 * 1000 * 60 * 60 * 24 * 365 = 8.64e22 in one
/// epoch.
public struct Volumes has copy, drop, store {
    total_volume: u128,
    total_staked_volume: u128,
    total_fees_collected: Balances,
    historic_median: u128,
    trade_params: TradeParams,
}

/// `History` represents the volume data for the current epoch and past epochs.
public struct History has store {
    epoch: u64,
    epoch_created: u64,
    volumes: Volumes,
    historic_volumes: Table<u64, Volumes>,
    balance_to_burn: u64,
}

public struct EpochData has copy, drop, store {
    epoch: u64,
    pool_id: ID,
    total_volume: u128,
    total_staked_volume: u128,
    base_fees_collected: u64,
    quote_fees_collected: u64,
    deep_fees_collected: u64,
    historic_median: u128,
    taker_fee: u64,
    maker_fee: u64,
    stake_required: u64,
}

// === Public-Package Functions ===
/// Create a new `History` instance. Called once upon pool creation. A single
/// blank `Volumes` instance is created and added to the historic_volumes table.
public(package) fun empty(
    trade_params: TradeParams,
    epoch_created: u64,
    ctx: &mut TxContext,
): History {
    let volumes = Volumes {
        total_volume: 0,
        total_staked_volume: 0,
        total_fees_collected: balances::empty(),
        historic_median: 0,
        trade_params,
    };
    let mut history = History {
        epoch: ctx.epoch(),
        epoch_created,
        volumes,
        historic_volumes: table::new(ctx),
        balance_to_burn: 0,
    };
    history.historic_volumes.add(ctx.epoch(), volumes);

    history
}

/// Update the epoch if it has changed. If there are accounts with rebates,
/// add the current epoch's volume data to the historic volumes.
public(package) fun update(
    self: &mut History,
    trade_params: TradeParams,
    pool_id: ID,
    ctx: &TxContext,
) {
    let epoch = ctx.epoch();
    if (self.epoch == epoch) return;
    if (self.historic_volumes.contains(self.epoch)) {
        self.historic_volumes.remove(self.epoch);
    };
    self.update_historic_median();
    self.historic_volumes.add(self.epoch, self.volumes);

    event::emit(EpochData {
        epoch: self.epoch,
        pool_id,
        total_volume: self.volumes.total_volume,
        total_staked_volume: self.volumes.total_staked_volume,
        base_fees_collected: self.volumes.total_fees_collected.base(),
        quote_fees_collected: self.volumes.total_fees_collected.quote(),
        deep_fees_collected: self.volumes.total_fees_collected.deep(),
        historic_median: self.volumes.historic_median,
        taker_fee: trade_params.taker_fee(),
        maker_fee: trade_params.maker_fee(),
        stake_required: trade_params.stake_required(),
    });

    self.epoch = epoch;
    self.reset_volumes(trade_params);
    self.historic_volumes.add(self.epoch, self.volumes);
}

/// Reset the current epoch's volume data.
public(package) fun reset_volumes(self: &mut History, trade_params: TradeParams) {
    event::emit(self.volumes);
    self.volumes =
        Volumes {
            total_volume: 0,
            total_staked_volume: 0,
            total_fees_collected: balances::empty(),
            historic_median: 0,
            trade_params,
        };
}

/// Given the epoch's volume data and the account's volume data,
/// calculate and returns rebate amount, updates the burn amount.
public(package) fun calculate_rebate_amount(
    self: &mut History,
    prev_epoch: u64,
    maker_volume: u128,
    account_stake: u64,
): Balances {
    assert!(self.historic_volumes.contains(prev_epoch), EHistoricVolumesNotFound);
    let volumes = &mut self.historic_volumes[prev_epoch];
    if (volumes.trade_params.stake_required() > account_stake) {
        return balances::empty()
    };

    let maker_volume = maker_volume as u128;
    let other_maker_liquidity = volumes.total_volume - maker_volume;
    let maker_rebate_percentage = if (volumes.historic_median > 0) {
        constants::float_scaling_u128() - constants::float_scaling_u128().min(
            math::div_u128(other_maker_liquidity, volumes.historic_median),
        )
    } else {
        0
    };
    let maker_rebate_percentage = maker_rebate_percentage as u64;
    let maker_volume_proportion = if (volumes.total_staked_volume > 0) {
        (math::div_u128(maker_volume, volumes.total_staked_volume)) as u64
    } else {
        0
    };
    let mut max_rebates = volumes.total_fees_collected;
    max_rebates.mul(maker_volume_proportion); // Maximum rebates possible
    let mut rebates = max_rebates;
    rebates.mul(maker_rebate_percentage); // Actual rebates

    let maker_burn = max_rebates.deep() - rebates.deep();

    self.balance_to_burn = self.balance_to_burn + maker_burn;

    rebates
}

/// Updates the historic_median for past 28 epochs.
public(package) fun update_historic_median(self: &mut History) {
    let epochs_since_creation = self.epoch - self.epoch_created;
    if (epochs_since_creation < constants::phase_out_epochs()) {
        self.volumes.historic_median = constants::max_u128();
        return
    };
    let mut median_vec = vector<u128>[];
    let mut i = self.epoch - constants::phase_out_epochs();
    while (i < self.epoch) {
        if (self.historic_volumes.contains(i)) {
            median_vec.push_back(self.historic_volumes[i].total_volume);
        } else {
            median_vec.push_back(0);
        };
        i = i + 1;
    };

    self.volumes.historic_median = math::median(median_vec);
}

/// Add volume to the current epoch's volume data.
/// Increments the total volume and total staked volume.
public(package) fun add_volume(self: &mut History, maker_volume: u64, account_stake: u64) {
    if (maker_volume == 0) return;

    let maker_volume = maker_volume as u128;
    self.volumes.total_volume = self.volumes.total_volume + maker_volume;
    if (account_stake >= self.volumes.trade_params.stake_required()) {
        self.volumes.total_staked_volume = self.volumes.total_staked_volume + maker_volume;
    };
}

public(package) fun balance_to_burn(self: &History): u64 {
    self.balance_to_burn
}

public(package) fun reset_balance_to_burn(self: &mut History): u64 {
    let balance_to_burn = self.balance_to_burn;
    self.balance_to_burn = 0;

    balance_to_burn
}

public(package) fun historic_maker_fee(self: &History, epoch: u64): u64 {
    assert!(self.historic_volumes.contains(epoch), EHistoricVolumesNotFound);

    self.historic_volumes[epoch].trade_params.maker_fee()
}

public(package) fun add_total_fees_collected(self: &mut History, fees: Balances) {
    self.volumes.total_fees_collected.add_balances(fees);
}

// === Test Functions ===
#[test_only]
public fun set_current_volumes(
    history: &mut History,
    total_volume: u64,
    total_staked_volume: u64,
    total_fees_collected: Balances,
) {
    let total_volume = total_volume as u128;
    let total_staked_volume = total_staked_volume as u128;

    let volumes = &mut history.volumes;
    volumes.total_volume = total_volume;
    volumes.total_staked_volume = total_staked_volume;
    volumes.total_fees_collected = total_fees_collected;
}
// Copyright (c) Mysten Labs, Inc.
// SPDX-License-Identifier: Apache-2.0

/// Registry holds all created pools.
module deepbook::registry;

use deepbook::constants;
use std::type_name::{Self, TypeName};
use sui::{bag::{Self, Bag}, dynamic_field, vec_set::{Self, VecSet}, versioned::{Self, Versioned}};

// === Errors ===
const EPoolAlreadyExists: u64 = 1;
const EPoolDoesNotExist: u64 = 2;
const EPackageVersionNotEnabled: u64 = 3;
const EVersionNotEnabled: u64 = 4;
const EVersionAlreadyEnabled: u64 = 5;
const ECannotDisableCurrentVersion: u64 = 6;
const ECoinAlreadyWhitelisted: u64 = 7;
const ECoinNotWhitelisted: u64 = 8;

public struct REGISTRY has drop {}

// === Structs ===
/// DeepbookAdminCap is used to call admin functions.
public struct DeepbookAdminCap has key, store {
    id: UID,
}

public struct Registry has key {
    id: UID,
    inner: Versioned,
}

public struct RegistryInner has store {
    allowed_versions: VecSet<u64>,
    pools: Bag,
    treasury_address: address,
}

public struct PoolKey has copy, drop, store {
    base: TypeName,
    quote: TypeName,
}

public struct StableCoinKey has copy, drop, store {}

fun init(_: REGISTRY, ctx: &mut TxContext) {
    let registry_inner = RegistryInner {
        allowed_versions: vec_set::singleton(constants::current_version()),
        pools: bag::new(ctx),
        treasury_address: ctx.sender(),
    };
    let registry = Registry {
        id: object::new(ctx),
        inner: versioned::create(
            constants::current_version(),
            registry_inner,
            ctx,
        ),
    };
    transfer::share_object(registry);
    let admin = DeepbookAdminCap { id: object::new(ctx) };
    transfer::public_transfer(admin, ctx.sender());
}

// === Public Admin Functions ===
/// Sets the treasury address where the pool creation fees are sent
/// By default, the treasury address is the publisher of the deepbook package
public fun set_treasury_address(
    self: &mut Registry,
    treasury_address: address,
    _cap: &DeepbookAdminCap,
) {
    let self = self.load_inner_mut();
    self.treasury_address = treasury_address;
}

/// Enables a package version
/// Only Admin can enable a package version
/// This function does not have version restrictions
public fun enable_version(self: &mut Registry, version: u64, _cap: &DeepbookAdminCap) {
    let self: &mut RegistryInner = self.inner.load_value_mut();
    assert!(!self.allowed_versions.contains(&version), EVersionAlreadyEnabled);
    self.allowed_versions.insert(version);
}

/// Disables a package version
/// Only Admin can disable a package version
/// This function does not have version restrictions
public fun disable_version(self: &mut Registry, version: u64, _cap: &DeepbookAdminCap) {
    let self: &mut RegistryInner = self.inner.load_value_mut();
    assert!(version != constants::current_version(), ECannotDisableCurrentVersion);
    assert!(self.allowed_versions.contains(&version), EVersionNotEnabled);
    self.allowed_versions.remove(&version);
}

/// Adds a stablecoin to the whitelist
/// Only Admin can add stablecoin
public fun add_stablecoin<StableCoin>(self: &mut Registry, _cap: &DeepbookAdminCap) {
    let _: &mut RegistryInner = self.load_inner_mut();
    let stable_type = type_name::with_defining_ids<StableCoin>();
    if (
        !dynamic_field::exists_(
            &self.id,
            StableCoinKey {},
        )
    ) {
        dynamic_field::add(
            &mut self.id,
            StableCoinKey {},
            vec_set::singleton(stable_type),
        );
    } else {
        let stable_coins: &mut VecSet<TypeName> = dynamic_field::borrow_mut(
            &mut self.id,
            StableCoinKey {},
        );
        assert!(!stable_coins.contains(&stable_type), ECoinAlreadyWhitelisted);
        stable_coins.insert(stable_type);
    };
}

/// Removes a stablecoin from the whitelist
/// Only Admin can remove stablecoin
public fun remove_stablecoin<StableCoin>(self: &mut Registry, _cap: &DeepbookAdminCap) {
    let _: &mut RegistryInner = self.load_inner_mut();
    let stable_type = type_name::with_defining_ids<StableCoin>();
    assert!(
        dynamic_field::exists_(
            &self.id,
            StableCoinKey {},
        ),
        ECoinNotWhitelisted,
    );
    let stable_coins: &mut VecSet<TypeName> = dynamic_field::borrow_mut(
        &mut self.id,
        StableCoinKey {},
    );
    assert!(stable_coins.contains(&stable_type), ECoinNotWhitelisted);
    stable_coins.remove(&stable_type);
}

/// Returns whether the given coin is whitelisted
public fun is_stablecoin(self: &Registry, stable_type: TypeName): bool {
    let _: &RegistryInner = self.load_inner();
    if (
        !dynamic_field::exists_(
            &self.id,
            StableCoinKey {},
        )
    ) {
        false
    } else {
        let stable_coins: &VecSet<TypeName> = dynamic_field::borrow(
            &self.id,
            StableCoinKey {},
        );

        stable_coins.contains(&stable_type)
    }
}

// === Public-Package Functions ===
public(package) fun load_inner_mut(self: &mut Registry): &mut RegistryInner {
    let inner: &mut RegistryInner = self.inner.load_value_mut();
    let package_version = constants::current_version();
    assert!(inner.allowed_versions.contains(&package_version), EPackageVersionNotEnabled);

    inner
}

/// Register a new pool in the registry.
/// Asserts if (Base, Quote) pool already exists or
/// (Quote, Base) pool already exists.
public(package) fun register_pool<BaseAsset, QuoteAsset>(self: &mut Registry, pool_id: ID) {
    let self = self.load_inner_mut();
    let key = PoolKey {
        base: type_name::with_defining_ids<QuoteAsset>(),
        quote: type_name::with_defining_ids<BaseAsset>(),
    };
    assert!(!self.pools.contains(key), EPoolAlreadyExists);

    let key = PoolKey {
        base: type_name::with_defining_ids<BaseAsset>(),
        quote: type_name::with_defining_ids<QuoteAsset>(),
    };
    assert!(!self.pools.contains(key), EPoolAlreadyExists);

    self.pools.add(key, pool_id);
}

/// Only admin can call this function
public(package) fun unregister_pool<BaseAsset, QuoteAsset>(self: &mut Registry) {
    let self = self.load_inner_mut();
    let key = PoolKey {
        base: type_name::with_defining_ids<BaseAsset>(),
        quote: type_name::with_defining_ids<QuoteAsset>(),
    };
    assert!(self.pools.contains(key), EPoolDoesNotExist);
    self.pools.remove<PoolKey, ID>(key);
}

public(package) fun load_inner(self: &Registry): &RegistryInner {
    let inner: &RegistryInner = self.inner.load_value();
    let package_version = constants::current_version();
    assert!(inner.allowed_versions.contains(&package_version), EPackageVersionNotEnabled);

    inner
}

/// Get the pool id for the given base and quote assets.
public(package) fun get_pool_id<BaseAsset, QuoteAsset>(self: &Registry): ID {
    let self = self.load_inner();
    let key = PoolKey {
        base: type_name::with_defining_ids<BaseAsset>(),
        quote: type_name::with_defining_ids<QuoteAsset>(),
    };
    assert!(self.pools.contains(key), EPoolDoesNotExist);

    *self.pools.borrow<PoolKey, ID>(key)
}

/// Get the treasury address
public(package) fun treasury_address(self: &Registry): address {
    let self = self.load_inner();
    self.treasury_address
}

public(package) fun allowed_versions(self: &Registry): VecSet<u64> {
    let self = self.load_inner();

    self.allowed_versions
}

// === Test Functions ===
#[test_only]
public fun test_registry(ctx: &mut TxContext): ID {
    let registry_inner = RegistryInner {
        allowed_versions: vec_set::singleton(constants::current_version()),
        pools: bag::new(ctx),
        treasury_address: ctx.sender(),
    };
    let registry = Registry {
        id: object::new(ctx),
        inner: versioned::create(
            constants::current_version(),
            registry_inner,
            ctx,
        ),
    };
    let id = object::id(&registry);
    transfer::share_object(registry);

    id
}

#[test_only]
public fun get_admin_cap_for_testing(ctx: &mut TxContext): DeepbookAdminCap {
    DeepbookAdminCap { id: object::new(ctx) }
}
// Copyright (c) Mysten Labs, Inc.
// SPDX-License-Identifier: Apache-2.0

/// This module defines the OrderPage struct and its methods to iterate over orders in a pool.
module deepbook::order_query;

use deepbook::{big_vector::slice_borrow, constants, order::Order, pool::Pool};

// === Structs ===
public struct OrderPage has drop {
    orders: vector<Order>,
    has_next_page: bool,
}

// === Public Functions ===
/// Bid minimum order id has 0 for its first bit, 0 for next 63 bits for price, and 1 for next 64 bits for order id.
/// Ask minimum order id has 1 for its first bit, 0 for next 63 bits for price, and 0 for next 64 bits for order id.
/// Bids are iterated from high to low order id, and asks are iterated from low to high order id.
public fun iter_orders<BaseAsset, QuoteAsset>(
    self: &Pool<BaseAsset, QuoteAsset>,
    start_order_id: Option<u128>,
    end_order_id: Option<u128>,
    min_expire_timestamp: Option<u64>,
    limit: u64,
    bids: bool,
): OrderPage {
    let self = self.load_inner();
    let bid_min_order_id = 0;
    let bid_max_order_id = 1u128 << 127;

    let ask_min_order_id = 1u128 << 127;
    let ask_max_order_id = constants::max_u128();

    let start = start_order_id.get_with_default({
        if (bids) bid_max_order_id else ask_min_order_id
    });

    let end = end_order_id.get_with_default({
        if (bids) bid_min_order_id else ask_max_order_id
    });

    let min_expire = min_expire_timestamp.get_with_default(0);
    let side = if (bids) self.bids() else self.asks();
    let mut orders = vector[];
    let (mut ref, mut offset) = if (bids) {
        side.slice_before(start)
    } else {
        side.slice_following(start)
    };

    while (!ref.is_null() && orders.length() < limit) {
        let order = slice_borrow(side.borrow_slice(ref), offset);
        if (bids && order.order_id() < end) break;
        if (!bids && order.order_id() > end) break;
        if (order.expire_timestamp() >= min_expire) {
            orders.push_back(order.copy_order());
        };

        (ref, offset) = if (bids) side.prev_slice(ref, offset) else side.next_slice(ref, offset);
    };

    OrderPage {
        orders: orders,
        has_next_page: !ref.is_null(),
    }
}

public fun orders(self: &OrderPage): &vector<Order> {
    &self.orders
}

public fun has_next_page(self: &OrderPage): bool {
    self.has_next_page
}
// Copyright (c) Mysten Labs, Inc.
// SPDX-License-Identifier: Apache-2.0

/// Order module defines the order struct and its methods.
/// All order matching happens in this module.
module deepbook::order_info;

use deepbook::{
    balances::{Self, Balances},
    constants,
    deep_price::OrderDeepPrice,
    fill::Fill,
    math,
    order::{Self, Order}
};
use sui::event;

// === Errors ===
const EOrderInvalidPrice: u64 = 0;
const EOrderBelowMinimumSize: u64 = 1;
const EOrderInvalidLotSize: u64 = 2;
const EInvalidExpireTimestamp: u64 = 3;
const EInvalidOrderType: u64 = 4;
const EPOSTOrderCrossesOrderbook: u64 = 5;
const EFOKOrderCannotBeFullyFilled: u64 = 6;
const EMarketOrderCannotBePostOnly: u64 = 7;
const ESelfMatchingCancelTaker: u64 = 8;

// === Structs ===
/// OrderInfo struct represents all order information.
/// This objects gets created at the beginning of the order lifecycle and
/// gets updated until it is completed or placed in the book.
/// It is returned at the end of the order lifecycle.
public struct OrderInfo has copy, drop, store {
    // ID of the pool
    pool_id: ID,
    // ID of the order within the pool
    order_id: u128,
    // ID of the account the order uses
    balance_manager_id: ID,
    // ID of the order defined by client
    client_order_id: u64,
    // Trader of the order
    trader: address,
    // Order type, NO_RESTRICTION, IMMEDIATE_OR_CANCEL, FILL_OR_KILL, POST_ONLY
    order_type: u8,
    // Self matching option,
    self_matching_option: u8,
    // Price, only used for limit orders
    price: u64,
    // Whether the order is a buy or a sell
    is_bid: bool,
    // Quantity (in base asset terms) when the order is placed
    original_quantity: u64,
    // Deep conversion used by the order
    order_deep_price: OrderDeepPrice,
    // Expiration timestamp in ms
    expire_timestamp: u64,
    // Quantity executed so far
    executed_quantity: u64,
    // Cumulative quote quantity executed so far
    cumulative_quote_quantity: u64,
    // Any partial fills
    fills: vector<Fill>,
    // Whether the fee is in DEEP terms
    fee_is_deep: bool,
    // Fees paid so far in base/quote/DEEP terms for taker orders
    paid_fees: u64,
    // Fees transferred to pool vault but not yet paid for maker order
    maker_fees: u64,
    // Epoch this order was placed
    epoch: u64,
    // Status of the order
    status: u8,
    // Is a market_order
    market_order: bool,
    // Executed in one transaction
    fill_limit_reached: bool,
    // Whether order is inserted
    order_inserted: bool,
    // Order Timestamp
    timestamp: u64,
}

/// Emitted when a maker order is filled.
public struct OrderFilled has copy, drop, store {
    pool_id: ID,
    maker_order_id: u128,
    taker_order_id: u128,
    maker_client_order_id: u64,
    taker_client_order_id: u64,
    price: u64,
    taker_is_bid: bool,
    taker_fee: u64,
    taker_fee_is_deep: bool,
    maker_fee: u64,
    maker_fee_is_deep: bool,
    base_quantity: u64,
    quote_quantity: u64,
    maker_balance_manager_id: ID,
    taker_balance_manager_id: ID,
    timestamp: u64,
}

/// Emitted when a maker order is injected into the order book.
public struct OrderPlaced has copy, drop, store {
    balance_manager_id: ID,
    pool_id: ID,
    order_id: u128,
    client_order_id: u64,
    trader: address,
    price: u64,
    is_bid: bool,
    placed_quantity: u64,
    expire_timestamp: u64,
    timestamp: u64,
}

/// Emitted when a maker order is expired.
public struct OrderExpired has copy, drop, store {
    balance_manager_id: ID,
    pool_id: ID,
    order_id: u128,
    client_order_id: u64,
    trader: address, // trader that expired the order
    price: u64,
    is_bid: bool,
    original_quantity: u64,
    base_asset_quantity_canceled: u64,
    timestamp: u64,
}

// === Public-View Functions ===
public fun pool_id(self: &OrderInfo): ID {
    self.pool_id
}

public fun order_id(self: &OrderInfo): u128 {
    self.order_id
}

public fun balance_manager_id(self: &OrderInfo): ID {
    self.balance_manager_id
}

public fun client_order_id(self: &OrderInfo): u64 {
    self.client_order_id
}

public fun trader(self: &OrderInfo): address {
    self.trader
}

public fun order_type(self: &OrderInfo): u8 {
    self.order_type
}

public fun self_matching_option(self: &OrderInfo): u8 {
    self.self_matching_option
}

public fun price(self: &OrderInfo): u64 {
    self.price
}

public fun is_bid(self: &OrderInfo): bool {
    self.is_bid
}

public fun original_quantity(self: &OrderInfo): u64 {
    self.original_quantity
}

public fun order_deep_price(self: &OrderInfo): OrderDeepPrice {
    self.order_deep_price
}

public fun expire_timestamp(self: &OrderInfo): u64 {
    self.expire_timestamp
}

public fun executed_quantity(self: &OrderInfo): u64 {
    self.executed_quantity
}

public fun cumulative_quote_quantity(self: &OrderInfo): u64 {
    self.cumulative_quote_quantity
}

public fun fills(self: &OrderInfo): vector<Fill> {
    self.fills
}

public fun fee_is_deep(self: &OrderInfo): bool {
    self.fee_is_deep
}

public fun paid_fees(self: &OrderInfo): u64 {
    self.paid_fees
}

public fun maker_fees(self: &OrderInfo): u64 {
    self.maker_fees
}

public fun epoch(self: &OrderInfo): u64 {
    self.epoch
}

public fun status(self: &OrderInfo): u8 {
    self.status
}

public fun fill_limit_reached(self: &OrderInfo): bool {
    self.fill_limit_reached
}

public fun order_inserted(self: &OrderInfo): bool {
    self.order_inserted
}

// === Public-Package Functions ===
public(package) fun new(
    pool_id: ID,
    balance_manager_id: ID,
    client_order_id: u64,
    trader: address,
    order_type: u8,
    self_matching_option: u8,
    price: u64,
    quantity: u64,
    is_bid: bool,
    fee_is_deep: bool,
    epoch: u64,
    expire_timestamp: u64,
    order_deep_price: OrderDeepPrice,
    market_order: bool,
    timestamp: u64,
): OrderInfo {
    OrderInfo {
        pool_id,
        order_id: 0,
        balance_manager_id,
        client_order_id,
        trader,
        order_type,
        self_matching_option,
        price,
        is_bid,
        original_quantity: quantity,
        order_deep_price,
        expire_timestamp,
        executed_quantity: 0,
        cumulative_quote_quantity: 0,
        fills: vector[],
        fee_is_deep,
        epoch,
        paid_fees: 0,
        maker_fees: 0,
        status: constants::live(),
        market_order,
        fill_limit_reached: false,
        order_inserted: false,
        timestamp,
    }
}

public(package) fun taker_fee(self: &OrderInfo): u64 {
    if (self.fills.length() > 0) {
        self.fills[0].taker_fee()
    } else {
        0
    }
}

public(package) fun market_order(self: &OrderInfo): bool {
    self.market_order
}

public(package) fun set_order_id(self: &mut OrderInfo, order_id: u128) {
    self.order_id = order_id;
}

public(package) fun set_paid_fees(self: &mut OrderInfo, paid_fees: u64) {
    self.paid_fees = paid_fees;
}

public(package) fun add_fill(self: &mut OrderInfo, fill: Fill) {
    self.fills.push_back(fill);
}

public(package) fun fills_ref(self: &mut OrderInfo): &mut vector<Fill> {
    &mut self.fills
}

public(package) fun paid_fees_balances(self: &OrderInfo): Balances {
    if (self.fee_is_deep) {
        balances::new(0, 0, self.paid_fees)
    } else if (self.is_bid) {
        balances::new(0, self.paid_fees, 0)
    } else {
        balances::new(self.paid_fees, 0, 0)
    }
}

/// Given a partially filled `OrderInfo`, the taker fee and maker fee, for the user
/// placing the order, calculate all of the balances that need to be settled and
/// the balances that are owed. The executed quantity is multiplied by the taker_fee
/// and the remaining quantity is multiplied by the maker_fee to get the DEEP fee.
public(package) fun calculate_partial_fill_balances(
    self: &mut OrderInfo,
    taker_fee: u64,
    maker_fee: u64,
): (Balances, Balances) {
    let mut taker_fee_quantity = self
        .order_deep_price
        .fee_quantity(
            self.executed_quantity,
            self.cumulative_quote_quantity,
            self.is_bid,
        );
    taker_fee_quantity.mul(taker_fee);
    self.paid_fees = taker_fee_quantity.non_zero_value();

    let fills = &mut self.fills;
    let mut i = 0;
    let num_fills = fills.length();
    while (i < num_fills) {
        let fill = &mut fills[i];
        if (!fill.expired()) {
            let base_quantity = fill.base_quantity();
            let quote_quantity = fill.quote_quantity();
            let mut fill_taker_fee_quantity = self
                .order_deep_price
                .fee_quantity(
                    base_quantity,
                    quote_quantity,
                    self.is_bid,
                );
            fill_taker_fee_quantity.mul(taker_fee);
            fill.set_fill_taker_fee(&fill_taker_fee_quantity);
        };

        i = i + 1;
    };

    let mut settled_balances = balances::new(0, 0, 0);
    let mut owed_balances = balances::new(0, 0, 0);
    owed_balances.add_balances(taker_fee_quantity);

    if (self.is_bid) {
        settled_balances.add_base(self.executed_quantity);
        owed_balances.add_quote(self.cumulative_quote_quantity);
    } else {
        settled_balances.add_quote(self.cumulative_quote_quantity);
        owed_balances.add_base(self.executed_quantity);
    };

    let remaining_quantity = self.remaining_quantity();
    if (self.order_inserted()) {
        let mut maker_fee_quantity = self
            .order_deep_price
            .fee_quantity(
                remaining_quantity,
                math::mul(remaining_quantity, self.price()),
                self.is_bid,
            );
        maker_fee_quantity.mul(maker_fee);
        self.maker_fees = maker_fee_quantity.non_zero_value();
        owed_balances.add_balances(maker_fee_quantity);
        if (self.is_bid) {
            owed_balances.add_quote(
                math::mul(remaining_quantity, self.price()),
            );
        } else {
            owed_balances.add_base(remaining_quantity);
        };
    };

    (settled_balances, owed_balances)
}

/// `OrderInfo` is converted to an `Order` before being injected into the order book.
/// This is done to save space in the order book. Order contains the minimum
/// information required to match orders.
public(package) fun to_order(self: &OrderInfo): Order {
    order::new(
        self.order_id,
        self.balance_manager_id,
        self.client_order_id,
        self.original_quantity,
        self.executed_quantity,
        self.fee_is_deep,
        self.order_deep_price,
        self.epoch,
        self.status,
        self.expire_timestamp,
    )
}

/// Validates that the initial order created meets the pool requirements.
public(package) fun validate_inputs(
    order_info: &OrderInfo,
    tick_size: u64,
    min_size: u64,
    lot_size: u64,
    timestamp: u64,
) {
    assert!(order_info.original_quantity >= min_size, EOrderBelowMinimumSize);
    assert!(order_info.original_quantity % lot_size == 0, EOrderInvalidLotSize);
    assert!(timestamp <= order_info.expire_timestamp, EInvalidExpireTimestamp);
    assert!(
        order_info.order_type >= constants::no_restriction() &&
        order_info.order_type <= constants::max_restriction(),
        EInvalidOrderType,
    );
    if (order_info.market_order) {
        assert!(order_info.order_type != constants::post_only(), EMarketOrderCannotBePostOnly);
        return
    };
    assert!(
        order_info.price >= constants::min_price() &&
        order_info.price <= constants::max_price(),
        EOrderInvalidPrice,
    );
    assert!(order_info.price % tick_size == 0, EOrderInvalidPrice);
}

/// Assert order types after partial fill against the order book.
public(package) fun assert_execution(self: &mut OrderInfo): bool {
    if (self.order_type == constants::post_only()) {
        assert!(self.executed_quantity == 0, EPOSTOrderCrossesOrderbook)
    };
    if (self.order_type == constants::fill_or_kill()) {
        assert!(self.executed_quantity == self.original_quantity, EFOKOrderCannotBeFullyFilled)
    };
    if (self.order_type == constants::immediate_or_cancel()) {
        if (self.remaining_quantity() > 0) {
            self.status = constants::canceled();
        } else {
            self.status = constants::filled();
        };

        return true
    };

    if (self.remaining_quantity() == 0) {
        self.status = constants::filled();

        return true
    };

    if (self.fill_limit_reached) {
        return true
    };

    false
}

/// Returns the remaining quantity for the order.
public(package) fun remaining_quantity(self: &OrderInfo): u64 {
    self.original_quantity - self.executed_quantity
}

/// Returns true if two opposite orders are overlapping in price.
public(package) fun can_match(self: &OrderInfo, order: &Order): bool {
    let maker_price = order.price();

    (
        self.original_quantity - self.executed_quantity > 0 && (
            self.is_bid && self.price >= maker_price ||
            !self.is_bid && self.price <= maker_price,
        ),
    )
}

/// Matches an `OrderInfo` with an `Order` from the book. Appends a `Fill` to fills.
/// If the book order is expired, the `Fill` will have the expired flag set to true.
/// Funds for the match or an expired order are returned to the maker as settled.
public(package) fun match_maker(self: &mut OrderInfo, maker: &mut Order, timestamp: u64): bool {
    if (!self.can_match(maker)) return false;

    if (self.self_matching_option() == constants::cancel_taker()) {
        assert!(maker.balance_manager_id() != self.balance_manager_id(), ESelfMatchingCancelTaker);
    };
    let expire_maker =
        self.self_matching_option() == constants::cancel_maker() &&
        maker.balance_manager_id() == self.balance_manager_id();
    let fill = maker.generate_fill(
        timestamp,
        self.remaining_quantity(),
        self.is_bid,
        expire_maker,
        self.fee_is_deep,
    );
    self.fills.push_back(fill);
    if (fill.expired()) return true;

    self.executed_quantity = self.executed_quantity + fill.base_quantity();
    self.cumulative_quote_quantity = self.cumulative_quote_quantity + fill.quote_quantity();
    self.status = constants::partially_filled();
    if (self.remaining_quantity() == 0) self.status = constants::filled();

    true
}

/// Emit all fills for this order in a vector of `OrderFilled` events.
/// To avoid DOS attacks, 100 fills are emitted at a time. Up to 10,000
/// fills can be emitted in a single call.
public(package) fun emit_orders_filled(self: &OrderInfo, timestamp: u64) {
    let mut i = 0;
    let num_fills = self.fills.length();
    while (i < num_fills) {
        let fill = &self.fills[i];
        if (!fill.expired()) {
            event::emit(self.order_filled_from_fill(fill, timestamp));
        } else {
            let cancel_maker = self.balance_manager_id() == fill.balance_manager_id();
            if (cancel_maker) {
                self.emit_order_canceled_maker_from_fill(fill, timestamp);
            } else {
                event::emit(self.order_expired_from_fill(fill, timestamp));
            };
        };
        i = i + 1;
    };
}

public(package) fun emit_order_placed(self: &OrderInfo) {
    event::emit(OrderPlaced {
        balance_manager_id: self.balance_manager_id,
        pool_id: self.pool_id,
        order_id: self.order_id,
        client_order_id: self.client_order_id,
        is_bid: self.is_bid,
        trader: self.trader,
        placed_quantity: self.remaining_quantity(),
        price: self.price,
        expire_timestamp: self.expire_timestamp,
        timestamp: self.timestamp,
    });
}

public(package) fun emit_order_info(self: &OrderInfo) {
    event::emit(*self);
}

public(package) fun set_fill_limit_reached(self: &mut OrderInfo) {
    self.fill_limit_reached = true;
}

public(package) fun set_order_inserted(self: &mut OrderInfo) {
    self.order_inserted = true;
}

// === Private Functions ===
fun order_filled_from_fill(self: &OrderInfo, fill: &Fill, timestamp: u64): OrderFilled {
    OrderFilled {
        pool_id: self.pool_id,
        maker_order_id: fill.maker_order_id(),
        taker_order_id: self.order_id,
        maker_client_order_id: fill.maker_client_order_id(),
        taker_client_order_id: self.client_order_id,
        price: fill.execution_price(),
        taker_is_bid: self.is_bid,
        taker_fee: fill.taker_fee(),
        taker_fee_is_deep: fill.taker_fee_is_deep(),
        maker_fee: fill.maker_fee(),
        maker_fee_is_deep: fill.maker_fee_is_deep(),
        base_quantity: fill.base_quantity(),
        quote_quantity: fill.quote_quantity(),
        maker_balance_manager_id: fill.balance_manager_id(),
        taker_balance_manager_id: self.balance_manager_id,
        timestamp,
    }
}

fun order_expired_from_fill(self: &OrderInfo, fill: &Fill, timestamp: u64): OrderExpired {
    OrderExpired {
        balance_manager_id: fill.balance_manager_id(),
        pool_id: self.pool_id,
        order_id: fill.maker_order_id(),
        client_order_id: fill.maker_client_order_id(),
        trader: self.trader(),
        price: fill.execution_price(),
        is_bid: !self.is_bid(),
        original_quantity: fill.original_maker_quantity(),
        base_asset_quantity_canceled: fill.base_quantity(),
        timestamp,
    }
}

fun emit_order_canceled_maker_from_fill(self: &OrderInfo, fill: &Fill, timestamp: u64) {
    order::emit_cancel_maker(
        fill.balance_manager_id(),
        self.pool_id,
        fill.maker_order_id(),
        fill.maker_client_order_id(),
        self.trader(),
        fill.execution_price(),
        !self.is_bid(),
        fill.original_maker_quantity(),
        fill.base_quantity(),
        timestamp,
    )
}
// Copyright (c) Mysten Labs, Inc.
// SPDX-License-Identifier: Apache-2.0

/// Order module defines the order struct and its methods.
/// All order matching happens in this module.
module deepbook::order;

use deepbook::{
    balances::{Self, Balances},
    constants,
    deep_price::OrderDeepPrice,
    fill::{Self, Fill},
    math,
    utils
};
use sui::event;

// === Errors ===
const EInvalidNewQuantity: u64 = 0;
const EOrderExpired: u64 = 1;

// === Structs ===
/// Order struct represents the order in the order book. It is optimized for space.
public struct Order has drop, store {
    balance_manager_id: ID,
    order_id: u128,
    client_order_id: u64,
    quantity: u64,
    filled_quantity: u64,
    fee_is_deep: bool,
    order_deep_price: OrderDeepPrice,
    epoch: u64,
    status: u8,
    expire_timestamp: u64,
}

/// Emitted when a maker order is canceled.
public struct OrderCanceled has copy, drop, store {
    balance_manager_id: ID,
    pool_id: ID,
    order_id: u128,
    client_order_id: u64,
    trader: address,
    price: u64,
    is_bid: bool,
    original_quantity: u64,
    base_asset_quantity_canceled: u64,
    timestamp: u64,
}

/// Emitted when a maker order is modified.
public struct OrderModified has copy, drop, store {
    balance_manager_id: ID,
    pool_id: ID,
    order_id: u128,
    client_order_id: u64,
    trader: address,
    price: u64,
    is_bid: bool,
    previous_quantity: u64,
    filled_quantity: u64,
    new_quantity: u64,
    timestamp: u64,
}

// === Public-View Functions ===
public fun balance_manager_id(self: &Order): ID {
    self.balance_manager_id
}

public fun order_id(self: &Order): u128 {
    self.order_id
}

public fun client_order_id(self: &Order): u64 {
    self.client_order_id
}

public fun quantity(self: &Order): u64 {
    self.quantity
}

public fun filled_quantity(self: &Order): u64 {
    self.filled_quantity
}

public fun fee_is_deep(self: &Order): bool {
    self.fee_is_deep
}

public fun order_deep_price(self: &Order): &OrderDeepPrice {
    &self.order_deep_price
}

public fun epoch(self: &Order): u64 {
    self.epoch
}

public fun status(self: &Order): u8 {
    self.status
}

public fun expire_timestamp(self: &Order): u64 {
    self.expire_timestamp
}

public fun price(self: &Order): u64 {
    let (_, price, _) = utils::decode_order_id(self.order_id);

    price
}

// === Public-Package Functions ===
/// initialize the order struct.
public(package) fun new(
    order_id: u128,
    balance_manager_id: ID,
    client_order_id: u64,
    quantity: u64,
    filled_quantity: u64,
    fee_is_deep: bool,
    order_deep_price: OrderDeepPrice,
    epoch: u64,
    status: u8,
    expire_timestamp: u64,
): Order {
    Order {
        order_id,
        balance_manager_id,
        client_order_id,
        quantity,
        filled_quantity,
        fee_is_deep,
        order_deep_price,
        epoch,
        status,
        expire_timestamp,
    }
}

/// Generate a fill for the resting order given the timestamp,
/// quantity and whether the order is a bid.
public(package) fun generate_fill(
    self: &mut Order,
    timestamp: u64,
    quantity: u64,
    is_bid: bool,
    expire_maker: bool,
    taker_fee_is_deep: bool,
): Fill {
    let remaining_quantity = self.quantity - self.filled_quantity;
    let mut base_quantity = remaining_quantity.min(quantity);
    let mut quote_quantity = math::mul(base_quantity, self.price());

    let order_id = self.order_id;
    let balance_manager_id = self.balance_manager_id;
    let expired = timestamp > self.expire_timestamp || expire_maker;

    if (expired) {
        self.status = constants::expired();
        base_quantity = remaining_quantity;
        quote_quantity = math::mul(base_quantity, self.price());
    } else {
        self.filled_quantity = self.filled_quantity + base_quantity;
        self.status = if (self.quantity == self.filled_quantity) constants::filled()
        else constants::partially_filled();
    };

    fill::new(
        order_id,
        self.client_order_id,
        self.price(),
        balance_manager_id,
        expired,
        self.quantity == self.filled_quantity,
        self.quantity,
        base_quantity,
        quote_quantity,
        is_bid,
        self.epoch,
        self.order_deep_price,
        taker_fee_is_deep,
        self.fee_is_deep,
    )
}

/// Modify the order with a new quantity. The new quantity must be greater
/// than the filled quantity and less than the original quantity. The
/// timestamp must be less than the expire timestamp.
public(package) fun modify(self: &mut Order, new_quantity: u64, timestamp: u64) {
    assert!(
        new_quantity > self.filled_quantity &&
        new_quantity < self.quantity,
        EInvalidNewQuantity,
    );
    assert!(timestamp <= self.expire_timestamp, EOrderExpired);
    self.quantity = new_quantity;
}

/// Calculate the refund for a canceled order. The refund is any
/// unfilled quantity and the maker fee. If the cancel quantity is
/// not provided, the remaining quantity is used. Cancel quantity is
/// provided when modifying an order, so that the refund can be calculated
/// based on the quantity that's reduced.
public(package) fun calculate_cancel_refund(
    self: &Order,
    maker_fee: u64,
    cancel_quantity: Option<u64>,
): Balances {
    let cancel_quantity = cancel_quantity.get_with_default(
        self.quantity - self.filled_quantity,
    );
    let mut fee_quantity = self
        .order_deep_price
        .fee_quantity(
            cancel_quantity,
            math::mul(cancel_quantity, self.price()),
            self.is_bid(),
        );
    fee_quantity.mul(maker_fee);

    let mut base_out = 0;
    let mut quote_out = 0;
    if (self.is_bid()) {
        quote_out = math::mul(cancel_quantity, self.price());
    } else {
        base_out = cancel_quantity;
    };

    let mut refund = balances::new(base_out, quote_out, 0);
    refund.add_balances(fee_quantity);

    refund
}

public(package) fun locked_balance(self: &Order, maker_fee: u64): Balances {
    let (is_bid, order_price, _) = utils::decode_order_id(self.order_id());
    let mut base_quantity = 0;
    let mut quote_quantity = 0;
    let remaining_base_quantity = self.quantity() - self.filled_quantity();
    let remaining_quote_quantity = math::mul(
        remaining_base_quantity,
        order_price,
    );

    if (is_bid) {
        quote_quantity = quote_quantity + remaining_quote_quantity;
    } else {
        base_quantity = base_quantity + remaining_base_quantity;
    };
    let mut fee_quantity = self
        .order_deep_price()
        .fee_quantity(
            remaining_base_quantity,
            remaining_quote_quantity,
            is_bid,
        );
    fee_quantity.mul(maker_fee);

    let mut locked_balance = balances::new(base_quantity, quote_quantity, 0);
    locked_balance.add_balances(fee_quantity);

    locked_balance
}

public(package) fun emit_order_canceled(
    self: &Order,
    pool_id: ID,
    trader: address,
    timestamp: u64,
) {
    let is_bid = self.is_bid();
    let price = self.price();
    let remaining_quantity = self.quantity - self.filled_quantity;
    event::emit(OrderCanceled {
        pool_id,
        order_id: self.order_id,
        balance_manager_id: self.balance_manager_id,
        client_order_id: self.client_order_id,
        is_bid,
        trader,
        original_quantity: self.quantity,
        base_asset_quantity_canceled: remaining_quantity,
        timestamp,
        price,
    });
}

public(package) fun emit_order_modified(
    self: &Order,
    pool_id: ID,
    previous_quantity: u64,
    trader: address,
    timestamp: u64,
) {
    let is_bid = self.is_bid();
    let price = self.price();
    event::emit(OrderModified {
        order_id: self.order_id,
        pool_id,
        client_order_id: self.client_order_id,
        balance_manager_id: self.balance_manager_id,
        trader,
        price,
        is_bid,
        previous_quantity,
        filled_quantity: self.filled_quantity,
        new_quantity: self.quantity,
        timestamp,
    });
}

public(package) fun emit_cancel_maker(
    balance_manager_id: ID,
    pool_id: ID,
    order_id: u128,
    client_order_id: u64,
    trader: address,
    price: u64,
    is_bid: bool,
    original_quantity: u64,
    base_asset_quantity_canceled: u64,
    timestamp: u64,
) {
    event::emit(OrderCanceled {
        balance_manager_id,
        pool_id,
        order_id,
        client_order_id,
        trader,
        price,
        is_bid,
        original_quantity,
        base_asset_quantity_canceled,
        timestamp,
    });
}

/// Copy the order struct.
public(package) fun copy_order(order: &Order): Order {
    Order {
        order_id: order.order_id,
        balance_manager_id: order.balance_manager_id,
        client_order_id: order.client_order_id,
        quantity: order.quantity,
        filled_quantity: order.filled_quantity,
        fee_is_deep: order.fee_is_deep,
        order_deep_price: order.order_deep_price,
        epoch: order.epoch,
        status: order.status,
        expire_timestamp: order.expire_timestamp,
    }
}

/// Update the order status to canceled.
public(package) fun set_canceled(self: &mut Order) {
    self.status = constants::canceled();
}

public(package) fun is_bid(self: &Order): bool {
    let (is_bid, _, _) = utils::decode_order_id(self.order_id);

    is_bid
}
// Copyright (c) Mysten Labs, Inc.
// SPDX-License-Identifier: Apache-2.0

/// `Fill` struct represents the results of a match between two orders.
module deepbook::fill;

use deepbook::{balances::{Self, Balances}, deep_price::OrderDeepPrice};

// === Structs ===
/// Fill struct represents the results of a match between two orders.
/// It is used to update the state.
public struct Fill has copy, drop, store {
    // ID of the maker order
    maker_order_id: u128,
    // Client Order ID of the maker order
    maker_client_order_id: u64,
    // Execution price
    execution_price: u64,
    // account_id of the maker order
    balance_manager_id: ID,
    // Whether the maker order is expired
    expired: bool,
    // Whether the maker order is fully filled
    completed: bool,
    // Original maker quantity
    original_maker_quantity: u64,
    // Quantity filled
    base_quantity: u64,
    // Quantity of quote currency filled
    quote_quantity: u64,
    // Whether the taker is bid
    taker_is_bid: bool,
    // Maker epoch
    maker_epoch: u64,
    // Maker deep price
    maker_deep_price: OrderDeepPrice,
    // Taker fee paid for fill
    taker_fee: u64,
    // Whether taker_fee is DEEP
    taker_fee_is_deep: bool,
    // Maker fee paid for fill
    maker_fee: u64,
    // Whether maker_fee is DEEP
    maker_fee_is_deep: bool,
}

// === Public-View Functions ===
public fun maker_order_id(self: &Fill): u128 {
    self.maker_order_id
}

public fun maker_client_order_id(self: &Fill): u64 {
    self.maker_client_order_id
}

public fun execution_price(self: &Fill): u64 {
    self.execution_price
}

public fun balance_manager_id(self: &Fill): ID {
    self.balance_manager_id
}

public fun expired(self: &Fill): bool {
    self.expired
}

public fun completed(self: &Fill): bool {
    self.completed
}

public fun original_maker_quantity(self: &Fill): u64 {
    self.original_maker_quantity
}

public fun base_quantity(self: &Fill): u64 {
    self.base_quantity
}

public fun taker_is_bid(self: &Fill): bool {
    self.taker_is_bid
}

public fun quote_quantity(self: &Fill): u64 {
    self.quote_quantity
}

public fun maker_epoch(self: &Fill): u64 {
    self.maker_epoch
}

public fun maker_deep_price(self: &Fill): OrderDeepPrice {
    self.maker_deep_price
}

public fun taker_fee(self: &Fill): u64 {
    self.taker_fee
}

public fun taker_fee_is_deep(self: &Fill): bool {
    self.taker_fee_is_deep
}

public fun maker_fee(self: &Fill): u64 {
    self.maker_fee
}

public fun maker_fee_is_deep(self: &Fill): bool {
    self.maker_fee_is_deep
}

// === Public-Package Functions ===
public(package) fun new(
    maker_order_id: u128,
    maker_client_order_id: u64,
    execution_price: u64,
    balance_manager_id: ID,
    expired: bool,
    completed: bool,
    original_maker_quantity: u64,
    base_quantity: u64,
    quote_quantity: u64,
    taker_is_bid: bool,
    maker_epoch: u64,
    maker_deep_price: OrderDeepPrice,
    taker_fee_is_deep: bool,
    maker_fee_is_deep: bool,
): Fill {
    Fill {
        maker_order_id,
        maker_client_order_id,
        execution_price,
        balance_manager_id,
        expired,
        completed,
        original_maker_quantity,
        base_quantity,
        quote_quantity,
        taker_is_bid,
        maker_epoch,
        maker_deep_price,
        taker_fee: 0,
        taker_fee_is_deep,
        maker_fee: 0,
        maker_fee_is_deep,
    }
}

/// Calculate the quantities to settle for the maker.
public(package) fun get_settled_maker_quantities(self: &Fill): Balances {
    let (base, quote) = if (self.expired) {
        if (self.taker_is_bid) {
            (self.base_quantity, 0)
        } else {
            (0, self.quote_quantity)
        }
    } else {
        if (self.taker_is_bid) {
            (0, self.quote_quantity)
        } else {
            (self.base_quantity, 0)
        }
    };

    balances::new(base, quote, 0)
}

public(package) fun set_fill_maker_fee(self: &mut Fill, fee: &Balances) {
    if (fee.deep() > 0) {
        self.maker_fee_is_deep = true;
    } else {
        self.maker_fee_is_deep = false;
    };

    self.maker_fee = fee.non_zero_value();
}

public(package) fun set_fill_taker_fee(self: &mut Fill, fee: &Balances) {
    if (fee.deep() > 0) {
        self.taker_fee_is_deep = true;
    } else {
        self.taker_fee_is_deep = false;
    };

    self.taker_fee = fee.non_zero_value();
}
// Copyright (c) Mysten Labs, Inc.
// SPDX-License-Identifier: Apache-2.0

/// The book module contains the `Book` struct which represents the order book.
/// All order book operations are defined in this module.
module deepbook::book;

use deepbook::{
    big_vector::{Self, BigVector, slice_borrow, slice_borrow_mut},
    constants,
    deep_price::OrderDeepPrice,
    math,
    order::Order,
    order_info::OrderInfo,
    utils
};

// === Errors ===
const EInvalidAmountIn: u64 = 1;
const EEmptyOrderbook: u64 = 2;
const EInvalidPriceRange: u64 = 3;
const EInvalidTicks: u64 = 4;
const EOrderBelowMinimumSize: u64 = 5;
const EOrderInvalidLotSize: u64 = 6;
const ENewQuantityMustBeLessThanOriginal: u64 = 7;

// === Constants ===
const START_BID_ORDER_ID: u64 = ((1u128 << 64) - 1) as u64;
const START_ASK_ORDER_ID: u64 = 1;

// === Structs ===
public struct Book has store {
    tick_size: u64,
    lot_size: u64,
    min_size: u64,
    bids: BigVector<Order>,
    asks: BigVector<Order>,
    next_bid_order_id: u64,
    next_ask_order_id: u64,
}

// === Public-Package Functions ===
public(package) fun bids(self: &Book): &BigVector<Order> {
    &self.bids
}

public(package) fun asks(self: &Book): &BigVector<Order> {
    &self.asks
}

public(package) fun tick_size(self: &Book): u64 {
    self.tick_size
}

public(package) fun lot_size(self: &Book): u64 {
    self.lot_size
}

public(package) fun min_size(self: &Book): u64 {
    self.min_size
}

public(package) fun empty(tick_size: u64, lot_size: u64, min_size: u64, ctx: &mut TxContext): Book {
    Book {
        tick_size,
        lot_size,
        min_size,
        bids: big_vector::empty(
            constants::max_slice_size(),
            constants::max_fan_out(),
            ctx,
        ),
        asks: big_vector::empty(
            constants::max_slice_size(),
            constants::max_fan_out(),
            ctx,
        ),
        next_bid_order_id: START_BID_ORDER_ID,
        next_ask_order_id: START_ASK_ORDER_ID,
    }
}

/// Creates a new order.
/// Order is matched against the book and injected into the book if necessary.
/// If order is IOC or fully executed, it will not be injected.
public(package) fun create_order(self: &mut Book, order_info: &mut OrderInfo, timestamp: u64) {
    order_info.validate_inputs(
        self.tick_size,
        self.min_size,
        self.lot_size,
        timestamp,
    );
    let order_id = utils::encode_order_id(
        order_info.is_bid(),
        order_info.price(),
        self.get_order_id(order_info.is_bid()),
    );
    order_info.set_order_id(order_id);
    self.match_against_book(order_info, timestamp);
    if (order_info.assert_execution()) return;
    self.inject_limit_order(order_info);
    order_info.set_order_inserted();
    order_info.emit_order_placed();
}

/// Given base_quantity and quote_quantity, calculate the base_quantity_out and
/// quote_quantity_out.
/// Will return (base_quantity_out, quote_quantity_out, deep_quantity_required)
/// if base_amount > 0 or quote_amount > 0.
public(package) fun get_quantity_out(
    self: &Book,
    base_quantity: u64,
    quote_quantity: u64,
    taker_fee: u64,
    deep_price: OrderDeepPrice,
    lot_size: u64,
    pay_with_deep: bool,
    current_timestamp: u64,
): (u64, u64, u64) {
    assert!((base_quantity > 0) != (quote_quantity > 0), EInvalidAmountIn);
    let is_bid = quote_quantity > 0;
    let input_fee_rate = math::mul(
        constants::fee_penalty_multiplier(),
        taker_fee,
    );
    if (base_quantity > 0) {
        let trading_base_quantity = if (pay_with_deep) {
            base_quantity
        } else {
            math::div(base_quantity, constants::float_scaling() + input_fee_rate)
        };
        if (trading_base_quantity < self.min_size) {
            return (base_quantity, quote_quantity, 0)
        }
    };

    let mut quantity_out = 0;
    let mut quantity_in_left = if (is_bid) quote_quantity else base_quantity;

    let book_side = if (is_bid) &self.asks else &self.bids;
    let (mut ref, mut offset) = if (is_bid) book_side.min_slice() else book_side.max_slice();
    let max_fills = constants::max_fills();
    let mut current_fills = 0;

    while (!ref.is_null() && quantity_in_left > 0 && current_fills < max_fills) {
        let order = slice_borrow(book_side.borrow_slice(ref), offset);
        let cur_price = order.price();
        let cur_quantity = order.quantity() - order.filled_quantity();

        if (current_timestamp <= order.expire_timestamp()) {
            let mut matched_base_quantity;
            let quantity_to_match = if (pay_with_deep) {
                quantity_in_left
            } else {
                math::div(
                    quantity_in_left,
                    constants::float_scaling() + input_fee_rate,
                )
            };
            if (is_bid) {
                matched_base_quantity = math::div(quantity_to_match, cur_price).min(cur_quantity);
                matched_base_quantity =
                    matched_base_quantity -
                    matched_base_quantity % lot_size;
                quantity_out = quantity_out + matched_base_quantity;
                let matched_quote_quantity = math::mul(
                    matched_base_quantity,
                    cur_price,
                );
                quantity_in_left = quantity_in_left - matched_quote_quantity;
                if (!pay_with_deep) {
                    quantity_in_left =
                        quantity_in_left -
                        math::mul(matched_quote_quantity, input_fee_rate);
                };
            } else {
                matched_base_quantity = quantity_to_match.min(cur_quantity);
                matched_base_quantity =
                    matched_base_quantity -
                    matched_base_quantity % lot_size;
                quantity_out = quantity_out + math::mul(matched_base_quantity, cur_price);
                quantity_in_left = quantity_in_left - matched_base_quantity;
                if (!pay_with_deep) {
                    quantity_in_left =
                        quantity_in_left -
                        math::mul(matched_base_quantity, input_fee_rate);
                };
            };

            if (matched_base_quantity == 0) break;
        };

        (ref, offset) = if (is_bid) book_side.next_slice(ref, offset)
        else book_side.prev_slice(ref, offset);
        current_fills = current_fills + 1;
    };

    let deep_fee = if (!pay_with_deep) {
        0
    } else {
        let fee_quantity = if (is_bid) {
            deep_price.fee_quantity(
                quantity_out,
                quote_quantity - quantity_in_left,
                is_bid,
            )
        } else {
            deep_price.fee_quantity(
                base_quantity - quantity_in_left,
                quantity_out,
                is_bid,
            )
        };

        math::mul(taker_fee, fee_quantity.deep())
    };

    if (is_bid) {
        if (quantity_out < self.min_size) {
            (base_quantity, quote_quantity, 0)
        } else {
            (quantity_out, quantity_in_left, deep_fee)
        }
    } else {
        (quantity_in_left, quantity_out, deep_fee)
    }
}

/// Cancels an order given order_id
public(package) fun cancel_order(self: &mut Book, order_id: u128): Order {
    self.book_side_mut(order_id).remove(order_id)
}

/// Modifies an order given order_id and new_quantity.
/// New quantity must be less than the original quantity.
/// Order must not have already expired.
public(package) fun modify_order(
    self: &mut Book,
    order_id: u128,
    new_quantity: u64,
    timestamp: u64,
): (u64, &Order) {
    assert!(new_quantity >= self.min_size, EOrderBelowMinimumSize);
    assert!(new_quantity % self.lot_size == 0, EOrderInvalidLotSize);

    let order = self.book_side_mut(order_id).borrow_mut(order_id);
    assert!(new_quantity < order.quantity(), ENewQuantityMustBeLessThanOriginal);
    let cancel_quantity = order.quantity() - new_quantity;
    order.modify(new_quantity, timestamp);

    (cancel_quantity, order)
}

/// Returns the mid price of the order book.
public(package) fun mid_price(self: &Book, current_timestamp: u64): u64 {
    let (mut ask_ref, mut ask_offset) = self.asks.min_slice();
    let (mut bid_ref, mut bid_offset) = self.bids.max_slice();
    let mut best_ask_price = 0;
    let mut best_bid_price = 0;

    while (!ask_ref.is_null()) {
        let best_ask_order = slice_borrow(
            self.asks.borrow_slice(ask_ref),
            ask_offset,
        );
        best_ask_price = best_ask_order.price();
        if (current_timestamp <= best_ask_order.expire_timestamp()) break;
        (ask_ref, ask_offset) = self.asks.next_slice(ask_ref, ask_offset);
    };

    while (!bid_ref.is_null()) {
        let best_bid_order = slice_borrow(
            self.bids.borrow_slice(bid_ref),
            bid_offset,
        );
        best_bid_price = best_bid_order.price();
        if (current_timestamp <= best_bid_order.expire_timestamp()) break;
        (bid_ref, bid_offset) = self.bids.prev_slice(bid_ref, bid_offset);
    };

    assert!(!ask_ref.is_null() && !bid_ref.is_null(), EEmptyOrderbook);

    math::mul(best_ask_price + best_bid_price, constants::half())
}

/// Returns the best bids and asks.
/// The number of ticks is the number of price levels to return.
/// The price_low and price_high are the range of prices to return.
public(package) fun get_level2_range_and_ticks(
    self: &Book,
    price_low: u64,
    price_high: u64,
    ticks: u64,
    is_bid: bool,
    current_timestamp: u64,
): (vector<u64>, vector<u64>) {
    assert!(price_low <= price_high, EInvalidPriceRange);
    assert!(
        price_low >= constants::min_price() &&
        price_low <= constants::max_price(),
        EInvalidPriceRange,
    );
    assert!(
        price_high >= constants::min_price() &&
        price_high <= constants::max_price(),
        EInvalidPriceRange,
    );
    assert!(ticks > 0, EInvalidTicks);

    let mut price_vec = vector[];
    let mut quantity_vec = vector[];

    // convert price_low and price_high to keys for searching
    let msb = if (is_bid) {
        (0 as u128)
    } else {
        (1 as u128) << 127
    };
    let key_low = ((price_low as u128) << 64) + msb;
    let key_high = ((price_high as u128) << 64) + (((1u128 << 64) - 1) as u128) + msb;
    let book_side = if (is_bid) &self.bids else &self.asks;
    let (mut ref, mut offset) = if (is_bid) {
        book_side.slice_before(key_high)
    } else {
        book_side.slice_following(key_low)
    };
    let mut ticks_left = ticks;
    let mut cur_price = 0;
    let mut cur_quantity = 0;

    while (!ref.is_null() && ticks_left > 0) {
        let order = slice_borrow(book_side.borrow_slice(ref), offset);
        if (current_timestamp <= order.expire_timestamp()) {
            let (_, order_price, _) = utils::decode_order_id(order.order_id());
            if (
                (is_bid && order_price < price_low) || (
                    !is_bid && order_price > price_high,
                )
            ) break;
            if (
                cur_price == 0 && (
                    (is_bid && order_price <= price_high) || (
                        !is_bid && order_price >= price_low,
                    ),
                )
            ) {
                cur_price = order_price
            };

            if (cur_price != 0 && order_price != cur_price) {
                price_vec.push_back(cur_price);
                quantity_vec.push_back(cur_quantity);
                cur_price = order_price;
                cur_quantity = 0;
                ticks_left = ticks_left - 1;
                if (ticks_left == 0) break;
            };
            if (cur_price != 0) {
                cur_quantity = cur_quantity + order.quantity() - order.filled_quantity();
            };
        };

        (ref, offset) = if (is_bid) book_side.prev_slice(ref, offset)
        else book_side.next_slice(ref, offset);
    };

    if (cur_price != 0 && ticks_left > 0) {
        price_vec.push_back(cur_price);
        quantity_vec.push_back(cur_quantity);
    };

    (price_vec, quantity_vec)
}

public(package) fun get_order(self: &Book, order_id: u128): Order {
    let order = self.book_side(order_id).borrow(order_id);

    order.copy_order()
}

public(package) fun set_tick_size(self: &mut Book, new_tick_size: u64) {
    self.tick_size = new_tick_size;
}

public(package) fun set_lot_size(self: &mut Book, new_lot_size: u64) {
    self.lot_size = new_lot_size;
}

public(package) fun set_min_size(self: &mut Book, new_min_size: u64) {
    self.min_size = new_min_size;
}

// === Private Functions ===
// Access side of book where order_id belongs
fun book_side_mut(self: &mut Book, order_id: u128): &mut BigVector<Order> {
    let (is_bid, _, _) = utils::decode_order_id(order_id);
    if (is_bid) {
        &mut self.bids
    } else {
        &mut self.asks
    }
}

fun book_side(self: &Book, order_id: u128): &BigVector<Order> {
    let (is_bid, _, _) = utils::decode_order_id(order_id);
    if (is_bid) {
        &self.bids
    } else {
        &self.asks
    }
}

/// Matches the given order and quantity against the order book.
/// If is_bid, it will match against asks, otherwise against bids.
/// Mutates the order and the maker order as necessary.
fun match_against_book(self: &mut Book, order_info: &mut OrderInfo, timestamp: u64) {
    let is_bid = order_info.is_bid();
    let book_side = if (is_bid) &mut self.asks else &mut self.bids;
    let (mut ref, mut offset) = if (is_bid) book_side.min_slice() else book_side.max_slice();
    let max_fills = constants::max_fills();
    let mut current_fills = 0;

    while (!ref.is_null() &&
        current_fills < max_fills) {
        let maker_order = slice_borrow_mut(
            book_side.borrow_slice_mut(ref),
            offset,
        );
        if (!order_info.match_maker(maker_order, timestamp)) break;
        (ref, offset) = if (is_bid) book_side.next_slice(ref, offset)
        else book_side.prev_slice(ref, offset);
        current_fills = current_fills + 1;
    };

    order_info.fills_ref().do_ref!(|fill| {
        if (fill.expired() || fill.completed()) {
            book_side.remove(fill.maker_order_id());
        };
    });

    if (current_fills == max_fills) {
        order_info.set_fill_limit_reached();
    }
}

fun get_order_id(self: &mut Book, is_bid: bool): u64 {
    if (is_bid) {
        self.next_bid_order_id = self.next_bid_order_id - 1;
        self.next_bid_order_id
    } else {
        self.next_ask_order_id = self.next_ask_order_id + 1;
        self.next_ask_order_id
    }
}

/// Balance accounting happens before this function is called
fun inject_limit_order(self: &mut Book, order_info: &OrderInfo) {
    let order = order_info.to_order();
    if (order_info.is_bid()) {
        self.bids.insert(order_info.order_id(), order);
    } else {
        self.asks.insert(order_info.order_id(), order);
    };
}
// Copyright (c) Mysten Labs, Inc.
// SPDX-License-Identifier: Apache-2.0

/// DeepBook utility functions.
module deepbook::utils;

/// Pop elements from the back of `v` until its length equals `n`,
/// returning the elements that were popped in the order they
/// appeared in `v`.
public(package) fun pop_until<T>(v: &mut vector<T>, n: u64): vector<T> {
    let mut res = vector[];
    while (v.length() > n) {
        res.push_back(v.pop_back());
    };

    res.reverse();
    res
}

/// Pop `n` elements from the back of `v`, returning the elements
/// that were popped in the order they appeared in `v`.
///
/// Aborts if `v` has fewer than `n` elements.
public(package) fun pop_n<T>(v: &mut vector<T>, n: u64): vector<T> {
    let mut res = vector[];
    n.do!(|_| res.push_back(v.pop_back()));
    res.reverse();
    res
}

/// first bit is 0 for bid, 1 for ask
/// next 63 bits are price (assertion for price is done in order function)
/// last 64 bits are order_id
public(package) fun encode_order_id(is_bid: bool, price: u64, order_id: u64): u128 {
    if (is_bid) {
        ((price as u128) << 64) + (order_id as u128)
    } else {
        (1u128 << 127) + ((price as u128) << 64) + (order_id as u128)
    }
}

/// Decode order_id into (is_bid, price, order_id)
public(package) fun decode_order_id(encoded_order_id: u128): (bool, u64, u64) {
    let is_bid = (encoded_order_id >> 127) == 0;
    let price = (encoded_order_id >> 64) as u64;
    let price = price & ((1u64 << 63) - 1);
    let order_id = (encoded_order_id & ((1u128 << 64) - 1)) as u64;

    (is_bid, price, order_id)
}

#[test]
fun test_encode_decode_order_id() {
    let is_bid = true;
    let price = 2371538230592318123;
    let order_id = 9211238512301581235;
    let encoded_order_id = encode_order_id(is_bid, price, order_id);
    let (decoded_is_bid, decoded_price, decoded_order_id) = decode_order_id(
        encoded_order_id,
    );
    assert!(decoded_is_bid == is_bid, 0);
    assert!(decoded_price == price, 0);
    assert!(decoded_order_id == order_id, 0);

    let is_bid = false;
    let price = 1;
    let order_id = 1;
    let encoded_order_id = encode_order_id(is_bid, price, order_id);
    let (decoded_is_bid, decoded_price, decoded_order_id) = decode_order_id(
        encoded_order_id,
    );
    assert!(decoded_is_bid == is_bid, 0);
    assert!(decoded_price == price, 0);
    assert!(decoded_order_id == order_id, 0);

    let is_bid = true;
    let price = ((1u128 << 63) - 1) as u64;
    let order_id = ((1u128 << 64) - 1) as u64;
    let encoded_order_id = encode_order_id(is_bid, price, order_id);
    let (decoded_is_bid, decoded_price, decoded_order_id) = decode_order_id(
        encoded_order_id,
    );
    assert!(decoded_is_bid == is_bid, 0);
    assert!(decoded_price == price, 0);
    assert!(decoded_order_id == order_id, 0);

    let is_bid = false;
    let price = 0;
    let order_id = 0;
    let encoded_order_id = encode_order_id(is_bid, price, order_id);
    let (decoded_is_bid, decoded_price, decoded_order_id) = decode_order_id(
        encoded_order_id,
    );
    assert!(decoded_is_bid == is_bid, 0);
    assert!(decoded_price == price, 0);
    assert!(decoded_order_id == order_id, 0);
}
// Copyright (c) Mysten Labs, Inc.
// SPDX-License-Identifier: Apache-2.0

/// BigVector is an arbitrary sized vector-like data structure,
/// implemented using an on-chain B+ Tree to support almost constant
/// time (log base max_fan_out) random access, insertion and removal.
///
/// Iteration is supported by exposing access to leaf nodes (slices).
/// Finding the initial slice can be done in almost constant time, and
/// subsequently finding the previous or next slice can also be done
/// in constant time.
///
/// Nodes in the B+ Tree are stored as individual dynamic fields
/// hanging off the `BigVector`.
///
/// Note: The index type is `u128`, but the length is stored as `u64`
/// because the expectation is that indices are sparsely distributed.
module deepbook::big_vector;

use sui::dynamic_field as df;

use fun sui::object::new as TxContext.new;

use fun deepbook::utils::pop_until as vector.pop_until;
use fun deepbook::utils::pop_n as vector.pop_n;

public struct BigVector<phantom E: store> has key, store {
    id: UID,
    /// How deep the tree structure is.
    depth: u8,
    /// Total number of elements that this vector contains, not
    /// including gaps in the vector.
    length: u64,
    /// Max size of leaf nodes (counted in number of elements, `E`).
    max_slice_size: u64,
    /// Max size of interior nodes (counted in number of children).
    max_fan_out: u64,
    /// ID of the tree's root structure. Value of `NO_SLICE` means
    /// there's no root.
    root_id: u64,
    /// The last node ID that was allocated.
    last_id: u64,
}

/// A node in the B+ tree.
///
/// If representing a leaf node, there are as many keys as values
/// (such that `keys[i]` is the key corresponding to `vals[i]`).
///
/// A `Slice<u64>` can also represent an interior node, in which
/// case `vals` contain the IDs of its children and `keys`
/// represent the partitions between children. There will be one
/// fewer key than value in this configuration.
public struct Slice<E: store> has drop, store {
    /// Previous node in the intrusive doubly-linked list data
    /// structure.
    prev: u64,
    /// Next node in the intrusive doubly-linked list data
    /// structure.
    next: u64,
    keys: vector<u128>,
    vals: vector<E>,
}

/// Wrapper type around indices for slices. The internal index is
/// the ID of the dynamic field containing the slice.
public struct SliceRef has copy, drop, store { ix: u64 }

// === Error Codes ===

/// Max Slice Size provided is too small.
const ESliceTooSmall: u64 = 0;

/// Max Slice Size provided is too big.
const ESliceTooBig: u64 = 1;

/// Max Fan-out provided is too small.
const EFanOutTooSmall: u64 = 2;

/// Max Fan-out provided is too big.
const EFanOutTooBig: u64 = 3;

/// `BigVector` is not empty.
const ENotEmpty: u64 = 4;

/// Key not found in `BigVector`.
const ENotFound: u64 = 5;

/// Key already exists in `BigVector`.
const EExists: u64 = 6;

/// Found a node in an unexpected state during removal (namely, we
/// tried to remove from a node's child and found that it had
/// become empty, which should not be possible).
const EBadRemove: u64 = 7;

/// Found a pair of nodes that are expected to be adjacent but
/// whose linked list pointers don't match up.
const ENotAdjacent: u64 = 8;

/// Tried to redistribute between two nodes, but the operation
/// would have had no effect.
const EBadRedistribution: u64 = 9;

// === Constants ===

/// Sentinel representing the absence of a slice.
const NO_SLICE: u64 = 0;

/// We will accommodate at least this much fan out before
/// splitting interior nodes, so that after the split, we don't
/// get an interior node that contains only one child.
const MIN_FAN_OUT: u64 = 4;

/// Internal nodes of `BigVector` can't have more children than
/// this, to avoid hitting object size limits.
const MAX_FAN_OUT: u64 = 4096;

/// Leaf nodes of `BigVector` can't be bigger than this, to avoid
/// hitting object size limits.
const MAX_SLICE_SIZE: u64 = 256 * 1024;

/// Leaf nodes of `BigVector` should have at least 2 elements for maximum size
const MIN_SLICE_SIZE: u64 = 2;

// === Removal fix-up strategies ===

/// 0b000: No fix-up.
const RM_FIX_NOTHING: u8 = 0;

/// 0b001: Node is completely empty (applies only to root).
const RM_FIX_EMPTY: u8 = 1;

/// 0b010: Stole a key from the left neighbour, additional value
/// is the new pivot after the steal.
const RM_FIX_STEAL_L: u8 = 2;

/// 0b011: Stole a key from the right neighbour, additional value
/// is the new pivot after the steal.
const RM_FIX_STEAL_R: u8 = 3;

/// 0b100: Merged with the left neighbour.
const RM_FIX_MERGE_L: u8 = 4;

/// 0b101: Merged with the right neighbour.
const RM_FIX_MERGE_R: u8 = 5;

// === Constructors ===

/// Construct a new, empty `BigVector`. `max_slice_size` contains
/// the maximum size of its leaf nodes, and `max_fan_out` contains
/// the maximum fan-out of its interior nodes.
public(package) fun empty<E: store>(
    max_slice_size: u64,
    max_fan_out: u64,
    ctx: &mut TxContext,
): BigVector<E> {
    assert!(MIN_SLICE_SIZE <= max_slice_size, ESliceTooSmall);
    assert!(max_slice_size <= MAX_SLICE_SIZE, ESliceTooBig);
    assert!(MIN_FAN_OUT <= max_fan_out, EFanOutTooSmall);
    assert!(max_fan_out <= MAX_FAN_OUT, EFanOutTooBig);

    BigVector {
        id: ctx.new(),
        depth: 0,
        length: 0,
        max_slice_size,
        max_fan_out,
        root_id: NO_SLICE,
        last_id: NO_SLICE,
    }
}

/// Destroy `self` as long as it is empty, even if its elements
/// are not droppable. Fails if `self` is not empty.
public(package) fun destroy_empty<E: store>(self: BigVector<E>) {
    let BigVector {
        id,
        depth: _,
        length,
        max_slice_size: _,
        max_fan_out: _,
        root_id: _,
        last_id: _,
    } = self;

    assert!(length == 0, ENotEmpty);
    id.delete();
}

// === BigVector Accessors ===

/// Whether `self` contains no elements or not.
public(package) fun is_empty<E: store>(self: &BigVector<E>): bool {
    self.length == 0
}

/// The number of elements contained in `self`.
public(package) fun length<E: store>(self: &BigVector<E>): u64 {
    self.length
}

/// The number of nodes between the root and the leaves in `self`.
/// This is within a constant factor of log base `max_fan_out` of
/// the length.
public(package) fun depth<E: store>(self: &BigVector<E>): u8 {
    self.depth
}

/// Access the element at index `ix` in `self`.
public(package) fun borrow<E: store>(self: &BigVector<E>, ix: u128): &E {
    let (ref, offset) = self.slice_around(ix);
    let slice = self.borrow_slice(ref);
    slice_borrow(slice, offset)
}

/// Access the element at index `ix` in `self`, mutably.
public(package) fun borrow_mut<E: store>(self: &mut BigVector<E>, ix: u128): &mut E {
    let (ref, offset) = self.slice_around(ix);
    let slice = self.borrow_slice_mut(ref);
    slice_borrow_mut(slice, offset)
}

// === BigVector Mutators ===

/// Add `val` to `self` at index `key`. Aborts if `key` is already
/// present in `self`.
public(package) fun insert<E: store>(self: &mut BigVector<E>, key: u128, val: E) {
    self.length = self.length + 1;

    if (self.root_id == NO_SLICE) {
        self.root_id = self.alloc(singleton(key, val));
        return
    };

    let (root_id, depth) = (self.root_id, self.depth);
    let (key, other) = self.slice_insert(root_id, depth, key, val);

    if (other != NO_SLICE) {
        self.root_id = self.alloc(branch(key, root_id, other));
        self.depth = self.depth + 1;
    }
}

/// Remove the element with key `key` from `self`, returning its
/// value. Aborts if `key` is not found.
public(package) fun remove<E: store>(self: &mut BigVector<E>, key: u128): E {
    if (self.root_id == NO_SLICE) {
        abort ENotFound
    };

    self.length = self.length - 1;

    let (root_id, depth) = (self.root_id, self.depth);
    let (val, rm_fix, _) = self.slice_remove(
        NO_SLICE,
        0u128,
        root_id,
        0u128,
        NO_SLICE,
        depth,
        key,
    );

    if (rm_fix == RM_FIX_EMPTY) {
        if (self.depth == 0) {
            let Slice<E> {
                prev: _,
                next: _,
                keys: _,
                vals,
            } = df::remove(&mut self.id, root_id);

            // SAFETY: The slice is guaranteed to be empty because
            // it is a leaf and we received the RM_FIX_EMPTY
            // fix-up.
            vals.destroy_empty();

            self.root_id = NO_SLICE;
        } else {
            let mut root: Slice<u64> = df::remove(&mut self.id, root_id);
            self.root_id = root.vals.pop_back();
            self.depth = self.depth - 1;
        }
    };

    val
}

/// Remove elements from `self` at the indices in `keys`,
/// returning the associated values.
///
/// Aborts if any of the keys are not found.
public(package) fun remove_batch<E: store>(
    _self: &mut BigVector<E>,
    _keys: vector<u128>,
): vector<E> {
    abort 0
}

// === SliceRef ===

/// Find the slice that contains the key-value pair for `key`,
/// assuming it exists in the data structure. Returns the
/// reference to the slice and the local offset within the slice
/// if it exists, aborts with `ENotFound` otherwise.
public(package) fun slice_around<E: store>(self: &BigVector<E>, key: u128): (SliceRef, u64) {
    if (self.root_id == NO_SLICE) {
        abort ENotFound
    };

    let (ix, leaf, off) = self.find_leaf(key);

    if (off >= leaf.keys.length()) {
        abort ENotFound
    } else if (key != leaf.keys[off]) {
        abort ENotFound
    };

    (SliceRef { ix }, off)
}

/// Find the slice that contains the key-value pair corresponding
/// to the next key in `self` at or after `key`. Returns the
/// reference to the slice and the local offset within the slice
/// if it exists, or (NO_SLICE, 0), if there is no matching
/// key-value pair.
public(package) fun slice_following<E: store>(self: &BigVector<E>, key: u128): (SliceRef, u64) {
    if (self.root_id == NO_SLICE) {
        return (SliceRef { ix: NO_SLICE }, 0)
    };

    let (ix, leaf, off) = self.find_leaf(key);
    if (off >= leaf.keys.length()) {
        (leaf.next(), 0)
    } else {
        (SliceRef { ix }, off)
    }
}

/// Find the slice that contains the key-value pair corresponding
/// to the previous key in `self`. Returns the reference to the slice
/// and the local offset within the slice if it exists, or (NO_SLICE, 0),
/// if there is no matching key-value pair.
public(package) fun slice_before<E: store>(self: &BigVector<E>, key: u128): (SliceRef, u64) {
    if (self.root_id == NO_SLICE) {
        return (SliceRef { ix: NO_SLICE }, 0)
    };

    let (ix, leaf, off) = self.find_leaf(key);
    if (off == 0) {
        let prev_ref = leaf.prev();
        if (prev_ref.is_null()) {
            (SliceRef { ix: NO_SLICE }, 0)
        } else {
            let prev_slice = self.borrow_slice(prev_ref);
            (prev_ref, prev_slice.keys.length() - 1)
        }
    } else {
        (SliceRef { ix }, off - 1)
    }
}

/// Find the slice that contains the key-value pair corresponding
/// to the minimum key in `self`. Returns the reference to the
/// slice and the local offset within the slice if it exists, or
/// (NO_SLICE, 0), if there is no matching key-value pair.
public(package) fun min_slice<E: store>(self: &BigVector<E>): (SliceRef, u64) {
    if (self.root_id == NO_SLICE) {
        return (SliceRef { ix: NO_SLICE }, 0)
    };

    let (ix, _, off) = self.find_min_leaf();
    (SliceRef { ix }, off)
}

/// Find the slice that contains the key-value pair corresponding
/// to the maximum key in `self`. Returns the reference to the
/// slice and the local offset within the slice if it exists, or
/// (NO_SLICE, 0), if there is no matching key-value pair.
public(package) fun max_slice<E: store>(self: &BigVector<E>): (SliceRef, u64) {
    if (self.root_id == NO_SLICE) {
        return (SliceRef { ix: NO_SLICE }, 0)
    };

    let (ix, _, off) = self.find_max_leaf();
    (SliceRef { ix }, off)
}

/// Given the current slice and offset, get the next slice and offset. Can be null.
public(package) fun next_slice<E: store>(
    self: &BigVector<E>,
    ref: SliceRef,
    offset: u64,
): (SliceRef, u64) {
    let slice = self.borrow_slice(ref);
    if (offset + 1 < slice.vals.length()) {
        (ref, offset + 1)
    } else {
        (slice.next(), 0)
    }
}

/// Given the current slice and offset, get the previous slice and offset. Can be null.
public(package) fun prev_slice<E: store>(
    self: &BigVector<E>,
    ref: SliceRef,
    offset: u64,
): (SliceRef, u64) {
    let slice = self.borrow_slice(ref);
    if (offset > 0) {
        (ref, offset - 1)
    } else {
        let mut prev_index = 0;
        let prev_slice = slice.prev();
        if (!prev_slice.is_null()) {
            prev_index = self.borrow_slice(prev_slice).vals.length() - 1
        };

        (prev_slice, prev_index)
    }
}

/// Borrow a slice from this vector.
public(package) fun borrow_slice<E: store>(self: &BigVector<E>, ref: SliceRef): &Slice<E> {
    df::borrow(&self.id, ref.ix)
}

/// Borrow a slice from this vector, mutably.
public(package) fun borrow_slice_mut<E: store>(
    self: &mut BigVector<E>,
    ref: SliceRef,
): &mut Slice<E> {
    df::borrow_mut(&mut self.id, ref.ix)
}

// === Receiver function aliases ===

public use fun slice_is_null as SliceRef.is_null;
public use fun slice_is_leaf as Slice.is_leaf;
public use fun slice_next as Slice.next;
public use fun slice_prev as Slice.prev;
public use fun slice_length as Slice.length;
public use fun slice_key as Slice.key;
public use fun slice_borrow as Slice.borrow;
public use fun slice_borrow_mut as Slice.borrow_mut;
public use fun slice_bisect_left as Slice.bisect_left;
public use fun slice_bisect_right as Slice.bisect_right;

// === Slice Accessors ===

/// Returns whether the SliceRef points to an actual slice, or the
/// `NO_SLICE` sentinel. It is an error to attempt to borrow a
/// slice from a `BigVector` if it doesn't exist.
public(package) fun slice_is_null(self: &SliceRef): bool {
    self.ix == NO_SLICE
}

/// Returns whether the slice is a leaf node or not. Leaf nodes
/// have as many keys as values.
public(package) fun slice_is_leaf<E: store>(self: &Slice<E>): bool {
    self.vals.length() == self.keys.length()
}

/// Reference to the next (neighbouring) slice to this one.
public(package) fun slice_next<E: store>(self: &Slice<E>): SliceRef {
    SliceRef { ix: self.next }
}

/// Reference to the previous (neighbouring) slice to this one.
public(package) fun slice_prev<E: store>(self: &Slice<E>): SliceRef {
    SliceRef { ix: self.prev }
}

/// Number of children (values) in this slice.
public(package) fun slice_length<E: store>(self: &Slice<E>): u64 {
    self.vals.length()
}

/// Access a key from this slice, referenced by its offset, local
/// to the slice.
public(package) fun slice_key<E: store>(self: &Slice<E>, ix: u64): u128 {
    self.keys[ix]
}

/// Access a value from this slice, referenced by its offset,
/// local to the slice.
public(package) fun slice_borrow<E: store>(self: &Slice<E>, ix: u64): &E {
    &self.vals[ix]
}

/// Access a value from this slice, mutably, referenced by its
/// offset, local to the slice.
public(package) fun slice_borrow_mut<E: store>(self: &mut Slice<E>, ix: u64): &mut E {
    &mut self.vals[ix]
}

// === Private Helpers ===

/// Store `slice` as a dynamic field on `self`, and use its
/// dynamic field ID to connect it into the doubly linked list
/// structure at its level. Returns the ID of the slice to be used
/// in a `SliceRef`.
fun alloc<E: store, F: store>(self: &mut BigVector<E>, slice: Slice<F>): u64 {
    let prev = slice.prev;
    let next = slice.next;

    self.last_id = self.last_id + 1;
    df::add(&mut self.id, self.last_id, slice);
    let curr = self.last_id;

    if (prev != NO_SLICE) {
        let prev: &mut Slice<F> = df::borrow_mut(&mut self.id, prev);
        prev.next = curr;
    };

    if (next != NO_SLICE) {
        let next: &mut Slice<F> = df::borrow_mut(&mut self.id, next);
        next.prev = curr;
    };

    curr
}

/// Create a slice representing a leaf node containing a single
/// key-value pair.
fun singleton<E: store>(key: u128, val: E): Slice<E> {
    Slice {
        prev: NO_SLICE,
        next: NO_SLICE,
        keys: vector[key],
        vals: vector[val],
    }
}

/// Create a slice representing an interior node containing a
/// single branch.
fun branch(key: u128, left: u64, right: u64): Slice<u64> {
    Slice {
        prev: NO_SLICE,
        next: NO_SLICE,
        keys: vector[key],
        vals: vector[left, right],
    }
}

/// Recursively `drop` the nodes under the node at id `node`.
/// Assumes that node has depth `depth` and is owned by `id`.
fun drop_slice<E: store + drop>(id: &mut UID, depth: u8, slice: u64) {
    if (slice == NO_SLICE) {
        return
    } else if (depth == 0) {
        let _: Slice<E> = df::remove(id, slice);
    } else {
        let mut slice: Slice<u64> = df::remove(id, slice);
        while (!slice.vals.is_empty()) {
            drop_slice<E>(id, depth - 1, slice.vals.pop_back());
        }
    }
}

/// Find the leaf slice that would contain `key` if it existed in
/// `self`. Returns the slice ref for the leaf, a reference to the
/// leaf, and the offset in the leaf of the key (if the key were
/// to exist in `self` it would appear here).
///
/// Assumes `self` is non-empty.
fun find_leaf<E: store>(self: &BigVector<E>, key: u128): (u64, &Slice<E>, u64) {
    let (mut slice_id, mut depth) = (self.root_id, self.depth);

    while (depth > 0) {
        let node: &Slice<u64> = df::borrow(&self.id, slice_id);
        let off = node.bisect_right(key);
        slice_id = node.vals[off];
        depth = depth - 1;
    };

    let leaf: &Slice<E> = df::borrow(&self.id, slice_id);
    let off = leaf.bisect_left(key);

    (slice_id, leaf, off)
}

/// Find the minimum leaf node that contains the smallest key in the BigVector.
/// Assumes `self` is non-empty.
fun find_min_leaf<E: store>(self: &BigVector<E>): (u64, &Slice<E>, u64) {
    let (mut slice_id, mut depth) = (self.root_id, self.depth);

    // Traverse down to the leftmost leaf node
    while (depth > 0) {
        let slice: &Slice<u64> = df::borrow(&self.id, slice_id);
        slice_id = slice.vals[0]; // Always take the leftmost child
        depth = depth - 1;
    };

    let leaf: &Slice<E> = df::borrow(&self.id, slice_id);

    (slice_id, leaf, 0)
}

/// Find the maximum leaf node that contains the largest key in the BigVector.
/// Assumes `self` is non-empty.
fun find_max_leaf<E: store>(self: &BigVector<E>): (u64, &Slice<E>, u64) {
    let (mut slice_id, mut depth) = (self.root_id, self.depth);

    // Traverse down to the rightmost leaf node
    while (depth > 0) {
        let slice: &Slice<u64> = df::borrow(&self.id, slice_id);
        slice_id = slice.vals[slice.keys.length()]; // Always take the rightmost child
        depth = depth - 1;
    };

    let leaf: &Slice<E> = df::borrow(&self.id, slice_id);

    (slice_id, leaf, leaf.keys.length() - 1)
}

/// Find the position in `slice.keys` of `key` if it exists, or
/// the minimal position it should be inserted in to maintain
/// sorted order.
fun slice_bisect_left<E: store>(self: &Slice<E>, key: u128): u64 {
    let (mut lo, mut hi) = (0, self.keys.length());

    // Invariant: keys[0, lo) < key <= keys[hi, ..)
    while (lo < hi) {
        let mid = (hi - lo) / 2 + lo;
        if (key <= self.keys[mid]) {
            hi = mid;
        } else {
            lo = mid + 1;
        }
    };

    lo
}

/// Find the largest index in `slice.keys` to insert `key` to
/// maintain sorted order.
fun slice_bisect_right<E: store>(self: &Slice<E>, key: u128): u64 {
    let (mut lo, mut hi) = (0, self.keys.length());

    // Invariant: keys[0, lo) <= key < keys[hi, ..)
    while (lo < hi) {
        let mid = (hi - lo) / 2 + lo;
        if (key < self.keys[mid]) {
            hi = mid;
        } else {
            lo = mid + 1;
        }
    };

    lo
}

/// Insert `key: val` into the slice at ID `slice_id` with depth
/// `depth`.
///
/// Returns (0, NO_SLICE), if the insertion could be completed
/// without splitting, otherwise returns the key that was split
/// upon, and the ID of the new Slice which always sits next to
/// (and not previously to) `slice_id`.
///
/// Upon returning, sibling pointers are fixed up, but children
/// pointers will not be.
///
/// Aborts if `key` is already found within the slice.
fun slice_insert<E: store>(
    self: &mut BigVector<E>,
    slice_id: u64,
    depth: u8,
    key: u128,
    val: E,
): (u128, u64) {
    if (depth == 0) {
        self.leaf_insert(slice_id, key, val)
    } else {
        self.node_insert(slice_id, depth - 1, key, val)
    }
}

/// Like `slice_insert` but you know that `slice_id` points to a leaf node.
fun leaf_insert<E: store>(self: &mut BigVector<E>, slice_id: u64, key: u128, val: E): (u128, u64) {
    let leaf: &mut Slice<E> = df::borrow_mut(&mut self.id, slice_id);
    let off = leaf.bisect_left(key);

    if (off < leaf.keys.length() &&
        key == leaf.keys[off]) {
        abort EExists
    };

    // If there is enough space in the current leaf, no need
    // to split.
    if (leaf.keys.length() < self.max_slice_size) {
        leaf.keys.insert(key, off);
        leaf.vals.insert(val, off);
        return (0, NO_SLICE)
    };

    // Split off half the current leaf to be the new `next` leaf.
    let split_at = leaf.vals.length() / 2;
    let mut next = Slice {
        prev: slice_id,
        next: leaf.next,
        keys: leaf.keys.pop_until(split_at),
        vals: leaf.vals.pop_until(split_at),
    };

    // Insert the key-value pair into the correct side of the
    // split -- the first element in the new slice is the pivot.
    //
    // SAFETY: The next slice is guaranteed to be non-empty,
    // because we round down the size of the original slice when
    // splitting, so as long as `leaf.keys` had at least one
    // element at the start of the call, then `next.keys` will
    // have at least one element at this point.
    let pivot = next.keys[0];
    if (key < pivot) {
        leaf.keys.insert(key, off);
        leaf.vals.insert(val, off);
    } else {
        next.keys.insert(key, off - split_at);
        next.vals.insert(val, off - split_at);
    };

    (pivot, self.alloc(next))
}

/// Like `slice_insert` but you know that `slice_id` points to an
/// interior node, and `depth` is the depth of its children, not
/// itself.
fun node_insert<E: store>(
    self: &mut BigVector<E>,
    slice_id: u64,
    depth: u8,
    key: u128,
    val: E,
): (u128, u64) {
    let node: &mut Slice<u64> = df::borrow_mut(&mut self.id, slice_id);
    let off = node.bisect_right(key);

    let child = node.vals[off];
    let (key, val) = self.slice_insert(child, depth, key, val);

    // The recursive call didn't introduce an extra slice, so no
    // work needed to accommodate it.
    if (val == NO_SLICE) {
        return (0, NO_SLICE)
    };

    // Re-borrow the current node, after the recursive call.
    let node: &mut Slice<u64> = df::borrow_mut(&mut self.id, slice_id);

    // The extra slice can be accommodated in the current node
    // without splitting it.
    if (node.vals.length() < self.max_fan_out) {
        node.keys.insert(key, off);
        node.vals.insert(val, off + 1);
        return (0, NO_SLICE)
    };

    let split_at = node.vals.length() / 2;
    let mut next = Slice {
        prev: slice_id,
        next: node.next,
        keys: node.keys.pop_until(split_at),
        vals: node.vals.pop_until(split_at),
    };

    // SAFETY: `node` is guaranteed to have a key to pop after
    // having `next` split off from it, because:
    //
    //    split_at
    //  = length(node.vals) / 2
    // >= self.max_fan_out  / 2
    // >= MIN_FAN_OUT / 2
    // >= 4 / 2
    //  = 2
    //
    // Meaning there will be at least 2 elements left in the key
    // vector after the split -- one to pop here, and then one to
    // leave behind to ensure the remaining node is at least
    // binary (not vestigial).
    let pivot = node.keys.pop_back();
    if (key < pivot) {
        node.keys.insert(key, off);
        node.vals.insert(val, off + 1);
    } else {
        next.keys.insert(key, off - split_at);
        next.vals.insert(val, off - split_at + 1);
    };

    (pivot, self.alloc(next))
}

/// Remove `key` from the slice at ID `slice_id` with depth
/// `depth`, in `self`.
///
/// `prev_id` and `next_id` are the IDs of slices either side of
/// `slice_id` that share the same parent, to be used for
/// redistribution and merging.
///
/// Aborts if `key` does not exist within the slice.
fun slice_remove<E: store>(
    self: &mut BigVector<E>,
    prev_id: u64,
    prev_key: u128,
    slice_id: u64,
    next_key: u128,
    next_id: u64,
    depth: u8,
    key: u128,
): (E, u8, u128) {
    if (depth == 0) {
        self.leaf_remove(
            prev_id,
            prev_key,
            slice_id,
            next_key,
            next_id,
            key,
        )
    } else {
        self.node_remove(
            prev_id,
            prev_key,
            slice_id,
            next_key,
            next_id,
            depth - 1,
            key,
        )
    }
}

/// Like `slice_remove` but you know that `slice_id` points to a
/// leaf.
fun leaf_remove<E: store>(
    self: &mut BigVector<E>,
    prev_id: u64,
    prev_key: u128,
    slice_id: u64,
    next_key: u128,
    next_id: u64,
    key: u128,
): (E, u8, u128) {
    let leaf: &mut Slice<E> = df::borrow_mut(&mut self.id, slice_id);
    let off = leaf.bisect_left(key);

    if (off >= leaf.keys.length()) {
        abort ENotFound
    };

    if (key != leaf.keys[off]) {
        abort ENotFound
    };

    leaf.keys.remove(off);
    let val = leaf.vals.remove(off);

    let remaining = leaf.vals.length();
    let min_slice_size = self.max_slice_size / 2;
    if (remaining >= min_slice_size) {
        return (val, RM_FIX_NOTHING, 0)
    };

    // Try redistribution with a neighbour
    if (prev_id != NO_SLICE) {
        let prev: &Slice<E> = df::borrow(&self.id, prev_id);
        if (prev.vals.length() > min_slice_size) {
            return (
                val,
                RM_FIX_STEAL_L,
                self.slice_redistribute<E, E>(
                    prev_id,
                    prev_key,
                    slice_id,
                ),
            )
        }
    };

    if (next_id != NO_SLICE) {
        let next: &Slice<E> = df::borrow(&self.id, next_id);
        if (next.vals.length() > min_slice_size) {
            return (
                val,
                RM_FIX_STEAL_R,
                self.slice_redistribute<E, E>(
                    slice_id,
                    next_key,
                    next_id,
                ),
            )
        }
    };

    // Try merging with a neighbour
    if (prev_id != NO_SLICE) {
        self.slice_merge<E, E>(prev_id, prev_key, slice_id);
        return (val, RM_FIX_MERGE_L, 0)
    };

    if (next_id != NO_SLICE) {
        self.slice_merge<E, E>(slice_id, next_key, next_id);
        return (val, RM_FIX_MERGE_R, 0)
    };

    // Neither neighbour exists, must be the root -- check whether
    // it's empty.
    if (remaining == 0) {
        (val, RM_FIX_EMPTY, 0)
    } else {
        (val, RM_FIX_NOTHING, 0)
    }
}

/// Like `slice_remove` but you know that `slice_id` points to an
/// interior node, and `depth` refers to the depth of its child
/// nodes.
fun node_remove<E: store>(
    self: &mut BigVector<E>,
    prev_id: u64,
    prev_key: u128,
    slice_id: u64,
    next_key: u128,
    next_id: u64,
    depth: u8,
    key: u128,
): (E, u8, u128) {
    let node: &Slice<u64> = df::borrow(&self.id, slice_id);
    let off = node.bisect_right(key);

    let child_id = node.vals[off];

    let (child_prev_id, child_prev_key) = if (off == 0) {
        (NO_SLICE, 0)
    } else (node.vals[off - 1], node.keys[off - 1]);

    let (child_next_id, child_next_key) = if (off == node.keys.length()) {
        (NO_SLICE, 0)
    } else (node.vals[off + 1], node.keys[off]);

    let (val, rm_fix, pivot) = self.slice_remove(
        child_prev_id,
        child_prev_key,
        child_id,
        child_next_key,
        child_next_id,
        depth,
        key,
    );

    // Re-borrow node mutably after recursive call, to perform
    // fix-ups.
    let node: &mut Slice<u64> = df::borrow_mut(&mut self.id, slice_id);

    if (rm_fix == RM_FIX_NOTHING) {
        return (val, RM_FIX_NOTHING, 0)
    } else if (rm_fix == RM_FIX_STEAL_L) {
        *(&mut node.keys[off - 1]) = pivot;
        return (val, RM_FIX_NOTHING, 0)
    } else if (rm_fix == RM_FIX_STEAL_R) {
        *(&mut node.keys[off]) = pivot;
        return (val, RM_FIX_NOTHING, 0)
    } else if (rm_fix == RM_FIX_MERGE_L) {
        node.keys.remove(off - 1);
        node.vals.remove(off);
    } else if (rm_fix == RM_FIX_MERGE_R) {
        node.keys.remove(off);
        node.vals.remove(off + 1);
    } else {
        abort EBadRemove
    };

    let remaining = node.vals.length();
    let min_fan_out = self.max_fan_out / 2;
    if (remaining >= min_fan_out) {
        return (val, RM_FIX_NOTHING, 0)
    };

    // Try redistribution with a neighbour
    if (prev_id != NO_SLICE) {
        let prev: &Slice<u64> = df::borrow(&self.id, prev_id);
        if (prev.vals.length() > min_fan_out) {
            return (
                val,
                RM_FIX_STEAL_L,
                self.slice_redistribute<E, u64>(
                    prev_id,
                    prev_key,
                    slice_id,
                ),
            )
        }
    };

    if (next_id != NO_SLICE) {
        let next: &Slice<u64> = df::borrow(&self.id, next_id);
        if (next.vals.length() > min_fan_out) {
            return (
                val,
                RM_FIX_STEAL_R,
                self.slice_redistribute<E, u64>(
                    slice_id,
                    next_key,
                    next_id,
                ),
            )
        }
    };

    // Try merging with a neighbour
    if (prev_id != NO_SLICE) {
        self.slice_merge<E, u64>(prev_id, prev_key, slice_id);
        return (val, RM_FIX_MERGE_L, 0)
    };

    if (next_id != NO_SLICE) {
        self.slice_merge<E, u64>(slice_id, next_key, next_id);
        return (val, RM_FIX_MERGE_R, 0)
    };

    // Neither neighbour exists, must be the root. As we are
    // dealing with an interior node, it is considered "empty"
    // when it has only one child (which can replace it), and it
    // is an error for it to be completely empty.
    if (remaining == 0) {
        abort EBadRemove
    } else if (remaining == 1) {
        (val, RM_FIX_EMPTY, 0)
    } else {
        (val, RM_FIX_NOTHING, 0)
    }
}

/// Redistribute the elements in `left_id` and `right_id`
/// separated by `pivot`, evenly between each other. Returns the
/// new pivot element between the two slices.
///
/// Aborts if left and right are not adjacent slices.
fun slice_redistribute<E: store, F: store>(
    self: &mut BigVector<E>,
    left_id: u64,
    pivot: u128,
    right_id: u64,
): u128 {
    // Remove the slices from `self` to make it easier to
    // manipulate both of them simultaneously.
    let left: Slice<F> = df::remove(&mut self.id, left_id);
    let right: Slice<F> = df::remove(&mut self.id, right_id);

    assert!(left.next == right_id, ENotAdjacent);
    assert!(right.prev == left_id, ENotAdjacent);

    let is_leaf = left.is_leaf();
    let Slice {
        prev: lprev,
        next: lnext,
        keys: mut lkeys,
        vals: mut lvals,
    } = left;

    let Slice {
        prev: rprev,
        next: rnext,
        keys: rkeys,
        vals: rvals,
    } = right;

    let old_l_len = lvals.length();
    let old_r_len = rvals.length();
    let total_len = old_l_len + old_r_len;
    let new_l_len = total_len / 2;
    let new_r_len = total_len - new_l_len;

    // Detect whether the redistribution is left-to-right or right-to-left.
    let left_to_right = if (new_l_len < old_l_len) {
        true
    } else if (new_r_len < old_r_len) {
        false
    } else {
        abort EBadRedistribution
    };

    // Redistribute values
    let (lvals, rvals) = if (left_to_right) {
        let mut mvals = lvals.pop_until(new_l_len);
        mvals.append(rvals);
        (lvals, mvals)
    } else {
        let mut mvals = rvals;
        let rvals = mvals.pop_n(new_r_len);
        lvals.append(mvals);
        (lvals, rvals)
    };

    // Redistribute keys and move pivot.
    //
    // The pivot moves from the left side to the right side of the
    // middle section depending on whether the keys are from left
    // to right or vice versa.
    //
    // The pivot also changes from inclusive to exclusive based on
    // whether the slices in question are leaves or not.
    //
    // When handling interior nodes, the previous pivot needs to
    // be incorporated during this process.
    let (lkeys, pivot, rkeys) = if (is_leaf && left_to_right) {
        let mut mkeys = lkeys.pop_until(new_l_len);
        let pivot = mkeys[0];
        mkeys.append(rkeys);
        (lkeys, pivot, mkeys)
    } else if (is_leaf && !left_to_right) {
        let mut mkeys = rkeys;
        let rkeys = mkeys.pop_n(new_r_len);
        let pivot = rkeys[0];
        lkeys.append(mkeys);
        (lkeys, pivot, rkeys)
    } else if (!is_leaf && left_to_right) {
        // [left, new-pivot, mid] old-pivot [right]
        // ... becomes ...
        // [left] new-pivot [mid, old-pivot, right]
        let mut mkeys = lkeys.pop_until(new_l_len);
        mkeys.push_back(pivot);
        mkeys.append(rkeys);
        let pivot = lkeys.pop_back();
        (lkeys, pivot, mkeys)
    } else {
        // [left] old-pivot [mid, new-pivot, right]
        // ... becomes ...
        // [left, old-pivot, mid] new-pivot [right]
        lkeys.push_back(pivot);
        let mut mkeys = rkeys;
        let rkeys = mkeys.pop_n(new_r_len - 1);
        let pivot = mkeys.pop_back();
        lkeys.append(mkeys);
        (lkeys, pivot, rkeys)
    };

    // Add the slices back to self.
    df::add(
        &mut self.id,
        left_id,
        Slice { prev: lprev, next: lnext, keys: lkeys, vals: lvals },
    );

    df::add(
        &mut self.id,
        right_id,
        Slice { prev: rprev, next: rnext, keys: rkeys, vals: rvals },
    );

    pivot
}

/// Merge the `right_id` slice into `left_id` (represented by
/// their IDs). Assumes that `left_id` and `right_id` are adjacent
/// slices, separated by `pivot`, and aborts if this is not the
/// case.
///
/// Upon success, `left_id` contains all the elements of both
/// slices, and the `right_id` slice has been removed from the
/// vector.
fun slice_merge<E: store, F: store>(
    self: &mut BigVector<E>,
    left_id: u64,
    pivot: u128,
    right_id: u64,
) {
    let right: Slice<F> = df::remove(&mut self.id, right_id);
    let left: &mut Slice<F> = df::borrow_mut(&mut self.id, left_id);

    assert!(left.next == right_id, ENotAdjacent);
    assert!(right.prev == left_id, ENotAdjacent);

    if (!left.is_leaf()) {
        left.keys.push_back(pivot);
    };

    let Slice { prev: _, next, keys, vals } = right;
    left.keys.append(keys);
    left.vals.append(vals);

    left.next = next;
    if (next != NO_SLICE) {
        let next: &mut Slice<F> = df::borrow_mut(&mut self.id, next);
        next.prev = left_id;
    }
}

// === Test Helpers ===

#[test_only]
/// Create a slice just for the purposes of testing bisect functions.
fun test_slice(keys: vector<u128>): Slice<u64> {
    Slice { prev: NO_SLICE, next: NO_SLICE, keys: keys, vals: vector[] }
}

#[test_only]
/// Returns the keys from `self`, in pre-order.
public(package) fun preorder_keys<E: store>(self: &BigVector<E>): vector<vector<u128>> {
    let mut keys = vector[];
    let (slice_id, depth) = (self.root_id, self.depth);
    self.preorder_key_traversal(&mut keys, slice_id, depth);
    keys
}

#[test_only]
fun preorder_key_traversal<E: store>(
    self: &BigVector<E>,
    keys: &mut vector<vector<u128>>,
    slice_id: u64,
    depth: u8,
) {
    if (slice_id == NO_SLICE) {
        return
    };

    if (depth == 0) {
        let leaf: &Slice<E> = df::borrow(&self.id, slice_id);
        keys.push_back(leaf.keys);
        return
    };

    let node: &Slice<u64> = df::borrow(&self.id, slice_id);
    keys.push_back(node.keys);

    let mut i = 0;
    while (i < node.vals.length()) {
        let child = node.vals[i];
        self.preorder_key_traversal(keys, child, depth - 1);
        i = i + 1;
    };
}

#[test_only]
/// Returns the values from `self`, in-order.
public(package) fun inorder_values<E: store + copy>(self: &BigVector<E>): vector<vector<E>> {
    let mut vals = vector[];
    if (self.root_id == NO_SLICE) {
        return vals
    };

    // (1). Traverse intermediate nodes to find left-most leaf.
    let (mut slice_id, mut depth) = (self.root_id, self.depth);
    while (depth > 0) {
        let slice: &Slice<u64> = df::borrow(&self.id, slice_id);
        slice_id = slice.vals[0];
        depth = depth - 1;
    };

    // (2). Iterate through leaves using linked list pointers.
    while (slice_id != NO_SLICE) {
        let leaf: &Slice<E> = df::borrow(&self.id, slice_id);
        vals.push_back(leaf.vals);
        slice_id = leaf.next;
    };

    vals
}

#[test_only]
/// Destroy `self`, even if it contains elements, as long as they
/// are droppable.
public(package) fun drop<E: store + drop>(self: BigVector<E>) {
    let BigVector {
        mut id,
        depth,
        length: _,
        max_slice_size: _,
        max_fan_out: _,
        root_id,
        last_id: _,
    } = self;

    drop_slice<E>(&mut id, depth, root_id);
    id.delete();
}

// === Tests ===

#[test]
fun test_bisect() {
    let slice = test_slice(vector[]);
    assert!(slice.bisect_left(0) == 0, 0);

    let slice = test_slice(vector[1, 3, 5, 7, 9]);
    assert!(slice.bisect_left(0) == 0, 0);
    assert!(slice.bisect_left(1) == 0, 0);
    assert!(slice.bisect_left(2) == 1, 0);
    assert!(slice.bisect_left(3) == 1, 0);
    assert!(slice.bisect_left(4) == 2, 0);
    assert!(slice.bisect_left(5) == 2, 0);
    assert!(slice.bisect_left(6) == 3, 0);
    assert!(slice.bisect_left(7) == 3, 0);
    assert!(slice.bisect_left(8) == 4, 0);
    assert!(slice.bisect_left(9) == 4, 0);
    assert!(slice.bisect_left(10) == 5, 0);
    assert!(slice.bisect_left(11) == 5, 0);

    assert!(slice.bisect_right(0) == 0, 0);
    assert!(slice.bisect_right(1) == 1, 0);
    assert!(slice.bisect_right(2) == 1, 0);
    assert!(slice.bisect_right(3) == 2, 0);
    assert!(slice.bisect_right(4) == 2, 0);
    assert!(slice.bisect_right(5) == 3, 0);
    assert!(slice.bisect_right(6) == 3, 0);
    assert!(slice.bisect_right(7) == 4, 0);
    assert!(slice.bisect_right(8) == 4, 0);
    assert!(slice.bisect_right(9) == 5, 0);
    assert!(slice.bisect_right(10) == 5, 0);
    assert!(slice.bisect_right(11) == 5, 0);
}
// Copyright (c) Mysten Labs, Inc.
// SPDX-License-Identifier: Apache-2.0

module deepbook::constants;

const CURRENT_VERSION: u64 = 4; // Update version during upgrades
const POOL_CREATION_FEE: u64 = 500 * 1_000_000; // 500 DEEP
const FLOAT_SCALING: u64 = 1_000_000_000;
const FLOAT_SCALING_U128: u128 = 1_000_000_000;
const MAX_U64: u64 = ((1u128 << 64) - 1) as u64;
const MAX_U128: u128 = ((1u256 << 128) - 1) as u128;
const MIN_PRICE: u64 = 1;
const MAX_PRICE: u64 = ((1u128 << 63) - 1) as u64;
const DEFAULT_STAKE_REQUIRED: u64 = 100_000_000; // 100 DEEP
const HALF: u64 = 500_000_000;
const DEEP_UNIT: u64 = 1_000_000;
const FEE_PENALTY_MULTIPLIER: u64 = 1_250_000_000; // 25% more than normal
const DEFAULT_EWMA_ALPHA: u64 = 10_000_000; // 1% smoothing factor. at 3 TPS ~ one minute alpha
const DEFAULT_Z_SCORE_THRESHOLD: u64 = 3_000_000_000; // 3 standard deviations
const DEFAULT_ADDITIONAL_TAKER_FEE: u64 = 1_000_000; // 10 bps
const EWMA_DF_KEY: vector<u8> = b"ewma";
const REFERRAL_DF_KEY: vector<u8> = b"referral";
const REFERRAL_MAX_BPS: u64 = 1_000_000; // 10 bps
const REFERRAL_MULTIPLE: u64 = 100_000; // 1 bp

// Restrictions on limit orders.
// No restriction on the order.
const NO_RESTRICTION: u8 = 0;
// Mandates that whatever amount of an order that can be executed in the current
// transaction, be filled and then the rest of the order canceled.
const IMMEDIATE_OR_CANCEL: u8 = 1;
// Mandates that the entire order size be filled in the current transaction.
// Otherwise, the order is canceled.
const FILL_OR_KILL: u8 = 2;
// Mandates that the entire order be passive. Otherwise, cancel the order.
const POST_ONLY: u8 = 3;
// Maximum restriction value.
const MAX_RESTRICTION: u8 = 3;

// Self matching types.
// Self matching is allowed.
const SELF_MATCHING_ALLOWED: u8 = 0;
// Cancel the taker order.
const CANCEL_TAKER: u8 = 1;
// Cancel the maker order.
const CANCEL_MAKER: u8 = 2;

// Order statuses.
const LIVE: u8 = 0;
const PARTIALLY_FILLED: u8 = 1;
const FILLED: u8 = 2;
const CANCELED: u8 = 3;
const EXPIRED: u8 = 4;

// Maximum number of fills per transaction
const MAX_FILLS: u64 = 100;

// Maximum number of open orders per balance manager
const MAX_OPEN_ORDERS: u64 = 100;

// Big vector params
const MAX_SLICE_SIZE: u64 = 64;
const MAX_FAN_OUT: u64 = 64;

// History constants
const PHASE_OUT_EPOCHS: u64 = 28;

// Fee type constants
const FEE_IS_DEEP: bool = true;

// Constants for testing
#[test_only]
const MAKER_FEE: u64 = 500000;
#[test_only]
const TAKER_FEE: u64 = 1000000;
#[test_only]
const STABLE_MAKER_FEE: u64 = 50000;
#[test_only]
const STABLE_TAKER_FEE: u64 = 100000;
#[test_only]
const TICK_SIZE: u64 = 1000;
#[test_only]
const LOT_SIZE: u64 = 1000;
#[test_only]
const MIN_SIZE: u64 = 10000;
#[test_only]
const DEEP_MULTIPLIER: u64 = 100 * FLOAT_SCALING;
#[test_only]
const TAKER_DISCOUNT: u64 = 500_000_000;
#[test_only]
const USDC_UNIT: u64 = 1_000_000;
#[test_only]
const SUI_UNIT: u64 = 1_000_000_000;

// Testing error codes
#[test_only]
const EOrderInfoMismatch: u64 = 0;
#[test_only]
const EBookOrderMismatch: u64 = 1;
#[test_only]
const EIncorrectMidPrice: u64 = 2;
#[test_only]
const EIncorrectPoolId: u64 = 3;
#[test_only]
const EFillMismatch: u64 = 4;

public fun current_version(): u64 {
    CURRENT_VERSION
}

public fun pool_creation_fee(): u64 {
    POOL_CREATION_FEE
}

public fun float_scaling(): u64 {
    FLOAT_SCALING
}

public fun float_scaling_u128(): u128 {
    FLOAT_SCALING_U128
}

public fun max_u64(): u64 {
    MAX_U64
}

public fun max_u128(): u128 {
    MAX_U128
}

public fun no_restriction(): u8 {
    NO_RESTRICTION
}

public fun immediate_or_cancel(): u8 {
    IMMEDIATE_OR_CANCEL
}

public fun fill_or_kill(): u8 {
    FILL_OR_KILL
}

public fun post_only(): u8 {
    POST_ONLY
}

public fun max_restriction(): u8 {
    MAX_RESTRICTION
}

public fun live(): u8 {
    LIVE
}

public fun partially_filled(): u8 {
    PARTIALLY_FILLED
}

public fun filled(): u8 {
    FILLED
}

public fun canceled(): u8 {
    CANCELED
}

public fun expired(): u8 {
    EXPIRED
}

public fun self_matching_allowed(): u8 {
    SELF_MATCHING_ALLOWED
}

public fun cancel_taker(): u8 {
    CANCEL_TAKER
}

public fun cancel_maker(): u8 {
    CANCEL_MAKER
}

public fun min_price(): u64 {
    MIN_PRICE
}

public fun max_price(): u64 {
    MAX_PRICE
}

public fun phase_out_epochs(): u64 {
    PHASE_OUT_EPOCHS
}

public fun default_stake_required(): u64 {
    DEFAULT_STAKE_REQUIRED
}

public fun half(): u64 {
    HALF
}

public fun fee_is_deep(): bool {
    FEE_IS_DEEP
}

public fun deep_unit(): u64 {
    DEEP_UNIT
}

public fun max_fills(): u64 {
    MAX_FILLS
}

public fun max_open_orders(): u64 {
    MAX_OPEN_ORDERS
}

public fun max_slice_size(): u64 {
    MAX_SLICE_SIZE
}

public fun max_fan_out(): u64 {
    MAX_FAN_OUT
}

public fun fee_penalty_multiplier(): u64 {
    FEE_PENALTY_MULTIPLIER
}

public fun default_ewma_alpha(): u64 {
    DEFAULT_EWMA_ALPHA
}

public fun default_z_score_threshold(): u64 {
    DEFAULT_Z_SCORE_THRESHOLD
}

public fun default_additional_taker_fee(): u64 {
    DEFAULT_ADDITIONAL_TAKER_FEE
}

public fun ewma_df_key(): vector<u8> {
    EWMA_DF_KEY
}

public fun referral_df_key(): vector<u8> {
    REFERRAL_DF_KEY
}

public fun referral_max_bps(): u64 {
    REFERRAL_MAX_BPS
}

public fun referral_multiple(): u64 {
    REFERRAL_MULTIPLE
}

#[test_only]
public fun maker_fee(): u64 {
    MAKER_FEE
}

#[test_only]
public fun taker_fee(): u64 {
    TAKER_FEE
}

#[test_only]
public fun stable_maker_fee(): u64 {
    STABLE_MAKER_FEE
}

#[test_only]
public fun stable_taker_fee(): u64 {
    STABLE_TAKER_FEE
}

#[test_only]
public fun tick_size(): u64 {
    TICK_SIZE
}

#[test_only]
public fun lot_size(): u64 {
    LOT_SIZE
}

#[test_only]
public fun min_size(): u64 {
    MIN_SIZE
}

#[test_only]
public fun deep_multiplier(): u64 {
    DEEP_MULTIPLIER
}

#[test_only]
public fun taker_discount(): u64 {
    TAKER_DISCOUNT
}

#[test_only]
public fun e_order_info_mismatch(): u64 {
    EOrderInfoMismatch
}

#[test_only]
public fun e_fill_mismatch(): u64 {
    EFillMismatch
}

#[test_only]
public fun e_book_order_mismatch(): u64 {
    EBookOrderMismatch
}

#[test_only]
public fun e_incorrect_mid_price(): u64 {
    EIncorrectMidPrice
}

#[test_only]
public fun usdc_unit(): u64 {
    USDC_UNIT
}

#[test_only]
public fun sui_unit(): u64 {
    SUI_UNIT
}

#[test_only]
public fun e_incorrect_pool_id(): u64 {
    EIncorrectPoolId
}
// Copyright (c) Mysten Labs, Inc.
// SPDX-License-Identifier: Apache-2.0

module deepbook::math;

/// scaling setting for float
const FLOAT_SCALING: u64 = 1_000_000_000;
const FLOAT_SCALING_U128: u128 = 1_000_000_000;
const FLOAT_SCALING_U256: u256 = 1_000_000_000;

/// Error codes
const EInvalidPrecision: u64 = 0;

/// Multiply two floating numbers.
/// This function will round down the result.
public fun mul(x: u64, y: u64): u64 {
    let (_, result) = mul_internal(x, y);

    result
}

public fun mul_u128(x: u128, y: u128): u128 {
    let (_, result) = mul_internal_u128(x, y);

    result
}

/// Multiply two floating numbers.
/// This function will round up the result.
public fun mul_round_up(x: u64, y: u64): u64 {
    let (is_round_down, result) = mul_internal(x, y);

    result + is_round_down
}

/// Divide two floating numbers.
/// This function will round down the result.
public fun div(x: u64, y: u64): u64 {
    let (_, result) = div_internal(x, y);

    result
}

public fun div_u128(x: u128, y: u128): u128 {
    let (_, result) = div_internal_u128(x, y);

    result
}

/// Divide two floating numbers.
/// This function will round up the result.
public fun div_round_up(x: u64, y: u64): u64 {
    let (is_round_down, result) = div_internal(x, y);

    result + is_round_down
}

/// given a vector of u64, return the median
public fun median(v: vector<u128>): u128 {
    let n = v.length();
    if (n == 0) {
        return 0
    };

    let sorted_v = quick_sort(v);
    if (n % 2 == 0) {
        mul_u128(
            (sorted_v[n / 2 - 1] + sorted_v[n / 2]),
            FLOAT_SCALING_U128 / 2,
        )
    } else {
        sorted_v[n / 2]
    }
}

/// Computes the integer square root of a scaled u64 value, assuming the
/// original value
/// is scaled by precision. The result will be in the same floating-point
/// representation.
public fun sqrt(x: u64, precision: u64): u64 {
    assert!(precision <= FLOAT_SCALING, EInvalidPrecision);
    let multiplier = (FLOAT_SCALING / precision) as u128;
    let scaled_x: u128 = (x as u128) * multiplier * FLOAT_SCALING_U128;
    let sqrt_scaled_x: u128 = std::u128::sqrt(scaled_x);

    (sqrt_scaled_x / multiplier) as u64
}

public fun is_power_of_ten(n: u64): bool {
    let mut num = n;

    if (num < 1) {
        false
    } else {
        while (num % 10 == 0) {
            num = num / 10;
        };

        num == 1
    }
}

fun quick_sort(data: vector<u128>): vector<u128> {
    if (data.length() <= 1) {
        return data
    };

    let pivot = data[0];
    let mut less = vector<u128>[];
    let mut equal = vector<u128>[];
    let mut greater = vector<u128>[];

    data.do!(|value| {
        if (value < pivot) {
            less.push_back(value);
        } else if (value == pivot) {
            equal.push_back(value);
        } else {
            greater.push_back(value);
        };
    });

    let mut sortedData = vector<u128>[];
    sortedData.append(quick_sort(less));
    sortedData.append(equal);
    sortedData.append(quick_sort(greater));
    sortedData
}

fun mul_internal(x: u64, y: u64): (u64, u64) {
    let x = x as u128;
    let y = y as u128;
    let round = if ((x * y) % FLOAT_SCALING_U128 == 0) 0 else 1;

    (round, (x * y / FLOAT_SCALING_U128) as u64)
}

fun mul_internal_u128(x: u128, y: u128): (u128, u128) {
    let x = x as u256;
    let y = y as u256;
    let round = if ((x * y) % FLOAT_SCALING_U256 == 0) 0 else 1;

    (round, (x * y / FLOAT_SCALING_U256) as u128)
}

fun div_internal(x: u64, y: u64): (u64, u64) {
    let x = x as u128;
    let y = y as u128;
    let round = if ((x * FLOAT_SCALING_U128 % y) == 0) 0 else 1;

    (round, (x * FLOAT_SCALING_U128 / y) as u64)
}

fun div_internal_u128(x: u128, y: u128): (u128, u128) {
    let x = x as u256;
    let y = y as u256;
    let round = if ((x * FLOAT_SCALING_U256 % y) == 0) 0 else 1;

    (round, (x * FLOAT_SCALING_U256 / y) as u128)
}

#[test]
/// Test median function
fun test_median() {
    let v = vector<u128>[
        1 * FLOAT_SCALING_U128,
        2 * FLOAT_SCALING_U128,
        3 * FLOAT_SCALING_U128,
        4 * FLOAT_SCALING_U128,
        5 * FLOAT_SCALING_U128,
    ];
    assert!(median(v) == 3 * FLOAT_SCALING_U128, 0);

    let v = vector<u128>[
        10 * FLOAT_SCALING_U128,
        15 * FLOAT_SCALING_U128,
        2 * FLOAT_SCALING_U128,
        3 * FLOAT_SCALING_U128,
        5 * FLOAT_SCALING_U128,
    ];
    assert!(median(v) == 5 * FLOAT_SCALING_U128, 0);

    let v = vector<u128>[
        10 * FLOAT_SCALING_U128,
        9 * FLOAT_SCALING_U128,
        23 * FLOAT_SCALING_U128,
        4 * FLOAT_SCALING_U128,
        5 * FLOAT_SCALING_U128,
        28 * FLOAT_SCALING_U128,
    ];
    assert!(median(v) == 9_500_000_000, 0);
}

#[test]
/// Test sqrt function
fun test_sqrt() {
    let scaling = 1_000_000;
    let precision_6 = 1_000_000;
    let precision_9 = 1_000_000_000;

    assert!(sqrt(0, precision_6) == 0, 0);
    assert!(sqrt(1 * scaling, precision_6) == 1 * scaling, 0);
    assert!(sqrt(2 * scaling, precision_6) == 1_414_213, 0);
    assert!(sqrt(25 * scaling, precision_6) == 5 * scaling, 0);
    assert!(sqrt(59 * scaling, precision_6) == 7_681_145, 0);
    assert!(sqrt(100_000 * scaling, precision_6) == 316_227_766, 0);
    assert!(sqrt(300_000 * scaling, precision_6) == 547_722_557, 0);
    assert!(sqrt(100_000_000, precision_6) == 10_000_000, 0);

    assert!(sqrt(0, precision_9) == 0, 0);
    assert!(sqrt(1_000 * scaling, precision_9) == 1_000 * scaling, 0);
    assert!(sqrt(2_000 * scaling, precision_9) == 1_414_213_562, 0);
    assert!(sqrt(2_250 * scaling, precision_9) == 1_500 * scaling, 0);
    assert!(sqrt(25_000 * scaling, precision_9) == 5_000 * scaling, 0);
    assert!(sqrt(59_000 * scaling, precision_9) == 7_681_145_747, 0);
    assert!(sqrt(100_000_000 * scaling, precision_9) == 316_227_766_016, 0);
    assert!(sqrt(300_000_000 * scaling, precision_9) == 547_722_557_505, 0);
    assert!(sqrt(100_000_000_000, precision_9) == 10_000_000_000, 0);
}

#[test]
/// Test is_power_of_ten function
fun test_is_power_of_ten() {
    assert!(is_power_of_ten(1), 0);
    assert!(is_power_of_ten(10), 0);
    assert!(is_power_of_ten(100), 0);
    assert!(is_power_of_ten(1000), 0);
    assert!(is_power_of_ten(10000), 0);
    assert!(is_power_of_ten(100000), 0);
    assert!(!is_power_of_ten(0), 0);
    assert!(!is_power_of_ten(2), 0);
    assert!(!is_power_of_ten(3), 0);
    assert!(!is_power_of_ten(20), 0);
    assert!(!is_power_of_ten(1001), 0);
}
// Copyright (c) Mysten Labs, Inc.
// SPDX-License-Identifier: Apache-2.0

/// DEEP price module. This module maintains the conversion rate
/// between DEEP and the base and quote assets.
module deepbook::deep_price;

use deepbook::{balances::{Self, Balances}, constants, math};
use sui::event;

// === Errors ===
const EDataPointRecentlyAdded: u64 = 1;
const ENoDataPoints: u64 = 2;

// === Constants ===
// Minimum of 1 minutes between data points
const MIN_DURATION_BETWEEN_DATA_POINTS_MS: u64 = 1000 * 60;
// Price points older than 1 day will be removed
const MAX_DATA_POINT_AGE_MS: u64 = 1000 * 60 * 60 * 24;
// Maximum number of data points to maintan
const MAX_DATA_POINTS: u64 = 100;

// === Structs ===
/// DEEP price point.
public struct Price has drop, store {
    conversion_rate: u64,
    timestamp: u64,
}

/// DEEP price point added event.
public struct PriceAdded has copy, drop {
    conversion_rate: u64,
    timestamp: u64,
    is_base_conversion: bool,
    reference_pool: ID,
    target_pool: ID,
}

/// DEEP price points used for trading fee calculations.
public struct DeepPrice has drop, store {
    base_prices: vector<Price>,
    cumulative_base: u64,
    quote_prices: vector<Price>,
    cumulative_quote: u64,
}

public struct OrderDeepPrice has copy, drop, store {
    asset_is_base: bool,
    deep_per_asset: u64,
}

// === Public-View Functions ===
public fun asset_is_base(self: &OrderDeepPrice): bool {
    self.asset_is_base
}

public fun deep_per_asset(self: &OrderDeepPrice): u64 {
    self.deep_per_asset
}

// === Public-Package Functions ===
public(package) fun empty(): DeepPrice {
    DeepPrice {
        base_prices: vector[],
        cumulative_base: 0,
        quote_prices: vector[],
        cumulative_quote: 0,
    }
}

public(package) fun new_order_deep_price(asset_is_base: bool, deep_per_asset: u64): OrderDeepPrice {
    OrderDeepPrice {
        asset_is_base: asset_is_base,
        deep_per_asset: deep_per_asset,
    }
}

public(package) fun get_order_deep_price(self: &DeepPrice, whitelisted: bool): OrderDeepPrice {
    let (asset_is_base, deep_per_asset) = self.calculate_order_deep_price(
        whitelisted,
    );

    new_order_deep_price(asset_is_base, deep_per_asset)
}

public(package) fun empty_deep_price(_self: &DeepPrice): OrderDeepPrice {
    new_order_deep_price(false, 0)
}

public(package) fun fee_quantity(
    self: &OrderDeepPrice,
    base_quantity: u64,
    quote_quantity: u64,
    is_bid: bool,
): Balances {
    let deep_quantity = if (self.asset_is_base) {
        math::mul(base_quantity, self.deep_per_asset)
    } else {
        math::mul(quote_quantity, self.deep_per_asset)
    };

    if (self.deep_per_asset > 0) {
        balances::new(0, 0, deep_quantity)
    } else if (is_bid) {
        balances::new(
            0,
            math::mul(
                quote_quantity,
                constants::fee_penalty_multiplier(),
            ),
            0,
        )
    } else {
        balances::new(
            math::mul(base_quantity, constants::fee_penalty_multiplier()),
            0,
            0,
        )
    }
}

public(package) fun deep_quantity_u128(
    self: &OrderDeepPrice,
    base_quantity: u128,
    quote_quantity: u128,
): u128 {
    if (self.asset_is_base) {
        math::mul_u128(base_quantity, self.deep_per_asset as u128)
    } else {
        math::mul_u128(quote_quantity, self.deep_per_asset as u128)
    }
}

/// Add a price point. If max data points are reached, the oldest data point is removed.
/// Remove all data points older than MAX_DATA_POINT_AGE_MS.
public(package) fun add_price_point(
    self: &mut DeepPrice,
    conversion_rate: u64,
    timestamp: u64,
    is_base_conversion: bool,
) {
    assert!(
        self.last_insert_timestamp(is_base_conversion) +
        MIN_DURATION_BETWEEN_DATA_POINTS_MS <
        timestamp,
        EDataPointRecentlyAdded,
    );
    let asset_prices = if (is_base_conversion) {
        &mut self.base_prices
    } else {
        &mut self.quote_prices
    };

    asset_prices.push_back(Price {
        timestamp: timestamp,
        conversion_rate: conversion_rate,
    });
    if (is_base_conversion) {
        self.cumulative_base = self.cumulative_base + conversion_rate;
        while (
            asset_prices.length() == MAX_DATA_POINTS + 1 ||
            asset_prices[0].timestamp + MAX_DATA_POINT_AGE_MS < timestamp
        ) {
            self.cumulative_base = self.cumulative_base - asset_prices[0].conversion_rate;
            asset_prices.remove(0);
        }
    } else {
        self.cumulative_quote = self.cumulative_quote + conversion_rate;
        while (
            asset_prices.length() == MAX_DATA_POINTS + 1 ||
            asset_prices[0].timestamp + MAX_DATA_POINT_AGE_MS < timestamp
        ) {
            self.cumulative_quote = self.cumulative_quote - asset_prices[0].conversion_rate;
            asset_prices.remove(0);
        }
    };
}

public(package) fun emit_deep_price_added(
    conversion_rate: u64,
    timestamp: u64,
    is_base_conversion: bool,
    reference_pool: ID,
    target_pool: ID,
) {
    event::emit(PriceAdded {
        conversion_rate,
        timestamp,
        is_base_conversion,
        reference_pool,
        target_pool,
    });
}

// === Private Functions ===
/// Returns the conversion rate of DEEP per asset token.
/// Quote will be used by default, if there are no quote data then base will be used
fun calculate_order_deep_price(self: &DeepPrice, whitelisted: bool): (bool, u64) {
    if (whitelisted) {
        return (false, 0) // no fees for whitelist
    };
    assert!(
        self.last_insert_timestamp(true) > 0 ||
        self.last_insert_timestamp(false) > 0,
        ENoDataPoints,
    );

    let is_base_conversion = self.last_insert_timestamp(false) == 0;

    let cumulative_asset = if (is_base_conversion) {
        self.cumulative_base
    } else {
        self.cumulative_quote
    };
    let asset_length = if (is_base_conversion) {
        self.base_prices.length()
    } else {
        self.quote_prices.length()
    };
    let deep_per_asset = cumulative_asset / asset_length;

    (is_base_conversion, deep_per_asset)
}

fun last_insert_timestamp(self: &DeepPrice, is_base_conversion: bool): u64 {
    let prices = if (is_base_conversion) {
        &self.base_prices
    } else {
        &self.quote_prices
    };
    if (prices.length() > 0) {
        prices[prices.length() - 1].timestamp
    } else {
        0
    }
}
// Copyright (c) Mysten Labs, Inc.
// SPDX-License-Identifier: Apache-2.0

/// The vault holds all of the assets for this pool. At the end of all
/// transaction processing, the vault is used to settle the balances for the user.
module deepbook::vault;

use deepbook::{balance_manager::{TradeProof, BalanceManager}, balances::Balances};
use std::type_name::{Self, TypeName};
use sui::{balance::{Self, Balance}, coin::Coin, event};
use token::deep::DEEP;

// === Errors ===
const ENotEnoughBaseForLoan: u64 = 1;
const ENotEnoughQuoteForLoan: u64 = 2;
const EInvalidLoanQuantity: u64 = 3;
const EIncorrectLoanPool: u64 = 4;
const EIncorrectTypeReturned: u64 = 5;
const EIncorrectQuantityReturned: u64 = 6;

// === Structs ===
public struct Vault<phantom BaseAsset, phantom QuoteAsset> has store {
    base_balance: Balance<BaseAsset>,
    quote_balance: Balance<QuoteAsset>,
    deep_balance: Balance<DEEP>,
}

public struct FlashLoan {
    pool_id: ID,
    borrow_quantity: u64,
    type_name: TypeName,
}

public struct FlashLoanBorrowed has copy, drop {
    pool_id: ID,
    borrow_quantity: u64,
    type_name: TypeName,
}

// === Public-Package Functions ===
public(package) fun balances<BaseAsset, QuoteAsset>(
    self: &Vault<BaseAsset, QuoteAsset>,
): (u64, u64, u64) {
    (self.base_balance.value(), self.quote_balance.value(), self.deep_balance.value())
}

public(package) fun empty<BaseAsset, QuoteAsset>(): Vault<BaseAsset, QuoteAsset> {
    Vault {
        base_balance: balance::zero(),
        quote_balance: balance::zero(),
        deep_balance: balance::zero(),
    }
}

/// Transfer any settled amounts for the `balance_manager`.
public(package) fun settle_balance_manager<BaseAsset, QuoteAsset>(
    self: &mut Vault<BaseAsset, QuoteAsset>,
    balances_out: Balances,
    balances_in: Balances,
    balance_manager: &mut BalanceManager,
    trade_proof: &TradeProof,
) {
    balance_manager.validate_proof(trade_proof);
    if (balances_out.base() > balances_in.base()) {
        let balance = self.base_balance.split(balances_out.base() - balances_in.base());
        balance_manager.deposit_with_proof(trade_proof, balance);
    };
    if (balances_out.quote() > balances_in.quote()) {
        let balance = self.quote_balance.split(balances_out.quote() - balances_in.quote());
        balance_manager.deposit_with_proof(trade_proof, balance);
    };
    if (balances_out.deep() > balances_in.deep()) {
        let balance = self.deep_balance.split(balances_out.deep() - balances_in.deep());
        balance_manager.deposit_with_proof(trade_proof, balance);
    };
    if (balances_in.base() > balances_out.base()) {
        let balance = balance_manager.withdraw_with_proof(
            trade_proof,
            balances_in.base() - balances_out.base(),
            false,
        );
        self.base_balance.join(balance);
    };
    if (balances_in.quote() > balances_out.quote()) {
        let balance = balance_manager.withdraw_with_proof(
            trade_proof,
            balances_in.quote() - balances_out.quote(),
            false,
        );
        self.quote_balance.join(balance);
    };
    if (balances_in.deep() > balances_out.deep()) {
        let balance = balance_manager.withdraw_with_proof(
            trade_proof,
            balances_in.deep() - balances_out.deep(),
            false,
        );
        self.deep_balance.join(balance);
    };
}

public(package) fun withdraw_deep_to_burn<BaseAsset, QuoteAsset>(
    self: &mut Vault<BaseAsset, QuoteAsset>,
    amount_to_burn: u64,
): Balance<DEEP> {
    self.deep_balance.split(amount_to_burn)
}

public(package) fun borrow_flashloan_base<BaseAsset, QuoteAsset>(
    self: &mut Vault<BaseAsset, QuoteAsset>,
    pool_id: ID,
    borrow_quantity: u64,
    ctx: &mut TxContext,
): (Coin<BaseAsset>, FlashLoan) {
    assert!(borrow_quantity > 0, EInvalidLoanQuantity);
    assert!(self.base_balance.value() >= borrow_quantity, ENotEnoughBaseForLoan);
    let borrow_type_name = type_name::with_defining_ids<BaseAsset>();
    let borrow: Coin<BaseAsset> = self.base_balance.split(borrow_quantity).into_coin(ctx);

    let flash_loan = FlashLoan {
        pool_id,
        borrow_quantity,
        type_name: borrow_type_name,
    };

    event::emit(FlashLoanBorrowed {
        pool_id,
        borrow_quantity,
        type_name: borrow_type_name,
    });

    (borrow, flash_loan)
}

public(package) fun borrow_flashloan_quote<BaseAsset, QuoteAsset>(
    self: &mut Vault<BaseAsset, QuoteAsset>,
    pool_id: ID,
    borrow_quantity: u64,
    ctx: &mut TxContext,
): (Coin<QuoteAsset>, FlashLoan) {
    assert!(borrow_quantity > 0, EInvalidLoanQuantity);
    assert!(self.quote_balance.value() >= borrow_quantity, ENotEnoughQuoteForLoan);
    let borrow_type_name = type_name::with_defining_ids<QuoteAsset>();
    let borrow: Coin<QuoteAsset> = self.quote_balance.split(borrow_quantity).into_coin(ctx);

    let flash_loan = FlashLoan {
        pool_id,
        borrow_quantity,
        type_name: borrow_type_name,
    };

    event::emit(FlashLoanBorrowed {
        pool_id,
        borrow_quantity,
        type_name: borrow_type_name,
    });

    (borrow, flash_loan)
}

public(package) fun return_flashloan_base<BaseAsset, QuoteAsset>(
    self: &mut Vault<BaseAsset, QuoteAsset>,
    pool_id: ID,
    coin: Coin<BaseAsset>,
    flash_loan: FlashLoan,
) {
    assert!(pool_id == flash_loan.pool_id, EIncorrectLoanPool);
    assert!(
        type_name::with_defining_ids<BaseAsset>() == flash_loan.type_name,
        EIncorrectTypeReturned,
    );
    assert!(coin.value() == flash_loan.borrow_quantity, EIncorrectQuantityReturned);

    self.base_balance.join(coin.into_balance<BaseAsset>());

    let FlashLoan {
        pool_id: _,
        borrow_quantity: _,
        type_name: _,
    } = flash_loan;
}

public(package) fun return_flashloan_quote<BaseAsset, QuoteAsset>(
    self: &mut Vault<BaseAsset, QuoteAsset>,
    pool_id: ID,
    coin: Coin<QuoteAsset>,
    flash_loan: FlashLoan,
) {
    assert!(pool_id == flash_loan.pool_id, EIncorrectLoanPool);
    assert!(
        type_name::with_defining_ids<QuoteAsset>() == flash_loan.type_name,
        EIncorrectTypeReturned,
    );
    assert!(coin.value() == flash_loan.borrow_quantity, EIncorrectQuantityReturned);

    self.quote_balance.join(coin.into_balance<QuoteAsset>());

    let FlashLoan {
        pool_id: _,
        borrow_quantity: _,
        type_name: _,
    } = flash_loan;
}
// Copyright (c) Mysten Labs, Inc.
// SPDX-License-Identifier: Apache-2.0

module margin_trading::margin_pool;

use deepbook::math;
use margin_trading::{
    margin_registry::{MarginRegistry, MaintainerCap, MarginPoolCap},
    margin_state::{Self, State},
    position_manager::{Self, PositionManager},
    protocol_config::{InterestConfig, MarginPoolConfig, ProtocolConfig}
};
use std::type_name::{Self, TypeName};
use sui::{balance::{Self, Balance}, clock::Clock, coin::Coin, event, vec_set::{Self, VecSet}};

// === Errors ===
const ENotEnoughAssetInPool: u64 = 1;
const ESupplyCapExceeded: u64 = 2;
const ECannotWithdrawMoreThanSupply: u64 = 3;
const EMaxPoolBorrowPercentageExceeded: u64 = 4;
const EInvalidLoanQuantity: u64 = 5;
const EDeepbookPoolAlreadyAllowed: u64 = 6;
const EDeepbookPoolNotAllowed: u64 = 7;
const EInvalidMarginPoolCap: u64 = 8;
const EBorrowAmountTooLow: u64 = 9;

// === Structs ===
public struct MarginPool<phantom Asset> has key, store {
    id: UID,
    vault: Balance<Asset>,
    state: State,
    config: ProtocolConfig,
    protocol_profit: u64,
    positions: PositionManager,
    allowed_deepbook_pools: VecSet<ID>,
}

// === Events ===
public struct MarginPoolCreated has copy, drop {
    margin_pool_id: ID,
    maintainer_cap_id: ID,
    asset_type: TypeName,
    config: ProtocolConfig,
    timestamp: u64,
}

public struct DeepbookPoolEnabled has copy, drop {
    margin_pool_id: ID,
    deepbook_pool_id: ID,
    pool_cap_id: ID,
    enabled: bool,
    timestamp: u64,
}

public struct InterestParamsUpdated has copy, drop {
    margin_pool_id: ID,
    pool_cap_id: ID,
    interest_config: InterestConfig,
    timestamp: u64,
}

public struct MarginPoolConfigUpdated has copy, drop {
    margin_pool_id: ID,
    pool_cap_id: ID,
    margin_pool_config: MarginPoolConfig,
    timestamp: u64,
}

public struct ProtocolProfitWithdrawn has copy, drop {
    margin_pool_id: ID,
    pool_cap_id: ID,
    asset_type: TypeName,
    profit: u64,
    timestamp: u64,
}

public struct AssetSupplied has copy, drop {
    margin_pool_id: ID,
    asset_type: TypeName,
    supplier: address,
    supply_amount: u64,
    supply_shares: u64,
    timestamp: u64,
}

public struct AssetWithdrawn has copy, drop {
    margin_pool_id: ID,
    asset_type: TypeName,
    supplier: address,
    withdrawal_amount: u64,
    withdrawal_shares: u64,
    timestamp: u64,
}

// === Public Functions * ADMIN *===
/// Creates and registers a new margin pool. If a same asset pool already exists, abort.
/// Sends a `MarginPoolCap` to the pool creator. Returns the created margin pool id.
public fun create_margin_pool<Asset>(
    registry: &mut MarginRegistry,
    config: ProtocolConfig,
    maintainer_cap: &MaintainerCap,
    clock: &Clock,
    ctx: &mut TxContext,
): ID {
    let id = object::new(ctx);
    let margin_pool_id = id.to_inner();
    let margin_pool = MarginPool<Asset> {
        id,
        vault: balance::zero<Asset>(),
        state: margin_state::default(clock),
        config,
        protocol_profit: 0,
        positions: position_manager::create_position_manager(ctx),
        allowed_deepbook_pools: vec_set::empty(),
    };
    transfer::share_object(margin_pool);

    let asset_type = type_name::with_defining_ids<Asset>();
    registry.register_margin_pool(asset_type, margin_pool_id, maintainer_cap, ctx);

    let maintainer_cap_id = maintainer_cap.maintainer_cap_id();
    event::emit(MarginPoolCreated {
        margin_pool_id,
        maintainer_cap_id,
        asset_type,
        config,
        timestamp: clock.timestamp_ms(),
    });

    margin_pool_id
}

/// Allow a margin manager tied to a deepbook pool to borrow from the margin pool.
public fun enable_deepbook_pool_for_loan<Asset>(
    self: &mut MarginPool<Asset>,
    registry: &MarginRegistry,
    deepbook_pool_id: ID,
    margin_pool_cap: &MarginPoolCap,
    clock: &Clock,
) {
    registry.load_inner();
    assert!(margin_pool_cap.margin_pool_id() == self.id(), EInvalidMarginPoolCap);
    assert!(!self.allowed_deepbook_pools.contains(&deepbook_pool_id), EDeepbookPoolAlreadyAllowed);
    self.allowed_deepbook_pools.insert(deepbook_pool_id);

    event::emit(DeepbookPoolEnabled {
        margin_pool_id: self.id(),
        pool_cap_id: margin_pool_cap.pool_cap_id(),
        deepbook_pool_id,
        enabled: true,
        timestamp: clock.timestamp_ms(),
    });
}

/// Disable a margin manager tied to a deepbook pool from borrowing from the margin pool.
public fun disable_deepbook_pool_for_loan<Asset>(
    self: &mut MarginPool<Asset>,
    registry: &MarginRegistry,
    deepbook_pool_id: ID,
    margin_pool_cap: &MarginPoolCap,
    clock: &Clock,
) {
    registry.load_inner();
    assert!(margin_pool_cap.margin_pool_id() == self.id(), EInvalidMarginPoolCap);
    assert!(self.allowed_deepbook_pools.contains(&deepbook_pool_id), EDeepbookPoolNotAllowed);
    self.allowed_deepbook_pools.remove(&deepbook_pool_id);

    event::emit(DeepbookPoolEnabled {
        margin_pool_id: self.id(),
        pool_cap_id: margin_pool_cap.pool_cap_id(),
        deepbook_pool_id,
        enabled: false,
        timestamp: clock.timestamp_ms(),
    });
}

/// Updates interest params for the margin pool
public fun update_interest_params<Asset>(
    self: &mut MarginPool<Asset>,
    registry: &MarginRegistry,
    interest_config: InterestConfig,
    margin_pool_cap: &MarginPoolCap,
    clock: &Clock,
) {
    registry.load_inner();
    assert!(margin_pool_cap.margin_pool_id() == self.id(), EInvalidMarginPoolCap);
    self.config.set_interest_config(interest_config);

    event::emit(InterestParamsUpdated {
        margin_pool_id: self.id(),
        pool_cap_id: margin_pool_cap.pool_cap_id(),
        interest_config,
        timestamp: clock.timestamp_ms(),
    });
}

/// Updates margin pool config
public fun update_margin_pool_config<Asset>(
    self: &mut MarginPool<Asset>,
    registry: &MarginRegistry,
    margin_pool_config: MarginPoolConfig,
    margin_pool_cap: &MarginPoolCap,
    clock: &Clock,
) {
    registry.load_inner();
    assert!(margin_pool_cap.margin_pool_id() == self.id(), EInvalidMarginPoolCap);
    self.config.set_margin_pool_config(margin_pool_config);

    event::emit(MarginPoolConfigUpdated {
        margin_pool_id: self.id(),
        pool_cap_id: margin_pool_cap.pool_cap_id(),
        margin_pool_config,
        timestamp: clock.timestamp_ms(),
    });
}

/// Resets the protocol profit and returns the coin.
public fun withdraw_protocol_profit<Asset>(
    self: &mut MarginPool<Asset>,
    registry: &MarginRegistry,
    margin_pool_cap: &MarginPoolCap,
    clock: &Clock,
    ctx: &mut TxContext,
): Coin<Asset> {
    registry.load_inner();
    assert!(margin_pool_cap.margin_pool_id() == self.id(), EInvalidMarginPoolCap);

    let profit = self.protocol_profit;
    self.protocol_profit = 0;
    let balance = self.vault.split(profit);

    let coin = balance.into_coin(ctx);

    event::emit(ProtocolProfitWithdrawn {
        margin_pool_id: self.id(),
        pool_cap_id: margin_pool_cap.pool_cap_id(),
        asset_type: type_name::with_defining_ids<Asset>(),
        profit,
        timestamp: clock.timestamp_ms(),
    });

    coin
}

// === Public Functions * LENDING * ===
/// Allows anyone to supply the margin pool. Returns the new user supply amount.
public fun supply<Asset>(
    self: &mut MarginPool<Asset>,
    registry: &MarginRegistry,
    coin: Coin<Asset>,
    clock: &Clock,
    ctx: &TxContext,
) {
    registry.load_inner();
    self.update_state(clock);

    let supplier = ctx.sender();

    let supply_amount = coin.value();
    let supply_shares = self.state.to_supply_shares(supply_amount);
    self.state.increase_total_supply(supply_amount);
    self.positions.increase_user_supply_shares(supplier, supply_shares);

    let balance = coin.into_balance();
    self.vault.join(balance);

    assert!(self.state.total_supply() <= self.config.supply_cap(), ESupplyCapExceeded);

    event::emit(AssetSupplied {
        margin_pool_id: self.id(),
        asset_type: type_name::with_defining_ids<Asset>(),
        supplier,
        supply_amount,
        supply_shares,
        timestamp: clock.timestamp_ms(),
    });
}

/// Allows withdrawal from the margin pool. Returns the withdrawn coin and the new user supply amount.
public fun withdraw<Asset>(
    self: &mut MarginPool<Asset>,
    registry: &MarginRegistry,
    amount: Option<u64>,
    clock: &Clock,
    ctx: &mut TxContext,
): Coin<Asset> {
    registry.load_inner();
    self.update_state(clock);

    let supplier = ctx.sender();

    let user_supply_shares = self.positions.user_supply_shares(supplier);
    let user_supply_amount = self.state.to_supply_amount(user_supply_shares);
    let withdrawal_amount = amount.get_with_default(user_supply_amount);
    let withdrawal_shares = self.state.to_supply_shares(withdrawal_amount);
    assert!(withdrawal_shares <= user_supply_shares, ECannotWithdrawMoreThanSupply);
    assert!(withdrawal_amount <= self.vault.value(), ENotEnoughAssetInPool);

    self.state.decrease_total_supply(withdrawal_amount);
    self.positions.decrease_user_supply_shares(supplier, withdrawal_shares);

    let coin = self.vault.split(withdrawal_amount).into_coin(ctx);

    event::emit(AssetWithdrawn {
        margin_pool_id: self.id(),
        asset_type: type_name::with_defining_ids<Asset>(),
        supplier,
        withdrawal_amount,
        withdrawal_shares,
        timestamp: clock.timestamp_ms(),
    });

    coin
}

// === Public-View Functions ===
public fun deepbook_pool_allowed<Asset>(self: &MarginPool<Asset>, deepbook_pool_id: ID): bool {
    self.allowed_deepbook_pools.contains(&deepbook_pool_id)
}

// === Public-Package Functions ===
public(package) fun update_state<Asset>(self: &mut MarginPool<Asset>, clock: &Clock) {
    let interest_accrued = self.state.update(&self.config, clock);
    let protocol_profit_accrued = math::mul(interest_accrued, self.config.protocol_spread());
    if (protocol_profit_accrued > 0) {
        self.protocol_profit = self.protocol_profit + protocol_profit_accrued;
        self.state.decrease_total_supply_with_index(protocol_profit_accrued);
    }
}

/// Allows borrowing from the margin pool. Returns the borrowed coin.
public(package) fun borrow<Asset>(
    self: &mut MarginPool<Asset>,
    amount: u64,
    clock: &Clock,
    ctx: &mut TxContext,
): Coin<Asset> {
    assert!(amount <= self.vault.value(), ENotEnoughAssetInPool);
    assert!(amount > 0, EInvalidLoanQuantity);

    self.update_state(clock);
    self.state.increase_total_borrow(amount);

    assert!(
        self.state.utilization_rate() <= self.config.max_utilization_rate(),
        EMaxPoolBorrowPercentageExceeded,
    );
    assert!(amount >= self.config.min_borrow(), EBorrowAmountTooLow);

    let balance = self.vault.split(amount);

    balance.into_coin(ctx)
}

/// Allows repaying the loan.
public(package) fun repay<Asset>(self: &mut MarginPool<Asset>, coin: Coin<Asset>, clock: &Clock) {
    self.update_state(clock);
    self.state.decrease_total_borrow(coin.value());
    self.vault.join(coin.into_balance());
}

public(package) fun repay_with_reward<Asset>(
    self: &mut MarginPool<Asset>,
    coin: Coin<Asset>,
    repay_amount: u64,
    reward_amount: u64,
    default_amount: u64,
    clock: &Clock,
) {
    self.update_state(clock);
    self.state.decrease_total_borrow(repay_amount);
    self.state.increase_total_supply_with_index(reward_amount);
    self.state.decrease_total_supply_with_index(default_amount);
    self.vault.join(coin.into_balance());
}

/// Returns the supply cap.
public(package) fun supply_cap<Asset>(self: &MarginPool<Asset>): u64 {
    self.config.supply_cap()
}

public(package) fun to_borrow_shares<Asset>(self: &MarginPool<Asset>, amount: u64): u64 {
    self.state.to_borrow_shares(amount)
}

public(package) fun to_borrow_amount<Asset>(self: &MarginPool<Asset>, shares: u64): u64 {
    self.state.to_borrow_amount(shares)
}

public(package) fun id<Asset>(self: &MarginPool<Asset>): ID {
    self.id.to_inner()
}
// Copyright (c) Mysten Labs, Inc.
// SPDX-License-Identifier: Apache-2.0

/// Registry holds all margin pools.
module margin_trading::margin_registry;

use deepbook::{constants, math, pool::Pool};
use margin_trading::margin_constants;
use std::type_name::{Self, TypeName};
use sui::{
    clock::Clock,
    dynamic_field as df,
    event,
    table::{Self, Table},
    vec_set::{Self, VecSet},
    versioned::{Self, Versioned}
};

use fun df::add as UID.add;
use fun df::borrow as UID.borrow;
use fun df::remove as UID.remove;

// === Errors ===
const EInvalidRiskParam: u64 = 1;
const EPoolAlreadyRegistered: u64 = 2;
const EPoolNotRegistered: u64 = 3;
const EPoolNotEnabled: u64 = 4;
const EPoolAlreadyEnabled: u64 = 5;
const EPoolAlreadyDisabled: u64 = 6;
const EMarginPoolAlreadyExists: u64 = 7;
const EMarginPoolDoesNotExists: u64 = 8;
const EMaintainerCapNotValid: u64 = 9;
const EPackageVersionDisabled: u64 = 10;
const EVersionAlreadyEnabled: u64 = 11;
const ECannotDisableCurrentVersion: u64 = 12;
const EVersionNotEnabled: u64 = 13;

public struct MARGIN_REGISTRY has drop {}

// === Structs ===
public struct MarginRegistry has key {
    id: UID,
    inner: Versioned,
}

public struct MarginRegistryInner has store {
    registry_id: ID,
    allowed_versions: VecSet<u64>,
    pool_registry: Table<ID, PoolConfig>,
    margin_pools: Table<TypeName, ID>,
    allowed_maintainers: VecSet<ID>,
}

public struct PoolConfig has copy, drop, store {
    base_margin_pool_id: ID,
    quote_margin_pool_id: ID,
    risk_ratios: RiskRatios,
    user_liquidation_reward: u64, // fractional reward for liquidating a position, in 9 decimals
    pool_liquidation_reward: u64, // fractional reward for the pool, in 9 decimals
    enabled: bool, // whether the pool is enabled for margin trading
}

public struct RiskRatios has copy, drop, store {
    min_withdraw_risk_ratio: u64,
    min_borrow_risk_ratio: u64,
    liquidation_risk_ratio: u64,
    target_liquidation_risk_ratio: u64,
}

public struct ConfigKey<phantom Config> has copy, drop, store {}

// === Caps ===
public struct MarginAdminCap has key, store {
    id: UID,
}

public struct MaintainerCap has key, store {
    id: UID,
}

public struct MarginPoolCap has key, store {
    id: UID,
    margin_pool_id: ID,
}

// === Events ===
public struct MaintainerCapUpdated has copy, drop {
    maintainer_cap_id: ID,
    allowed: bool,
    timestamp: u64,
}

public struct DeepbookPoolRegistered has copy, drop {
    pool_id: ID,
    timestamp: u64,
}

public struct DeepbookPoolUpdated has copy, drop {
    pool_id: ID,
    enabled: bool,
    timestamp: u64,
}

public struct DeepbookPoolConfigUpdated has copy, drop {
    pool_id: ID,
    config: PoolConfig,
    timestamp: u64,
}

fun init(_: MARGIN_REGISTRY, ctx: &mut TxContext) {
    let id = object::new(ctx);
    let margin_registry_inner = MarginRegistryInner {
        registry_id: id.to_inner(),
        allowed_versions: vec_set::singleton(margin_constants::margin_version()),
        pool_registry: table::new(ctx),
        margin_pools: table::new(ctx),
        allowed_maintainers: vec_set::empty(),
    };

    let registry = MarginRegistry {
        id,
        inner: versioned::create(margin_constants::margin_version(), margin_registry_inner, ctx),
    };
    let margin_admin_cap = MarginAdminCap { id: object::new(ctx) };
    transfer::share_object(registry);
    transfer::public_transfer(margin_admin_cap, ctx.sender());
}

// === Public Functions * ADMIN * ===
/// Mint a `MaintainerCap`, only admin can mint a `MaintainerCap`.
public fun mint_maintainer_cap(
    self: &mut MarginRegistry,
    _cap: &MarginAdminCap,
    clock: &Clock,
    ctx: &mut TxContext,
): MaintainerCap {
    let self = self.load_inner_mut();
    let id = object::new(ctx);
    self.allowed_maintainers.insert(id.to_inner());

    event::emit(MaintainerCapUpdated {
        maintainer_cap_id: id.to_inner(),
        allowed: true,
        timestamp: clock.timestamp_ms(),
    });

    MaintainerCap {
        id,
    }
}

/// Revoke a `MaintainerCap`. Only the admin can revoke a `MaintainerCap`.
public fun revoke_maintainer_cap(
    self: &mut MarginRegistry,
    _cap: &MarginAdminCap,
    maintainer_cap_id: ID,
    clock: &Clock,
) {
    let self = self.load_inner_mut();
    assert!(self.allowed_maintainers.contains(&maintainer_cap_id), EMaintainerCapNotValid);
    self.allowed_maintainers.remove(&maintainer_cap_id);

    event::emit(MaintainerCapUpdated {
        maintainer_cap_id,
        allowed: false,
        timestamp: clock.timestamp_ms(),
    });
}

/// Register a margin pool for margin trading with existing margin pools
public fun register_deepbook_pool<BaseAsset, QuoteAsset>(
    self: &mut MarginRegistry,
    _cap: &MarginAdminCap,
    pool: &Pool<BaseAsset, QuoteAsset>,
    pool_config: PoolConfig,
    clock: &Clock,
) {
    let inner = self.load_inner_mut();
    let pool_id = pool.id();
    assert!(!inner.pool_registry.contains(pool_id), EPoolAlreadyRegistered);

    inner.pool_registry.add(pool_id, pool_config);

    event::emit(DeepbookPoolRegistered {
        pool_id,
        timestamp: clock.timestamp_ms(),
    });
}

/// Enables a deepbook pool for margin trading.
public fun enable_deepbook_pool<BaseAsset, QuoteAsset>(
    self: &mut MarginRegistry,
    _cap: &MarginAdminCap,
    pool: &mut Pool<BaseAsset, QuoteAsset>,
    clock: &Clock,
) {
    let inner = self.load_inner_mut();
    let pool_id = pool.id();
    assert!(inner.pool_registry.contains(pool_id), EPoolNotRegistered);

    let config = inner.pool_registry.borrow_mut(pool_id);
    assert!(config.enabled == false, EPoolAlreadyEnabled);
    config.enabled = true;

    event::emit(DeepbookPoolUpdated {
        pool_id,
        enabled: true,
        timestamp: clock.timestamp_ms(),
    });
}

/// Disables a deepbook pool from margin trading. Only reduce only orders, cancels, and withdraw settled amounts are allowed.
public fun disable_deepbook_pool<BaseAsset, QuoteAsset>(
    self: &mut MarginRegistry,
    _cap: &MarginAdminCap,
    pool: &mut Pool<BaseAsset, QuoteAsset>,
    clock: &Clock,
) {
    let inner = self.load_inner_mut();
    let pool_id = pool.id();
    assert!(inner.pool_registry.contains(pool_id), EPoolNotRegistered);

    let config = inner.pool_registry.borrow_mut(pool_id);
    assert!(config.enabled == true, EPoolAlreadyDisabled);
    config.enabled = false;

    event::emit(DeepbookPoolUpdated {
        pool_id,
        enabled: false,
        timestamp: clock.timestamp_ms(),
    });
}

/// Updates risk params for a deepbook pool as the admin.
public fun update_risk_params<BaseAsset, QuoteAsset>(
    self: &mut MarginRegistry,
    _cap: &MarginAdminCap,
    pool: &Pool<BaseAsset, QuoteAsset>,
    pool_config: PoolConfig,
    clock: &Clock,
) {
    let inner = self.load_inner_mut();
    let pool_id = pool.id();
    assert!(inner.pool_registry.contains(pool_id), EPoolNotRegistered);

    let prev_config = inner.pool_registry.remove(pool_id);
    assert!(
        pool_config.risk_ratios.liquidation_risk_ratio <= prev_config
            .risk_ratios
            .liquidation_risk_ratio,
        EInvalidRiskParam,
    );
    assert!(prev_config.enabled, EPoolNotEnabled);

    // Validate new risk parameters
    assert!(
        pool_config.risk_ratios.min_borrow_risk_ratio < pool_config
            .risk_ratios
            .min_withdraw_risk_ratio,
        EInvalidRiskParam,
    );
    assert!(
        pool_config.risk_ratios.liquidation_risk_ratio < pool_config
            .risk_ratios
            .min_borrow_risk_ratio,
        EInvalidRiskParam,
    );
    assert!(
        pool_config.risk_ratios.liquidation_risk_ratio < pool_config
            .risk_ratios
            .target_liquidation_risk_ratio,
        EInvalidRiskParam,
    );
    assert!(
        pool_config.risk_ratios.liquidation_risk_ratio >= constants::float_scaling(),
        EInvalidRiskParam,
    );

    inner.pool_registry.add(pool_id, pool_config);

    event::emit(DeepbookPoolConfigUpdated {
        pool_id,
        config: pool_config,
        timestamp: clock.timestamp_ms(),
    });
}

/// Add Pyth Config to the MarginRegistry.
public fun add_config<Config: store + drop>(
    self: &mut MarginRegistry,
    _cap: &MarginAdminCap,
    config: Config,
) {
    self.load_inner();
    self.id.add(ConfigKey<Config> {}, config);
}

/// Remove Pyth Config from the MarginRegistry.
public fun remove_config<Config: store + drop>(
    self: &mut MarginRegistry,
    _cap: &MarginAdminCap,
): Config {
    self.load_inner();
    self.id.remove(ConfigKey<Config> {})
}

/// Enables a package version
/// Only Admin can enable a package version
/// This function does not have version restrictions
public fun enable_version(self: &mut MarginRegistry, version: u64, _cap: &MarginAdminCap) {
    let self: &mut MarginRegistryInner = self.inner.load_value_mut();
    assert!(!self.allowed_versions.contains(&version), EVersionAlreadyEnabled);
    self.allowed_versions.insert(version);
}

/// Disables a package version
/// Only Admin can disable a package version
/// This function does not have version restrictions
public fun disable_version(self: &mut MarginRegistry, version: u64, _cap: &MarginAdminCap) {
    let self: &mut MarginRegistryInner = self.inner.load_value_mut();
    assert!(version != margin_constants::margin_version(), ECannotDisableCurrentVersion);
    assert!(self.allowed_versions.contains(&version), EVersionNotEnabled);
    self.allowed_versions.remove(&version);
}

// === Public Helper Functions ===
/// Create a PoolConfig with margin pool IDs and risk parameters
/// Enable is false by default, must be enabled after registration
public fun new_pool_config<BaseAsset, QuoteAsset>(
    self: &MarginRegistry,
    min_withdraw_risk_ratio: u64,
    min_borrow_risk_ratio: u64,
    liquidation_risk_ratio: u64,
    target_liquidation_risk_ratio: u64,
    user_liquidation_reward: u64,
    pool_liquidation_reward: u64,
): PoolConfig {
    assert!(min_borrow_risk_ratio < min_withdraw_risk_ratio, EInvalidRiskParam);
    assert!(liquidation_risk_ratio < min_borrow_risk_ratio, EInvalidRiskParam);
    assert!(liquidation_risk_ratio < target_liquidation_risk_ratio, EInvalidRiskParam);
    assert!(liquidation_risk_ratio >= constants::float_scaling(), EInvalidRiskParam);
    assert!(user_liquidation_reward <= constants::float_scaling(), EInvalidRiskParam);
    assert!(pool_liquidation_reward <= constants::float_scaling(), EInvalidRiskParam);
    assert!(
        user_liquidation_reward + pool_liquidation_reward <= constants::float_scaling(),
        EInvalidRiskParam,
    );
    assert!(
        target_liquidation_risk_ratio >
        constants::float_scaling() + user_liquidation_reward + pool_liquidation_reward,
        EInvalidRiskParam,
    );

    PoolConfig {
        base_margin_pool_id: self.get_margin_pool_id<BaseAsset>(),
        quote_margin_pool_id: self.get_margin_pool_id<QuoteAsset>(),
        risk_ratios: RiskRatios {
            min_withdraw_risk_ratio,
            min_borrow_risk_ratio,
            liquidation_risk_ratio,
            target_liquidation_risk_ratio,
        },
        user_liquidation_reward,
        pool_liquidation_reward,
        enabled: false,
    }
}

/// Create a PoolConfig with default risk parameters based on leverage
public fun new_pool_config_with_leverage<BaseAsset, QuoteAsset>(
    self: &MarginRegistry,
    leverage: u64,
): PoolConfig {
    self.load_inner();
    assert!(leverage > margin_constants::min_leverage(), EInvalidRiskParam);
    assert!(leverage <= margin_constants::max_leverage(), EInvalidRiskParam);

    let factor = math::div(constants::float_scaling(), leverage - constants::float_scaling());
    let risk_ratios = calculate_risk_ratios(factor);

    self.new_pool_config<BaseAsset, QuoteAsset>(
        risk_ratios.min_withdraw_risk_ratio,
        risk_ratios.min_borrow_risk_ratio,
        risk_ratios.liquidation_risk_ratio,
        risk_ratios.target_liquidation_risk_ratio,
        margin_constants::default_user_liquidation_reward(),
        margin_constants::default_pool_liquidation_reward(),
    )
}

// === Public-View Functions ===
/// Check if a deepbook pool is registered for margin trading
public fun pool_enabled<BaseAsset, QuoteAsset>(
    self: &MarginRegistry,
    pool: &Pool<BaseAsset, QuoteAsset>,
): bool {
    let inner = self.load_inner();
    let pool_id = pool.id();
    if (inner.pool_registry.contains(pool_id)) {
        let config = inner.pool_registry.borrow(pool_id);

        config.enabled
    } else {
        false
    }
}

/// Get the margin pool id for the given asset.
public fun get_margin_pool_id<Asset>(self: &MarginRegistry): ID {
    let inner = self.load_inner();
    let key = type_name::with_defining_ids<Asset>();
    assert!(inner.margin_pools.contains(key), EMarginPoolDoesNotExists);

    *inner.margin_pools.borrow<TypeName, ID>(key)
}

/// Get the margin pool IDs for a deepbook pool
public fun get_deepbook_pool_margin_pool_ids(
    self: &MarginRegistry,
    deepbook_pool_id: ID,
): (ID, ID) {
    self.load_inner();
    let config = self.get_pool_config(deepbook_pool_id);
    (config.base_margin_pool_id, config.quote_margin_pool_id)
}

// === Public-Package Functions ===
#[allow(lint(self_transfer))]
public(package) fun register_margin_pool(
    self: &mut MarginRegistry,
    key: TypeName,
    margin_pool_id: ID,
    maintainer_cap: &MaintainerCap,
    ctx: &mut TxContext,
) {
    let inner = self.load_inner_mut();
    assert!(
        inner.allowed_maintainers.contains(&maintainer_cap.id.to_inner()),
        EMaintainerCapNotValid,
    );
    assert!(!inner.margin_pools.contains(key), EMarginPoolAlreadyExists);
    inner.margin_pools.add(key, margin_pool_id);

    let margin_pool_cap = MarginPoolCap {
        id: object::new(ctx),
        margin_pool_id,
    };

    transfer::public_transfer(margin_pool_cap, ctx.sender());
}

public(package) fun load_inner_mut(self: &mut MarginRegistry): &mut MarginRegistryInner {
    let inner: &mut MarginRegistryInner = self.inner.load_value_mut();
    let package_version = margin_constants::margin_version();
    assert!(inner.allowed_versions.contains(&package_version), EPackageVersionDisabled);

    inner
}

public(package) fun load_inner(self: &MarginRegistry): &MarginRegistryInner {
    let inner: &MarginRegistryInner = self.inner.load_value();
    let package_version = margin_constants::margin_version();
    assert!(inner.allowed_versions.contains(&package_version), EPackageVersionDisabled);

    inner
}

/// Get the pool configuration for a deepbook pool
public(package) fun get_pool_config(self: &MarginRegistry, deepbook_pool_id: ID): &PoolConfig {
    let inner = self.load_inner();
    assert!(inner.pool_registry.contains(deepbook_pool_id), EPoolNotRegistered);
    inner.pool_registry.borrow(deepbook_pool_id)
}

public(package) fun can_withdraw(
    self: &MarginRegistry,
    deepbook_pool_id: ID,
    risk_ratio: u64,
): bool {
    let config = self.get_pool_config(deepbook_pool_id);
    risk_ratio >= config.risk_ratios.min_withdraw_risk_ratio
}

public(package) fun can_borrow(self: &MarginRegistry, deepbook_pool_id: ID, risk_ratio: u64): bool {
    let config = self.get_pool_config(deepbook_pool_id);
    risk_ratio >= config.risk_ratios.min_borrow_risk_ratio
}

public(package) fun can_liquidate(
    self: &MarginRegistry,
    deepbook_pool_id: ID,
    risk_ratio: u64,
): bool {
    let config = self.get_pool_config(deepbook_pool_id);
    risk_ratio < config.risk_ratios.liquidation_risk_ratio
}

public(package) fun target_liquidation_risk_ratio(
    self: &MarginRegistry,
    deepbook_pool_id: ID,
): u64 {
    let config = self.get_pool_config(deepbook_pool_id);
    config.risk_ratios.target_liquidation_risk_ratio
}

public(package) fun user_liquidation_reward(self: &MarginRegistry, deepbook_pool_id: ID): u64 {
    let config = self.get_pool_config(deepbook_pool_id);
    config.user_liquidation_reward
}

public(package) fun pool_liquidation_reward(self: &MarginRegistry, deepbook_pool_id: ID): u64 {
    let config = self.get_pool_config(deepbook_pool_id);
    config.pool_liquidation_reward
}

public(package) fun get_config<Config: store + drop>(self: &MarginRegistry): &Config {
    self.id.borrow(ConfigKey<Config> {})
}

public(package) fun margin_pool_id(margin_pool_cap: &MarginPoolCap): ID {
    margin_pool_cap.margin_pool_id
}

public(package) fun pool_cap_id(margin_pool_cap: &MarginPoolCap): ID {
    margin_pool_cap.id.to_inner()
}

public(package) fun maintainer_cap_id(maintainer_cap: &MaintainerCap): ID {
    maintainer_cap.id.to_inner()
}

/// Calculate risk parameters based on leverage factor
fun calculate_risk_ratios(leverage_factor: u64): RiskRatios {
    RiskRatios {
        min_withdraw_risk_ratio: constants::float_scaling() + 4 * leverage_factor, // 1 + 1 = 2x
        min_borrow_risk_ratio: constants::float_scaling() + leverage_factor, // 1 + 0.25 = 1.25x
        liquidation_risk_ratio: constants::float_scaling() +
        leverage_factor / 2, // 1 + 0.125 = 1.125x
        target_liquidation_risk_ratio: constants::float_scaling() +
        leverage_factor, // 1 + 0.25 = 1.25x
    }
}

#[test_only]
public fun new_for_testing(ctx: &mut TxContext): MarginAdminCap {
    let id = object::new(ctx);
    let margin_registry_inner = MarginRegistryInner {
        registry_id: id.to_inner(),
        allowed_versions: vec_set::singleton(margin_constants::margin_version()),
        pool_registry: table::new(ctx),
        margin_pools: table::new(ctx),
        allowed_maintainers: vec_set::empty(),
    };

    let registry = MarginRegistry {
        id,
        inner: versioned::create(margin_constants::margin_version(), margin_registry_inner, ctx),
    };
    let margin_admin_cap = MarginAdminCap { id: object::new(ctx) };

    transfer::share_object(registry);

    margin_admin_cap
}
// Copyright (c) Mysten Labs, Inc.
// SPDX-License-Identifier: Apache-2.0

module margin_trading::margin_manager;

use deepbook::{
    balance_manager::{
        Self,
        BalanceManager,
        TradeCap,
        DepositCap,
        WithdrawCap,
        TradeProof,
        DeepBookReferral
    },
    pool::Pool
};
use margin_trading::{
    manager_info::{Self, ManagerInfo, Fulfillment, calculate_return_amounts},
    margin_pool::MarginPool,
    margin_registry::MarginRegistry
};
use pyth::price_info::PriceInfoObject;
use std::type_name;
use sui::{clock::Clock, coin::{Self, Coin}, event};
use token::deep::DEEP;

// === Errors ===
const EInvalidDeposit: u64 = 1;
const EMarginTradingNotAllowedInPool: u64 = 2;
const EInvalidMarginManagerOwner: u64 = 3;
const ECannotHaveLoanInMoreThanOneMarginPool: u64 = 4;
const EIncorrectDeepBookPool: u64 = 5;
const EDeepbookPoolNotAllowedForLoan: u64 = 6;
const EInvalidMarginManager: u64 = 7;
const EBorrowRiskRatioExceeded: u64 = 8;
const EWithdrawRiskRatioExceeded: u64 = 9;
const EInvalidDebtAsset: u64 = 10;
const ECannotLiquidate: u64 = 11;
const ERepaymentNotEnough: u64 = 12;
const EIncorrectMarginPool: u64 = 13;
const EInvalidManagerForSharing: u64 = 14;

// === Constants ===
const WITHDRAW: u8 = 0;
const BORROW: u8 = 1;

// === Structs ===
/// A shared object that wraps a `BalanceManager` and provides the necessary capabilities to deposit, withdraw, and trade.
public struct MarginManager<phantom BaseAsset, phantom QuoteAsset> has key {
    id: UID,
    owner: address,
    deepbook_pool: ID,
    margin_pool_id: Option<ID>, // If none, margin manager has no current loans in any margin pool
    balance_manager: BalanceManager,
    deposit_cap: DepositCap,
    withdraw_cap: WithdrawCap,
    trade_cap: TradeCap,
    base_borrowed_shares: u64,
    quote_borrowed_shares: u64,
    active_liquidation: bool, // without this, the margin manager can be liquidated multiple times within the same tx
}

/// Request_type: 0 for withdraw, 1 for borrow
public struct Request {
    margin_manager_id: ID,
    request_type: u8,
}

/// Hot potato to ensure manager is shared during creation
public struct ManagerInitializer {
    margin_manager_id: ID,
}

// === Events ===
/// Event emitted when a new margin manager is created.
public struct MarginManagerEvent has copy, drop {
    margin_manager_id: ID,
    balance_manager_id: ID,
    owner: address,
    timestamp: u64,
}

/// Event emitted when loan is borrowed
public struct LoanBorrowedEvent has copy, drop {
    margin_manager_id: ID,
    margin_pool_id: ID,
    loan_amount: u64,
    loan_shares: u64,
    timestamp: u64,
}

/// Event emitted when loan is repaid
public struct LoanRepaidEvent has copy, drop {
    margin_manager_id: ID,
    margin_pool_id: ID,
    repay_amount: u64,
    repay_shares: u64,
    timestamp: u64,
}

/// Event emitted when margin manager is liquidated
public struct LiquidationEvent has copy, drop {
    margin_manager_id: ID,
    margin_pool_id: ID,
    liquidation_amount: u64,
    pool_reward_amount: u64,
    default_amount: u64,
    risk_ratio: u64,
    timestamp: u64,
}

// === Public Functions - Margin Manager ===
/// Creates a new margin manager and shares it.
public fun new<BaseAsset, QuoteAsset>(
    pool: &Pool<BaseAsset, QuoteAsset>,
    registry: &MarginRegistry,
    clock: &Clock,
    ctx: &mut TxContext,
) {
    let manager = new_margin_manager(pool, registry, clock, ctx);
    transfer::share_object(manager);
}

/// Creates a new margin manager and returns it along with an initializer.
/// The initializer is used to ensure the margin manager is shared after creation.
public fun new_with_initializer<BaseAsset, QuoteAsset>(
    pool: &Pool<BaseAsset, QuoteAsset>,
    registry: &MarginRegistry,
    clock: &Clock,
    ctx: &mut TxContext,
): (MarginManager<BaseAsset, QuoteAsset>, ManagerInitializer) {
    let manager = new_margin_manager(pool, registry, clock, ctx);
    let initializer = ManagerInitializer {
        margin_manager_id: manager.id(),
    };

    (manager, initializer)
}

/// Shares the margin manager. The initializer is dropped in the process.
public fun share<BaseAsset, QuoteAsset>(
    manager: MarginManager<BaseAsset, QuoteAsset>,
    initializer: ManagerInitializer,
) {
    assert!(manager.id() == initializer.margin_manager_id, EInvalidManagerForSharing);
    transfer::share_object(manager);

    let ManagerInitializer {
        margin_manager_id: _,
    } = initializer;
}

/// Set the referral for the margin manager.
public fun set_referral<BaseAsset, QuoteAsset>(
    self: &mut MarginManager<BaseAsset, QuoteAsset>,
    referral_cap: &DeepBookReferral,
    ctx: &mut TxContext,
) {
    self.validate_owner(ctx);
    self.balance_manager.set_referral(referral_cap, &self.trade_cap);
}

/// Unset the referral for the margin manager.
public fun unset_referral<BaseAsset, QuoteAsset>(
    self: &mut MarginManager<BaseAsset, QuoteAsset>,
    ctx: &mut TxContext,
) {
    self.validate_owner(ctx);
    self.balance_manager.unset_referral(&self.trade_cap);
}

// === Public Functions - Margin Manager ===
/// Deposit a coin into the margin manager. The coin must be of the same type as either the base, quote, or DEEP.
public fun deposit<BaseAsset, QuoteAsset, DepositAsset>(
    self: &mut MarginManager<BaseAsset, QuoteAsset>,
    registry: &MarginRegistry,
    coin: Coin<DepositAsset>,
    ctx: &mut TxContext,
) {
    registry.load_inner();
    self.validate_owner(ctx);

    let deposit_asset_type = type_name::with_defining_ids<DepositAsset>();
    let base_asset_type = type_name::with_defining_ids<BaseAsset>();
    let quote_asset_type = type_name::with_defining_ids<QuoteAsset>();
    let deep_asset_type = type_name::with_defining_ids<DEEP>();
    assert!(
        deposit_asset_type == base_asset_type || deposit_asset_type == quote_asset_type || deposit_asset_type == deep_asset_type,
        EInvalidDeposit,
    );

    let balance_manager = &mut self.balance_manager;
    let deposit_cap = &self.deposit_cap;

    balance_manager.deposit_with_cap<DepositAsset>(deposit_cap, coin, ctx);
}

/// Withdraw a specified amount of an asset from the margin manager. The asset must be of the same type as either the base, quote, or DEEP.
/// The withdrawal is subject to the risk ratio limit. This is restricted through the Request.
/// Request must be destroyed using prove_and_destroy_request
public fun withdraw<BaseAsset, QuoteAsset, WithdrawAsset>(
    self: &mut MarginManager<BaseAsset, QuoteAsset>,
    registry: &MarginRegistry,
    withdraw_amount: u64,
    ctx: &mut TxContext,
): (Coin<WithdrawAsset>, Request) {
    registry.load_inner();
    self.validate_owner(ctx);

    let balance_manager = &mut self.balance_manager;
    let withdraw_cap = &self.withdraw_cap;

    let coin = balance_manager.withdraw_with_cap<WithdrawAsset>(
        withdraw_cap,
        withdraw_amount,
        ctx,
    );

    let withdrawal_request = Request {
        margin_manager_id: self.id(),
        request_type: WITHDRAW,
    };

    (coin, withdrawal_request)
}

/// Borrow the base asset using the margin manager.
/// Request must be destroyed using prove_and_destroy_request
public fun borrow_base<BaseAsset, QuoteAsset>(
    self: &mut MarginManager<BaseAsset, QuoteAsset>,
    registry: &MarginRegistry,
    base_margin_pool: &mut MarginPool<BaseAsset>,
    loan_amount: u64,
    clock: &Clock,
    ctx: &mut TxContext,
): Request {
    registry.load_inner();
    self.validate_owner(ctx);
    assert!(self.can_borrow(base_margin_pool), ECannotHaveLoanInMoreThanOneMarginPool);
    assert!(
        base_margin_pool.deepbook_pool_allowed(self.deepbook_pool),
        EDeepbookPoolNotAllowedForLoan,
    );
    base_margin_pool.update_state(clock);
    let loan_shares = base_margin_pool.to_borrow_shares(loan_amount);
    self.increase_borrowed_shares(true, loan_shares);
    self.margin_pool_id = option::some(base_margin_pool.id());

    let timestamp = clock.timestamp_ms();
    event::emit(LoanBorrowedEvent {
        margin_manager_id: self.id(),
        margin_pool_id: base_margin_pool.id(),
        loan_amount,
        loan_shares,
        timestamp,
    });

    self.borrow<BaseAsset, QuoteAsset, BaseAsset>(
        registry,
        base_margin_pool,
        loan_amount,
        clock,
        ctx,
    )
}

/// Borrow the quote asset using the margin manager.
/// Request must be destroyed using prove_and_destroy_request
public fun borrow_quote<BaseAsset, QuoteAsset>(
    self: &mut MarginManager<BaseAsset, QuoteAsset>,
    registry: &MarginRegistry,
    quote_margin_pool: &mut MarginPool<QuoteAsset>,
    loan_amount: u64,
    clock: &Clock,
    ctx: &mut TxContext,
): Request {
    registry.load_inner();
    self.validate_owner(ctx);
    assert!(self.can_borrow(quote_margin_pool), ECannotHaveLoanInMoreThanOneMarginPool);
    assert!(
        quote_margin_pool.deepbook_pool_allowed(self.deepbook_pool),
        EDeepbookPoolNotAllowedForLoan,
    );
    quote_margin_pool.update_state(clock);
    let loan_shares = quote_margin_pool.to_borrow_shares(loan_amount);
    self.increase_borrowed_shares(false, loan_shares);
    self.margin_pool_id = option::some(quote_margin_pool.id());

    let timestamp = clock.timestamp_ms();
    event::emit(LoanBorrowedEvent {
        margin_manager_id: self.id(),
        margin_pool_id: quote_margin_pool.id(),
        loan_amount,
        loan_shares,
        timestamp,
    });

    self.borrow<BaseAsset, QuoteAsset, QuoteAsset>(
        registry,
        quote_margin_pool,
        loan_amount,
        clock,
        ctx,
    )
}

/// Destroys the request to borrow or withdraw if risk ratio conditions are met.
/// This function is called after the borrow or withdraw request is created.
public fun prove_and_destroy_request<BaseAsset, QuoteAsset, DebtAsset>(
    self: &MarginManager<BaseAsset, QuoteAsset>,
    registry: &MarginRegistry,
    margin_pool: &mut MarginPool<DebtAsset>,
    pool: &Pool<BaseAsset, QuoteAsset>,
    base_price_info_object: &PriceInfoObject,
    quote_price_info_object: &PriceInfoObject,
    clock: &Clock,
    request: Request,
) {
    let margin_pool_id = margin_pool.id();
    assert!(self.margin_pool_id.contains(&margin_pool_id), EIncorrectMarginPool);
    assert!(request.margin_manager_id == self.id(), EInvalidMarginManager);
    assert!(self.deepbook_pool == pool.id(), EIncorrectDeepBookPool);

    margin_pool.update_state(clock);
    let manager_info = self.manager_info<BaseAsset, QuoteAsset, DebtAsset>(
        registry,
        margin_pool,
        pool,
        base_price_info_object,
        quote_price_info_object,
        clock,
        pool.id(),
    );
    let risk_ratio = manager_info.risk_ratio();
    let pool_id = pool.id();
    if (request.request_type == BORROW) {
        assert!(registry.can_borrow(pool_id, risk_ratio), EBorrowRiskRatioExceeded);
    } else if (request.request_type == WITHDRAW) {
        assert!(registry.can_withdraw(pool_id, risk_ratio), EWithdrawRiskRatioExceeded);
    };

    let Request {
        margin_manager_id: _,
        request_type: _,
    } = request;
}

/// Repay the base asset loan using the margin manager.
/// Returns the total amount repaid
public fun repay_base<BaseAsset, QuoteAsset>(
    self: &mut MarginManager<BaseAsset, QuoteAsset>,
    registry: &MarginRegistry,
    margin_pool: &mut MarginPool<BaseAsset>,
    repay_amount: Option<u64>, // if None, repay all
    clock: &Clock,
    ctx: &mut TxContext,
): u64 {
    registry.load_inner();
    self.validate_owner(ctx);
    assert!(self.margin_pool_id.contains(&margin_pool.id()), EIncorrectMarginPool);

    self.repay<BaseAsset, QuoteAsset, BaseAsset>(
        margin_pool,
        repay_amount,
        clock,
        ctx,
    )
}

/// Repay the quote asset loan using the margin manager.
/// Returns the total amount repaid
public fun repay_quote<BaseAsset, QuoteAsset>(
    self: &mut MarginManager<BaseAsset, QuoteAsset>,
    registry: &MarginRegistry,
    margin_pool: &mut MarginPool<QuoteAsset>,
    repay_amount: Option<u64>, // if None, repay all
    clock: &Clock,
    ctx: &mut TxContext,
): u64 {
    registry.load_inner();
    self.validate_owner(ctx);
    assert!(self.margin_pool_id.contains(&margin_pool.id()), EIncorrectMarginPool);

    self.repay<BaseAsset, QuoteAsset, QuoteAsset>(
        margin_pool,
        repay_amount,
        clock,
        ctx,
    )
}

// === Public Functions - Liquidation - Receive Assets before liquidation ===
/// Liquidates a margin manager. Can source liquidity from anywhere.
/// Returns the fulfillment, base coin, and quote coin.
/// Fulfillment must be destroyed using repay_liquidation
public fun liquidate<BaseAsset, QuoteAsset, DebtAsset>(
    self: &mut MarginManager<BaseAsset, QuoteAsset>,
    registry: &MarginRegistry,
    base_price_info_object: &PriceInfoObject,
    quote_price_info_object: &PriceInfoObject,
    margin_pool: &mut MarginPool<DebtAsset>,
    pool: &mut Pool<BaseAsset, QuoteAsset>,
    clock: &Clock,
    ctx: &mut TxContext,
): (Fulfillment, Coin<BaseAsset>, Coin<QuoteAsset>) {
    let pool_id = pool.id();
    let margin_pool_id = margin_pool.id();
    assert!(self.deepbook_pool == pool_id, EIncorrectDeepBookPool);
    assert!(self.margin_pool_id.contains(&margin_pool_id), EIncorrectMarginPool);

    margin_pool.update_state(clock);
    let manager_info = self.manager_info<BaseAsset, QuoteAsset, DebtAsset>(
        registry,
        margin_pool,
        pool,
        base_price_info_object,
        quote_price_info_object,
        clock,
        pool_id,
    );
    assert!(registry.can_liquidate(pool_id, manager_info.risk_ratio()), ECannotLiquidate);
    assert!(!self.active_liquidation, ECannotLiquidate);
    self.active_liquidation = true;

    // cancel all orders. at this point, all available assets are in the balance manager.
    let trade_proof = self.trade_proof(ctx);
    let balance_manager = self.balance_manager_mut();
    pool.cancel_all_orders(balance_manager, &trade_proof, clock, ctx);

    let fulfillment = manager_info.produce_fulfillment(self.id());

    let base = self.liquidation_withdraw_base(
        fulfillment.base_exit_amount(),
        ctx,
    );
    let quote = self.liquidation_withdraw_quote(
        fulfillment.quote_exit_amount(),
        ctx,
    );

    (fulfillment, base, quote)
}

/// Repays the loan as the liquidator.
/// Returns the remainder coin if the there is extra coin left over after the repayment.
/// The full amount must be paid in order to satisfy the liquidation.
public fun repay_liquidation<BaseAsset, QuoteAsset, RepayAsset>(
    self: &mut MarginManager<BaseAsset, QuoteAsset>,
    registry: &MarginRegistry,
    margin_pool: &mut MarginPool<RepayAsset>,
    coin: Coin<RepayAsset>,
    fulfillment: Fulfillment,
    clock: &Clock,
    ctx: &mut TxContext,
): Coin<RepayAsset> {
    let total_fulfillment_amount = fulfillment.repay_amount() + fulfillment.pool_reward_amount();
    assert!(coin.value() >= total_fulfillment_amount, ERepaymentNotEnough);

    let base_coin = coin::zero<BaseAsset>(ctx);
    let quote_coin = coin::zero<QuoteAsset>(ctx);

    let (base_coin, quote_coin, remainder_coin) = self.repay_liquidation_int(
        registry,
        margin_pool,
        coin,
        base_coin,
        quote_coin,
        fulfillment,
        clock,
        ctx,
    );
    coin::destroy_zero(base_coin);
    coin::destroy_zero(quote_coin);

    remainder_coin
}

/// Repays the loan as the liquidator.
/// Returns the extra coin not required for repayment.
/// If the liquidation is not full, the repay percentage is returned
fun repay_liquidation_int<BaseAsset, QuoteAsset, RepayAsset>(
    self: &mut MarginManager<BaseAsset, QuoteAsset>,
    registry: &MarginRegistry,
    margin_pool: &mut MarginPool<RepayAsset>,
    mut coin: Coin<RepayAsset>,
    mut base_coin: Coin<BaseAsset>,
    mut quote_coin: Coin<QuoteAsset>,
    mut fulfillment: Fulfillment,
    clock: &Clock,
    ctx: &mut TxContext,
): (Coin<BaseAsset>, Coin<QuoteAsset>, Coin<RepayAsset>) {
    registry.load_inner();
    margin_pool.update_state(clock);
    assert!(fulfillment.manager_id() == self.id(), EInvalidMarginManager);
    assert!(self.active_liquidation, ECannotLiquidate);
    self.active_liquidation = false;

    let margin_manager_id = self.id();
    let margin_pool_id = margin_pool.id();
    let repay_coin_amount = coin.value();

    let return_percent = fulfillment.update_fulfillment(repay_coin_amount);
    let repay_amount = fulfillment.repay_amount();
    let mut pool_reward_amount = fulfillment.pool_reward_amount();
    let mut default_amount = fulfillment.default_amount();
    let actual_fulfillment_amount = repay_amount + pool_reward_amount;

    let repay_is_base = self.has_base_debt();
    let repay_shares = margin_pool.to_borrow_shares(repay_amount);
    self.decrease_borrowed_shares(repay_is_base, repay_shares);
    let default_shares = margin_pool.to_borrow_shares(fulfillment.default_amount());
    self.decrease_borrowed_shares(repay_is_base, default_shares);
    self.reset_margin_pool_id();

    let cancel_amount = pool_reward_amount.min(default_amount);
    pool_reward_amount = pool_reward_amount - cancel_amount;
    default_amount = default_amount - cancel_amount;

    let repay_coin = coin.split(actual_fulfillment_amount, ctx);
    let timestamp = clock.timestamp_ms();

    margin_pool.repay_with_reward(
        repay_coin,
        repay_amount,
        pool_reward_amount,
        default_amount,
        clock,
    );

    // Return coins accordingly if this is a partial liquidation
    if (return_percent > 0) {
        let (base_return_amount, quote_return_amount) = calculate_return_amounts(
            return_percent,
            base_coin.value(),
            quote_coin.value(),
        );
        let base_return_coin = base_coin.split(base_return_amount, ctx);
        let quote_return_coin = quote_coin.split(quote_return_amount, ctx);
        self.liquidation_deposit_base(base_return_coin, ctx);
        self.liquidation_deposit_quote(quote_return_coin, ctx);
    };

    event::emit(LoanRepaidEvent {
        margin_manager_id,
        margin_pool_id,
        repay_amount,
        repay_shares,
        timestamp,
    });

    let risk_ratio = fulfillment.fulfillment_risk_ratio();

    event::emit(LiquidationEvent {
        margin_manager_id,
        margin_pool_id,
        liquidation_amount: repay_amount,
        pool_reward_amount,
        default_amount,
        risk_ratio,
        timestamp,
    });

    fulfillment.drop();

    (base_coin, quote_coin, coin)
}

// === Public Functions - Liquidation - Receive rewards after liquidation ===
/// Liquidates the base asset loan for the margin manager.
/// Returns a mix of base and quote assets as the user liquidation reward.
public fun liquidate_base_loan<BaseAsset, QuoteAsset>(
    self: &mut MarginManager<BaseAsset, QuoteAsset>,
    registry: &MarginRegistry,
    margin_pool: &mut MarginPool<BaseAsset>,
    pool: &mut Pool<BaseAsset, QuoteAsset>,
    base_price_info_object: &PriceInfoObject,
    quote_price_info_object: &PriceInfoObject,
    liquidation_coin: Coin<BaseAsset>,
    clock: &Clock,
    ctx: &mut TxContext,
): (Coin<BaseAsset>, Coin<QuoteAsset>) {
    let (mut base_coin, quote_coin, liquidation_coin) = self.liquidate_loan<
        BaseAsset,
        QuoteAsset,
        BaseAsset,
    >(
        registry,
        base_price_info_object,
        quote_price_info_object,
        margin_pool,
        pool,
        liquidation_coin,
        clock,
        ctx,
    );
    base_coin.join(liquidation_coin);

    (base_coin, quote_coin)
}

/// Liquidates the quote asset loan for the margin manager.
/// Returns a mix of base and quote assets as the user liquidation reward.
public fun liquidate_quote_loan<BaseAsset, QuoteAsset>(
    self: &mut MarginManager<BaseAsset, QuoteAsset>,
    registry: &MarginRegistry,
    margin_pool: &mut MarginPool<QuoteAsset>,
    pool: &mut Pool<BaseAsset, QuoteAsset>,
    base_price_info_object: &PriceInfoObject,
    quote_price_info_object: &PriceInfoObject,
    liquidation_coin: Coin<QuoteAsset>,
    clock: &Clock,
    ctx: &mut TxContext,
): (Coin<BaseAsset>, Coin<QuoteAsset>) {
    let (base_coin, mut quote_coin, liquidation_coin) = self.liquidate_loan<
        BaseAsset,
        QuoteAsset,
        QuoteAsset,
    >(
        registry,
        base_price_info_object,
        quote_price_info_object,
        margin_pool,
        pool,
        liquidation_coin,
        clock,
        ctx,
    );
    quote_coin.join(liquidation_coin);

    (base_coin, quote_coin)
}

public fun liquidate_loan<BaseAsset, QuoteAsset, DebtAsset>(
    self: &mut MarginManager<BaseAsset, QuoteAsset>,
    registry: &MarginRegistry,
    base_price_info_object: &PriceInfoObject,
    quote_price_info_object: &PriceInfoObject,
    margin_pool: &mut MarginPool<DebtAsset>,
    pool: &mut Pool<BaseAsset, QuoteAsset>,
    liquidation_coin: Coin<DebtAsset>,
    clock: &Clock,
    ctx: &mut TxContext,
): (Coin<BaseAsset>, Coin<QuoteAsset>, Coin<DebtAsset>) {
    let (fulfillment, base_coin, quote_coin) = self.liquidate<BaseAsset, QuoteAsset, DebtAsset>(
        registry,
        base_price_info_object,
        quote_price_info_object,
        margin_pool,
        pool,
        clock,
        ctx,
    );

    let (base_coin_returned, quote_coin_returned, remainder_coin) = self.repay_liquidation_int<
        BaseAsset,
        QuoteAsset,
        DebtAsset,
    >(
        registry,
        margin_pool,
        liquidation_coin,
        base_coin,
        quote_coin,
        fulfillment,
        clock,
        ctx,
    );

    (base_coin_returned, quote_coin_returned, remainder_coin)
}

// === Public Functions - Read Only ===
/// Risk ratio = total asset in USD / (total debt and interest in USD)
/// Risk ratio above 2.0 allows for withdrawal from balance manager, borrowing, and trading
/// Risk ratio between 1.25 and 2.0 allows for borrowing and trading
/// Risk ratio between 1.1 and 1.25 allows for trading only
/// Risk ratio below 1.1 allows for liquidation
/// These numbers can be updated by the admin. 1.25 is the default borrow risk ratio, this is equivalent to 5x leverage.
/// Returns asset, debt, and risk ratio information for the margin manager.
public fun manager_info<BaseAsset, QuoteAsset, DebtAsset>(
    self: &MarginManager<BaseAsset, QuoteAsset>,
    registry: &MarginRegistry,
    margin_pool: &MarginPool<DebtAsset>,
    pool: &Pool<BaseAsset, QuoteAsset>,
    base_price_info_object: &PriceInfoObject,
    quote_price_info_object: &PriceInfoObject,
    clock: &Clock,
    pool_id: ID,
): ManagerInfo {
    let margin_pool_id = margin_pool.id();
    assert!(self.margin_pool_id.contains(&margin_pool_id), EIncorrectMarginPool);
    assert!(self.deepbook_pool == pool.id(), EIncorrectDeepBookPool);

    let (base_debt, quote_debt) = self.calculate_debts<BaseAsset, QuoteAsset, DebtAsset>(
        margin_pool,
    );

    let (base_asset, quote_asset) = self.calculate_assets<BaseAsset, QuoteAsset>(
        pool,
    );

    // Delegate all USD calculations and risk ratio computation to manager_info module
    manager_info::new_manager_info<BaseAsset, QuoteAsset>(
        base_asset,
        quote_asset,
        base_debt,
        quote_debt,
        registry,
        base_price_info_object,
        quote_price_info_object,
        clock,
        pool_id,
    )
}

/// Returns (base_asset, quote_asset) for margin manager.
public fun calculate_assets<BaseAsset, QuoteAsset>(
    self: &MarginManager<BaseAsset, QuoteAsset>,
    pool: &Pool<BaseAsset, QuoteAsset>,
): (u64, u64) {
    let balance_manager = self.balance_manager();
    let (mut base, mut quote, _) = pool.locked_balance(balance_manager);
    base = base + balance_manager.balance<BaseAsset>();
    quote = quote + balance_manager.balance<QuoteAsset>();

    (base, quote)
}

/// General helper for debt calculation and asset totals.
/// Returns (base_debt, quote_debt)
/// Note this function does not ensure the margin pool is in the most updated state
/// It is purely for informational purposes
public fun calculate_debts<BaseAsset, QuoteAsset, DebtAsset>(
    self: &MarginManager<BaseAsset, QuoteAsset>,
    margin_pool: &MarginPool<DebtAsset>,
): (u64, u64) {
    let margin_pool_id = margin_pool.id();
    assert!(self.margin_pool_id.contains(&margin_pool_id), EIncorrectMarginPool);

    let debt_is_base = self.has_base_debt();
    let debt_shares = if (debt_is_base) {
        self.base_borrowed_shares
    } else {
        self.quote_borrowed_shares
    };

    let base_debt = if (debt_is_base) {
        assert!(
            type_name::with_defining_ids<DebtAsset>() == type_name::with_defining_ids<BaseAsset>(),
            EInvalidDebtAsset,
        );
        margin_pool.to_borrow_amount(debt_shares)
    } else {
        0
    };
    let quote_debt = if (debt_is_base) {
        0
    } else {
        assert!(
            type_name::with_defining_ids<DebtAsset>() == type_name::with_defining_ids<QuoteAsset>(),
            EInvalidDebtAsset,
        );
        margin_pool.to_borrow_amount(debt_shares)
    };

    (base_debt, quote_debt)
}

public fun deepbook_pool<BaseAsset, QuoteAsset>(self: &MarginManager<BaseAsset, QuoteAsset>): ID {
    self.deepbook_pool
}

// === Public-Package Functions ===
public(package) fun balance_manager<BaseAsset, QuoteAsset>(
    self: &MarginManager<BaseAsset, QuoteAsset>,
): &BalanceManager {
    &self.balance_manager
}

public(package) fun balance_manager_mut<BaseAsset, QuoteAsset>(
    self: &mut MarginManager<BaseAsset, QuoteAsset>,
): &mut BalanceManager {
    &mut self.balance_manager
}

/// Unwraps balance manager for trading in deepbook.
public(package) fun balance_manager_trading_mut<BaseAsset, QuoteAsset>(
    self: &mut MarginManager<BaseAsset, QuoteAsset>,
    ctx: &TxContext,
): &mut BalanceManager {
    assert!(self.owner == ctx.sender(), EInvalidMarginManagerOwner);

    &mut self.balance_manager
}

public(package) fun base_borrowed_shares<BaseAsset, QuoteAsset>(
    self: &MarginManager<BaseAsset, QuoteAsset>,
): u64 {
    self.base_borrowed_shares
}

public(package) fun quote_borrowed_shares<BaseAsset, QuoteAsset>(
    self: &MarginManager<BaseAsset, QuoteAsset>,
): u64 {
    self.quote_borrowed_shares
}

/// Unwraps balance manager for trading in deepbook.
public(package) fun trade_proof<BaseAsset, QuoteAsset>(
    self: &mut MarginManager<BaseAsset, QuoteAsset>,
    ctx: &TxContext,
): TradeProof {
    self.balance_manager.generate_proof_as_trader(&self.trade_cap, ctx)
}

public(package) fun id<BaseAsset, QuoteAsset>(self: &MarginManager<BaseAsset, QuoteAsset>): ID {
    object::id(self)
}

// === Private Functions ===
fun new_margin_manager<BaseAsset, QuoteAsset>(
    pool: &Pool<BaseAsset, QuoteAsset>,
    registry: &MarginRegistry,
    clock: &Clock,
    ctx: &mut TxContext,
): MarginManager<BaseAsset, QuoteAsset> {
    registry.load_inner();
    assert!(registry.pool_enabled(pool), EMarginTradingNotAllowedInPool);

    let id = object::new(ctx);
    let margin_manager_id = id.to_inner();

    let (
        balance_manager,
        deposit_cap,
        withdraw_cap,
        trade_cap,
    ) = balance_manager::new_with_custom_owner_and_caps(id.to_address(), ctx);

    event::emit(MarginManagerEvent {
        margin_manager_id,
        balance_manager_id: object::id(&balance_manager),
        owner: ctx.sender(),
        timestamp: clock.timestamp_ms(),
    });

    MarginManager<BaseAsset, QuoteAsset> {
        id,
        owner: ctx.sender(),
        deepbook_pool: pool.id(),
        margin_pool_id: option::none(),
        balance_manager,
        deposit_cap,
        withdraw_cap,
        trade_cap,
        base_borrowed_shares: 0,
        quote_borrowed_shares: 0,
        active_liquidation: false,
    }
}

fun validate_owner<BaseAsset, QuoteAsset>(
    self: &MarginManager<BaseAsset, QuoteAsset>,
    ctx: &TxContext,
) {
    assert!(ctx.sender() == self.owner, EInvalidMarginManagerOwner);
}

fun borrow<BaseAsset, QuoteAsset, BorrowAsset>(
    self: &mut MarginManager<BaseAsset, QuoteAsset>,
    registry: &MarginRegistry,
    margin_pool: &mut MarginPool<BorrowAsset>,
    loan_amount: u64,
    clock: &Clock,
    ctx: &mut TxContext,
): Request {
    let manager_id = self.id();
    let coin = margin_pool.borrow(loan_amount, clock, ctx);
    self.deposit<BaseAsset, QuoteAsset, BorrowAsset>(registry, coin, ctx);

    Request {
        margin_manager_id: manager_id,
        request_type: BORROW,
    }
}

/// Repays the loan using the margin manager.
/// Returns the total amount repaid
/// TODO: Can the conversion here cause a rounding error?
fun repay<BaseAsset, QuoteAsset, RepayAsset>(
    self: &mut MarginManager<BaseAsset, QuoteAsset>,
    margin_pool: &mut MarginPool<RepayAsset>,
    repay_amount: Option<u64>,
    clock: &Clock,
    ctx: &mut TxContext,
): u64 {
    margin_pool.update_state(clock);

    let repay_is_base = self.has_base_debt();
    let repay_amount = if (repay_amount.is_some()) {
        repay_amount.destroy_some()
    } else {
        if (repay_is_base) {
            margin_pool.to_borrow_amount(self.base_borrowed_shares)
        } else {
            margin_pool.to_borrow_amount(self.quote_borrowed_shares)
        }
    };
    let available_balance = self.balance_manager().balance<RepayAsset>();
    let repay_amount = repay_amount.min(available_balance);
    let repay_shares = margin_pool.to_borrow_shares(repay_amount);
    self.decrease_borrowed_shares(repay_is_base, repay_shares);
    self.reset_margin_pool_id();

    let coin = self.repay_withdraw<BaseAsset, QuoteAsset, RepayAsset>(
        repay_amount,
        ctx,
    );
    let timestamp = clock.timestamp_ms();

    margin_pool.repay(
        coin,
        clock,
    );

    event::emit(LoanRepaidEvent {
        margin_manager_id: self.id(),
        margin_pool_id: margin_pool.id(),
        repay_amount,
        repay_shares,
        timestamp,
    });

    repay_amount
}

fun reset_margin_pool_id<BaseAsset, QuoteAsset>(self: &mut MarginManager<BaseAsset, QuoteAsset>) {
    if (self.base_borrowed_shares == 0 && self.quote_borrowed_shares == 0) {
        self.margin_pool_id = option::none();
    };
}

/// Deposit base asset to margin manager during liquidation
fun liquidation_deposit_base<BaseAsset, QuoteAsset>(
    self: &mut MarginManager<BaseAsset, QuoteAsset>,
    coin: Coin<BaseAsset>,
    ctx: &TxContext,
) {
    self.liquidation_deposit<BaseAsset, QuoteAsset, BaseAsset>(
        coin,
        ctx,
    )
}

/// Deposit quote asset to margin manager during liquidation
fun liquidation_deposit_quote<BaseAsset, QuoteAsset>(
    self: &mut MarginManager<BaseAsset, QuoteAsset>,
    coin: Coin<QuoteAsset>,
    ctx: &TxContext,
) {
    self.liquidation_deposit<BaseAsset, QuoteAsset, QuoteAsset>(
        coin,
        ctx,
    )
}

fun liquidation_deposit<BaseAsset, QuoteAsset, DepositAsset>(
    self: &mut MarginManager<BaseAsset, QuoteAsset>,
    coin: Coin<DepositAsset>,
    ctx: &TxContext,
) {
    let balance_manager = &mut self.balance_manager;

    balance_manager.deposit_with_cap<DepositAsset>(
        &self.deposit_cap,
        coin,
        ctx,
    )
}

fun liquidation_withdraw_base<BaseAsset, QuoteAsset>(
    self: &mut MarginManager<BaseAsset, QuoteAsset>,
    withdraw_amount: u64,
    ctx: &mut TxContext,
): Coin<BaseAsset> {
    self.liquidation_withdraw<BaseAsset, QuoteAsset, BaseAsset>(
        withdraw_amount,
        ctx,
    )
}

fun liquidation_withdraw_quote<BaseAsset, QuoteAsset>(
    self: &mut MarginManager<BaseAsset, QuoteAsset>,
    withdraw_amount: u64,
    ctx: &mut TxContext,
): Coin<QuoteAsset> {
    self.liquidation_withdraw<BaseAsset, QuoteAsset, QuoteAsset>(
        withdraw_amount,
        ctx,
    )
}

fun liquidation_withdraw<BaseAsset, QuoteAsset, WithdrawAsset>(
    self: &mut MarginManager<BaseAsset, QuoteAsset>,
    withdraw_amount: u64,
    ctx: &mut TxContext,
): Coin<WithdrawAsset> {
    let balance_manager = &mut self.balance_manager;

    balance_manager.withdraw_with_cap<WithdrawAsset>(
        &self.withdraw_cap,
        withdraw_amount,
        ctx,
    )
}

/// This can only be called by the manager owner
fun repay_withdraw<BaseAsset, QuoteAsset, WithdrawAsset>(
    self: &mut MarginManager<BaseAsset, QuoteAsset>,
    withdraw_amount: u64,
    ctx: &mut TxContext,
): Coin<WithdrawAsset> {
    validate_owner(self, ctx);
    let balance_manager = &mut self.balance_manager;

    let coin = balance_manager.withdraw_with_cap<WithdrawAsset>(
        &self.withdraw_cap,
        withdraw_amount,
        ctx,
    );

    coin
}

fun has_base_debt<BaseAsset, QuoteAsset>(self: &MarginManager<BaseAsset, QuoteAsset>): bool {
    self.base_borrowed_shares > 0
}

/// Helper function to determine if margin manager can borrow from a margin pool
fun can_borrow<BaseAsset, QuoteAsset, BorrowAsset>(
    self: &MarginManager<BaseAsset, QuoteAsset>,
    margin_pool: &MarginPool<BorrowAsset>,
): bool {
    let no_current_loan = self.margin_pool_id.is_none();

    self.margin_pool_id.contains(&margin_pool.id()) || no_current_loan
}

fun increase_borrowed_shares<BaseAsset, QuoteAsset>(
    self: &mut MarginManager<BaseAsset, QuoteAsset>,
    debt_is_base: bool,
    shares: u64,
) {
    if (debt_is_base) {
        self.base_borrowed_shares = self.base_borrowed_shares + shares;
    } else {
        self.quote_borrowed_shares = self.quote_borrowed_shares + shares;
    };
}

fun decrease_borrowed_shares<BaseAsset, QuoteAsset>(
    self: &mut MarginManager<BaseAsset, QuoteAsset>,
    debt_is_base: bool,
    shares: u64,
) {
    if (debt_is_base) {
        self.base_borrowed_shares = self.base_borrowed_shares - shares;
    } else {
        self.quote_borrowed_shares = self.quote_borrowed_shares - shares;
    };
}
// Copyright (c) Mysten Labs, Inc.
// SPDX-License-Identifier: Apache-2.0

module margin_trading::pool_proxy;

use deepbook::{math, order_info::OrderInfo, pool::Pool};
use margin_trading::{
    margin_manager::MarginManager,
    margin_pool::MarginPool,
    margin_registry::MarginRegistry
};
use std::type_name;
use sui::clock::Clock;
use token::deep::DEEP;

// === Errors ===
const ECannotStakeWithDeepMarginManager: u64 = 1;
const EPoolNotEnabledForMarginTrading: u64 = 2;
const ENotReduceOnlyOrder: u64 = 3;
const EIncorrectDeepBookPool: u64 = 4;

// === Public Proxy Functions - Trading ===
/// Places a limit order in the pool.
public fun place_limit_order<BaseAsset, QuoteAsset>(
    registry: &MarginRegistry,
    margin_manager: &mut MarginManager<BaseAsset, QuoteAsset>,
    pool: &mut Pool<BaseAsset, QuoteAsset>,
    client_order_id: u64,
    order_type: u8,
    self_matching_option: u8,
    price: u64,
    quantity: u64,
    is_bid: bool,
    pay_with_deep: bool,
    expire_timestamp: u64,
    clock: &Clock,
    ctx: &TxContext,
): OrderInfo {
    assert!(margin_manager.deepbook_pool() == pool.id(), EIncorrectDeepBookPool);
    let trade_proof = margin_manager.trade_proof(ctx);
    let balance_manager = margin_manager.balance_manager_trading_mut(ctx);
    assert!(registry.pool_enabled(pool), EPoolNotEnabledForMarginTrading);

    pool.place_limit_order(
        balance_manager,
        &trade_proof,
        client_order_id,
        order_type,
        self_matching_option,
        price,
        quantity,
        is_bid,
        pay_with_deep,
        expire_timestamp,
        clock,
        ctx,
    )
}

/// Places a market order in the pool.
public fun place_market_order<BaseAsset, QuoteAsset>(
    registry: &MarginRegistry,
    margin_manager: &mut MarginManager<BaseAsset, QuoteAsset>,
    pool: &mut Pool<BaseAsset, QuoteAsset>,
    client_order_id: u64,
    self_matching_option: u8,
    quantity: u64,
    is_bid: bool,
    pay_with_deep: bool,
    clock: &Clock,
    ctx: &TxContext,
): OrderInfo {
    assert!(margin_manager.deepbook_pool() == pool.id(), EIncorrectDeepBookPool);
    let trade_proof = margin_manager.trade_proof(ctx);
    let balance_manager = margin_manager.balance_manager_trading_mut(ctx);
    assert!(registry.pool_enabled(pool), EPoolNotEnabledForMarginTrading);

    pool.place_market_order(
        balance_manager,
        &trade_proof,
        client_order_id,
        self_matching_option,
        quantity,
        is_bid,
        pay_with_deep,
        clock,
        ctx,
    )
}

/// Places a reduce-only order in the pool. Used when margin trading is disabled.
public fun place_reduce_only_limit_order<BaseAsset, QuoteAsset, DebtAsset>(
    registry: &MarginRegistry,
    margin_manager: &mut MarginManager<BaseAsset, QuoteAsset>,
    pool: &mut Pool<BaseAsset, QuoteAsset>,
    margin_pool: &MarginPool<DebtAsset>,
    client_order_id: u64,
    order_type: u8,
    self_matching_option: u8,
    price: u64,
    quantity: u64,
    is_bid: bool,
    pay_with_deep: bool,
    expire_timestamp: u64,
    clock: &Clock,
    ctx: &TxContext,
): OrderInfo {
    registry.load_inner();
    assert!(margin_manager.deepbook_pool() == pool.id(), EIncorrectDeepBookPool);
    let (base_debt, quote_debt) = margin_manager.calculate_debts<BaseAsset, QuoteAsset, DebtAsset>(
        margin_pool,
    );
    let (base_asset, quote_asset) = margin_manager.calculate_assets<BaseAsset, QuoteAsset>(
        pool,
    );

    // The order is a bid, and quantity is less than the net base debt.
    // The order is a ask, and quote quantity is less than the net quote debt.
    assert!(
        (is_bid && base_debt > base_asset && quantity <= base_debt - base_asset) ||
            (!is_bid && quote_debt > quote_asset && math::mul(quantity, price) <= quote_debt - quote_asset),
        ENotReduceOnlyOrder,
    );

    let trade_proof = margin_manager.trade_proof(ctx);
    let balance_manager = margin_manager.balance_manager_trading_mut(ctx);

    pool.place_limit_order(
        balance_manager,
        &trade_proof,
        client_order_id,
        order_type,
        self_matching_option,
        price,
        quantity,
        is_bid,
        pay_with_deep,
        expire_timestamp,
        clock,
        ctx,
    )
}

/// Places a reduce-only market order in the pool. Used when margin trading is disabled.
public fun place_reduce_only_market_order<BaseAsset, QuoteAsset, DebtAsset>(
    registry: &MarginRegistry,
    margin_manager: &mut MarginManager<BaseAsset, QuoteAsset>,
    pool: &mut Pool<BaseAsset, QuoteAsset>,
    margin_pool: &MarginPool<DebtAsset>,
    client_order_id: u64,
    self_matching_option: u8,
    quantity: u64,
    is_bid: bool,
    pay_with_deep: bool,
    clock: &Clock,
    ctx: &TxContext,
): OrderInfo {
    registry.load_inner();
    assert!(margin_manager.deepbook_pool() == pool.id(), EIncorrectDeepBookPool);
    let (base_debt, quote_debt) = margin_manager.calculate_debts<BaseAsset, QuoteAsset, DebtAsset>(
        margin_pool,
    );
    let (base_asset, quote_asset) = margin_manager.calculate_assets<BaseAsset, QuoteAsset>(
        pool,
    );

    let (_, quote_quantity, _) = if (pay_with_deep) {
        pool.get_quote_quantity_out(quantity, clock)
    } else {
        pool.get_quote_quantity_out_input_fee(quantity, clock)
    };

    // The order is a bid, and quantity is less than the net base debt.
    // The order is a ask, and quote quantity is less than the net quote debt.
    assert!(
        (is_bid && base_debt > base_asset && quantity <= base_debt - base_asset) ||
            (!is_bid && quote_debt > quote_asset && quote_quantity <= quote_debt - quote_asset),
        ENotReduceOnlyOrder,
    );

    let trade_proof = margin_manager.trade_proof(ctx);
    let balance_manager = margin_manager.balance_manager_trading_mut(ctx);

    pool.place_market_order(
        balance_manager,
        &trade_proof,
        client_order_id,
        self_matching_option,
        quantity,
        is_bid,
        pay_with_deep,
        clock,
        ctx,
    )
}

/// Modifies an order
public fun modify_order<BaseAsset, QuoteAsset>(
    registry: &MarginRegistry,
    margin_manager: &mut MarginManager<BaseAsset, QuoteAsset>,
    pool: &mut Pool<BaseAsset, QuoteAsset>,
    order_id: u128,
    new_quantity: u64,
    clock: &Clock,
    ctx: &TxContext,
) {
    registry.load_inner();
    assert!(margin_manager.deepbook_pool() == pool.id(), EIncorrectDeepBookPool);
    let trade_proof = margin_manager.trade_proof(ctx);
    let balance_manager = margin_manager.balance_manager_trading_mut(ctx);

    pool.modify_order(
        balance_manager,
        &trade_proof,
        order_id,
        new_quantity,
        clock,
        ctx,
    )
}

/// Cancels an order
public fun cancel_order<BaseAsset, QuoteAsset>(
    registry: &MarginRegistry,
    margin_manager: &mut MarginManager<BaseAsset, QuoteAsset>,
    pool: &mut Pool<BaseAsset, QuoteAsset>,
    order_id: u128,
    clock: &Clock,
    ctx: &TxContext,
) {
    registry.load_inner();
    assert!(margin_manager.deepbook_pool() == pool.id(), EIncorrectDeepBookPool);
    let trade_proof = margin_manager.trade_proof(ctx);
    let balance_manager = margin_manager.balance_manager_trading_mut(ctx);

    pool.cancel_order(
        balance_manager,
        &trade_proof,
        order_id,
        clock,
        ctx,
    );
}

/// Cancel multiple orders within a vector.
public fun cancel_orders<BaseAsset, QuoteAsset>(
    registry: &MarginRegistry,
    margin_manager: &mut MarginManager<BaseAsset, QuoteAsset>,
    pool: &mut Pool<BaseAsset, QuoteAsset>,
    order_ids: vector<u128>,
    clock: &Clock,
    ctx: &TxContext,
) {
    registry.load_inner();
    assert!(margin_manager.deepbook_pool() == pool.id(), EIncorrectDeepBookPool);
    let trade_proof = margin_manager.trade_proof(ctx);
    let balance_manager = margin_manager.balance_manager_trading_mut(ctx);

    pool.cancel_orders(
        balance_manager,
        &trade_proof,
        order_ids,
        clock,
        ctx,
    );
}

/// Cancels all orders for the given account.
public fun cancel_all_orders<BaseAsset, QuoteAsset>(
    registry: &MarginRegistry,
    margin_manager: &mut MarginManager<BaseAsset, QuoteAsset>,
    pool: &mut Pool<BaseAsset, QuoteAsset>,
    clock: &Clock,
    ctx: &TxContext,
) {
    registry.load_inner();
    assert!(margin_manager.deepbook_pool() == pool.id(), EIncorrectDeepBookPool);
    let trade_proof = margin_manager.trade_proof(ctx);
    let balance_manager = margin_manager.balance_manager_trading_mut(ctx);

    pool.cancel_all_orders(
        balance_manager,
        &trade_proof,
        clock,
        ctx,
    );
}

/// Withdraw settled amounts to balance_manager.
public fun withdraw_settled_amounts<BaseAsset, QuoteAsset>(
    registry: &MarginRegistry,
    margin_manager: &mut MarginManager<BaseAsset, QuoteAsset>,
    pool: &mut Pool<BaseAsset, QuoteAsset>,
    ctx: &TxContext,
) {
    registry.load_inner();
    assert!(margin_manager.deepbook_pool() == pool.id(), EIncorrectDeepBookPool);
    let trade_proof = margin_manager.trade_proof(ctx);
    let balance_manager = margin_manager.balance_manager_trading_mut(ctx);

    pool.withdraw_settled_amounts(
        balance_manager,
        &trade_proof,
    );
}

/// Stake DEEP tokens to the pool.
public fun stake<BaseAsset, QuoteAsset>(
    registry: &MarginRegistry,
    margin_manager: &mut MarginManager<BaseAsset, QuoteAsset>,
    pool: &mut Pool<BaseAsset, QuoteAsset>,
    amount: u64,
    ctx: &TxContext,
) {
    registry.load_inner();
    assert!(margin_manager.deepbook_pool() == pool.id(), EIncorrectDeepBookPool);
    let base_asset_type = type_name::with_defining_ids<BaseAsset>();
    let quote_asset_type = type_name::with_defining_ids<QuoteAsset>();
    let deep_asset_type = type_name::with_defining_ids<DEEP>();
    assert!(
        base_asset_type != deep_asset_type && quote_asset_type != deep_asset_type,
        ECannotStakeWithDeepMarginManager,
    );

    let trade_proof = margin_manager.trade_proof(ctx);
    let balance_manager = margin_manager.balance_manager_trading_mut(ctx);

    pool.stake(
        balance_manager,
        &trade_proof,
        amount,
        ctx,
    );
}

/// Unstake DEEP tokens from the pool.
public fun unstake<BaseAsset, QuoteAsset>(
    registry: &MarginRegistry,
    margin_manager: &mut MarginManager<BaseAsset, QuoteAsset>,
    pool: &mut Pool<BaseAsset, QuoteAsset>,
    ctx: &TxContext,
) {
    registry.load_inner();
    assert!(margin_manager.deepbook_pool() == pool.id(), EIncorrectDeepBookPool);
    let trade_proof = margin_manager.trade_proof(ctx);
    let balance_manager = margin_manager.balance_manager_trading_mut(ctx);

    pool.unstake(
        balance_manager,
        &trade_proof,
        ctx,
    );
}

/// Submit proposal using the margin manager.
public fun submit_proposal<BaseAsset, QuoteAsset>(
    registry: &MarginRegistry,
    margin_manager: &mut MarginManager<BaseAsset, QuoteAsset>,
    pool: &mut Pool<BaseAsset, QuoteAsset>,
    taker_fee: u64,
    maker_fee: u64,
    stake_required: u64,
    ctx: &TxContext,
) {
    registry.load_inner();
    assert!(margin_manager.deepbook_pool() == pool.id(), EIncorrectDeepBookPool);
    let trade_proof = margin_manager.trade_proof(ctx);
    let balance_manager = margin_manager.balance_manager_trading_mut(ctx);

    pool.submit_proposal(
        balance_manager,
        &trade_proof,
        taker_fee,
        maker_fee,
        stake_required,
        ctx,
    );
}

/// Vote on a proposal using the margin manager.
public fun vote<BaseAsset, QuoteAsset>(
    registry: &MarginRegistry,
    margin_manager: &mut MarginManager<BaseAsset, QuoteAsset>,
    pool: &mut Pool<BaseAsset, QuoteAsset>,
    proposal_id: ID,
    ctx: &TxContext,
) {
    registry.load_inner();
    assert!(margin_manager.deepbook_pool() == pool.id(), EIncorrectDeepBookPool);
    let trade_proof = margin_manager.trade_proof(ctx);
    let balance_manager = margin_manager.balance_manager_trading_mut(ctx);

    pool.vote(
        balance_manager,
        &trade_proof,
        proposal_id,
        ctx,
    );
}

public fun claim_rebates<BaseAsset, QuoteAsset>(
    registry: &MarginRegistry,
    margin_manager: &mut MarginManager<BaseAsset, QuoteAsset>,
    pool: &mut Pool<BaseAsset, QuoteAsset>,
    ctx: &mut TxContext,
) {
    registry.load_inner();
    assert!(margin_manager.deepbook_pool() == pool.id(), EIncorrectDeepBookPool);
    let trade_proof = margin_manager.trade_proof(ctx);
    let balance_manager = margin_manager.balance_manager_trading_mut(ctx);

    pool.claim_rebates(balance_manager, &trade_proof, ctx);
}
// Copyright (c) Mysten Labs, Inc.
// SPDX-License-Identifier: Apache-2.0

module margin_trading::manager_info;

use deepbook::{constants, math};
use margin_trading::{
    margin_constants,
    margin_registry::MarginRegistry,
    oracle::calculate_target_amount
};
use pyth::price_info::PriceInfoObject;
use sui::clock::Clock;

// === Structs ===
/// Information about a single asset (base or quote)
public struct AssetInfo has copy, drop {
    asset: u64, // Asset amount in native units
    debt: u64, // Debt amount in native units
    usd_asset: u64, // Asset value in USD
    usd_debt: u64, // Debt value in USD
}

/// Combined information about a margin manager's position
public struct ManagerInfo has copy, drop {
    base: AssetInfo,
    quote: AssetInfo,
    debt: u64,
    asset_usd: u64, // Asset value in USD
    debt_usd: u64, // Debt value in USD
    risk_ratio: u64, // Risk ratio with 9 decimals
    base_per_dollar: u64, // Base asset per dollar with 9 decimals
    quote_per_dollar: u64, // Quote asset per dollar with 9 decimals
    debt_per_dollar: u64, // Debt per dollar with 9 decimals
    user_liquidation_reward: u64, // User liquidation reward with 9 decimals
    pool_liquidation_reward: u64, // Pool liquidation reward with 9 decimals
    target_ratio: u64, // Target ratio with 9 decimals
}

public struct Fulfillment {
    manager_id: ID,
    repay_amount: u64,
    pool_reward_amount: u64,
    default_amount: u64,
    base_exit_amount: u64,
    quote_exit_amount: u64,
    risk_ratio: u64,
}

// === Public Functions ===
public fun risk_ratio(manager_info: &ManagerInfo): u64 {
    manager_info.risk_ratio
}

/// === Public(package) Functions ===
/// Calculate ManagerInfo from raw asset/debt data and oracle information
/// This centralizes all USD calculation and risk ratio computation logic
public(package) fun new_manager_info<BaseAsset, QuoteAsset>(
    base_asset: u64,
    quote_asset: u64,
    base_debt: u64,
    quote_debt: u64,
    registry: &MarginRegistry,
    base_price_info_object: &PriceInfoObject,
    quote_price_info_object: &PriceInfoObject,
    clock: &Clock,
    pool_id: ID,
): ManagerInfo {
    let base_per_dollar = calculate_target_amount<BaseAsset>(
        base_price_info_object,
        registry,
        constants::float_scaling(),
        clock,
    );

    let quote_per_dollar = calculate_target_amount<QuoteAsset>(
        quote_price_info_object,
        registry,
        constants::float_scaling(),
        clock,
    );

    let debt_per_dollar = if (base_debt > 0) {
        base_per_dollar
    } else {
        quote_per_dollar
    };

    // Calculate debt in USD
    let base_usd_debt = if (base_debt > 0) {
        math::div(base_debt, base_per_dollar)
    } else {
        0
    };

    let quote_usd_debt = if (quote_debt > 0) {
        math::div(quote_debt, quote_per_dollar)
    } else {
        0
    };

    // Calculate asset values in USD
    let base_usd_asset = math::div(base_asset, base_per_dollar);
    let quote_usd_asset = math::div(quote_asset, quote_per_dollar);

    // Calculate risk ratio
    let total_usd_debt = base_usd_debt + quote_usd_debt;
    let total_usd_asset = base_usd_asset + quote_usd_asset;
    let max_risk_ratio = margin_constants::max_risk_ratio();

    let risk_ratio = if (
        total_usd_debt == 0 || total_usd_asset > math::mul(total_usd_debt, max_risk_ratio)
    ) {
        max_risk_ratio
    } else {
        math::div(total_usd_asset, total_usd_debt) // 9 decimals
    };

    // Construct and return ManagerInfo
    ManagerInfo {
        base: AssetInfo {
            asset: base_asset,
            debt: base_debt,
            usd_asset: base_usd_asset,
            usd_debt: base_usd_debt,
        },
        quote: AssetInfo {
            asset: quote_asset,
            debt: quote_debt,
            usd_asset: quote_usd_asset,
            usd_debt: quote_usd_debt,
        },
        debt: base_debt.max(quote_debt),
        asset_usd: total_usd_asset,
        debt_usd: total_usd_debt,
        debt_per_dollar,
        risk_ratio,
        base_per_dollar,
        quote_per_dollar,
        user_liquidation_reward: registry.user_liquidation_reward(pool_id),
        pool_liquidation_reward: registry.pool_liquidation_reward(pool_id),
        target_ratio: registry.target_liquidation_risk_ratio(pool_id),
    }
}

public(package) fun produce_fulfillment(self: &ManagerInfo, manager_id: ID): Fulfillment {
    let usd_to_repay_with_rewards = self.calculate_usd_amount_to_repay(); // 1000
    let repay_usd_with_rewards = self.asset_usd.min(usd_to_repay_with_rewards); // 900
    let liquidation_reward = self.user_liquidation_reward + self.pool_liquidation_reward;
    let liquidation_reward_ratio = constants::float_scaling() + liquidation_reward; // 1.05

    let usd_to_repay = math::div(repay_usd_with_rewards, liquidation_reward_ratio); // 900 / 1.05 = 857
    let pool_reward_usd = math::mul(usd_to_repay, self.pool_liquidation_reward); // 857 * 0.03 = 26

    let in_default = self.debt_usd > self.asset_usd; // 1000 > 900 = true
    let default_usd = if (in_default) {
        self.debt_usd - usd_to_repay
    } else {
        0
    };

    let base_usd_asset = self.base.usd_asset;
    let quote_usd_asset = self.quote.usd_asset;
    let (base_usd, quote_usd) = if (self.base.debt > 0) {
        let base_usd = repay_usd_with_rewards.min(base_usd_asset);
        let repay_usd_with_rewards = repay_usd_with_rewards - base_usd;
        let quote_usd = repay_usd_with_rewards.min(quote_usd_asset);
        (base_usd, quote_usd)
    } else {
        let quote_usd = repay_usd_with_rewards.min(quote_usd_asset);
        let repay_usd_with_rewards = repay_usd_with_rewards - quote_usd;
        let base_usd = repay_usd_with_rewards.min(base_usd_asset);
        (base_usd, quote_usd)
    };

    let repay_amount = math::mul(usd_to_repay, self.debt_per_dollar);
    let pool_reward_amount = math::mul(pool_reward_usd, self.debt_per_dollar);
    let default_amount = math::mul(default_usd, self.debt_per_dollar);
    let base_exit_amount = math::mul(base_usd, self.base_per_dollar);
    let quote_exit_amount = math::mul(quote_usd, self.quote_per_dollar);

    Fulfillment {
        manager_id,
        repay_amount,
        pool_reward_amount,
        default_amount,
        base_exit_amount,
        quote_exit_amount,
        risk_ratio: self.risk_ratio,
    }
}

public(package) fun calculate_usd_amount_to_repay(manager_info: &ManagerInfo): u64 {
    let target_ratio = manager_info.target_ratio; // 1.25
    let debt_in_usd = manager_info.base.usd_debt.max(manager_info.quote.usd_debt); // 1000
    let liquidation_reward =
        manager_info.user_liquidation_reward + manager_info.pool_liquidation_reward; // 5%
    let assets_in_usd = manager_info.base.usd_asset + manager_info.quote.usd_asset; // 1100
    let numerator = math::mul(target_ratio, debt_in_usd) - assets_in_usd; // 1250 - 1100 = 150
    let denominator = target_ratio - (constants::float_scaling() + liquidation_reward); // 1.25 - 1.05 = 0.2
    let usd_to_repay = math::div(numerator, denominator); // 750

    math::mul(usd_to_repay, constants::float_scaling() + liquidation_reward) // 750 * 1.05 = 787.5
}

/// Calculate return amounts for partial liquidations
/// Returns: (base_return_amount, quote_return_amount)
public(package) fun calculate_return_amounts(
    return_percent: u64,
    base_coin_value: u64,
    quote_coin_value: u64,
): (u64, u64) {
    let base_return_amount = math::mul(return_percent, base_coin_value);
    let quote_return_amount = math::mul(return_percent, quote_coin_value);

    (base_return_amount, quote_return_amount)
}

/// Calculate and updates fulfillment based on repay percentage
/// Returns the percent of the base and quote assets are returned to the manager
public(package) fun update_fulfillment(fulfillment: &mut Fulfillment, repay_coin_amount: u64): u64 {
    let total_fulfillment_amount = fulfillment.repay_amount + fulfillment.pool_reward_amount;
    let full_liquidation = repay_coin_amount >= total_fulfillment_amount;
    let repay_percent = if (full_liquidation) {
        constants::float_scaling()
    } else {
        math::div(repay_coin_amount, total_fulfillment_amount)
    };
    let repay_amount = math::mul(repay_percent, fulfillment.repay_amount);
    let pool_reward_amount = math::mul(repay_percent, fulfillment.pool_reward_amount);

    let default_amount = if (full_liquidation) {
        fulfillment.default_amount
    } else {
        0
    };
    let return_percent = constants::float_scaling() - repay_percent;

    fulfillment.repay_amount = repay_amount;
    fulfillment.pool_reward_amount = pool_reward_amount;
    fulfillment.default_amount = default_amount;

    return_percent
}

public(package) fun user_liquidation_reward(manager_info: &ManagerInfo): u64 {
    manager_info.user_liquidation_reward
}

public(package) fun pool_liquidation_reward(manager_info: &ManagerInfo): u64 {
    manager_info.pool_liquidation_reward
}

public(package) fun manager_id(fulfillment: &Fulfillment): ID {
    fulfillment.manager_id
}

public(package) fun repay_amount(fulfillment: &Fulfillment): u64 {
    fulfillment.repay_amount
}

public(package) fun pool_reward_amount(fulfillment: &Fulfillment): u64 {
    fulfillment.pool_reward_amount
}

public(package) fun default_amount(fulfillment: &Fulfillment): u64 {
    fulfillment.default_amount
}

public(package) fun base_exit_amount(fulfillment: &Fulfillment): u64 {
    fulfillment.base_exit_amount
}

public(package) fun quote_exit_amount(fulfillment: &Fulfillment): u64 {
    fulfillment.quote_exit_amount
}

public(package) fun fulfillment_risk_ratio(fulfillment: &Fulfillment): u64 {
    fulfillment.risk_ratio
}

public(package) fun drop(fulfillment: Fulfillment) {
    let Fulfillment {
        manager_id: _,
        repay_amount: _,
        pool_reward_amount: _,
        default_amount: _,
        base_exit_amount: _,
        quote_exit_amount: _,
        risk_ratio: _,
    } = fulfillment;
}
module margin_trading::protocol_config;

use deepbook::{constants, math};
use margin_trading::margin_constants;

const EInvalidRiskParam: u64 = 1;
const EInvalidProtocolSpread: u64 = 2;

public struct ProtocolConfig has copy, drop, store {
    margin_pool_config: MarginPoolConfig,
    interest_config: InterestConfig,
}

public struct MarginPoolConfig has copy, drop, store {
    supply_cap: u64,
    max_utilization_rate: u64,
    protocol_spread: u64,
    min_borrow: u64,
}

public struct InterestConfig has copy, drop, store {
    base_rate: u64,
    base_slope: u64,
    optimal_utilization: u64,
    excess_slope: u64,
}

public fun new_protocol_config(
    margin_pool_config: MarginPoolConfig,
    interest_config: InterestConfig,
): ProtocolConfig {
    ProtocolConfig {
        margin_pool_config,
        interest_config,
    }
}

public fun new_margin_pool_config(
    supply_cap: u64,
    max_utilization_rate: u64,
    protocol_spread: u64,
    min_borrow: u64,
): MarginPoolConfig {
    MarginPoolConfig {
        supply_cap,
        max_utilization_rate,
        protocol_spread,
        min_borrow,
    }
}

public fun new_interest_config(
    base_rate: u64,
    base_slope: u64,
    optimal_utilization: u64,
    excess_slope: u64,
): InterestConfig {
    InterestConfig {
        base_rate,
        base_slope,
        optimal_utilization,
        excess_slope,
    }
}

public(package) fun set_interest_config(self: &mut ProtocolConfig, config: InterestConfig) {
    assert!(
        self.margin_pool_config.max_utilization_rate >= config.optimal_utilization,
        EInvalidRiskParam,
    );
    self.interest_config = config;
}

public(package) fun set_margin_pool_config(self: &mut ProtocolConfig, config: MarginPoolConfig) {
    assert!(config.protocol_spread <= constants::float_scaling(), EInvalidProtocolSpread);
    assert!(config.max_utilization_rate <= constants::float_scaling(), EInvalidRiskParam);
    assert!(
        config.max_utilization_rate >= self.interest_config.optimal_utilization,
        EInvalidRiskParam,
    );
    assert!(config.min_borrow >= margin_constants::min_min_borrow(), EInvalidRiskParam);
    self.margin_pool_config = config;
}

public(package) fun time_adjusted_rate(
    self: &ProtocolConfig,
    utilization_rate: u64,
    time_elapsed: u64,
): u64 {
    let interest_rate = self.interest_rate(utilization_rate);
    math::div(
        math::mul(time_elapsed, interest_rate),
        margin_constants::year_ms(),
    )
}

public(package) fun interest_rate(self: &ProtocolConfig, utilization_rate: u64): u64 {
    let base_rate = self.interest_config.base_rate;
    let base_slope = self.interest_config.base_slope;
    let optimal_utilization = self.interest_config.optimal_utilization;
    let excess_slope = self.interest_config.excess_slope;

    if (utilization_rate < optimal_utilization) {
        // Use base slope
        math::mul(utilization_rate, base_slope) + base_rate
    } else {
        // Use base slope and excess slope
        let excess_utilization = utilization_rate - optimal_utilization;
        let excess_rate = math::mul(excess_utilization, excess_slope);

        base_rate + math::mul(optimal_utilization, base_slope) + excess_rate
    }
}

public(package) fun supply_cap(self: &ProtocolConfig): u64 {
    self.margin_pool_config.supply_cap
}

public(package) fun max_utilization_rate(self: &ProtocolConfig): u64 {
    self.margin_pool_config.max_utilization_rate
}

public(package) fun protocol_spread(self: &ProtocolConfig): u64 {
    self.margin_pool_config.protocol_spread
}

public(package) fun min_borrow(self: &ProtocolConfig): u64 {
    self.margin_pool_config.min_borrow
}

public(package) fun base_rate(self: &ProtocolConfig): u64 {
    self.interest_config.base_rate
}

public(package) fun base_slope(self: &ProtocolConfig): u64 {
    self.interest_config.base_slope
}

public(package) fun optimal_utilization(self: &ProtocolConfig): u64 {
    self.interest_config.optimal_utilization
}

public(package) fun excess_slope(self: &ProtocolConfig): u64 {
    self.interest_config.excess_slope
}
module margin_trading::margin_state;

use deepbook::{constants, math};
use margin_trading::protocol_config::ProtocolConfig;
use sui::clock::Clock;

// === Constants ===
public struct State has drop, store {
    total_supply: u64,
    total_borrow: u64,
    supply_index: u64,
    borrow_index: u64,
    last_index_update_timestamp: u64,
}

public(package) fun default(clock: &Clock): State {
    State {
        total_supply: 0,
        total_borrow: 0,
        supply_index: constants::float_scaling(),
        borrow_index: constants::float_scaling(),
        last_index_update_timestamp: clock.timestamp_ms(),
    }
}

// === Public-Package Functions ===
/// Updates the index for the margin pool.
public(package) fun update(self: &mut State, config: &ProtocolConfig, clock: &Clock): u64 {
    let current_timestamp = clock.timestamp_ms();
    if (self.last_index_update_timestamp == current_timestamp) return 0;

    let time_adjusted_rate = config.time_adjusted_rate(
        self.utilization_rate(),
        current_timestamp - self.last_index_update_timestamp,
    );
    let total_interest_accrued = math::mul(self.total_borrow, time_adjusted_rate);

    let new_supply = self.total_supply + total_interest_accrued;
    let new_borrow = self.total_borrow + total_interest_accrued;
    self.update_supply_index(new_supply);
    self.update_borrow_index(new_borrow);
    self.last_index_update_timestamp = current_timestamp;

    total_interest_accrued
}

public(package) fun increase_total_supply(self: &mut State, amount: u64) {
    self.total_supply = self.total_supply + amount;
}

public(package) fun increase_total_supply_with_index(self: &mut State, amount: u64) {
    let current_supply = self.total_supply;
    let new_supply = current_supply + amount;
    let new_supply_index = math::mul(
        self.supply_index,
        math::div(new_supply, current_supply),
    );
    self.total_supply = new_supply;
    self.supply_index = new_supply_index;
}

public(package) fun decrease_total_supply(self: &mut State, amount: u64) {
    self.total_supply = self.total_supply - amount;
}

public(package) fun decrease_total_supply_with_index(self: &mut State, amount: u64) {
    let current_supply = self.total_supply;
    let new_supply = current_supply - amount;
    let new_supply_index = math::mul(
        self.supply_index,
        math::div(new_supply, current_supply),
    );
    self.total_supply = new_supply;
    self.supply_index = new_supply_index;
}

public(package) fun increase_total_borrow(self: &mut State, amount: u64) {
    self.total_borrow = self.total_borrow + amount;
}

public(package) fun decrease_total_borrow(self: &mut State, amount: u64) {
    self.total_borrow = self.total_borrow - amount;
}

public(package) fun to_supply_shares(self: &State, amount: u64): u64 {
    math::div(amount, self.supply_index)
}

public(package) fun to_borrow_shares(self: &State, amount: u64): u64 {
    math::div(amount, self.borrow_index)
}

public(package) fun to_supply_amount(self: &State, shares: u64): u64 {
    math::mul(shares, self.supply_index)
}

public(package) fun to_borrow_amount(self: &State, shares: u64): u64 {
    math::mul(shares, self.borrow_index)
}

public(package) fun supply_index(self: &State): u64 {
    self.supply_index
}

public(package) fun borrow_index(self: &State): u64 {
    self.borrow_index
}

public(package) fun utilization_rate(self: &State): u64 {
    if (self.total_supply == 0) {
        0
    } else {
        math::div(self.total_borrow, self.total_supply) // 9 decimals
    }
}

public(package) fun total_supply(self: &State): u64 {
    self.total_supply
}

public(package) fun total_supply_shares(self: &State): u64 {
    math::mul(self.total_supply, self.supply_index)
}

public(package) fun total_borrow(self: &State): u64 {
    self.total_borrow
}

fun update_supply_index(self: &mut State, new_supply: u64) {
    let new_supply_index = if (self.total_supply == 0) {
        self.supply_index
    } else {
        math::mul(
            self.supply_index,
            math::div(new_supply, self.total_supply),
        )
    };
    self.supply_index = new_supply_index;
    self.total_supply = new_supply;
}

fun update_borrow_index(self: &mut State, new_borrow: u64) {
    let new_borrow_index = if (self.total_borrow == 0) {
        self.borrow_index
    } else {
        math::mul(
            self.borrow_index,
            math::div(new_borrow, self.total_borrow),
        )
    };
    self.borrow_index = new_borrow_index;
    self.total_borrow = new_borrow;
}
// Copyright (c) Mysten Labs, Inc.
// SPDX-License-Identifier: Apache-2.0

/// Position manager is responsible for managing the positions of the users.
/// It is used to track the supply and loan shares of the users.
module margin_trading::position_manager;

use sui::table::{Self, Table};

public struct PositionManager has store {
    supply_shares: Table<address, u64>,
}

public(package) fun create_position_manager(ctx: &mut TxContext): PositionManager {
    PositionManager {
        supply_shares: table::new(ctx),
    }
}

/// Increase the supply shares of the user
public(package) fun increase_user_supply_shares(
    self: &mut PositionManager,
    user: address,
    supply_shares: u64,
): u64 {
    self.add_supply_entry(user);
    let supply = self.supply_shares.borrow_mut(user);
    *supply = *supply + supply_shares;

    *supply
}

/// Decrease the supply shares of the user
public(package) fun decrease_user_supply_shares(
    self: &mut PositionManager,
    user: address,
    supply_shares: u64,
): u64 {
    let supply = self.supply_shares.borrow_mut(user);
    *supply = *supply - supply_shares;

    *supply
}

/// Get the supply shares of the user.
public(package) fun user_supply_shares(self: &PositionManager, user: address): u64 {
    *self.supply_shares.borrow(user)
}

public(package) fun add_supply_entry(self: &mut PositionManager, user: address) {
    if (!self.supply_shares.contains(user)) {
        self
            .supply_shares
            .add(
                user,
                0,
            );
    }
}
// Copyright (c) Mysten Labs, Inc.
// SPDX-License-Identifier: Apache-2.0

module margin_trading::margin_constants;

const MARGIN_VERSION: u64 = 1;
const MAX_RISK_RATIO: u64 = 1_000 * 1_000_000_000; // Risk ratio above 1000 will be considered as 1000
const DEFAULT_USER_LIQUIDATION_REWARD: u64 = 10_000_000; // 1%
const DEFAULT_POOL_LIQUIDATION_REWARD: u64 = 40_000_000; // 4%
const MIN_LEVERAGE: u64 = 1_000_000_000; // 1x
const MAX_LEVERAGE: u64 = 20_000_000_000; // 20x
const YEAR_MS: u64 = 365 * 24 * 60 * 60 * 1000;
const MIN_MIN_BORROW: u64 = 1000;

public fun margin_version(): u64 {
    MARGIN_VERSION
}

public fun max_risk_ratio(): u64 {
    MAX_RISK_RATIO
}

public fun default_user_liquidation_reward(): u64 {
    DEFAULT_USER_LIQUIDATION_REWARD
}

public fun default_pool_liquidation_reward(): u64 {
    DEFAULT_POOL_LIQUIDATION_REWARD
}

public fun min_leverage(): u64 {
    MIN_LEVERAGE
}

public fun max_leverage(): u64 {
    MAX_LEVERAGE
}

public fun year_ms(): u64 {
    YEAR_MS
}

public fun min_min_borrow(): u64 {
    MIN_MIN_BORROW
}
// Copyright (c) Mysten Labs, Inc.
// SPDX-License-Identifier: Apache-2.0

#[test_only]
module margin_trading::test_constants;

// === Test Addresses ===
const USER1: address = @0xA;
const USER2: address = @0xB;
const ADMIN: address = @0x0;
const LIQUIDATOR: address = @0xC;

// === Test Coin Types ===
public struct USDC has drop {}
public struct USDT has drop {}
public struct BTC has drop {}
public struct INVALID_ASSET has drop {}

const USDC_MULTIPLIER: u64 = 1000000;
const USDT_MULTIPLIER: u64 = 1000000;
const DEEP_MULTIPLIER: u64 = 1000000;
const BTC_MULTIPLIER: u64 = 100000000;

// === Margin Pool Constants ===
const SUPPLY_CAP: u64 = 1_000_000_000_000_000; // 1B tokens with 9 decimals
const MAX_UTILIZATION_RATE: u64 = 800_000_000; // 80%
const PROTOCOL_SPREAD: u64 = 100_000_000; // 10%
const MIN_BORROW: u64 = 1000;

// === Interest Rate Constants ===
const BASE_RATE: u64 = 50_000_000; // 5%
const BASE_SLOPE: u64 = 100_000_000; // 10%
const OPTIMAL_UTILIZATION: u64 = 800_000_000; // 80%
const EXCESS_SLOPE: u64 = 2_000_000_000; // 200%

// === Pool Configuration Constants ===
const MIN_WITHDRAW_RISK_RATIO: u64 = 2_000_000_000; // 200%
const MIN_BORROW_RISK_RATIO: u64 = 1_500_000_000; // 150%
const LIQUIDATION_RISK_RATIO: u64 = 1_200_000_000; // 120%
const TARGET_LIQUIDATION_RISK_RATIO: u64 = 1_300_000_000; // 130%
const USER_LIQUIDATION_REWARD: u64 = 50_000_000; // 5%
const POOL_LIQUIDATION_REWARD: u64 = 10_000_000; // 1%

// === Pyth Price Feed IDs for Testing ===
const USDC_PRICE_FEED_ID: vector<u8> = b"USDC0000000000000000000000000000";
const USDT_PRICE_FEED_ID: vector<u8> = b"USDT0000000000000000000000000000";
const BTC_PRICE_FEED_ID: vector<u8> = b"BTC00000000000000000000000000000";

public fun supply_cap(): u64 {
    SUPPLY_CAP
}

public fun max_utilization_rate(): u64 {
    MAX_UTILIZATION_RATE
}

public fun protocol_spread(): u64 {
    PROTOCOL_SPREAD
}

public fun min_borrow(): u64 {
    MIN_BORROW
}

public fun base_rate(): u64 {
    BASE_RATE
}

public fun base_slope(): u64 {
    BASE_SLOPE
}

public fun optimal_utilization(): u64 {
    OPTIMAL_UTILIZATION
}

public fun excess_slope(): u64 {
    EXCESS_SLOPE
}

public fun user1(): address {
    USER1
}

public fun user2(): address {
    USER2
}

public fun admin(): address {
    ADMIN
}

public fun liquidator(): address {
    LIQUIDATOR
}

// === Pool Configuration Getters ===
public fun min_withdraw_risk_ratio(): u64 {
    MIN_WITHDRAW_RISK_RATIO
}

public fun min_borrow_risk_ratio(): u64 {
    MIN_BORROW_RISK_RATIO
}

public fun liquidation_risk_ratio(): u64 {
    LIQUIDATION_RISK_RATIO
}

public fun target_liquidation_risk_ratio(): u64 {
    TARGET_LIQUIDATION_RISK_RATIO
}

public fun user_liquidation_reward(): u64 {
    USER_LIQUIDATION_REWARD
}

public fun pool_liquidation_reward(): u64 {
    POOL_LIQUIDATION_REWARD
}

// === Pyth Price Feed ID Getters ===
public fun usdc_price_feed_id(): vector<u8> {
    USDC_PRICE_FEED_ID
}

public fun usdt_price_feed_id(): vector<u8> {
    USDT_PRICE_FEED_ID
}

public fun btc_price_feed_id(): vector<u8> {
    BTC_PRICE_FEED_ID
}

public fun usdc_multiplier(): u64 {
    USDC_MULTIPLIER
}

public fun usdt_multiplier(): u64 {
    USDT_MULTIPLIER
}

public fun deep_multiplier(): u64 {
    DEEP_MULTIPLIER
}

public fun btc_multiplier(): u64 {
    BTC_MULTIPLIER
}
// Copyright (c) Mysten Labs, Inc.
// SPDX-License-Identifier: Apache-2.0

module margin_trading::oracle;

use margin_trading::margin_registry::MarginRegistry;
use pyth::{price_info::PriceInfoObject, pyth};
use std::type_name::{Self, TypeName};
use sui::{clock::Clock, coin::CoinMetadata, vec_map::{Self, VecMap}};

use fun get_config_for_type as MarginRegistry.get_config_for_type;

const EInvalidPythPrice: u64 = 1;
const ECurrencyNotSupported: u64 = 2;
const EPriceFeedIdMismatch: u64 = 3;

/// A buffer added to the exponent when doing currency conversions.
const BUFFER: u8 = 10;

/// Holds a VecMap that determines the configuration for each currency.
public struct PythConfig has drop, store {
    currencies: VecMap<TypeName, CoinTypeData>,
    max_age_secs: u64, // max age tolerance for pyth prices in seconds
}

/// Find price feed IDs here https://www.pyth.network/developers/price-feed-ids
public struct CoinTypeData has copy, drop, store {
    decimals: u8,
    price_feed_id: vector<u8>, // Make sure to omit the `0x` prefix.
    type_name: TypeName,
}

public struct ConversionConfig has copy, drop {
    target_decimals: u8,
    base_decimals: u8,
    pyth_price: u64,
    pyth_decimals: u8,
}

/// Creates a new CoinTypeData struct of type T.
/// Uses CoinMetadata to avoid any errors in decimals.
public fun new_coin_type_data<T>(
    coin_metadata: &CoinMetadata<T>,
    price_feed_id: vector<u8>,
): CoinTypeData {
    let type_name = type_name::with_defining_ids<T>();
    CoinTypeData {
        decimals: coin_metadata.get_decimals(),
        price_feed_id,
        type_name,
    }
}

/// Creates a new PythConfig struct.
/// Can be attached by the Admin to MarginRegistry to allow oracle to work.
public fun new_pyth_config(setups: vector<CoinTypeData>, max_age_secs: u64): PythConfig {
    let mut currencies: VecMap<TypeName, CoinTypeData> = vec_map::empty();

    setups.do!(|coin_type| {
        currencies.insert(coin_type.type_name, coin_type);
    });

    PythConfig {
        currencies,
        max_age_secs,
    }
}

/// Calculates the USD price of a given asset or debt amount.
/// 9 decimals are used for USD representation.
public(package) fun calculate_usd_price<T>(
    price_info_object: &PriceInfoObject,
    registry: &MarginRegistry,
    amount: u64,
    clock: &Clock,
): u64 {
    let config = price_config<T>(
        price_info_object,
        registry,
        true,
        clock,
    );

    config.calculate_usd_currency_amount(
        amount,
    )
}

public(package) fun calculate_usd_currency_amount(
    config: ConversionConfig,
    base_currency_amount: u64,
): u64 {
    assert!(config.pyth_price > 0, EInvalidPythPrice);
    let exponent_with_buffer = BUFFER + config.base_decimals - config.target_decimals;

    let target_currency_amount =
        (
            ((base_currency_amount as u128) * (config.pyth_price as u128)).divide_and_round_up(
                10u128.pow(
                    config.pyth_decimals,
                )) * (10u128.pow(BUFFER)),
        ).divide_and_round_up(10u128.pow(
            exponent_with_buffer,
        )) as u64;

    target_currency_amount
}

/// Calculates the amount in target currency based on usd amount
public(package) fun calculate_target_amount<T>(
    price_info_object: &PriceInfoObject,
    registry: &MarginRegistry,
    usd_amount: u64,
    clock: &Clock,
): u64 {
    let config = price_config<T>(
        price_info_object,
        registry,
        false,
        clock,
    );

    calculate_target_currency_amount(
        config,
        usd_amount,
    )
}

public(package) fun calculate_target_currency_amount(
    config: ConversionConfig,
    base_currency_amount: u64,
): u64 {
    assert!(config.pyth_price > 0, EInvalidPythPrice);

    // We use a buffer in the edge case where target_decimals + pyth_decimals <
    // base_decimals
    let exponent_with_buffer =
        BUFFER + config.target_decimals + config.pyth_decimals - config.base_decimals;

    // We cast to u128 to avoid overflow, which is very likely with the buffer
    let target_currency_amount =
        (base_currency_amount as u128 * 10u128.pow(exponent_with_buffer))
            .divide_and_round_up(config.pyth_price as u128)
            .divide_and_round_up(10u128.pow(BUFFER)) as u64;

    target_currency_amount
}

fun price_config<T>(
    price_info_object: &PriceInfoObject,
    registry: &MarginRegistry,
    is_usd_price_config: bool,
    clock: &Clock,
): ConversionConfig {
    let config = registry.get_config<PythConfig>();
    let type_config = registry.get_config_for_type<T>();

    let price = pyth::get_price_no_older_than(
        price_info_object,
        clock,
        config.max_age_secs,
    );
    let price_info = price_info_object.get_price_info_from_price_info_object();

    // verify that the price feed id matches the one we have in our config.
    assert!(
        price_info.get_price_identifier().get_bytes() == type_config.price_feed_id,
        EPriceFeedIdMismatch,
    );

    let target_decimals = if (is_usd_price_config) {
        9
    } else {
        type_config.decimals
    }; // Our target decimals
    let base_decimals = if (is_usd_price_config) {
        type_config.decimals
    } else {
        9
    }; // Our starting decimals
    let pyth_price = price.get_price().get_magnitude_if_positive();
    let pyth_decimals = price.get_expo().get_magnitude_if_negative() as u8;

    ConversionConfig {
        target_decimals,
        base_decimals,
        pyth_price,
        pyth_decimals,
    }
}

/// Gets the configuration for a given currency type.
fun get_config_for_type<T>(registry: &MarginRegistry): CoinTypeData {
    let config = registry.get_config<PythConfig>();
    let payment_type = type_name::with_defining_ids<T>();
    assert!(config.currencies.contains(&payment_type), ECurrencyNotSupported);
    *config.currencies.get(&payment_type)
}

#[test_only]
public fun test_conversion_config(
    target_decimals: u8,
    base_decimals: u8,
    pyth_price: u64,
    pyth_decimals: u8,
): ConversionConfig {
    ConversionConfig {
        target_decimals,
        base_decimals,
        pyth_price,
        pyth_decimals,
    }
}

#[test_only]
/// Create a test CoinTypeData for testing without needing CoinMetadata
public fun test_coin_type_data<T>(decimals: u8, price_feed_id: vector<u8>): CoinTypeData {
    CoinTypeData {
        decimals,
        price_feed_id,
        type_name: type_name::with_defining_ids<T>(),
    }
}
// Copyright (c) Mysten Labs, Inc.
// SPDX-License-Identifier: Apache-2.0

module token::deep;

public struct DEEP has drop {}

public struct ProtectedTreasury has key {
    id: UID,
}

public struct TreasuryCapKey has copy, drop, store {}

public fun burn(arg0: &mut ProtectedTreasury, arg1: sui::coin::Coin<DEEP>) {
    sui::coin::burn<DEEP>(borrow_cap_mut(arg0), arg1);
}

public fun total_supply(arg0: &ProtectedTreasury): u64 {
    sui::coin::total_supply<DEEP>(borrow_cap(arg0))
}

fun borrow_cap(arg0: &ProtectedTreasury): &sui::coin::TreasuryCap<DEEP> {
    let v0 = TreasuryCapKey {};
    sui::dynamic_object_field::borrow<TreasuryCapKey, sui::coin::TreasuryCap<DEEP>>(
        &arg0.id,
        v0,
    )
}

fun borrow_cap_mut(arg0: &mut ProtectedTreasury): &mut sui::coin::TreasuryCap<DEEP> {
    let v0 = TreasuryCapKey {};
    sui::dynamic_object_field::borrow_mut<TreasuryCapKey, sui::coin::TreasuryCap<DEEP>>(
        &mut arg0.id,
        v0,
    )
}

fun create_coin(
    arg0: DEEP,
    arg1: u64,
    arg2: &mut sui::tx_context::TxContext,
): (ProtectedTreasury, sui::coin::Coin<DEEP>) {
    let (v0, v1) = sui::coin::create_currency<DEEP>(
        arg0,
        6,
        b"DEEP",
        b"DeepBook Token",
        b"The DEEP token secures the DeepBook protocol, the premier wholesale liquidity venue for on-chain trading.",
        std::option::some<sui::url::Url>(
            sui::url::new_unsafe_from_bytes(b"https://images.deepbook.tech/icon.svg"),
        ),
        arg2,
    );
    let mut cap = v0;
    sui::transfer::public_freeze_object<sui::coin::CoinMetadata<DEEP>>(v1);
    let mut protected_treasury = ProtectedTreasury { id: sui::object::new(arg2) };

    let coin = sui::coin::mint<DEEP>(&mut cap, arg1, arg2);
    sui::dynamic_object_field::add<TreasuryCapKey, sui::coin::TreasuryCap<DEEP>>(
        &mut protected_treasury.id,
        TreasuryCapKey {},
        cap,
    );

    (protected_treasury, coin)
}

#[allow(lint(share_owned))]
fun init(arg0: DEEP, arg1: &mut TxContext) {
    let (v0, v1) = create_coin(arg0, 10000000000000000, arg1);
    sui::transfer::share_object<ProtectedTreasury>(v0);
    sui::transfer::public_transfer<sui::coin::Coin<DEEP>>(v1, sui::tx_context::sender(arg1));
}

#[test_only]
public fun share_treasury_for_testing(ctx: &mut sui::tx_context::TxContext) {
    let (v0, v1) = create_coin(DEEP {}, 10000000000000000, ctx);
    sui::transfer::share_object<ProtectedTreasury>(v0);
    v1.burn_for_testing();
}
