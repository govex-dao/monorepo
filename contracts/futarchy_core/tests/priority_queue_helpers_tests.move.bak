#[test_only]
module futarchy_core::priority_queue_helpers_tests;

use account_protocol::account;
use futarchy_core::proposal_fee_manager;
use futarchy_core::priority_queue::{Self, ProposalQueue, QueueMutationAuth};
use futarchy_core::priority_queue_helpers;
use std::string;
use sui::clock::{Self, Clock};
use sui::sui::SUI;
use sui::test_scenario as ts;
use sui::test_utils::destroy;

const ADMIN: address = @0xAD;
const PROPOSER: address = @0xBEEF;

// === Test Helpers ===

fun start(): (ts::Scenario, Clock) {
    let mut scenario = ts::begin(ADMIN);
    let clock = clock::create_for_testing(ts::ctx(&mut scenario));
    (scenario, clock)
}

fun end(scenario: ts::Scenario, clock: Clock) {
    destroy(clock);
    ts::end(scenario);
}

// === ProposalData Tests ===

#[test]
fun test_new_proposal_data() {
    let (scenario, clock) = start();

    let title = string::utf8(b"Test Proposal");
    let metadata = string::utf8(b"Some metadata");
    let outcome_messages = vector[string::utf8(b"Approve"), string::utf8(b"Reject")];
    let outcome_details = vector[
        string::utf8(b"Details for approve"),
        string::utf8(b"Details for reject"),
    ];
    let initial_asset_amounts = vector[1000, 2000];
    let initial_stable_amounts = vector[3000, 4000];

    let data = priority_queue_helpers::new_proposal_data(
        title,
        metadata,
        outcome_messages,
        outcome_details,
        initial_asset_amounts,
        initial_stable_amounts,
    );

    // Verify data was created (can access getters)
    assert!(priority_queue_helpers::get_title(&data) == &string::utf8(b"Test Proposal"), 0);
    assert!(priority_queue_helpers::get_metadata(&data) == &string::utf8(b"Some metadata"), 1);

    end(scenario, clock);
}

#[test]
fun test_proposal_data_getters() {
    let (scenario, clock) = start();

    let title = string::utf8(b"My Proposal");
    let metadata = string::utf8(b"Metadata");
    let outcome_messages = vector[string::utf8(b"Yes"), string::utf8(b"No")];
    let outcome_details = vector[string::utf8(b"Detail 1"), string::utf8(b"Detail 2")];
    let initial_asset_amounts = vector[100, 200];
    let initial_stable_amounts = vector[300, 400];

    let data = priority_queue_helpers::new_proposal_data(
        title,
        metadata,
        outcome_messages,
        outcome_details,
        initial_asset_amounts,
        initial_stable_amounts,
    );

    // Test all getters
    assert!(priority_queue_helpers::get_title(&data) == &string::utf8(b"My Proposal"), 0);
    assert!(priority_queue_helpers::get_metadata(&data) == &string::utf8(b"Metadata"), 1);

    let messages = priority_queue_helpers::get_outcome_messages(&data);
    assert!(messages.length() == 2, 2);
    assert!(messages[0] == string::utf8(b"Yes"), 3);
    assert!(messages[1] == string::utf8(b"No"), 4);

    let details = priority_queue_helpers::get_outcome_details(&data);
    assert!(details.length() == 2, 5);
    assert!(details[0] == string::utf8(b"Detail 1"), 6);
    assert!(details[1] == string::utf8(b"Detail 2"), 7);

    // Note: initial_asset_amounts and initial_stable_amounts are not stored in new version
    // They return empty vectors for backward compatibility
    let asset_amounts = priority_queue_helpers::get_initial_asset_amounts(&data);
    assert!(asset_amounts.length() == 0, 8);

    let stable_amounts = priority_queue_helpers::get_initial_stable_amounts(&data);
    assert!(stable_amounts.length() == 0, 9);

    end(scenario, clock);
}

// === QueuedProposal Getter Tests ===

#[test]
fun test_queued_proposal_getters() {
    let (mut scenario, mut clock) = start();

    let dao_id = object::id_from_address(@0xDA0);
    let title = string::utf8(b"Test");

    clock.set_for_testing(1000);

    // Create test proposal
    let proposal = priority_queue::new_test_queued_proposal<SUI>(
        dao_id,
        PROPOSER,
        5000, // fee
        title,
        &clock,
        ts::ctx(&mut scenario),
    );

    // Test getters
    assert!(priority_queue_helpers::get_proposer(&proposal) == PROPOSER, 0);
    assert!(priority_queue_helpers::get_fee(&proposal) == 5000, 1);
    assert!(priority_queue_helpers::uses_dao_liquidity(&proposal) == false, 2);
    assert!(priority_queue_helpers::get_timestamp(&proposal) == 1000, 3);

    let data = priority_queue_helpers::get_data(&proposal);
    assert!(priority_queue_helpers::get_title(data) == &string::utf8(b"Test"), 4);

    priority_queue::destroy_for_testing(proposal);
    end(scenario, clock);
}

// === extract_max Tests ===

#[test]
#[expected_failure(abort_code = priority_queue_helpers::EQueueEmpty)]
fun test_extract_max_empty_queue_fails() {
    let (mut scenario, clock) = start();

    let dao_id = object::id_from_address(@0xDA0);
    let mut queue = priority_queue::new<SUI>(dao_id, 10, 300000, ts::ctx(&mut scenario));
    let auth = priority_queue::create_mutation_auth();

    // Try to extract from empty queue - should abort with EQueueEmpty
    let proposal = priority_queue_helpers::extract_max(auth, &mut queue);

    // This code will never be reached due to abort above
    priority_queue::destroy_for_testing(proposal);
    priority_queue::destroy_queue_for_testing(queue);
    end(scenario, clock);
}

#[test]
fun test_extract_max_single_proposal() {
    let (mut scenario, mut clock) = start();

    let dao_id = object::id_from_address(@0xDA0);
    let mut queue = priority_queue::new<SUI>(dao_id, 10, 300000, ts::ctx(&mut scenario));

    // Create fee manager and account for testing
    let mut fee_manager = proposal_fee_manager::new<SUI>(ts::ctx(&mut scenario));
    let mut account = account::new_for_testing(ts::ctx(&mut scenario));

    clock.set_for_testing(1000);

    // Add one proposal
    let proposal = priority_queue::new_test_queued_proposal<SUI>(
        dao_id,
        PROPOSER,
        5000,
        string::utf8(b"Proposal 1"),
        &clock,
    );

    let _ = priority_queue::insert(&mut queue, proposal, &mut fee_manager, &mut account, &clock, ts::ctx(&mut scenario));

    // Extract it
    let auth = priority_queue::create_mutation_auth();
    let extracted = priority_queue_helpers::extract_max(auth, &mut queue);

    // Verify it's the right one
    assert!(priority_queue_helpers::get_fee(&extracted) == 5000, 0);
    assert!(priority_queue_helpers::get_proposer(&extracted) == PROPOSER, 1);

    priority_queue::destroy_for_testing(extracted);
    priority_queue::destroy_queue_for_testing(queue);
    proposal_fee_manager::destroy_for_testing(fee_manager);
    account::destroy_for_testing<account::TestConfig>(account);
    end(scenario, clock);
}

#[test]
fun test_extract_max_multiple_proposals() {
    let (mut scenario, mut clock) = start();

    let dao_id = object::id_from_address(@0xDA0);
    let mut queue = priority_queue::new<SUI>(dao_id, 10, 300000, ts::ctx(&mut scenario));

    // Create fee manager and account for testing
    let mut fee_manager = proposal_fee_manager::new<SUI>(ts::ctx(&mut scenario));
    let mut account = account::new_for_testing(ts::ctx(&mut scenario));

    clock.set_for_testing(1000);

    // Add proposals with different fees
    let p1 = priority_queue::new_test_queued_proposal<SUI>(
        dao_id,
        @0x1,
        1000,
        string::utf8(b"Low fee"),
        &clock,
    );
    let p2 = priority_queue::new_test_queued_proposal<SUI>(
        dao_id,
        @0x2,
        5000,
        string::utf8(b"High fee"),
        &clock,
    );
    let p3 = priority_queue::new_test_queued_proposal<SUI>(
        dao_id,
        @0x3,
        3000,
        string::utf8(b"Mid fee"),
        &clock,
    );

    let _ = priority_queue::insert(&mut queue, p1, &mut fee_manager, &mut account, &clock, ts::ctx(&mut scenario));
    let _ = priority_queue::insert(&mut queue, p2, &mut fee_manager, &mut account, &clock, ts::ctx(&mut scenario));
    let _ = priority_queue::insert(&mut queue, p3, &mut fee_manager, &mut account, &clock, ts::ctx(&mut scenario));

    // Extract max - should be highest fee (5000)
    let auth = priority_queue::create_mutation_auth();
    let extracted = priority_queue_helpers::extract_max(auth, &mut queue);

    assert!(priority_queue_helpers::get_fee(&extracted) == 5000, 0);
    assert!(priority_queue_helpers::get_proposer(&extracted) == @0x2, 1);

    priority_queue::destroy_for_testing(extracted);
    priority_queue::destroy_queue_for_testing(queue);
    proposal_fee_manager::destroy_for_testing(fee_manager);
    account::destroy_for_testing<account::TestConfig>(account);
    end(scenario, clock);
}

#[test]
fun test_extract_max_tie_breaking_by_timestamp() {
    let (mut scenario, mut clock) = start();

    let dao_id = object::id_from_address(@0xDA0);
    let mut queue = priority_queue::new<SUI>(dao_id, 10, 300000, ts::ctx(&mut scenario));

    // Create fee manager and account for testing
    let mut fee_manager = proposal_fee_manager::new<SUI>(ts::ctx(&mut scenario));
    let mut account = account::new_for_testing(ts::ctx(&mut scenario));

    // Add proposals with same fee but different timestamps
    clock.set_for_testing(1000);
    let p1 = priority_queue::new_test_queued_proposal<SUI>(
        dao_id,
        @0x1,
        5000,
        string::utf8(b"First"),
        &clock,
    );
    // Insert p1 while clock is at 1000
    let _ = priority_queue::insert(&mut queue, p1, &mut fee_manager, &mut account, &clock, ts::ctx(&mut scenario));

    // Now change clock for p2
    clock.set_for_testing(2000);
    let p2 = priority_queue::new_test_queued_proposal<SUI>(
        dao_id,
        @0x2,
        5000,
        string::utf8(b"Second"),
        &clock,
    );
    // Insert p2 while clock is at 2000
    let _ = priority_queue::insert(&mut queue, p2, &mut fee_manager, &mut account, &clock, ts::ctx(&mut scenario));

    // Extract max - should be earliest timestamp (p1)
    let auth = priority_queue::create_mutation_auth();
    let extracted = priority_queue_helpers::extract_max(auth, &mut queue);

    assert!(priority_queue_helpers::get_proposer(&extracted) == @0x1, 0);
    assert!(priority_queue_helpers::get_timestamp(&extracted) == 1000, 1);

    priority_queue::destroy_for_testing(extracted);
    priority_queue::destroy_queue_for_testing(queue);
    proposal_fee_manager::destroy_for_testing(fee_manager);
    account::destroy_for_testing<account::TestConfig>(account);
    end(scenario, clock);
}

// === Integration Tests ===

#[test]
fun test_full_workflow() {
    let (mut scenario, mut clock) = start();

    // 1. Create proposal data
    let title = string::utf8(b"Funding Proposal");
    let metadata = string::utf8(b"Request for 10k funding");
    let outcome_messages = vector[string::utf8(b"Approve"), string::utf8(b"Reject")];
    let outcome_details = vector[string::utf8(b"Approve funding"), string::utf8(b"Reject funding")];
    let initial_asset_amounts = vector[10000, 0];
    let initial_stable_amounts = vector[0, 0];

    let data = priority_queue_helpers::new_proposal_data(
        title,
        metadata,
        outcome_messages,
        outcome_details,
        initial_asset_amounts,
        initial_stable_amounts,
    );

    // 2. Verify data
    assert!(priority_queue_helpers::get_title(&data) == &string::utf8(b"Funding Proposal"), 0);
    assert!(
        priority_queue_helpers::get_metadata(&data) == &string::utf8(b"Request for 10k funding"),
        1,
    );

    // Verify outcome messages
    let messages = priority_queue_helpers::get_outcome_messages(&data);
    assert!(messages.length() == 2, 2);
    assert!(messages[0] == string::utf8(b"Approve"), 3);
    assert!(messages[1] == string::utf8(b"Reject"), 4);

    end(scenario, clock);
}
