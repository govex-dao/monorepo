futarchy::oracle Module Tests
Function: new_oracle
test_new_oracle_success_typical_values: Verifies successful oracle creation with standard, valid inputs and correct initialization of all fields.
test_new_oracle_success_min_delay: Checks successful creation when twap_start_delay is 0 (and a multiple of window size).
test_new_oracle_success_max_valid_delay: Checks successful creation with twap_start_delay just under ONE_WEEK_MS and a multiple of window size.
test_new_oracle_success_large_init_price: Validates creation with twap_initialization_price at u128::max_value().
test_new_oracle_success_large_cap_step: Validates creation with twap_cap_step at u64::max_value().
test_new_oracle_fail_zero_init_price: Asserts failure (EZERO_INITIALIZATION) when twap_initialization_price is 0.
test_new_oracle_fail_zero_cap_step: Asserts failure (EZERO_STEP) when twap_cap_step is 0.
test_new_oracle_fail_delay_too_long: Asserts failure (ELONG_DELAY) when twap_start_delay is equal to ONE_WEEK_MS.
test_new_oracle_fail_delay_exceeds_limit: Asserts failure (ELONG_DELAY) when twap_start_delay is greater than ONE_WEEK_MS.
test_new_oracle_fail_delay_not_multiple_of_window: Asserts failure (E_NONE_FULL_WIDOW_TWAP_DELAY) when twap_start_delay is not a multiple of TWAP_PRICE_CAP_WINDOW.
Function: one_step_cap_price_change (Helper)
test_cap_price_up_within_step: New price is higher but change is less than twap_cap_step; returns new_price.
test_cap_price_up_at_step: New price is higher and change equals twap_cap_step; returns twap_base + twap_cap_step.
test_cap_price_up_exceeds_step: New price is higher and change exceeds twap_cap_step; returns twap_base + twap_cap_step.
test_cap_price_up_saturating_add_overflow: twap_base + twap_cap_step saturates at u128::max_value().
test_cap_price_down_within_step: New price is lower but change is less than twap_cap_step; returns new_price.
test_cap_price_down_at_step: New price is lower and change equals twap_cap_step; returns twap_base - twap_cap_step.
test_cap_price_down_exceeds_step: New price is lower and change exceeds twap_cap_step; returns twap_base - twap_cap_step.
test_cap_price_down_saturating_sub_underflow: twap_base - twap_cap_step saturates at 0.
test_cap_price_no_change: new_price equals twap_base; returns twap_base.
test_cap_price_twap_base_zero_up: twap_base is 0, new_price increases; capped by twap_cap_step.
test_cap_price_twap_base_zero_down: twap_base is 0, new_price is 0 (or negative if allowed, but u128); returns 0.
test_cap_price_new_price_zero_from_positive: new_price is 0, twap_base is positive; capped by twap_base - twap_cap_step.
test_cap_price_cap_step_zero_price_increase: twap_cap_step is 0, new_price > twap_base; returns twap_base.
test_cap_price_cap_step_zero_price_decrease: twap_cap_step is 0, new_price < twap_base; returns twap_base.
test_cap_price_large_cap_step_no_effective_cap_up: twap_cap_step is very large, price increase is not capped; returns new_price.
test_cap_price_large_cap_step_no_effective_cap_down: twap_cap_step is very large, price decrease is not capped; returns new_price.
Function: write_observation
test_write_obs_fail_timestamp_regression: Asserts failure (ETIMESTAMP_REGRESSION) if input timestamp is less than oracle.last_timestamp.
test_write_obs_case0_no_time_passed: timestamp == oracle.last_timestamp; verifies no state change, twap_accumulate not effectively called.
test_write_obs_case1_first_obs_before_delay: First observation, last_timestamp (market start) and timestamp are both before delay_threshold.
test_write_obs_case1_subsequent_obs_before_delay: Multiple observations, all timestamps remain before delay_threshold.
test_write_obs_case2_cross_delay_last_ts_before_to_ts_at_delay: oracle.last_timestamp < delay_threshold, timestamp == delay_threshold. Verifies Part A accumulation, Part B reset.
test_write_obs_case2_cross_delay_last_ts_before_to_ts_after_delay: oracle.last_timestamp < delay_threshold, timestamp > delay_threshold. Verifies Part A, B, and C accumulations.
test_write_obs_case2_cross_delay_last_ts_at_delay_to_ts_after_delay: oracle.last_timestamp == delay_threshold, timestamp > delay_threshold. Verifies Part B (effectively) and C accumulation.
test_write_obs_case2_single_obs_from_market_start_to_far_after_delay: A single write_observation from market_start_time to a timestamp significantly beyond delay_threshold.
test_write_obs_case3_first_obs_at_delay_threshold_post_reset: First observation after delay period, oracle.last_timestamp is now delay_threshold, input timestamp is also delay_threshold (but handled by case 0 or effectively meaning twap_accumulate with 0 duration).
test_write_obs_case3_first_obs_after_delay_threshold_post_reset: First observation where oracle.last_timestamp (now delay_threshold) < timestamp, and timestamp is after delay_threshold.
test_write_obs_case3_subsequent_obs_after_delay: Multiple observations, all timestamps are after delay_threshold has been crossed and accumulators reset.
test_write_obs_delay_threshold_equals_market_start: twap_start_delay is 0; observations immediately go to Case 3 logic (after reset at market_start_time).
Function: twap_accumulate
test_accumulate_fail_timestamp_regression_direct: Asserts failure (ETIMESTAMP_REGRESSION) if timestamp < oracle.last_timestamp.
test_accumulate_fail_inconsistent_state_last_ts_lt_window_end: Asserts failure (ETIMESTAMP_REGRESSION) if oracle.last_timestamp < oracle.last_window_end (pre-condition).
test_accumulate_fail_internal_error_final_timestamp_mismatch: Asserts failure (EINTERNAL_TWAP_ERROR) if oracle.last_timestamp != timestamp at function end (requires manipulating mock execution to test).
test_accumulate_zero_duration_no_change: timestamp == oracle.last_timestamp; verifies no accumulation stages run, oracle state (esp. cumulative prices) unchanged.
test_accumulate_stage1_only_intra_window_no_boundary_cross: Time delta < TWAP_PRICE_CAP_WINDOW, last_timestamp not near boundary, observation ends within same window.
test_accumulate_stage1_only_completes_window_exactly: Time delta makes oracle.last_timestamp + duration_stage1 land exactly on oracle.last_window_end + TWAP_PRICE_CAP_WINDOW.
test_accumulate_stage2_only_single_full_window_from_boundary: oracle.last_timestamp is at a window boundary, time delta is exactly TWAP_PRICE_CAP_WINDOW.
test_accumulate_stage2_only_multiple_full_windows_from_boundary: oracle.last_timestamp at window boundary, time delta is N * TWAP_PRICE_CAP_WINDOW.
test_accumulate_stage1_partial_then_stage2_full_ends_on_boundary: Observation starts mid-window, crosses into and completes one or more full windows, ending on a window boundary.
test_accumulate_stage1_partial_then_stage2_full_then_stage3_partial: Most general case: starts mid-window, covers N full windows, ends mid-window.
test_accumulate_stage2_full_then_stage3_partial_from_boundary: Starts at window boundary, covers N full windows, then a final partial window.
test_accumulate_stage1_to_boundary_then_stage3_partial_within_next_window: Observation starts mid-window, completes it (Stage 1), then Stage 3 processes a short duration into the next window but not a full window. (This implies Stage 2 num_full_windows was 0).
test_accumulate_very_long_duration_many_full_windows: timestamp - oracle.last_timestamp is very large, ensuring multi_full_window_accumulation handles many windows.
Function: intra_window_accumulation
test_intra_accum_positive_time_no_boundary: additional_time_to_include > 0, timestamp doesn't complete a window; verifies total_cumulative_price, last_timestamp, last_price update.
test_intra_accum_completes_window_boundary: additional_time_to_include makes timestamp - oracle.last_window_end == TWAP_PRICE_CAP_WINDOW; verifies all fields update including last_window_twap.
test_intra_accum_price_capped_up: Input price is high, capped_price reflects upward cap.
test_intra_accum_price_capped_down: Input price is low, capped_price reflects downward cap.
test_intra_accum_price_not_capped: Input price is within cap limits, capped_price == price.
test_intra_accum_zero_additional_time: additional_time_to_include is 0; total_cumulative_price unchanged. last_timestamp updates, boundary logic might trigger if timestamp lands on it.
test_intra_accum_large_price_contribution_u256: capped_price * additional_time_to_include is large, fits in u256 for total_cumulative_price.
test_intra_accum_twap_calc_result_truncation: Calculated TWAP for window (sum_diff / window_size) (u256/u256) results in fraction, check u128 truncation.
test_intra_accum_twap_calc_result_exceeds_u128_max: Calculated TWAP for window (as u256) > u128::max_value(); verify u128 result is u128::max_value().
Function: multi_full_window_accumulation
Setup Note: These tests require oracle.last_window_twap to be set.
test_multi_price_equals_base_twap: price == oracle.last_window_twap. g_abs=0, s_dev_mag=0, p_n_w_effective and new last_window_twap are oracle.last_window_twap.
test_multi_price_increases_ramp_absorbs_all: price > B, N_W >= k_cap_idx. p_n_w_effective should become price.
test_multi_price_increases_ramp_limited_by_nw: price > B, N_W < k_cap_idx. p_n_w_effective is B + N_W * cap_step.
test_multi_price_decreases_ramp_absorbs_all: price < B, N_W >= k_cap_idx. p_n_w_effective should become price.
test_multi_price_decreases_ramp_limited_by_nw: price < B, N_W < k_cap_idx. p_n_w_effective is B - N_W * cap_step.
test_multi_k_cap_idx_u128_exceeds_u64_max: (g_abs - 1) / cap_step_u128 + 1 > u64::max_value(); k_cap_idx becomes u64::max_value().
test_multi_n_ramp_terms_zero_due_to_k_ramp_limit_zero: g_abs is small or zero, k_cap_idx <= 1, so k_ramp_limit = 0, n_ramp_terms = 0.
test_multi_v_ramp_overflow: (cap_step_u128) * sum_indices_part overflows u128; asserts EOVERFLOW_V_RAMP.
test_multi_v_ramp_n_ramp_terms_even_and_odd: Covers both parity cases for n_ramp_terms in sum_indices_part calculation.
test_multi_v_flat_overflow: g_abs * num_flat_terms_u128 overflows u128; asserts EOVERFLOW_V_FLAT.
test_multi_v_flat_num_flat_terms_zero: num_flat_terms is 0 (e.g. N_W <= k_ramp_limit); v_flat is 0.
test_multi_s_dev_mag_overflow: v_ramp + v_flat overflows u128; asserts EOVERFLOW_S_DEV_MAG.
test_multi_base_price_sum_overflow: oracle.last_window_twap * num_new_windows_u128 overflows u128; asserts EOVERFLOW_BASE_PRICE_SUM_FINAL.
test_multi_v_sum_prices_add_overflow: price >= B, base_price_sum + s_dev_mag overflows u128; asserts EOVERFLOW_V_SUM_PRICES_ADD.
test_multi_v_sum_prices_sub_no_underflow_below_zero: price < B, base_price_sum - s_dev_mag is calculated (should be non-negative by design).
test_multi_pnw_nw_times_delta_m_calculation_overflow: (num_new_windows * cap_step) overflows u128, nw_times_delta_m becomes u128::max_value().
test_multi_pnw_saturating_add_hits_u128_max: B + deviation_for_p_n_w saturates at u128::max_value().
test_multi_pnw_saturating_sub_hits_zero: B - deviation_for_p_n_w saturates at 0.
test_multi_one_new_window: num_new_windows is 1; verify logic for this specific case.
test_multi_large_num_new_windows_with_price_far_from_base: num_new_windows is large, price is very different from B; tests ramp and flat sections comprehensively.
test_multi_state_updates_all_fields_correct: Verifies last_timestamp, last_window_end, last_window_end_cumulative_price, total_cumulative_price, last_price, last_window_twap are all correctly updated.
test_multi_cumulative_price_contribution_u256: (v_sum_prices as u256) * (TWAP_PRICE_CAP_WINDOW as u256) uses u256 correctly for large values.
Function: get_twap
test_get_twap_success_valid_state: Oracle state is valid, time is appropriate; TWAP calculated correctly.
test_get_twap_fail_stale_read: current_time != oracle.last_timestamp; asserts ESTALE_TWAP.
test_get_twap_fail_last_ts_zero: oracle.last_timestamp == 0 (if possible to set up); asserts ETIMESTAMP_REGRESSION.
test_get_twap_fail_not_started_before_delay_ends: current_time - market_start_time < twap_start_delay; asserts ETWAP_NOT_STARTED.
test_get_twap_fail_current_time_before_market_start: current_time < oracle.market_start_time; asserts ETIMESTAMP_REGRESSION.
test_get_twap_fail_zero_period: period (i.e., current_time - market_start_time - twap_start_delay) is 0; asserts EZERO_PERIOD.
test_get_twap_immediately_after_delay_period_valid: current_time is slightly past market_start_time + twap_start_delay, period is small but > 0.
test_get_twap_large_cumulative_price_and_period: Both numerator and denominator are large; tests u256 division.
test_get_twap_result_truncation_to_u128: total_cumulative_price / period (u256) results in a fraction; verify u128 cast truncates.
test_get_twap_result_exceeds_u128_max: TWAP calculated as u256 is > u128::max_value(); verify u128 cast results in u128::max_value().
test_get_twap_after_accumulator_reset: write_observation crossed delay_threshold, total_cumulative_price was reset. get_twap should use this new total_cumulative_price and the period since reset (implicitly handled by period calculation relative to delay_threshold).
