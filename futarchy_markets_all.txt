/// ============================================================================
/// SIMPLE TWAP - UNISWAP V2 STYLE TIME-WEIGHTED AVERAGE PRICE
/// ============================================================================
///
/// PURPOSE: External price oracle for lending protocols and integrations
///
/// KEY FEATURES:
/// - Rolling 90-day window for time-weighted average (longer = safer)
/// - Pure arithmetic mean (no price capping needed)
/// - Uniswap V2 proven design with extended window
/// - Manipulation cost scales with window size (90 days = extremely expensive)
///
/// USED BY:
/// - External lending protocols (Compound, Aave style)
/// - Price aggregators
/// - Any protocol needing standard TWAP
///
/// NOT USED FOR:
/// - Governance decisions (use futarchy oracle)
/// - Determining proposal winners (use futarchy oracle)
///
/// DESIGN:
/// - Accumulates price × time over rolling 90-day window
/// - NO price capping (like Uniswap V2)
/// - Returns TWAP = cumulative / window_duration
/// - Long window makes manipulation economically infeasible
///
/// ============================================================================

module futarchy_markets::simple_twap;

use futarchy_one_shot_utils::math;
use sui::clock::Clock;
use sui::event;

// ============================================================================
// Constants
// ============================================================================

const NINETY_DAYS_MS: u64 = 7_776_000_000; // 90 days in milliseconds
const PRICE_SCALE: u128 = 1_000_000_000_000; // 10^12 for precision
const PPM_DENOMINATOR: u64 = 1_000_000; // Parts per million

// Errors
const ENotInitialized: u64 = 1;
const EInvalidCapPpm: u64 = 2;
const ETwapNotReady: u64 = 3;
const EBackfillMismatch: u64 = 5;
const EInvalidPeriod: u64 = 6;
const EOverflow: u64 = 7;
const EPriceDeviationTooLarge: u64 = 8;
const ECumulativeOverflow: u64 = 9;

// Safety limits
const MAX_PRICE_DEVIATION_RATIO: u64 = 100; // 100x max price change allowed

// ============================================================================
// Events
// ============================================================================

public struct TWAPUpdated has copy, drop {
    old_price: u128,
    new_price: u128,
    raw_price: u128,
    capped: bool,
    timestamp: u64,
    time_elapsed_ms: u64,
}

public struct WindowSlided has copy, drop {
    old_start: u64,
    new_start: u64,
    removed_duration_ms: u64,
}

public struct BackfillApplied has copy, drop {
    period_start: u64,
    period_end: u64,
    period_cumulative: u256,
    period_final_price: u128,
}

// ============================================================================
// Structs
// ============================================================================

/// Simple TWAP oracle - Uniswap V2 style (pure arithmetic mean)
public struct SimpleTWAP has store {
    // TWAP state
    initialized_at: u64,           // When oracle was initialized
    last_price: u128,              // Last recorded price
    last_timestamp: u64,           // Last update timestamp

    // Rolling window (90 days) - for simple consumers
    window_start_timestamp: u64,   // Start of current 90-day window
    window_cumulative_price: u256, // Cumulative price × time in current window

    // Infinite accumulation (Uniswap V2) - for advanced consumers
    total_cumulative_price: u256,  // Total cumulative since initialization (never resets)
}

// ============================================================================
// Core Functions
// ============================================================================

/// Create new SimpleTWAP oracle - Uniswap V2 style (no capping)
///
/// # Arguments
/// * `initial_price` - Starting price (e.g., stable_reserve / asset_reserve × PRICE_SCALE)
/// * `clock` - Sui clock for timestamp
///
/// # Design
/// - Simple consumers use get_twap() for 90-day TWAP
/// - Advanced consumers use get_cumulative_and_timestamp() for custom windows (Uniswap V2)
public fun new(
    initial_price: u128,
    clock: &Clock,
): SimpleTWAP {
    let now = clock.timestamp_ms();

    SimpleTWAP {
        initialized_at: now,
        last_price: initial_price,
        last_timestamp: now,
        window_start_timestamp: now,
        window_cumulative_price: 0,
        total_cumulative_price: 0,  // Infinite accumulation starts at 0
    }
}

/// Update oracle with new price - Uniswap V2 style (no capping)
public fun update(
    oracle: &mut SimpleTWAP,
    new_price: u128,
    clock: &Clock,
) {
    let now = clock.timestamp_ms();

    // Skip if no time passed
    if (now == oracle.last_timestamp) return;

    let time_elapsed = now - oracle.last_timestamp;

    // Accumulate price × time for elapsed period
    let price_time = (oracle.last_price as u256) * (time_elapsed as u256);

    // Update rolling window (90-day)
    oracle.window_cumulative_price = oracle.window_cumulative_price + price_time;

    // Update infinite cumulative (Uniswap V2 - never resets)
    oracle.total_cumulative_price = oracle.total_cumulative_price + price_time;

    // Update rolling window
    update_rolling_window(oracle, now);

    // Emit event
    event::emit(TWAPUpdated {
        old_price: oracle.last_price,
        new_price,
        raw_price: new_price,
        capped: false,  // Never capped (Uniswap V2 style)
        timestamp: now,
        time_elapsed_ms: time_elapsed,
    });

    // Update state
    oracle.last_price = new_price;
    oracle.last_timestamp = now;
}

/// Get current TWAP over 90-day window with overflow protection
public fun get_twap(oracle: &SimpleTWAP, clock: &Clock): u128 {
    let now = clock.timestamp_ms();

    // Require at least 90 days of history
    assert!(now >= oracle.initialized_at + NINETY_DAYS_MS, ETwapNotReady);

    // Project cumulative to now
    let time_since_last = now - oracle.last_timestamp;
    let projected_cumulative = oracle.window_cumulative_price +
        ((oracle.last_price as u256) * (time_since_last as u256));

    // Calculate window duration
    let window_age = now - oracle.window_start_timestamp;
    let effective_duration = if (window_age > NINETY_DAYS_MS) {
        NINETY_DAYS_MS
    } else {
        window_age
    };

    if (effective_duration > 0) {
        let twap_u256 = projected_cumulative / (effective_duration as u256);
        // Protect against u128 overflow
        assert!(twap_u256 <= (std::u128::max_value!() as u256), EOverflow);
        (twap_u256 as u128)
    } else {
        oracle.last_price
    }
}

/// Get current spot price (last recorded price)
public fun get_spot_price(oracle: &SimpleTWAP): u128 {
    oracle.last_price
}

/// Check if TWAP is ready (has 90+ days of history)
public fun is_ready(oracle: &SimpleTWAP, clock: &Clock): bool {
    let now = clock.timestamp_ms();
    now >= oracle.initialized_at + NINETY_DAYS_MS
}

// ============================================================================
// Helper Functions
// ============================================================================

/// Update rolling 90-day window - Uniswap V2 style (simple estimation)
fun update_rolling_window(oracle: &mut SimpleTWAP, now: u64) {
    let window_age = now - oracle.window_start_timestamp;

    if (window_age > NINETY_DAYS_MS) {
        let old_start = oracle.window_start_timestamp;

        // Slide window forward
        let new_window_start = now - NINETY_DAYS_MS;
        let time_to_remove = new_window_start - oracle.window_start_timestamp;

        // Estimate old price using current price (Uniswap V2 approach)
        // This is an approximation but becomes accurate as window ages
        let current_twap = if (window_age > 0) {
            ((oracle.window_cumulative_price / (window_age as u256)) as u128)
        } else {
            oracle.last_price
        };

        let price_to_remove = (current_twap as u256) * (time_to_remove as u256);

        // Remove old data from accumulator
        if (oracle.window_cumulative_price > price_to_remove) {
            oracle.window_cumulative_price = oracle.window_cumulative_price - price_to_remove;
        } else {
            // Fallback: reset to current price × 90 days
            oracle.window_cumulative_price = (oracle.last_price as u256) * (NINETY_DAYS_MS as u256);
        };

        oracle.window_start_timestamp = new_window_start;

        // Emit event
        event::emit(WindowSlided {
            old_start,
            new_start: new_window_start,
            removed_duration_ms: time_to_remove,
        });
    };
}

// ============================================================================
// Safety Helper Functions
// ============================================================================

/// Validate price is within reasonable bounds (prevents price oracle poisoning)
/// Checks that new_price is within MAX_PRICE_DEVIATION_RATIO of old_price
fun validate_price_deviation(old_price: u128, new_price: u128) {
    // Allow any price if old price is zero (initialization case)
    if (old_price == 0) return;

    // Calculate max and min allowed prices
    let max_allowed = (old_price as u256) * (MAX_PRICE_DEVIATION_RATIO as u256);
    let min_allowed = (old_price as u256) / (MAX_PRICE_DEVIATION_RATIO as u256);

    assert!(
        (new_price as u256) <= max_allowed && (new_price as u256) >= min_allowed,
        EPriceDeviationTooLarge
    );
}

/// Safely add to cumulative with overflow check
fun safe_add_to_cumulative(cumulative: u256, addition: u256): u256 {
    // Check for overflow before adding
    let max_u256 = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;
    assert!(cumulative <= max_u256 - addition, ECumulativeOverflow);
    cumulative + addition
}

/// Safely multiply u256 values with overflow check
public fun safe_mul_u256(a: u256, b: u256): u256 {
    if (a == 0 || b == 0) return 0;

    let max_u256 = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;
    assert!(a <= max_u256 / b, EOverflow);
    a * b
}

// ============================================================================
// Getter Functions
// ============================================================================

public fun last_price(oracle: &SimpleTWAP): u128 {
    oracle.last_price
}

public fun last_timestamp(oracle: &SimpleTWAP): u64 {
    oracle.last_timestamp
}

public fun initialized_at(oracle: &SimpleTWAP): u64 {
    oracle.initialized_at
}

public fun window_start(oracle: &SimpleTWAP): u64 {
    oracle.window_start_timestamp
}

/// Get window cumulative price (for combining with conditional TWAP)
public fun window_cumulative_price(oracle: &SimpleTWAP): u256 {
    oracle.window_cumulative_price
}

/// Get window start timestamp (for combining with conditional TWAP)
public fun window_start_timestamp(oracle: &SimpleTWAP): u64 {
    oracle.window_start_timestamp
}

/// Get cumulative and timestamp for Uniswap V2 style custom TWAP calculations
///
/// # Usage (Advanced Consumers - Lending Protocols)
/// ```
/// // Step 1: Store snapshot at desired window start
/// let (snapshot_cumulative, snapshot_timestamp) = get_cumulative_and_timestamp(oracle);
/// // Consumer stores these in their contract
///
/// // Step 2: Later, read current values
/// let (current_cumulative, current_timestamp) = get_cumulative_and_timestamp(oracle);
///
/// // Step 3: Calculate custom TWAP
/// let time_elapsed = current_timestamp - snapshot_timestamp;
/// let cumulative_delta = current_cumulative - snapshot_cumulative;
/// let custom_twap = cumulative_delta / time_elapsed;
/// ```
///
/// # Returns
/// * `cumulative_price` - Total cumulative price × time since initialization
/// * `timestamp` - Last update timestamp in milliseconds
///
/// # Examples
/// - 30-min TWAP: Store snapshot 30 min ago, read now
/// - 1-hour TWAP: Store snapshot 1 hour ago, read now
/// - 24-hour TWAP: Store snapshot 24 hours ago, read now
public fun get_cumulative_and_timestamp(oracle: &SimpleTWAP): (u256, u64) {
    (oracle.total_cumulative_price, oracle.last_timestamp)
}

/// Calculate projected cumulative to a specific timestamp
/// Used for combining spot + conditional TWAPs
public fun projected_cumulative_to(oracle: &SimpleTWAP, target_timestamp: u64): u256 {
    let time_since_last = target_timestamp - oracle.last_timestamp;
    oracle.window_cumulative_price + ((oracle.last_price as u256) * (time_since_last as u256))
}

/// Backfill cumulative data from conditional oracle after proposal ends
/// This "fills the gap" in spot's oracle with winning conditional's data
///
/// # Arguments
/// * `period_start` - When the proposal started (when spot froze)
/// * `period_end` - When the proposal ended
/// * `period_cumulative` - Conditional's cumulative price × time for this period
/// * `period_final_price` - Conditional's final price at proposal end
///
/// # Safety
/// * Validates period aligns with oracle's last timestamp (prevents duplicate backfills)
/// * Validates period_end > period_start
/// * Emits event for observability
public fun backfill_from_conditional(
    oracle: &mut SimpleTWAP,
    period_start: u64,
    period_end: u64,
    period_cumulative: u256,
    period_final_price: u128,
) {
    // CRITICAL: Validate period aligns with oracle state to prevent duplicate backfills
    assert!(period_start == oracle.last_timestamp, EBackfillMismatch);
    assert!(period_end > period_start, EInvalidPeriod);

    // SAFETY: Validate price deviation to prevent oracle poisoning
    validate_price_deviation(oracle.last_price, period_final_price);

    // SAFETY: Add conditional's cumulative to spot's rolling window with overflow protection
    oracle.window_cumulative_price = safe_add_to_cumulative(
        oracle.window_cumulative_price,
        period_cumulative
    );

    // SAFETY: Add to infinite cumulative (for Uniswap V2 style consumers) with overflow protection
    oracle.total_cumulative_price = safe_add_to_cumulative(
        oracle.total_cumulative_price,
        period_cumulative
    );

    // Update state to resume from conditional's final state
    oracle.last_price = period_final_price;
    oracle.last_timestamp = period_end;

    // Recalculate window TWAP with backfilled data
    let window_age = period_end - oracle.window_start_timestamp;
    let window_duration = if (window_age > NINETY_DAYS_MS) {
        NINETY_DAYS_MS
    } else {
        window_age
    };

    if (window_duration > 0) {
        // Note: We removed last_window_twap field, so this calculation is no longer needed
        // The get_twap() function calculates TWAP on the fly from window_cumulative_price
    };

    // Emit event
    event::emit(BackfillApplied {
        period_start,
        period_end,
        period_cumulative,
        period_final_price,
    });
}

// ============================================================================
// Test Functions
// ============================================================================

#[test_only]
public fun destroy_for_testing(oracle: SimpleTWAP) {
    let SimpleTWAP {
        initialized_at: _,
        last_price: _,
        last_timestamp: _,
        window_start_timestamp: _,
        window_cumulative_price: _,
        total_cumulative_price: _,
    } = oracle;
}
/// Common validation logic for conditional token coin metadata and treasury caps
/// Used by both coin_registry and proposal modules to enforce invariants
module futarchy_markets::coin_validation;

use sui::coin::{TreasuryCap, CoinMetadata};
use std::string;
use std::ascii;

// === Errors ===
const ESupplyNotZero: u64 = 0;
const EMetadataMismatch: u64 = 1;
const ETreasuryCapMismatch: u64 = 2;
const ENameNotEmpty: u64 = 3;
const EDescriptionNotEmpty: u64 = 4;
const ESymbolNotEmpty: u64 = 5;
const EIconUrlNotEmpty: u64 = 6;

// === Public Validation Functions ===

/// Validates that a coin's total supply is zero
public fun assert_zero_supply<T>(treasury_cap: &TreasuryCap<T>) {
    assert!(treasury_cap.total_supply() == 0, ESupplyNotZero);
}

/// Validates that metadata and treasury cap match the same coin type
public fun assert_caps_match<T>(
    treasury_cap: &TreasuryCap<T>,
    metadata: &CoinMetadata<T>,
) {
    // Type safety ensures they match at compile time
    // This function exists for explicit validation calls
    let _ = treasury_cap;
    let _ = metadata;
}

/// Validates that coin name is empty (will be set by proposal)
public fun assert_empty_name<T>(metadata: &CoinMetadata<T>) {
    let name = metadata.get_name();
    let name_bytes = string::bytes(&name);
    // Name must be empty - proposal will set it
    assert!(name_bytes.is_empty(), ENameNotEmpty);
}

/// Validates that metadata fields are empty/minimal
public fun assert_empty_metadata<T>(metadata: &CoinMetadata<T>) {
    // Description should be empty
    let description = metadata.get_description();
    assert!(string::bytes(&description).is_empty(), EDescriptionNotEmpty);

    // Symbol should be empty
    let symbol = metadata.get_symbol();
    assert!(ascii::as_bytes(&symbol).is_empty(), ESymbolNotEmpty);

    // Icon URL should be empty
    let icon_url = metadata.get_icon_url();
    assert!(icon_url.is_none(), EIconUrlNotEmpty);
}

/// Complete validation - checks all requirements
public fun validate_conditional_coin<T>(
    treasury_cap: &TreasuryCap<T>,
    metadata: &CoinMetadata<T>,
) {
    assert_zero_supply(treasury_cap);
    assert_caps_match(treasury_cap, metadata);
    assert_empty_name(metadata);
    assert_empty_metadata(metadata);
}

// === View Functions ===

/// Check if supply is zero without aborting
public fun is_supply_zero<T>(treasury_cap: &TreasuryCap<T>): bool {
    treasury_cap.total_supply() == 0
}

/// Check if name is empty without aborting
public fun is_name_empty<T>(metadata: &CoinMetadata<T>): bool {
    let name = metadata.get_name();
    let name_bytes = string::bytes(&name);
    name_bytes.is_empty()
}

/// Check if metadata is empty without aborting
public fun is_metadata_empty<T>(metadata: &CoinMetadata<T>): bool {
    let description = metadata.get_description();
    let symbol = metadata.get_symbol();
    let icon_url = metadata.get_icon_url();

    string::bytes(&description).is_empty() &&
    ascii::as_bytes(&symbol).is_empty() &&
    icon_url.is_none()
}
/// Early resolution system for futarchy proposals
///
/// This module handles flip tracking and eligibility checks for proposals
/// that can be resolved early when market consensus is clear and stable.
///
/// ## Architecture
/// - Metrics stored in Proposal struct (proposal.move owns storage)
/// - Logic centralized here (single responsibility principle)
/// - Called from swap::finalize_swap_session for flip detection
///
/// ## Flip Detection
/// Uses instant prices (not TWAP) for fast flip detection during trading.
/// TWAP is used for final resolution to prevent manipulation.
module futarchy_markets::early_resolve;

use futarchy_markets::proposal::{Self, Proposal};
use futarchy_markets::conditional_amm;
use futarchy_markets::market_state::{Self, MarketState};
use futarchy_core::futarchy_config::{Self, EarlyResolveConfig};
use std::string::{Self, String};
use sui::clock::Clock;
use sui::event;
use sui::object::ID;

// === Errors ===
const EInvalidOutcome: u64 = 0;

// === Structs ===

// Note: EarlyResolveMetrics is defined in proposal.move to avoid circular dependencies.
// This module provides logic to manipulate the metrics, but the struct lives where it's stored.

// === Events ===

public struct WinnerFlipped has copy, drop {
    proposal_id: ID,
    old_winner: u64,
    new_winner: u64,
    spread: u128,
    winning_price: u128,  // Actually instant price, not TWAP
    timestamp: u64,
}

public struct MetricsUpdated has copy, drop {
    proposal_id: ID,
    current_winner: u64,
    flip_count: u64,
    total_trades: u64,
    total_fees: u64,
    eligible_for_early_resolve: bool,
    timestamp: u64,
}

public struct ProposalEarlyResolved has copy, drop {
    proposal_id: ID,
    winning_outcome: u64,
    proposal_age_ms: u64,
    flips_in_window: u64,
    keeper: address,
    keeper_reward: u64,
    timestamp: u64,
}

// === Public Functions ===

/// Initialize early resolution metrics for a proposal
/// Called when proposal enters TRADING state
/// Delegates to proposal module to construct the struct
public fun new_metrics(
    initial_winner: u64,
    current_time_ms: u64,
): proposal::EarlyResolveMetrics {
    proposal::new_early_resolve_metrics(initial_winner, current_time_ms)
}

/// Update early resolve metrics (keeper-triggered or swap-triggered)
/// Tracks winner changes - simple design with no exponential decay
/// Does nothing if early resolution is not enabled for this proposal
///
/// This is called from swap::finalize_swap_session() to ensure flip
/// detection happens exactly once per transaction AFTER all swaps complete.
///
/// NOTE: This now works with MarketState directly for pool access,
/// but still needs Proposal for metrics storage (until we refactor that too)
public fun update_metrics<AssetType, StableType>(
    proposal: &mut Proposal<AssetType, StableType>,
    market_state: &mut futarchy_markets::market_state::MarketState,
    clock: &Clock,
) {
    // If early resolution not enabled, do nothing
    if (!proposal::has_early_resolve_metrics(proposal)) {
        return
    };

    let current_time_ms = clock.timestamp_ms();
    let proposal_id = proposal::get_id(proposal);

    // Calculate current winner from MarketState pools (no Proposal dependency!)
    let (winner_idx, winner_price, spread) = calculate_current_winner_by_price(market_state);

    // Now borrow metrics mutably from proposal
    let metrics = proposal::borrow_early_resolve_metrics_mut(proposal);

    // Check if winner has flipped
    let current_winner_idx = proposal::metrics_current_winner(metrics);
    let has_flipped = winner_idx != current_winner_idx;

    if (has_flipped) {
        let old_winner = current_winner_idx;

        // Winner changed - update tracking
        proposal::metrics_set_current_winner(metrics, winner_idx);
        proposal::metrics_set_last_flip_time_ms(metrics, current_time_ms);

        // Emit WinnerFlipped event
        event::emit(WinnerFlipped {
            proposal_id,
            old_winner,
            new_winner: winner_idx,
            spread,
            winning_price: winner_price,
            timestamp: current_time_ms,
        });
    };

    // Emit MetricsUpdated event (simplified - no flip count or revenue tracking)
    event::emit(MetricsUpdated {
        proposal_id,
        current_winner: proposal::metrics_current_winner(metrics),
        flip_count: 0,  // Removed exponential decay tracking
        total_trades: 0,  // Removed trade tracking
        total_fees: 0,  // Removed revenue tracking
        eligible_for_early_resolve: false,  // Computed in check_eligibility
        timestamp: current_time_ms,
    });
}

/// Check if proposal is eligible for early resolution
/// Returns (is_eligible, reason_if_not)
/// Simplified design: just check time bounds and stability
public fun check_eligibility<AssetType, StableType>(
    proposal: &Proposal<AssetType, StableType>,
    config: &EarlyResolveConfig,
    clock: &Clock,
): (bool, String) {
    // Check if early resolution is enabled (min < max)
    if (!futarchy_config::early_resolve_enabled(config)) {
        return (false, string::utf8(b"Early resolution not enabled"))
    };

    // Check if proposal has metrics initialized
    if (!proposal::has_early_resolve_metrics(proposal)) {
        return (false, string::utf8(b"Early resolve metrics not initialized"))
    };

    let metrics = proposal::borrow_early_resolve_metrics(proposal);
    let current_time_ms = clock.timestamp_ms();

    // Get proposal start time (use market_initialized_at if available, else created_at)
    let start_time = proposal::get_start_time_for_early_resolve(proposal);
    let proposal_age_ms = current_time_ms - start_time;

    // Check minimum proposal duration
    let min_duration = futarchy_config::early_resolve_min_duration(config);
    if (proposal_age_ms < min_duration) {
        return (false, string::utf8(b"Proposal too young for early resolution"))
    };

    // Check maximum proposal duration (should resolve by now)
    let max_duration = futarchy_config::early_resolve_max_duration(config);
    if (proposal_age_ms > max_duration) {
        return (false, string::utf8(b"Proposal exceeded max duration"))
    };

    // Check time since last flip (simple stability check)
    let last_flip_time = proposal::metrics_last_flip_time_ms(metrics);
    let time_since_last_flip_ms = current_time_ms - last_flip_time;
    let min_time_since_flip = futarchy_config::early_resolve_min_time_since_flip(config);
    if (time_since_last_flip_ms < min_time_since_flip) {
        return (false, string::utf8(b"Winner changed too recently"))
    };

    // Note: Spread check happens in try_early_resolve (requires &mut for TWAP calculation)

    // All checks passed
    (true, string::utf8(b"Eligible for early resolution"))
}

/// Get time until proposal is eligible for early resolution (in milliseconds)
/// Returns 0 if already eligible or if early resolution not enabled
public fun time_until_eligible<AssetType, StableType>(
    proposal: &Proposal<AssetType, StableType>,
    config: &EarlyResolveConfig,
    clock: &Clock,
): u64 {
    // If not enabled or no metrics, return 0
    if (!futarchy_config::early_resolve_enabled(config) || !proposal::has_early_resolve_metrics(proposal)) {
        return 0
    };

    let metrics = proposal::borrow_early_resolve_metrics(proposal);
    let current_time_ms = clock.timestamp_ms();

    // Get proposal start time
    let start_time = proposal::get_start_time_for_early_resolve(proposal);
    let proposal_age_ms = current_time_ms - start_time;

    // Check minimum duration requirement
    let min_duration = futarchy_config::early_resolve_min_duration(config);
    if (proposal_age_ms < min_duration) {
        return min_duration - proposal_age_ms
    };

    // Check time since last flip requirement
    let last_flip_time = proposal::metrics_last_flip_time_ms(metrics);
    let time_since_last_flip_ms = current_time_ms - last_flip_time;
    let min_time_since_flip = futarchy_config::early_resolve_min_time_since_flip(config);
    if (time_since_last_flip_ms < min_time_since_flip) {
        return min_time_since_flip - time_since_last_flip_ms
    };

    // Already eligible (or other conditions not met - would need full check)
    0
}

// === Getter Functions ===

/// Get current winner index from metrics
public fun current_winner(metrics: &proposal::EarlyResolveMetrics): u64 {
    proposal::metrics_current_winner(metrics)
}

/// Get last flip timestamp from metrics
public fun last_flip_time_ms(metrics: &proposal::EarlyResolveMetrics): u64 {
    proposal::metrics_last_flip_time_ms(metrics)
}

// === Internal Helper Functions ===

/// Calculate current winner by INSTANT PRICE from MarketState pools
/// Returns (winner_index, winner_price, spread)
/// Used for flip detection - works directly with market infrastructure
fun calculate_current_winner_by_price(
    market_state: &mut MarketState,
): (u64, u128, u128) {
    let pools = market_state::borrow_amm_pools_mut(market_state);
    let outcome_count = pools.length();

    assert!(outcome_count >= 2, EInvalidOutcome);

    // Get instant prices from all pools
    let mut winner_idx = 0u64;
    let mut winner_price = conditional_amm::get_current_price(&pools[0]);
    let mut second_price = 0u128;

    let mut i = 1u64;
    while (i < outcome_count) {
        let current_price = conditional_amm::get_current_price(&pools[i]);

        if (current_price > winner_price) {
            // New winner found
            second_price = winner_price;
            winner_price = current_price;
            winner_idx = i;
        } else if (current_price > second_price) {
            // Update second place
            second_price = current_price;
        };

        i = i + 1;
    };

    // Calculate spread between winner and second place
    let spread = if (winner_price > second_price) {
        winner_price - second_price
    } else {
        0u128
    };

    (winner_idx, winner_price, spread)
}
module futarchy_markets::conditional_amm;

use futarchy_one_shot_utils::math;
use sui::object::ID;
use futarchy_markets::oracle::{Self, Oracle};
use futarchy_markets::simple_twap::{Self, SimpleTWAP};
use futarchy_one_shot_utils::constants;
use sui::clock::Clock;
use sui::event;
use std::u64;
use sui::tx_context::TxContext;  // Audit fix: missing import

// === Introduction ===
// This is a Uniswap V2-style XY=K AMM implementation for futarchy prediction markets.
// 
// === Live-Flow Model Architecture ===
// This AMM is part of the "live-flow" liquidity model which allows dynamic liquidity
// management even while proposals are active. Key features:
// 
// 1. **No Liquidity Locking**: Unlike traditional prediction markets, liquidity providers
//    can add or remove liquidity at any time, even during active proposals.
// 
// 2. **Conditional Token Pools**: Each AMM pool trades conditional tokens (not spot tokens)
//    for a specific outcome. This allows the spot pool to remain liquid.
// 
// 3. **Proportional Liquidity**: When LPs add/remove from the spot pool during active
//    proposals, liquidity is proportionally distributed/collected across all outcome AMMs.
// 
// 4. **LP Token Architecture**: Each AMM pool has its own LP token type, but in the live-flow
//    model, these are managed internally. LPs only receive spot pool LP tokens.
// 
// The flow works as follows:
// - Add liquidity: Spot tokens → Mint conditional tokens → Distribute to AMMs
// - Remove liquidity: Collect from AMMs → Redeem conditional tokens → Return spot tokens

// === Errors ===
const ELowLiquidity: u64 = 0; // Pool liquidity below minimum threshold
const EPoolEmpty: u64 = 1; // Attempting to swap/remove from empty pool
const EExcessiveSlippage: u64 = 2; // Output amount less than minimum specified
const EDivByZero: u64 = 3; // Division by zero in calculations
const EZeroLiquidity: u64 = 4; // Pool has zero liquidity
const EPriceTooHigh: u64 = 5; // Price exceeds maximum allowed value
const EZeroAmount: u64 = 6; // Input amount is zero
const EMarketIdMismatch: u64 = 7; // Market ID doesn't match expected value
const EInsufficientLPTokens: u64 = 8; // Not enough LP tokens to burn
const EInvalidTokenType: u64 = 9; // Wrong conditional token type provided
const EOverflow: u64 = 10; // Arithmetic overflow detected
const EInvalidFeeRate: u64 = 11; // Fee rate is invalid (e.g., >= 100%)
const EKInvariantViolation: u64 = 12; // K-invariant violation (guards constant-product invariant)

// === Constants ===
const FEE_SCALE: u64 = 10000;
const DEFAULT_FEE: u64 = 30; // 0.3%
const MINIMUM_LIQUIDITY: u128 = 1000;
// Other constants moved to constants module

// === Structs ===

public struct LiquidityPool has key, store {
    id: UID,
    market_id: ID,
    outcome_idx: u8,
    asset_reserve: u64,
    stable_reserve: u64,
    fee_percent: u64,
    oracle: Oracle,  // Futarchy oracle (for determining winner, internal use)
    simple_twap: SimpleTWAP,  // SimpleTWAP oracle (for external consumers)
    protocol_fees: u64, // Track accumulated stable fees
    lp_supply: u64, // Track total LP shares for this pool
}

// === Events ===
public struct SwapEvent has copy, drop {
    market_id: ID,
    outcome: u8,
    is_buy: bool,
    amount_in: u64,
    amount_out: u64,
    price_impact: u128,
    price: u128,
    sender: address,
    asset_reserve: u64,
    stable_reserve: u64,
    timestamp: u64,
}

public struct LiquidityAdded has copy, drop {
    market_id: ID,
    outcome: u8,
    asset_amount: u64,
    stable_amount: u64,
    lp_amount: u64,
    sender: address,
    timestamp: u64,
}

public struct LiquidityRemoved has copy, drop {
    market_id: ID,
    outcome: u8,
    asset_amount: u64,
    stable_amount: u64,
    lp_amount: u64,
    sender: address,
    timestamp: u64,
}

// === Public Functions ===
public fun new_pool(
    market_id: ID,
    outcome_idx: u8,
    fee_percent: u64,
    initial_asset: u64,
    initial_stable: u64,
    twap_initial_observation: u128,
    twap_start_delay: u64,
    twap_step_max: u64,
    clock: &Clock,
    ctx: &mut TxContext,
): LiquidityPool {
    assert!(initial_asset > 0 && initial_stable > 0, EZeroAmount);
    let k = math::mul_div_to_128(initial_asset, initial_stable, 1);
    assert!(k >= MINIMUM_LIQUIDITY, ELowLiquidity);
    assert!(fee_percent <= constants::max_amm_fee_bps(), EInvalidFeeRate);

    // Use twap_initial_observation for BOTH oracles to ensure consistency
    let initial_price = twap_initial_observation;

    check_price_under_max(initial_price);

    // Initialize futarchy oracle (for determining winner)
    let oracle = oracle::new_oracle(
        initial_price,
        twap_start_delay,
        twap_step_max,
        ctx,
    );

    // Initialize SimpleTWAP oracle (for external consumers)
    // Uniswap V2 style - no capping
    let simple_twap_oracle = simple_twap::new(
        initial_price,
        clock,
    );

    // Create pool object
    let pool = LiquidityPool {
        id: object::new(ctx),
        market_id,
        outcome_idx,
        asset_reserve: initial_asset,
        stable_reserve: initial_stable,
        fee_percent,
        oracle,
        simple_twap: simple_twap_oracle,
        protocol_fees: 0,
        lp_supply: 0, // Start at 0 so first provider logic works correctly
    };

    pool
}

// === Core Swap Functions ===
// Note: These functions take generic references to allow inline arbitrage
// without creating circular dependencies between spot_amm and conditional_amm

public fun swap_asset_to_stable(
    pool: &mut LiquidityPool,
    market_id: ID,
    amount_in: u64,
    min_amount_out: u64,
    clock: &Clock,
    ctx: &TxContext,
): u64 {
    assert!(pool.market_id == market_id, EMarketIdMismatch);
    assert!(amount_in > 0, EZeroAmount);

    // K-GUARD: Capture reserves before swap to validate constant-product invariant
    // WHY: LP fees stay in pool, so k must GROW. Catches fee accounting bugs.
    let k_before = (pool.asset_reserve as u128) * (pool.stable_reserve as u128);

    // When selling outcome tokens (asset -> stable):
    // 1. Calculate the gross output amount (amount_out_before_fee) based on current reserves and amount_in.
    // 2. Calculate the fee amount from this gross output.
    // 3. Split the fee: 80% for LPs (lp_share), 20% for the protocol (protocol_share).
    // 4. The `protocol_share` is moved to `pool.protocol_fees`.
    // 5. The `lp_share` is left in the pool's stable reserve to reward LPs, causing `k` to grow.
    // 6. The user receives the net output `amount_out = amount_out_before_fee - total_fee`.
    let amount_out_before_fee = calculate_output(
        amount_in,
        pool.asset_reserve,
        pool.stable_reserve,
    );

    // Calculate fee from stable output
    let total_fee = calculate_fee(amount_out_before_fee, pool.fee_percent);
    let lp_share = math::mul_div_to_64(total_fee, constants::conditional_lp_fee_share_bps(), constants::total_fee_bps());
    let protocol_share = total_fee - lp_share;

    // Net amount for the user
    let amount_out = amount_out_before_fee - total_fee;

    // Send protocol's share to the fee collector
    pool.protocol_fees = pool.protocol_fees + protocol_share;

    assert!(amount_out >= min_amount_out, EExcessiveSlippage);
    assert!(amount_out_before_fee < pool.stable_reserve, EPoolEmpty);

    let price_impact = calculate_price_impact(
        amount_in,
        pool.asset_reserve,
        amount_out_before_fee, // Use before-fee amount for impact calculation
        pool.stable_reserve,
    );

    // Capture previous reserve state before the update
    let old_asset = pool.asset_reserve;
    let old_stable = pool.stable_reserve;

    let timestamp = clock.timestamp_ms();
    let old_price = math::mul_div_to_128(old_stable, constants::basis_points(), old_asset);
    // Oracle observation is recorded using the reserves *before* the swap.
    // This ensures that the TWAP accurately reflects the price at the beginning of the swap.
    write_observation(
        &mut pool.oracle,
        timestamp,
        old_price,
    );

    // Update SimpleTWAP oracle (for external consumers)
    simple_twap::update(&mut pool.simple_twap, old_price, clock);

    // Update reserves.
    pool.asset_reserve = pool.asset_reserve + amount_in;

    // The stable reserve is reduced by the gross output, BUT the LPs' share is kept in the pool.
    // So we add it back.
    // This is equivalent to `pool.stable_reserve - (amount_out + protocol_share)`
    pool.stable_reserve = pool.stable_reserve - amount_out_before_fee + lp_share;

    // K-GUARD: Validate k increased (LP fees stay in pool, so k must grow)
    // Formula: (asset + amount_in) * (stable - amount_out - protocol_share) >= asset * stable
    let k_after = (pool.asset_reserve as u128) * (pool.stable_reserve as u128);
    assert!(k_after >= k_before, EKInvariantViolation);

    let current_price = get_current_price(pool);
    check_price_under_max(current_price);

    event::emit(SwapEvent {
        market_id: pool.market_id,
        outcome: pool.outcome_idx,
        is_buy: false,
        amount_in,
        amount_out, // Amount after fee for event logging
        price_impact,
        price: current_price,
        sender: ctx.sender(),
        asset_reserve: pool.asset_reserve,
        stable_reserve: pool.stable_reserve,
        timestamp,
    });

    amount_out
}

// Modified swap_asset_to_stable (selling outcome tokens)
public fun swap_stable_to_asset(
    pool: &mut LiquidityPool,
    market_id: ID,
    amount_in: u64,
    min_amount_out: u64,
    clock: &Clock,
    ctx: &TxContext,
): u64 {
    assert!(pool.market_id == market_id, EMarketIdMismatch);
    assert!(amount_in > 0, EZeroAmount);

    // K-GUARD: Capture reserves before swap to validate constant-product invariant
    // WHY: LP fees stay in pool, so k must GROW. Catches fee accounting bugs.
    let k_before = (pool.asset_reserve as u128) * (pool.stable_reserve as u128);

    // When buying outcome tokens (stable -> asset):
    // 1. Calculate the fee from the input amount (amount_in).
    // 2. The actual amount used for the swap (amount_in_after_fee) is the original input minus the fee.
    // 3. Split the total fee: 80% for LPs (lp_share), 20% for the protocol (protocol_share).
    // 4. `protocol_share` is moved to `pool.protocol_fees`.
    // 5. `amount_in_after_fee` is used to calculate the swap output.
    // 6. The pool's stable reserve increases by `amount_in_after_fee + lp_share`, growing `k`.
    let total_fee = calculate_fee(amount_in, pool.fee_percent);
    let lp_share = math::mul_div_to_64(total_fee, constants::conditional_lp_fee_share_bps(), constants::total_fee_bps());
    let protocol_share = total_fee - lp_share;

    // Amount used for the swap calculation
    let amount_in_after_fee = amount_in - total_fee;

    // Send protocol's share to the fee collector
    pool.protocol_fees = pool.protocol_fees + protocol_share;

    // Calculate output based on amount after fee
    let amount_out = calculate_output(
        amount_in_after_fee,
        pool.stable_reserve,
        pool.asset_reserve,
    );

    assert!(amount_out >= min_amount_out, EExcessiveSlippage);
    assert!(amount_out < pool.asset_reserve, EPoolEmpty);

    let price_impact = calculate_price_impact(
        amount_in_after_fee,
        pool.stable_reserve,
        amount_out,
        pool.asset_reserve,
    );

    // Capture previous reserve state before the update
    let old_asset = pool.asset_reserve;
    let old_stable = pool.stable_reserve;

    let timestamp = clock.timestamp_ms();
    let old_price = math::mul_div_to_128(old_stable, constants::basis_points(), old_asset);
    // Oracle observation is recorded using the reserves *before* the swap.
    // This ensures that the TWAP accurately reflects the price at the beginning of the swap.
    write_observation(
        &mut pool.oracle,
        timestamp,
        old_price,
    );

    // Update SimpleTWAP oracle (for external consumers)
    simple_twap::update(&mut pool.simple_twap, old_price, clock);

    // Update reserves. The amount added to the stable reserve is the portion used for the swap
    // PLUS the LP share of the fee. The protocol share was already removed.
    let new_stable_reserve = pool.stable_reserve + amount_in_after_fee + lp_share;
    assert!(new_stable_reserve >= pool.stable_reserve, EOverflow);

    pool.stable_reserve = new_stable_reserve;
    pool.asset_reserve = pool.asset_reserve - amount_out;

    // K-GUARD: Validate k increased (LP fees stay in pool, so k must grow)
    // Formula: (asset - amount_out) * (stable + amount_in_after_fee + lp_share) >= asset * stable
    let k_after = (pool.asset_reserve as u128) * (pool.stable_reserve as u128);
    assert!(k_after >= k_before, EKInvariantViolation);

    let current_price = get_current_price(pool);
    check_price_under_max(current_price);

    event::emit(SwapEvent {
        market_id: pool.market_id,
        outcome: pool.outcome_idx,
        is_buy: true,
        amount_in, // Original amount for event logging
        amount_out,
        price_impact,
        price: current_price,
        sender: ctx.sender(),
        asset_reserve: pool.asset_reserve,
        stable_reserve: pool.stable_reserve,
        timestamp,
    });

    amount_out
}

// === Liquidity Functions ===

/// Add liquidity proportionally to the AMM pool
/// Only handles calculations and reserve updates, no token operations
/// Returns the amount of LP tokens to mint
public fun add_liquidity_proportional(
    pool: &mut LiquidityPool,
    asset_amount: u64,
    stable_amount: u64,
    min_lp_out: u64,
    clock: &Clock,
    ctx: &TxContext,
): u64 {
    assert!(asset_amount > 0, EZeroAmount);
    assert!(stable_amount > 0, EZeroAmount);
    
    // Calculate LP tokens to mint based on current pool state
    let (lp_to_mint, new_lp_supply) = if (pool.lp_supply == 0) {
        // First liquidity provider - bootstrap the pool
        let k_squared = math::mul_div_to_128(asset_amount, stable_amount, 1);
        let k = (math::sqrt_u128(k_squared) as u64);
        assert!(k > (MINIMUM_LIQUIDITY as u64), ELowLiquidity);
        // For the first liquidity provider, a small amount of LP tokens (MINIMUM_LIQUIDITY)
        // is intentionally burned and locked in the pool. This is a standard practice in Uniswap V2
        // to prevent division-by-zero errors and to ensure that LP token prices are always well-defined.
        // This amount is accounted for in the `lp_supply` but is not redeemable.
        let locked = (MINIMUM_LIQUIDITY as u64);
        let minted = k - locked;
        // Return the minted amount and the resulting total supply
        (minted, k)
    } else {
        // Subsequent providers - mint proportionally
        // The `math::min` function is used here, similar to Uniswap V2, to calculate the LP tokens to mint.
        // This approach inherently protects against adding imbalanced liquidity by only considering the
        // smaller of the two potential LP amounts derived from asset and stable contributions.
        //
        // The min_lp_out parameter provides slippage protection for users.
        let lp_from_asset = math::mul_div_to_64(asset_amount, pool.lp_supply, pool.asset_reserve);
        let lp_from_stable = math::mul_div_to_64(stable_amount, pool.lp_supply, pool.stable_reserve);
        // Use minimum to ensure proper ratio
        let minted = math::min(lp_from_asset, lp_from_stable);
        (minted, pool.lp_supply + minted)
    };
    
    // Slippage protection: ensure LP tokens minted meet minimum expectation
    assert!(lp_to_mint >= min_lp_out, EExcessiveSlippage);
    
    // Update reserves with overflow checks
    let new_asset_reserve = pool.asset_reserve + asset_amount;
    let new_stable_reserve = pool.stable_reserve + stable_amount;
    // Use the precomputed total supply
    
    // Check for overflow
    assert!(new_asset_reserve >= pool.asset_reserve, EOverflow);
    assert!(new_stable_reserve >= pool.stable_reserve, EOverflow);
    assert!(new_lp_supply >= pool.lp_supply, EOverflow);
    
    pool.asset_reserve = new_asset_reserve;
    pool.stable_reserve = new_stable_reserve;
    pool.lp_supply = new_lp_supply;

    // Update SimpleTWAP after liquidity change
    let new_price = get_current_price(pool);
    simple_twap::update(&mut pool.simple_twap, new_price, clock);

    event::emit(LiquidityAdded {
        market_id: pool.market_id,
        outcome: pool.outcome_idx,
        asset_amount,
        stable_amount,
        lp_amount: lp_to_mint,
        sender: ctx.sender(),
        timestamp: clock.timestamp_ms(),
    });

    lp_to_mint
}

/// Remove liquidity proportionally from the AMM pool
/// Only handles calculations and reserve updates, no token operations
/// Returns the amounts of asset and stable tokens to mint
public fun remove_liquidity_proportional(
    pool: &mut LiquidityPool,
    lp_amount: u64,
    clock: &Clock,
    ctx: &TxContext
): (u64, u64) {
    // Check for zero liquidity in the pool first to provide a more accurate error message
    assert!(pool.lp_supply > 0, EZeroLiquidity);
    assert!(lp_amount > 0, EZeroAmount);
    
    // Calculate proportional share to remove from this AMM
    let asset_to_remove = math::mul_div_to_64(lp_amount, pool.asset_reserve, pool.lp_supply);
    let stable_to_remove = math::mul_div_to_64(lp_amount, pool.stable_reserve, pool.lp_supply);
    
    // Ensure minimum liquidity remains
    assert!(pool.asset_reserve > asset_to_remove, EPoolEmpty);
    assert!(pool.stable_reserve > stable_to_remove, EPoolEmpty);
    assert!(pool.lp_supply > lp_amount, EInsufficientLPTokens);
    
    // Ensure remaining liquidity is above minimum threshold
    let remaining_asset = pool.asset_reserve - asset_to_remove;
    let remaining_stable = pool.stable_reserve - stable_to_remove;
    let remaining_k = math::mul_div_to_128(remaining_asset, remaining_stable, 1);
    assert!(remaining_k >= (MINIMUM_LIQUIDITY as u128), ELowLiquidity);
    
    // Update pool state (underflow already checked by earlier asserts)
    pool.asset_reserve = pool.asset_reserve - asset_to_remove;
    pool.stable_reserve = pool.stable_reserve - stable_to_remove;
    pool.lp_supply = pool.lp_supply - lp_amount;

    // Update SimpleTWAP after liquidity change
    let new_price = get_current_price(pool);
    simple_twap::update(&mut pool.simple_twap, new_price, clock);

    event::emit(LiquidityRemoved {
        market_id: pool.market_id,
        outcome: pool.outcome_idx,
        asset_amount: asset_to_remove,
        stable_amount: stable_to_remove,
        lp_amount,
        sender: ctx.sender(),
        timestamp: clock.timestamp_ms(),
    });

    (asset_to_remove, stable_to_remove)
}

public fun empty_all_amm_liquidity(
    pool: &mut LiquidityPool,
    _ctx: &mut TxContext,
): (u64, u64) {
    // This function is now only used in the final step of the old model and can be deprecated/removed.
    // Or kept for admin/emergency purposes.
    let asset_amount_out = pool.asset_reserve;
    let stable_amount_out = pool.stable_reserve;
    pool.asset_reserve = 0;
    pool.stable_reserve = 0;
    (asset_amount_out, stable_amount_out)
}

// === Oracle Functions ===
// Update new_oracle to be simpler:
fun write_observation(oracle: &mut Oracle, timestamp: u64, price: u128) {
    oracle.write_observation(timestamp, price)
}

public fun get_oracle(pool: &LiquidityPool): &Oracle {
    &pool.oracle
}

public fun get_simple_twap(pool: &LiquidityPool): &SimpleTWAP {
    &pool.simple_twap
}

// === View Functions ===

public fun get_reserves(pool: &LiquidityPool): (u64, u64) {
    (pool.asset_reserve, pool.stable_reserve)
}

public fun get_lp_supply(pool: &LiquidityPool): u64 {
    pool.lp_supply
}

/// Get pool fee in basis points
public fun get_fee_bps(pool: &LiquidityPool): u64 {
    pool.fee_percent
}

public fun get_price(pool: &LiquidityPool): u128 {
    pool.oracle.last_price()
}

public fun get_twap(pool: &mut LiquidityPool, clock: &Clock): u128 {
    update_twap_observation(pool, clock);
    pool.oracle.get_twap(clock)
}

public fun quote_swap_asset_to_stable(pool: &LiquidityPool, amount_in: u64): u64 {
    // First calculate total output
    let amount_out_before_fee = calculate_output(
        amount_in,
        pool.asset_reserve,
        pool.stable_reserve,
    );
    // Then take fee from stable output (same as swap function)
    let fee_amount = calculate_fee(amount_out_before_fee, pool.fee_percent);
    amount_out_before_fee - fee_amount
}

public fun quote_swap_stable_to_asset(pool: &LiquidityPool, amount_in: u64): u64 {
    let amount_in_with_fee = amount_in - calculate_fee(amount_in, pool.fee_percent);
    calculate_output(
        amount_in_with_fee,
        pool.stable_reserve,
        pool.asset_reserve,
    )
}

// === Arbitrage Helper Functions ===

/// Feeless swap asset→stable (for internal arbitrage only)
/// No fees charged to maximize arbitrage efficiency
///
/// AUDIT FIX: Now MUTATES reserves (Q3: swaps should always update state)
public(package) fun feeless_swap_asset_to_stable(
    pool: &mut LiquidityPool,
    amount_in: u64,
): u64 {
    assert!(amount_in > 0, EZeroAmount);
    assert!(pool.asset_reserve > 0 && pool.stable_reserve > 0, EPoolEmpty);

    // K-GUARD: Feeless swaps should preserve k EXACTLY (no fees = no k growth)
    // WHY: Validates arbitrage math is correct (used in executor's multi-pool swaps)
    let k_before = (pool.asset_reserve as u128) * (pool.stable_reserve as u128);

    // No fee for arbitrage swaps (fee-free constant product)
    let stable_out = calculate_output(
        amount_in,
        pool.asset_reserve,
        pool.stable_reserve,
    );
    assert!(stable_out < pool.stable_reserve, EPoolEmpty);

    // CRITICAL FIX: Update reserves! Any swap must mutate state.
    pool.asset_reserve = pool.asset_reserve + amount_in;
    pool.stable_reserve = pool.stable_reserve - stable_out;

    // K-GUARD: Validate k unchanged (feeless swap preserves k within rounding)
    // Formula: (asset + amount_in) * (stable - stable_out) ≈ asset * stable
    // Allow tiny rounding tolerance (1 part in 10^6)
    let k_after = (pool.asset_reserve as u128) * (pool.stable_reserve as u128);
    let k_delta = if (k_after > k_before) { k_after - k_before } else { k_before - k_after };
    let tolerance = k_before / 1000000; // 0.0001% tolerance
    assert!(k_delta <= tolerance, EKInvariantViolation);

    stable_out
}

/// Feeless swap stable→asset (for internal arbitrage only)
///
/// AUDIT FIX: Now MUTATES reserves (Q3: swaps should always update state)
public(package) fun feeless_swap_stable_to_asset(
    pool: &mut LiquidityPool,
    amount_in: u64,
): u64 {
    assert!(amount_in > 0, EZeroAmount);
    assert!(pool.asset_reserve > 0 && pool.stable_reserve > 0, EPoolEmpty);

    // K-GUARD: Feeless swaps should preserve k EXACTLY (no fees = no k growth)
    // WHY: Validates arbitrage math is correct (used in executor's multi-pool swaps)
    let k_before = (pool.asset_reserve as u128) * (pool.stable_reserve as u128);

    // No fee for arbitrage swaps
    let asset_out = calculate_output(
        amount_in,
        pool.stable_reserve,
        pool.asset_reserve,
    );
    assert!(asset_out < pool.asset_reserve, EPoolEmpty);

    // CRITICAL FIX: Update reserves! Any swap must mutate state.
    pool.stable_reserve = pool.stable_reserve + amount_in;
    pool.asset_reserve = pool.asset_reserve - asset_out;

    // K-GUARD: Validate k unchanged (feeless swap preserves k within rounding)
    // Formula: (asset - asset_out) * (stable + amount_in) ≈ asset * stable
    // Allow tiny rounding tolerance (1 part in 10^6)
    let k_after = (pool.asset_reserve as u128) * (pool.stable_reserve as u128);
    let k_delta = if (k_after > k_before) { k_after - k_before } else { k_before - k_after };
    let tolerance = k_before / 1000000; // 0.0001% tolerance
    assert!(k_delta <= tolerance, EKInvariantViolation);

    asset_out
}

/// Simulate asset→stable swap without executing
/// Pure function for arbitrage optimization
///
/// AUDIT FIX: Match execution exactly - fee charged on OUTPUT only (not input!)
public fun simulate_swap_asset_to_stable(
    pool: &LiquidityPool,
    amount_in: u64,
): u64 {
    if (amount_in == 0) return 0;
    if (pool.asset_reserve == 0 || pool.stable_reserve == 0) return 0;

    // CRITICAL FIX: Match swap_asset_to_stable execution exactly
    // Fee is charged on OUTPUT, NOT input!
    let amount_out_before_fee = calculate_output(
        amount_in,  // No input fee!
        pool.asset_reserve,
        pool.stable_reserve,
    );

    if (amount_out_before_fee >= pool.stable_reserve) return 0;

    // Calculate fee from output (matching swap function logic)
    let total_fee = calculate_fee(amount_out_before_fee, pool.fee_percent);
    if (amount_out_before_fee > total_fee) {
        amount_out_before_fee - total_fee
    } else {
        0
    }
}

/// Simulate stable→asset swap without executing
public fun simulate_swap_stable_to_asset(
    pool: &LiquidityPool,
    amount_in: u64,
): u64 {
    if (amount_in == 0) return 0;
    if (pool.asset_reserve == 0 || pool.stable_reserve == 0) return 0;

    // Simulate with fee
    let total_fee = calculate_fee(amount_in, pool.fee_percent);
    let amount_in_after_fee = if (amount_in > total_fee) {
        amount_in - total_fee
    } else {
        return 0
    };

    let asset_out = calculate_output(
        amount_in_after_fee,
        pool.stable_reserve,
        pool.asset_reserve,
    );

    if (asset_out >= pool.asset_reserve) return 0;

    asset_out
}

fun calculate_price_impact(
    amount_in: u64,
    reserve_in: u64,
    amount_out: u64,
    reserve_out: u64,
): u128 {
    // Use u256 for intermediate calculations to prevent overflow
    let amount_in_256 = (amount_in as u256);
    let reserve_out_256 = (reserve_out as u256);
    let reserve_in_256 = (reserve_in as u256);
    
    // Calculate ideal output with u256 to prevent overflow
    let ideal_out_256 = (amount_in_256 * reserve_out_256) / reserve_in_256;
    assert!(ideal_out_256 <= (std::u128::max_value!() as u256), EOverflow);
    let ideal_out = (ideal_out_256 as u128);
    
    // The assert below ensures that `ideal_out` is always greater than or equal to `amount_out`.
    // This prevents underflow when calculating `ideal_out - (amount_out as u128)`.
    assert!(ideal_out >= (amount_out as u128), EOverflow); // Ensure no underflow
    math::mul_div_mixed(ideal_out - (amount_out as u128), FEE_SCALE, ideal_out)
}

// Update the LiquidityPool struct price calculation to use TWAP:
public fun get_current_price(pool: &LiquidityPool): u128 {
    assert!(pool.asset_reserve > 0 && pool.stable_reserve > 0, EZeroLiquidity);

    let price = math::mul_div_to_128(
        pool.stable_reserve,
        constants::basis_points(),
        pool.asset_reserve,
    );

    price
}

public fun update_twap_observation(pool: &mut LiquidityPool, clock: &Clock) {
    let timestamp = clock.timestamp_ms();
    let current_price = get_current_price(pool);
    // Use the sum of reserves as a liquidity measure
    pool.oracle.write_observation(timestamp, current_price);
}

public fun set_oracle_start_time(pool: &mut LiquidityPool, market_id: ID, trading_start_time: u64) {
    assert!(get_ms_id(pool) == market_id, EMarketIdMismatch);
    pool.oracle.set_oracle_start_time(trading_start_time);
}

// === Private Functions ===
fun calculate_fee(amount: u64, fee_percent: u64): u64 {
    math::mul_div_to_64(amount, fee_percent, FEE_SCALE)
}

public fun calculate_output(
    amount_in_with_fee: u64,
    reserve_in: u64,
    reserve_out: u64,
): u64 {
    assert!(reserve_in > 0 && reserve_out > 0, EPoolEmpty);

    let denominator = reserve_in + amount_in_with_fee;
    assert!(denominator > 0, EDivByZero);
    let numerator = (amount_in_with_fee as u256) * (reserve_out as u256);
    let output = numerator / (denominator as u256);
    assert!(output <= (u64::max_value!() as u256), EOverflow);
    (output as u64)
}

public fun get_outcome_idx(pool: &LiquidityPool): u8 {
    pool.outcome_idx
}

public fun get_id(pool: &LiquidityPool): ID {
    pool.id.to_inner()
}

public fun get_k(pool: &LiquidityPool): u128 {
    math::mul_div_to_128(pool.asset_reserve, pool.stable_reserve, 1)
}

public fun check_price_under_max(price: u128) {
    let max_price = (0xFFFFFFFFFFFFFFFFu64 as u128) * (constants::basis_points() as u128);
    assert!(price <= max_price, EPriceTooHigh)
}

public fun get_protocol_fees(pool: &LiquidityPool): u64 {
    pool.protocol_fees
}

public fun get_ms_id(pool: &LiquidityPool): ID {
    pool.market_id
}

public fun reset_protocol_fees(pool: &mut LiquidityPool) {
    pool.protocol_fees = 0;
}

/// Add subsidy to reserves (for keeper-cranked subsidy system)
/// Directly increases reserves without minting LP tokens
/// Benefits existing LPs by increasing k
///
/// CRITICAL: Only callable by liquidity_subsidy module to prevent manipulation
public(package) fun add_subsidy_to_reserves(
    pool: &mut LiquidityPool,
    asset_add: u64,
    stable_add: u64,
) {
    // K-GUARD: Adding subsidy should increase k (benefits LPs)
    let k_before = (pool.asset_reserve as u128) * (pool.stable_reserve as u128);

    // Add to reserves directly
    pool.asset_reserve = pool.asset_reserve + asset_add;
    pool.stable_reserve = pool.stable_reserve + stable_add;

    // K-GUARD: Validate k increased
    let k_after = (pool.asset_reserve as u128) * (pool.stable_reserve as u128);
    assert!(k_after > k_before, EKInvariantViolation);
}

// === Test Functions ===
#[test_only]
public fun create_test_pool(
    market_id: ID,
    outcome_idx: u8,
    fee_percent: u64,
    asset_reserve: u64,
    stable_reserve: u64,
    clock: &Clock,
    ctx: &mut TxContext,
): LiquidityPool {
    let initial_price = math::mul_div_to_128(stable_reserve, 1_000_000_000_000, asset_reserve);

    LiquidityPool {
        id: object::new(ctx),
        market_id,
        outcome_idx,
        asset_reserve,
        stable_reserve,
        fee_percent,
        oracle: oracle::new_oracle(
            initial_price,
            0, // Use 0 which is always a valid multiple of TWAP_PRICE_CAP_WINDOW
            1_000,
            ctx,
        ),
        simple_twap: simple_twap::new(initial_price, clock),  // Uniswap V2 style
        protocol_fees: 0,
        lp_supply: (MINIMUM_LIQUIDITY as u64),
    }
}

#[test_only]
public fun destroy_for_testing(pool: LiquidityPool) {
    let LiquidityPool {
        id,
        market_id: _,
        outcome_idx: _,
        asset_reserve: _,
        stable_reserve: _,
        fee_percent: _,
        oracle,
        simple_twap,
        protocol_fees: _,
        lp_supply: _,
    } = pool;
    id.delete();
    oracle.destroy_for_testing();
    simple_twap.destroy_for_testing();
}
module futarchy_markets::market_state;

use std::string::String;
use sui::clock::Clock;
use sui::event;
use futarchy_markets::conditional_amm::LiquidityPool;

// === Introduction ===
// This module tracks proposal life cycle and acts as a source of truth for proposal state

// === Errors ===
const ETradingAlreadyStarted: u64 = 0;
const EOutcomeOutOfBounds: u64 = 1;
const EAlreadyFinalized: u64 = 2;
const ETradingAlreadyEnded: u64 = 3;
const ETradingNotEnded: u64 = 4;
const ENotFinalized: u64 = 5;
const ETradingNotStarted: u64 = 6;
const EInvalidDuration: u64 = 7;

// === Constants ===
const MAX_TRADING_DURATION_MS: u64 = 30 * 24 * 60 * 60 * 1000; // 30 days

// === Structs ===
public struct MarketStatus has copy, drop, store {
    trading_started: bool,
    trading_ended: bool,
    finalized: bool,
}

public struct MarketState has key, store {
    id: UID,
    market_id: ID,
    dao_id: ID,
    outcome_count: u64,
    outcome_messages: vector<String>,

    // Market infrastructure - AMM pools for price discovery
    amm_pools: Option<vector<LiquidityPool>>,

    // Lifecycle state
    status: MarketStatus,
    winning_outcome: Option<u64>,
    creation_time: u64,
    trading_start: u64,
    trading_end: Option<u64>,
    finalization_time: Option<u64>,
}

// === Events ===
public struct TradingStartedEvent has copy, drop {
    market_id: ID,
    start_time: u64,
}

public struct TradingEndedEvent has copy, drop {
    market_id: ID,
    timestamp_ms: u64,
}

public struct MarketStateFinalizedEvent has copy, drop {
    market_id: ID,
    winning_outcome: u64,
    timestamp_ms: u64,
}

// === Public Package Functions ===
public fun new(
    market_id: ID,
    dao_id: ID,
    outcome_count: u64,
    outcome_messages: vector<String>,
    clock: &Clock,
    ctx: &mut TxContext,
): MarketState {
    let timestamp = clock.timestamp_ms();

    MarketState {
        id: object::new(ctx),
        market_id,
        dao_id,
        outcome_count,
        outcome_messages,
        amm_pools: option::none(),  // Pools added later during market initialization
        status: MarketStatus {
            trading_started: false,
            trading_ended: false,
            finalized: false,
        },
        winning_outcome: option::none(),
        creation_time: timestamp,
        trading_start: 0,
        trading_end: option::none(),
        finalization_time: option::none(),
    }
}

public fun start_trading(state: &mut MarketState, duration_ms: u64, clock: &Clock) {
    assert!(!state.status.trading_started, ETradingAlreadyStarted);
    assert!(duration_ms > 0 && duration_ms <= MAX_TRADING_DURATION_MS, EInvalidDuration);

    let start_time = clock.timestamp_ms();
    let end_time = start_time + duration_ms;

    state.status.trading_started = true;
    state.trading_start = start_time;
    state.trading_end = option::some(end_time);

    event::emit(TradingStartedEvent {
        market_id: state.market_id,
        start_time,
    });
}

// === Public Functions ===
public fun assert_trading_active(state: &MarketState) {
    assert!(state.status.trading_started, ETradingNotStarted);
    assert!(!state.status.trading_ended, ETradingAlreadyEnded);
}

public fun assert_in_trading_or_pre_trading(state: &MarketState) {
    assert!(!state.status.trading_ended, ETradingAlreadyEnded);
    assert!(!state.status.finalized, EAlreadyFinalized);
}

public fun end_trading(state: &mut MarketState, clock: &Clock) {
    assert!(state.status.trading_started, ETradingNotStarted);
    assert!(!state.status.trading_ended, ETradingAlreadyEnded);

    let timestamp = clock.timestamp_ms();
    state.status.trading_ended = true;

    event::emit(TradingEndedEvent {
        market_id: state.market_id,
        timestamp_ms: timestamp,
    });
}

public fun finalize(state: &mut MarketState, winner: u64, clock: &Clock) {
    assert!(state.status.trading_ended, ETradingNotEnded);
    assert!(!state.status.finalized, EAlreadyFinalized);
    assert!(winner < state.outcome_count, EOutcomeOutOfBounds);

    let timestamp = clock.timestamp_ms();
    state.status.finalized = true;
    state.winning_outcome = option::some(winner);
    state.finalization_time = option::some(timestamp);

    event::emit(MarketStateFinalizedEvent {
        market_id: state.market_id,
        winning_outcome: winner,
        timestamp_ms: timestamp,
    });
}

// === Pool Management Functions ===

/// Initialize AMM pools for the market
/// Called once when market transitions to TRADING state
public(package) fun set_amm_pools(state: &mut MarketState, pools: vector<LiquidityPool>) {
    assert!(state.amm_pools.is_none(), 0); // Pools can only be set once
    option::fill(&mut state.amm_pools, pools);
}

/// Check if market has AMM pools initialized
public fun has_amm_pools(state: &MarketState): bool {
    state.amm_pools.is_some()
}

/// Borrow AMM pools immutably
public(package) fun borrow_amm_pools(state: &MarketState): &vector<LiquidityPool> {
    state.amm_pools.borrow()
}

/// Borrow AMM pools mutably
public(package) fun borrow_amm_pools_mut(state: &mut MarketState): &mut vector<LiquidityPool> {
    state.amm_pools.borrow_mut()
}

/// Get a specific pool by outcome index
public(package) fun get_pool_by_outcome(state: &MarketState, outcome_idx: u8): &LiquidityPool {
    let pools = state.amm_pools.borrow();
    &pools[(outcome_idx as u64)]
}

/// Get a specific pool mutably by outcome index
public(package) fun get_pool_mut_by_outcome(state: &mut MarketState, outcome_idx: u8): &mut LiquidityPool {
    let pools = state.amm_pools.borrow_mut();
    &mut pools[(outcome_idx as u64)]
}

/// Get all pools (for cleanup/migration)
public(package) fun extract_amm_pools(state: &mut MarketState): vector<LiquidityPool> {
    state.amm_pools.extract()
}

// === Assertion Functions ===
public fun assert_market_finalized(state: &MarketState) {
    assert!(state.status.finalized, ENotFinalized);
}

public fun assert_not_finalized(state: &MarketState) {
    assert!(!state.status.finalized, EAlreadyFinalized);
}

public fun validate_outcome(state: &MarketState, outcome: u64) {
    assert!(outcome < state.outcome_count, EOutcomeOutOfBounds);
}

// === View Functions (Getters) ===
public fun market_id(state: &MarketState): ID {
    state.market_id
}

public fun outcome_count(state: &MarketState): u64 {
    state.outcome_count
}

// === View Functions (Predicates) ===
public fun is_trading_active(state: &MarketState): bool {
    state.status.trading_started && !state.status.trading_ended
}

public fun is_finalized(state: &MarketState): bool {
    state.status.finalized
}

public fun dao_id(state: &MarketState): ID {
    state.dao_id
}

public fun get_winning_outcome(state: &MarketState): u64 {
    use std::option;
    assert!(state.status.finalized, ENotFinalized);
    let opt_ref = &state.winning_outcome;
    assert!(option::is_some(opt_ref), ENotFinalized);
    *option::borrow(opt_ref)
}

public fun get_outcome_message(state: &MarketState, outcome_idx: u64): String {
    assert!(outcome_idx < state.outcome_count, EOutcomeOutOfBounds);
    state.outcome_messages[outcome_idx]
}

public fun get_creation_time(state: &MarketState): u64 {
    state.creation_time
}

public fun get_trading_end_time(state: &MarketState): Option<u64> {
    state.trading_end
}

public fun get_trading_start(state: &MarketState): u64 {
    state.trading_start
}

public fun get_finalization_time(state: &MarketState): Option<u64> {
    state.finalization_time
}

// === Test Functions ===
#[test_only]
public fun create_for_testing(outcomes: u64, ctx: &mut TxContext): MarketState {
    let dummy_id = object::new(ctx);
    let market_id = dummy_id.uid_to_inner();
    dummy_id.delete();

    MarketState {
        id: object::new(ctx),
        market_id,
        dao_id: market_id,
        outcome_messages: vector[],
        outcome_count: outcomes,
        amm_pools: option::none(),
        status: MarketStatus {
            trading_started: false,
            trading_ended: false,
            finalized: false,
        },
        winning_outcome: option::none(),
        creation_time: 0,
        trading_start: 0,
        trading_end: option::none(),
        finalization_time: option::none(),
    }
}

#[test_only]
public fun init_trading_for_testing(state: &mut MarketState) {
    state.status.trading_started = true;
    state.trading_start = 0;
    state.trading_end = option::some(9999999999999);
}
#[test_only]
public fun reset_state_for_testing(state: &mut MarketState) {
    state.status.trading_started = false;
    state.trading_start = 0;
}

#[test_only]
public fun finalize_for_testing(state: &mut MarketState) {
    state.status.trading_ended = true;
    state.status.finalized = true;
    state.winning_outcome = option::some(0);
    state.finalization_time = option::some(0);
}

#[test_only]
public fun destroy_for_testing(state: MarketState) {
    sui::test_utils::destroy(state);
}

#[test_only]
public fun copy_market_id(state: &MarketState): ID {
    state.market_id
}

#[test_only]
public fun copy_status(state: &MarketState): MarketStatus {
    state.status
}

#[test_only]
public fun copy_winning_outcome(state: &MarketState): Option<u64> {
    state.winning_outcome
}

#[test_only]
public fun test_set_winning_outcome(state: &mut MarketState, outcome: u64) {
    state.winning_outcome = option::some(outcome);
}

#[test_only]
public fun test_set_finalized(state: &mut MarketState) {
    state.status.finalized = true;
    state.status.trading_ended = true;
    state.finalization_time = option::some(0);
}
module futarchy_markets::liquidity_initialize;

use futarchy_markets::conditional_amm::{Self, LiquidityPool};
use futarchy_markets::coin_escrow::TokenEscrow;
use sui::balance::Balance;
use sui::clock::Clock;

// === Introduction ===
// Method to initialize AMM liquidity using TreasuryCap-based conditional coins
// Assumes TreasuryCaps have been registered with escrow before calling this

// === Errors ===
const EInitAssetReservesMismatch: u64 = 100;
const EInitStableReservesMismatch: u64 = 101;
const EInitPoolCountMismatch: u64 = 102;
const EInitPoolOutcomeMismatch: u64 = 103;
const EInitZeroLiquidity: u64 = 104;
const ECapsNotRegistered: u64 = 105;

// === Public Functions ===
/// Create outcome markets using TreasuryCap-based conditional coins
/// IMPORTANT: TreasuryCaps must be registered with escrow BEFORE calling this function
/// The caller (PTB) must have called register_conditional_caps() N times before this
public fun create_outcome_markets<AssetType, StableType>(
    escrow: &mut TokenEscrow<AssetType, StableType>,
    outcome_count: u64,
    asset_amounts: vector<u64>,
    stable_amounts: vector<u64>,
    twap_start_delay: u64,
    twap_initial_observation: u128,
    twap_step_max: u64,
    amm_total_fee_bps: u64,
    initial_asset: Balance<AssetType>,
    initial_stable: Balance<StableType>,
    clock: &Clock,
    ctx: &mut TxContext,
): vector<LiquidityPool> {
    assert!(asset_amounts.length() == outcome_count, EInitAssetReservesMismatch);
    assert!(stable_amounts.length() == outcome_count, EInitStableReservesMismatch);

    // Validate that all amounts are non-zero to prevent division by zero in AMM calculations
    let mut j = 0;
    while (j < outcome_count) {
        assert!(asset_amounts[j] > 0, EInitZeroLiquidity);
        assert!(stable_amounts[j] > 0, EInitZeroLiquidity);
        j = j + 1;
    };

    // Verify TreasuryCaps are registered for all outcomes
    assert!(escrow.caps_registered_count() == outcome_count, ECapsNotRegistered);

    let mut amm_pools = vector[];

    // 1. Deposit spot liquidity into escrow (quantum liquidity model)
    escrow.deposit_spot_liquidity(initial_asset, initial_stable);

    // 2. Create AMM pools for each outcome
    let mut i = 0;
    while (i < outcome_count) {
        let asset_amt = asset_amounts[i];
        let stable_amt = stable_amounts[i];

        let ms = escrow.get_market_state();
        let market_id = futarchy_markets::market_state::market_id(ms);
        let pool = conditional_amm::new_pool(
            market_id,
            (i as u8),
            amm_total_fee_bps,
            asset_amt,
            stable_amt,
            twap_initial_observation,
            twap_start_delay,
            twap_step_max,
            clock,
            ctx,
        );
        amm_pools.push_back(pool);

        i = i + 1;
    };

    // Note: Validation removed - quantum liquidity means supplies won't match AMM reserves
    // in the same way as the old system. Invariants are checked differently now.

    amm_pools
}

// REMOVED: assert_initial_reserves_consistency
// The old validation checked that AMM reserves + token supply = escrow balance
// With quantum liquidity model, this relationship is different:
// - Escrow holds ALL spot tokens
// - Each outcome has conditional coins minted equal to spot balance
// - AMMs trade conditional coins, not spot
// Validation now happens at the escrow level via quantum invariant checks
module futarchy_markets::coin_escrow;

use futarchy_markets::market_state::MarketState;
use futarchy_markets::spot_amm;
use sui::balance::{Self, Balance};
use sui::clock::Clock;
use sui::coin::{Self, Coin, TreasuryCap, CoinMetadata};
use sui::event;
use sui::dynamic_field;

// === Introduction ===
// The TokenEscrow manages TreasuryCap-based conditional coins in the futarchy prediction market system.
//
// === TreasuryCap-Based Conditional Coins ===
// Uses real Sui Coin<T> types instead of custom ConditionalToken structs:
// 1. **TreasuryCap Storage**: Each outcome has 2 TreasuryCaps (asset + stable) stored in dynamic fields
// 2. **Registry Integration**: Blank coins acquired from permissionless registry
// 3. **Quantum Liquidity**: Spot tokens exist simultaneously in ALL outcomes (not split between them)
//
// === Quantum Liquidity Invariant ===
// **CRITICAL**: 100 spot tokens → 100 conditional tokens in EACH outcome
// - NOT proportional split (not 50/50 across 2 outcomes)
// - Liquidity exists fully in all markets simultaneously
// - Only highest-priced outcome wins at finalization
// - Invariant: spot_asset_balance == each_outcome_asset_supply (for ALL outcomes)
//
// === Architecture ===
// - TreasuryCaps stored via dynamic fields with AssetCapKey/StableCapKey
// - Vector-like indexing: outcome_index determines which cap to use
// - Mint/burn functions borrow caps mutably, perform operation, return cap to storage
// - No Supply objects - total_supply() comes directly from TreasuryCap

// === Errors ===
const EInsufficientBalance: u64 = 0; // Token balance insufficient for operation
const EIncorrectSequence: u64 = 1; // Tokens not provided in correct sequence/order
const EWrongMarket: u64 = 2; // Token belongs to different market
const EWrongTokenType: u64 = 3; // Wrong token type (asset vs stable)
const ESuppliesNotInitialized: u64 = 4; // Token supplies not yet initialized
const EOutcomeOutOfBounds: u64 = 5; // Outcome index exceeds market outcomes
const EWrongOutcome: u64 = 6; // Token outcome doesn't match expected
const ENotEnough: u64 = 7; // Not enough tokens/balance for operation
const ENotEnoughLiquidity: u64 = 8; // Insufficient liquidity in escrow
const EInsufficientAsset: u64 = 9; // Not enough asset tokens provided
const EInsufficientStable: u64 = 10; // Not enough stable tokens provided
const EMarketNotExpired: u64 = 11; // Market hasn't reached expiry period
const EBadWitness: u64 = 12; // Invalid one-time witness
const EZeroAmount: u64 = 13; // Amount must be greater than zero
const EInvalidAssetType: u64 = 14; // Asset type must be 0 (asset) or 1 (stable)
const EOverflow: u64 = 15; // Arithmetic overflow protection
const EInvariantViolation: u64 = 16; // Differential minting invariant violated

// === Constants ===
const TOKEN_TYPE_ASSET: u8 = 0;
const TOKEN_TYPE_STABLE: u8 = 1;
const TOKEN_TYPE_LP: u8 = 2;
const ETokenTypeMismatch: u64 = 100;
const MARKET_EXPIRY_PERIOD_MS: u64 = 2_592_000_000; // 30 days in ms

// === Key Structures for TreasuryCap Storage ===
/// Key for asset conditional coin TreasuryCaps (indexed by outcome)
public struct AssetCapKey has store, copy, drop {
    outcome_index: u64,
}

/// Key for stable conditional coin TreasuryCaps (indexed by outcome)
public struct StableCapKey has store, copy, drop {
    outcome_index: u64,
}

// === Structs ===
public struct TokenEscrow<phantom AssetType, phantom StableType> has key, store {
    id: UID,
    market_state: MarketState,
    // Central balances used for tokens and liquidity
    escrowed_asset: Balance<AssetType>,
    escrowed_stable: Balance<StableType>,

    // TreasuryCaps stored as dynamic fields on UID (vector-like access by index)
    // Asset caps: dynamic_field with AssetCapKey { outcome_index } -> TreasuryCap<T>
    // Stable caps: dynamic_field with StableCapKey { outcome_index } -> TreasuryCap<T>
    // Each outcome's TreasuryCap has a unique generic type T
    outcome_count: u64,  // Track how many outcomes have registered caps
}

public struct COIN_ESCROW has drop {}

// === Events ===
public struct LiquidityWithdrawal has copy, drop {
    escrowed_asset: u64,
    escrowed_stable: u64,
    asset_amount: u64,
    stable_amount: u64,
}

public struct LiquidityDeposit has copy, drop {
    escrowed_asset: u64,
    escrowed_stable: u64,
    asset_amount: u64,
    stable_amount: u64,
}

public struct TokenRedemption has copy, drop {
    outcome: u64,
    token_type: u8,
    amount: u64,
}

public fun new<AssetType, StableType>(
    market_state: MarketState,
    ctx: &mut TxContext,
): TokenEscrow<AssetType, StableType> {
    TokenEscrow {
        id: object::new(ctx),
        market_state,
        escrowed_asset: balance::zero(),
        escrowed_stable: balance::zero(),
        outcome_count: 0,  // Will be incremented as caps are registered
    }
}

/// NEW: Register conditional coin TreasuryCaps for an outcome
/// Must be called once per outcome with both asset and stable caps
/// Caps are stored as dynamic fields with vector-like indexing semantics
public fun register_conditional_caps<AssetType, StableType, AssetConditionalCoin, StableConditionalCoin>(
    escrow: &mut TokenEscrow<AssetType, StableType>,
    outcome_idx: u64,
    asset_treasury_cap: TreasuryCap<AssetConditionalCoin>,
    stable_treasury_cap: TreasuryCap<StableConditionalCoin>,
) {
    let market_outcome_count = escrow.market_state.outcome_count();
    assert!(outcome_idx < market_outcome_count, EOutcomeOutOfBounds);

    // Must register in order (like pushing to a vector)
    assert!(outcome_idx == escrow.outcome_count, EIncorrectSequence);

    // Store TreasuryCaps as dynamic fields with index-based keys
    let asset_key = AssetCapKey { outcome_index: outcome_idx };
    let stable_key = StableCapKey { outcome_index: outcome_idx };

    dynamic_field::add(&mut escrow.id, asset_key, asset_treasury_cap);
    dynamic_field::add(&mut escrow.id, stable_key, stable_treasury_cap);

    // Increment count (like vector length)
    escrow.outcome_count = escrow.outcome_count + 1;
}

// === NEW: TreasuryCap-based Mint/Burn Helpers ===

/// Mint conditional coins for a specific outcome using its TreasuryCap
/// Borrows the cap, mints, and returns it (maintains vector-like storage)
public fun mint_conditional_asset<AssetType, StableType, ConditionalCoinType>(
    escrow: &mut TokenEscrow<AssetType, StableType>,
    outcome_index: u64,
    amount: u64,
    ctx: &mut TxContext,
): Coin<ConditionalCoinType> {
    let market_outcome_count = escrow.market_state.outcome_count();
    assert!(outcome_index < market_outcome_count, EOutcomeOutOfBounds);

    // Borrow the TreasuryCap from dynamic field
    let asset_key = AssetCapKey { outcome_index };
    let cap: &mut TreasuryCap<ConditionalCoinType> =
        dynamic_field::borrow_mut(&mut escrow.id, asset_key);

    // Mint and return
    coin::mint(cap, amount, ctx)
}

/// Mint conditional stable coins for a specific outcome
public fun mint_conditional_stable<AssetType, StableType, ConditionalCoinType>(
    escrow: &mut TokenEscrow<AssetType, StableType>,
    outcome_index: u64,
    amount: u64,
    ctx: &mut TxContext,
): Coin<ConditionalCoinType> {
    let market_outcome_count = escrow.market_state.outcome_count();
    assert!(outcome_index < market_outcome_count, EOutcomeOutOfBounds);

    // Borrow the TreasuryCap from dynamic field
    let stable_key = StableCapKey { outcome_index };
    let cap: &mut TreasuryCap<ConditionalCoinType> =
        dynamic_field::borrow_mut(&mut escrow.id, stable_key);

    // Mint and return
    coin::mint(cap, amount, ctx)
}

/// Burn conditional asset coins for a specific outcome
public fun burn_conditional_asset<AssetType, StableType, ConditionalCoinType>(
    escrow: &mut TokenEscrow<AssetType, StableType>,
    outcome_index: u64,
    coin: Coin<ConditionalCoinType>,
) {
    let market_outcome_count = escrow.market_state.outcome_count();
    assert!(outcome_index < market_outcome_count, EOutcomeOutOfBounds);

    // Borrow the TreasuryCap from dynamic field
    let asset_key = AssetCapKey { outcome_index };
    let cap: &mut TreasuryCap<ConditionalCoinType> =
        dynamic_field::borrow_mut(&mut escrow.id, asset_key);

    // Burn
    coin::burn(cap, coin);
}

/// Burn conditional stable coins for a specific outcome
public fun burn_conditional_stable<AssetType, StableType, ConditionalCoinType>(
    escrow: &mut TokenEscrow<AssetType, StableType>,
    outcome_index: u64,
    coin: Coin<ConditionalCoinType>,
) {
    let market_outcome_count = escrow.market_state.outcome_count();
    assert!(outcome_index < market_outcome_count, EOutcomeOutOfBounds);

    // Borrow the TreasuryCap from dynamic field
    let stable_key = StableCapKey { outcome_index };
    let cap: &mut TreasuryCap<ConditionalCoinType> =
        dynamic_field::borrow_mut(&mut escrow.id, stable_key);

    // Burn
    coin::burn(cap, coin);
}

/// Get the total supply of a specific outcome's asset conditional coin
public fun get_asset_supply<AssetType, StableType, ConditionalCoinType>(
    escrow: &TokenEscrow<AssetType, StableType>,
    outcome_index: u64,
): u64 {
    let asset_key = AssetCapKey { outcome_index };
    let cap: &TreasuryCap<ConditionalCoinType> =
        dynamic_field::borrow(&escrow.id, asset_key);
    coin::total_supply(cap)
}

/// Get the total supply of a specific outcome's stable conditional coin
public fun get_stable_supply<AssetType, StableType, ConditionalCoinType>(
    escrow: &TokenEscrow<AssetType, StableType>,
    outcome_index: u64,
): u64 {
    let stable_key = StableCapKey { outcome_index };
    let cap: &TreasuryCap<ConditionalCoinType> =
        dynamic_field::borrow(&escrow.id, stable_key);
    coin::total_supply(cap)
}

// === Getters ===

/// Get the market state from escrow
public fun get_market_state<AssetType, StableType>(escrow: &TokenEscrow<AssetType, StableType>): &MarketState {
    &escrow.market_state
}

/// Get mutable market state from escrow
public fun get_market_state_mut<AssetType, StableType>(escrow: &mut TokenEscrow<AssetType, StableType>): &mut MarketState {
    &mut escrow.market_state
}

/// Get the market state ID from escrow
public fun market_state_id<AssetType, StableType>(escrow: &TokenEscrow<AssetType, StableType>): ID {
    escrow.market_state.market_id()
}

/// Get the number of outcomes that have registered TreasuryCaps
public fun caps_registered_count<AssetType, StableType>(escrow: &TokenEscrow<AssetType, StableType>): u64 {
    escrow.outcome_count
}

/// Deposit spot liquidity into escrow (quantum liquidity model)
/// This adds to the escrow balances that will be split quantum-mechanically across all outcomes
public fun deposit_spot_liquidity<AssetType, StableType>(
    escrow: &mut TokenEscrow<AssetType, StableType>,
    asset: Balance<AssetType>,
    stable: Balance<StableType>,
) {
    escrow.escrowed_asset.join(asset);
    escrow.escrowed_stable.join(stable);
}

// === Burn and Withdraw Helpers (For Redemption) ===

/// Burn conditional asset coins and withdraw equivalent spot asset
/// Used when redeeming conditional coins back to spot tokens (e.g., after market finalization)
public fun burn_conditional_asset_and_withdraw<AssetType, StableType, ConditionalCoinType>(
    escrow: &mut TokenEscrow<AssetType, StableType>,
    outcome_index: u64,
    amount: u64,
    ctx: &mut TxContext,
): Coin<AssetType> {
    // Mint the conditional coins to burn them (quantum liquidity: amounts must match)
    let conditional_coin = mint_conditional_asset<AssetType, StableType, ConditionalCoinType>(
        escrow,
        outcome_index,
        amount,
        ctx,
    );

    // Burn the conditional coins
    burn_conditional_asset<AssetType, StableType, ConditionalCoinType>(
        escrow,
        outcome_index,
        conditional_coin,
    );

    // Withdraw equivalent spot tokens (1:1 due to quantum liquidity)
    let asset_balance = escrow.escrowed_asset.split(amount);
    coin::from_balance(asset_balance, ctx)
}

/// Burn conditional stable coins and withdraw equivalent spot stable
public fun burn_conditional_stable_and_withdraw<AssetType, StableType, ConditionalCoinType>(
    escrow: &mut TokenEscrow<AssetType, StableType>,
    outcome_index: u64,
    amount: u64,
    ctx: &mut TxContext,
): Coin<StableType> {
    // Mint the conditional coins to burn them
    let conditional_coin = mint_conditional_stable<AssetType, StableType, ConditionalCoinType>(
        escrow,
        outcome_index,
        amount,
        ctx,
    );

    // Burn the conditional coins
    burn_conditional_stable<AssetType, StableType, ConditionalCoinType>(
        escrow,
        outcome_index,
        conditional_coin,
    );

    // Withdraw equivalent spot tokens
    let stable_balance = escrow.escrowed_stable.split(amount);
    coin::from_balance(stable_balance, ctx)
}

// === Deposit and Mint Helpers (For Creating Conditional Coins) ===

/// Deposit spot asset and mint equivalent conditional asset coins
/// Quantum liquidity: Depositing X spot mints X conditional in specified outcome
public fun deposit_asset_and_mint_conditional<AssetType, StableType, ConditionalCoinType>(
    escrow: &mut TokenEscrow<AssetType, StableType>,
    outcome_index: u64,
    asset_coin: Coin<AssetType>,
    ctx: &mut TxContext,
): Coin<ConditionalCoinType> {
    let amount = asset_coin.value();

    // Deposit spot tokens to escrow
    let asset_balance = coin::into_balance(asset_coin);
    escrow.escrowed_asset.join(asset_balance);

    // Mint equivalent conditional coins (1:1 due to quantum liquidity)
    mint_conditional_asset<AssetType, StableType, ConditionalCoinType>(
        escrow,
        outcome_index,
        amount,
        ctx,
    )
}

/// Deposit spot stable and mint equivalent conditional stable coins
public fun deposit_stable_and_mint_conditional<AssetType, StableType, ConditionalCoinType>(
    escrow: &mut TokenEscrow<AssetType, StableType>,
    outcome_index: u64,
    stable_coin: Coin<StableType>,
    ctx: &mut TxContext,
): Coin<ConditionalCoinType> {
    let amount = stable_coin.value();

    // Deposit spot tokens to escrow
    let stable_balance = coin::into_balance(stable_coin);
    escrow.escrowed_stable.join(stable_balance);

    // Mint equivalent conditional coins
    mint_conditional_stable<AssetType, StableType, ConditionalCoinType>(
        escrow,
        outcome_index,
        amount,
        ctx,
    )
}

/// Get escrow spot balances (read-only)
public fun get_spot_balances<AssetType, StableType>(
    escrow: &TokenEscrow<AssetType, StableType>,
): (u64, u64) {
    (escrow.escrowed_asset.value(), escrow.escrowed_stable.value())
}

/// Withdraw asset balance from escrow (for internal use)
public fun withdraw_asset_balance<AssetType, StableType>(
    escrow: &mut TokenEscrow<AssetType, StableType>,
    amount: u64,
    ctx: &mut TxContext,
): Coin<AssetType> {
    let balance = escrow.escrowed_asset.split(amount);
    coin::from_balance(balance, ctx)
}

/// Withdraw stable balance from escrow (for internal use)
public fun withdraw_stable_balance<AssetType, StableType>(
    escrow: &mut TokenEscrow<AssetType, StableType>,
    amount: u64,
    ctx: &mut TxContext,
): Coin<StableType> {
    let balance = escrow.escrowed_stable.split(amount);
    coin::from_balance(balance, ctx)
}

// === Quantum Liquidity Invariant Checking ===

/// Assert the quantum liquidity invariant: each outcome's supply equals spot balance
/// CRITICAL: In quantum liquidity model, 100 spot tokens → 100 in EACH outcome simultaneously
/// This is NOT proportional splitting - liquidity exists fully in all outcomes at once
///
/// The invariant must hold UNTIL proposal finalization:
/// - spot_asset_balance == each_outcome_asset_supply (for all outcomes)
/// - spot_stable_balance == each_outcome_stable_supply (for all outcomes)
///
/// After finalization, only the winning outcome's supply matters (others can be burned)
public fun assert_quantum_invariant<AssetType, StableType>(
    escrow: &TokenEscrow<AssetType, StableType>,
) {
    let spot_asset = escrow.escrowed_asset.value();
    let spot_stable = escrow.escrowed_stable.value();
    let outcome_count = escrow.outcome_count;

    // Check each outcome has supply equal to spot balance
    let mut i = 0;
    while (i < outcome_count) {
        // Get asset supply for this outcome
        let asset_key = AssetCapKey { outcome_index: i };
        let asset_cap_exists = dynamic_field::exists_(&escrow.id, asset_key);

        if (asset_cap_exists) {
            // We can't call get_asset_supply without the generic type parameter
            // So we'll leave this as a framework for manual checking
            // In practice, caller must provide the ConditionalCoinType to check
        };

        // Get stable supply for this outcome
        let stable_key = StableCapKey { outcome_index: i };
        let stable_cap_exists = dynamic_field::exists_(&escrow.id, stable_key);

        if (stable_cap_exists) {
            // Same limitation - need generic type to check supply
        };

        i = i + 1;
    };

    // NOTE: Full invariant check requires knowing all ConditionalCoinTypes at compile time
    // This function serves as documentation of the invariant
    // Actual enforcement happens in mint/burn operations that maintain the invariant
}

// === Complete Set Operations (Split/Recombine) ===

/// Split spot asset into complete set of conditional assets (all outcomes)
/// Creates 1 conditional asset for EACH outcome (quantum liquidity)
/// For 2-outcome markets
public entry fun split_asset_into_complete_set_2<AssetType, StableType, Cond0, Cond1>(
    escrow: &mut TokenEscrow<AssetType, StableType>,
    spot_asset: Coin<AssetType>,
    ctx: &mut TxContext,
) {
    let amount = spot_asset.value();
    assert!(amount > 0, EZeroAmount);

    // Deposit spot asset to escrow
    let asset_balance = coin::into_balance(spot_asset);
    escrow.escrowed_asset.join(asset_balance);

    // Mint conditional asset for outcome 0
    let cond_0 = mint_conditional_asset<AssetType, StableType, Cond0>(escrow, 0, amount, ctx);

    // Mint conditional asset for outcome 1
    let cond_1 = mint_conditional_asset<AssetType, StableType, Cond1>(escrow, 1, amount, ctx);

    // Transfer to sender
    transfer::public_transfer(cond_0, ctx.sender());
    transfer::public_transfer(cond_1, ctx.sender());
}

/// Split spot stable into complete set of conditional stables (all outcomes)
/// For 2-outcome markets
public entry fun split_stable_into_complete_set_2<AssetType, StableType, Cond0, Cond1>(
    escrow: &mut TokenEscrow<AssetType, StableType>,
    spot_stable: Coin<StableType>,
    ctx: &mut TxContext,
) {
    let amount = spot_stable.value();
    assert!(amount > 0, EZeroAmount);

    // Deposit spot stable to escrow
    let stable_balance = coin::into_balance(spot_stable);
    escrow.escrowed_stable.join(stable_balance);

    // Mint conditional stable for outcome 0
    let cond_0 = mint_conditional_stable<AssetType, StableType, Cond0>(escrow, 0, amount, ctx);

    // Mint conditional stable for outcome 1
    let cond_1 = mint_conditional_stable<AssetType, StableType, Cond1>(escrow, 1, amount, ctx);

    // Transfer to sender
    transfer::public_transfer(cond_0, ctx.sender());
    transfer::public_transfer(cond_1, ctx.sender());
}

/// Recombine complete set of conditional assets back into spot asset
/// Burns 1 conditional asset from EACH outcome, returns 1 spot asset (quantum liquidity)
/// For 2-outcome markets
public entry fun recombine_asset_complete_set_2<AssetType, StableType, Cond0, Cond1>(
    escrow: &mut TokenEscrow<AssetType, StableType>,
    cond_0: Coin<Cond0>,
    cond_1: Coin<Cond1>,
    ctx: &mut TxContext,
) {
    let amount_0 = cond_0.value();
    let amount_1 = cond_1.value();
    assert!(amount_0 == amount_1, EInsufficientBalance);
    assert!(amount_0 > 0, EZeroAmount);

    let amount = amount_0;

    // Burn conditional assets for each outcome
    burn_conditional_asset<AssetType, StableType, Cond0>(escrow, 0, cond_0);
    burn_conditional_asset<AssetType, StableType, Cond1>(escrow, 1, cond_1);

    // Withdraw spot asset (1:1 due to quantum liquidity)
    let spot_asset = withdraw_asset_balance(escrow, amount, ctx);

    // Transfer to sender
    transfer::public_transfer(spot_asset, ctx.sender());
}

/// Recombine complete set of conditional stables back into spot stable
/// For 2-outcome markets
public entry fun recombine_stable_complete_set_2<AssetType, StableType, Cond0, Cond1>(
    escrow: &mut TokenEscrow<AssetType, StableType>,
    cond_0: Coin<Cond0>,
    cond_1: Coin<Cond1>,
    ctx: &mut TxContext,
) {
    let amount_0 = cond_0.value();
    let amount_1 = cond_1.value();
    assert!(amount_0 == amount_1, EInsufficientBalance);
    assert!(amount_0 > 0, EZeroAmount);

    let amount = amount_0;

    // Burn conditional stables for each outcome
    burn_conditional_stable<AssetType, StableType, Cond0>(escrow, 0, cond_0);
    burn_conditional_stable<AssetType, StableType, Cond1>(escrow, 1, cond_1);

    // Withdraw spot stable
    let spot_stable = withdraw_stable_balance(escrow, amount, ctx);

    // Transfer to sender
    transfer::public_transfer(spot_stable, ctx.sender());
}

/// For 3-outcome markets - split spot asset into complete set
public entry fun split_asset_into_complete_set_3<AssetType, StableType, Cond0, Cond1, Cond2>(
    escrow: &mut TokenEscrow<AssetType, StableType>,
    spot_asset: Coin<AssetType>,
    ctx: &mut TxContext,
) {
    let amount = spot_asset.value();
    assert!(amount > 0, EZeroAmount);

    let asset_balance = coin::into_balance(spot_asset);
    escrow.escrowed_asset.join(asset_balance);

    let cond_0 = mint_conditional_asset<AssetType, StableType, Cond0>(escrow, 0, amount, ctx);
    let cond_1 = mint_conditional_asset<AssetType, StableType, Cond1>(escrow, 1, amount, ctx);
    let cond_2 = mint_conditional_asset<AssetType, StableType, Cond2>(escrow, 2, amount, ctx);

    transfer::public_transfer(cond_0, ctx.sender());
    transfer::public_transfer(cond_1, ctx.sender());
    transfer::public_transfer(cond_2, ctx.sender());
}

/// For 3-outcome markets - recombine conditional assets into spot asset
public entry fun recombine_asset_complete_set_3<AssetType, StableType, Cond0, Cond1, Cond2>(
    escrow: &mut TokenEscrow<AssetType, StableType>,
    cond_0: Coin<Cond0>,
    cond_1: Coin<Cond1>,
    cond_2: Coin<Cond2>,
    ctx: &mut TxContext,
) {
    let amount_0 = cond_0.value();
    let amount_1 = cond_1.value();
    let amount_2 = cond_2.value();
    assert!(amount_0 == amount_1 && amount_1 == amount_2, EInsufficientBalance);
    assert!(amount_0 > 0, EZeroAmount);

    let amount = amount_0;

    burn_conditional_asset<AssetType, StableType, Cond0>(escrow, 0, cond_0);
    burn_conditional_asset<AssetType, StableType, Cond1>(escrow, 1, cond_1);
    burn_conditional_asset<AssetType, StableType, Cond2>(escrow, 2, cond_2);

    let spot_asset = withdraw_asset_balance(escrow, amount, ctx);
    transfer::public_transfer(spot_asset, ctx.sender());
}
/// Keeper-cranked liquidity subsidy system for conditional AMMs
///
/// Architecture:
/// 1. DAO config specifies subsidy amount per proposal (in stable tokens)
/// 2. Protocol config specifies crank steps and keeper fee
/// 3. When proposal enters trading, create SubsidyEscrow with stable coins from DAO
/// 4. Keepers crank portions of subsidy into conditional AMMs over time
/// 5. Each crank adds reserves proportionally (not as LP) to all conditional AMMs
/// 6. Keeper receives fee (1% × outcome_count) per crank
///
/// Security:
/// - Escrow tracks proposal_id and amm_ids to prevent cranking wrong markets
/// - Only during trading period (before finalization)
/// - Gradual drip prevents MEV/manipulation
module futarchy_markets::liquidity_subsidy;

use std::option::{Self, Option};
use sui::object::{Self, UID, ID};
use sui::balance::{Self, Balance};
use sui::coin::{Self, Coin};
use sui::clock::{Self, Clock};
use sui::tx_context::{Self, TxContext};
use sui::transfer;
use sui::event;
use futarchy_markets::conditional_amm::{Self, LiquidityPool};
use futarchy_markets::simple_twap;
use futarchy_one_shot_utils::math;

// === Errors ===
const ESubsidyExhausted: u64 = 0;           // All cranks completed
const EProposalMismatch: u64 = 1;           // Escrow not for this proposal
const EAmmMismatch: u64 = 2;                // AMM ID not in escrow's tracked list
const EInsufficientBalance: u64 = 3;        // Not enough stable in escrow
const ETooEarlyCrank: u64 = 4;              // Cranking too fast (min interval not met)
const EProposalFinalized: u64 = 5;          // Cannot crank after finalization
const EInvalidConfig: u64 = 6;              // Invalid subsidy config
const EZeroSubsidy: u64 = 7;                // Subsidy amount is zero

// === Protocol Constants (could be moved to constants module) ===
const DEFAULT_CRANK_STEPS: u64 = 100;       // Default number of crank iterations
const DEFAULT_KEEPER_FEE_BPS: u64 = 100;    // 1% base keeper fee (multiplied by outcome_count)
const MIN_CRANK_INTERVAL_MS: u64 = 300_000; // 5 minutes minimum between cranks

// === Structs ===

/// Configuration for liquidity subsidy system (stored in DAO config or protocol config)
public struct SubsidyConfig has store, copy, drop {
    enabled: bool,                          // If true, subsidies are enabled for this DAO
    subsidy_amount_per_proposal: u64,       // Amount of stable to subsidize per proposal (0 = disabled)
    crank_steps: u64,                       // How many times keepers can crank (default: 100)
    keeper_fee_base_bps: u64,               // Base keeper fee in bps (multiplied by outcome_count)
    min_crank_interval_ms: u64,             // Minimum time between cranks
}

/// Escrow holding stable coins for gradual subsidy dripping
/// Created when proposal enters trading state
public struct SubsidyEscrow<phantom StableType> has key, store {
    id: UID,
    proposal_id: ID,                        // Which proposal this subsidizes
    amm_ids: vector<ID>,                    // Allowed AMM IDs (security check)
    stable_balance: Balance<StableType>,    // Stable coins to drip feed
    total_subsidy: u64,                     // Original subsidy amount
    cranks_completed: u64,                  // How many cranks done
    total_cranks: u64,                      // Total cranks allowed
    keeper_fee_base_bps: u64,               // Base keeper fee (× outcome_count)
    last_crank_time: Option<u64>,          // Last crank timestamp (for rate limiting)
    finalized: bool,                        // If true, no more cranks allowed
}

// === Events ===

/// Emitted when subsidy escrow is created
public struct SubsidyEscrowCreated has copy, drop {
    escrow_id: ID,
    proposal_id: ID,
    total_subsidy: u64,
    total_cranks: u64,
    outcome_count: u64,
}

/// Emitted when keeper cranks subsidy into AMMs
public struct SubsidyCranked has copy, drop {
    escrow_id: ID,
    proposal_id: ID,
    crank_number: u64,
    total_cranks: u64,
    amount_per_amm: u64,
    outcome_count: u64,
    keeper_fee: u64,
    keeper: address,
    timestamp: u64,
}

/// Emitted when subsidy escrow is finalized (all cranks done or proposal ended)
public struct SubsidyFinalized has copy, drop {
    escrow_id: ID,
    proposal_id: ID,
    cranks_completed: u64,
    remaining_balance: u64,
}

// === Public Functions ===

/// Create default subsidy config (disabled)
public fun new_subsidy_config(): SubsidyConfig {
    SubsidyConfig {
        enabled: false,
        subsidy_amount_per_proposal: 0,
        crank_steps: DEFAULT_CRANK_STEPS,
        keeper_fee_base_bps: DEFAULT_KEEPER_FEE_BPS,
        min_crank_interval_ms: MIN_CRANK_INTERVAL_MS,
    }
}

/// Create custom subsidy config
public fun new_subsidy_config_custom(
    enabled: bool,
    subsidy_amount_per_proposal: u64,
    crank_steps: u64,
    keeper_fee_base_bps: u64,
    min_crank_interval_ms: u64,
): SubsidyConfig {
    assert!(crank_steps > 0, EInvalidConfig);
    assert!(keeper_fee_base_bps <= 10000, EInvalidConfig); // Max 100% base fee

    SubsidyConfig {
        enabled,
        subsidy_amount_per_proposal,
        crank_steps,
        keeper_fee_base_bps,
        min_crank_interval_ms,
    }
}

// === Getters for SubsidyConfig ===
public fun subsidy_enabled(config: &SubsidyConfig): bool { config.enabled }
public fun subsidy_amount_per_proposal(config: &SubsidyConfig): u64 { config.subsidy_amount_per_proposal }
public fun crank_steps(config: &SubsidyConfig): u64 { config.crank_steps }
public fun keeper_fee_base_bps(config: &SubsidyConfig): u64 { config.keeper_fee_base_bps }
public fun min_crank_interval_ms(config: &SubsidyConfig): u64 { config.min_crank_interval_ms }

// === Getters for SubsidyEscrow ===
public fun escrow_proposal_id<StableType>(escrow: &SubsidyEscrow<StableType>): ID { escrow.proposal_id }
public fun escrow_total_subsidy<StableType>(escrow: &SubsidyEscrow<StableType>): u64 { escrow.total_subsidy }
public fun escrow_cranks_completed<StableType>(escrow: &SubsidyEscrow<StableType>): u64 { escrow.cranks_completed }
public fun escrow_total_cranks<StableType>(escrow: &SubsidyEscrow<StableType>): u64 { escrow.total_cranks }
public fun escrow_remaining_balance<StableType>(escrow: &SubsidyEscrow<StableType>): u64 { escrow.stable_balance.value() }
public fun escrow_is_finalized<StableType>(escrow: &SubsidyEscrow<StableType>): bool { escrow.finalized }

/// Create subsidy escrow when proposal enters trading
/// Called by proposal lifecycle when transitioning to TRADING state
///
/// ## Arguments
/// - `proposal_id`: ID of the proposal being subsidized
/// - `amm_ids`: Vector of conditional AMM IDs (for security validation)
/// - `stable_coins`: Stable coins from DAO treasury
/// - `config`: Subsidy configuration (crank steps, keeper fee, etc.)
/// - `ctx`: Transaction context
public fun create_escrow<StableType>(
    proposal_id: ID,
    amm_ids: vector<ID>,
    stable_coins: Coin<StableType>,
    config: &SubsidyConfig,
    ctx: &mut TxContext,
): SubsidyEscrow<StableType> {
    let total_subsidy = stable_coins.value();
    assert!(total_subsidy > 0, EZeroSubsidy);

    let escrow_id = object::new(ctx);
    let outcome_count = amm_ids.length();

    // Emit creation event
    event::emit(SubsidyEscrowCreated {
        escrow_id: object::uid_to_inner(&escrow_id),
        proposal_id,
        total_subsidy,
        total_cranks: config.crank_steps,
        outcome_count,
    });

    SubsidyEscrow<StableType> {
        id: escrow_id,
        proposal_id,
        amm_ids,
        stable_balance: coin::into_balance(stable_coins),
        total_subsidy,
        cranks_completed: 0,
        total_cranks: config.crank_steps,
        keeper_fee_base_bps: config.keeper_fee_base_bps,
        last_crank_time: option::none(),
        finalized: false,
    }
}

/// Crank subsidy into conditional AMMs (permissionless keeper function)
///
/// ## Flow:
/// 1. Verify escrow matches proposal and AMMs
/// 2. Calculate crank amount (remaining_balance / remaining_cranks)
/// 3. Calculate keeper fee (1% × outcome_count of crank amount)
/// 4. Split remaining stable equally across all conditional AMMs
/// 5. Add to each AMM's reserves proportionally (maintains price)
/// 6. Pay keeper fee
/// 7. Update escrow state
///
/// ## Arguments
/// - `escrow`: Subsidy escrow to crank from
/// - `proposal_id`: Proposal ID (security check)
/// - `conditional_pools`: Vector of conditional AMM pools (must match escrow.amm_ids)
/// - `clock`: For timestamp and rate limiting
/// - `ctx`: Transaction context (to pay keeper)
///
/// ## Returns
/// - Keeper fee coin
public fun crank_subsidy<AssetType, StableType>(
    escrow: &mut SubsidyEscrow<StableType>,
    proposal_id: ID,
    conditional_pools: &mut vector<LiquidityPool>,
    clock: &Clock,
    ctx: &mut TxContext,
): Coin<StableType> {
    // Security checks
    assert!(escrow.proposal_id == proposal_id, EProposalMismatch);
    assert!(!escrow.finalized, EProposalFinalized);
    assert!(escrow.cranks_completed < escrow.total_cranks, ESubsidyExhausted);

    // Rate limiting: ensure minimum interval between cranks
    let now = clock.timestamp_ms();
    if (escrow.last_crank_time.is_some()) {
        let last_crank = *escrow.last_crank_time.borrow();
        let min_interval = MIN_CRANK_INTERVAL_MS; // Could use escrow.min_crank_interval_ms if stored
        assert!(now >= last_crank + min_interval, ETooEarlyCrank);
    };

    // Verify AMM IDs match escrow
    let outcome_count = conditional_pools.length();
    assert!(outcome_count == escrow.amm_ids.length(), EAmmMismatch);

    let mut i = 0;
    while (i < outcome_count) {
        let pool = vector::borrow(conditional_pools, i);
        let pool_id = conditional_amm::get_id(pool);
        let expected_id = *vector::borrow(&escrow.amm_ids, i);
        assert!(pool_id == expected_id, EAmmMismatch);
        i = i + 1;
    };

    // Calculate crank amount (evenly distribute remaining balance across remaining cranks)
    let remaining_cranks = escrow.total_cranks - escrow.cranks_completed;
    let crank_amount = escrow.stable_balance.value() / remaining_cranks;
    assert!(crank_amount > 0, EInsufficientBalance);

    // Calculate keeper fee: base_fee_bps × outcome_count
    // Example: 1% base × 2 outcomes = 2% total keeper fee
    let keeper_fee_bps = escrow.keeper_fee_base_bps * outcome_count;
    let keeper_fee = math::mul_div_to_64(crank_amount, keeper_fee_bps, 10000);

    // Amount to distribute to AMMs (after keeper fee)
    let subsidy_amount = crank_amount - keeper_fee;

    // Split subsidy equally across all conditional AMMs
    let amount_per_amm = subsidy_amount / outcome_count;

    // Add to each conditional AMM's reserves proportionally
    let mut j = 0;
    while (j < outcome_count) {
        let pool = vector::borrow_mut(conditional_pools, j);

        // Add reserves proportionally to maintain current price
        inject_subsidy_proportional(pool, amount_per_amm, clock);

        j = j + 1;
    };

    // Update escrow state
    escrow.cranks_completed = escrow.cranks_completed + 1;
    escrow.last_crank_time = option::some(now);

    // Extract keeper fee from escrow
    let keeper_fee_balance = escrow.stable_balance.split(keeper_fee);

    // Extract subsidy amount that was distributed
    let subsidy_balance = escrow.stable_balance.split(subsidy_amount);
    subsidy_balance.destroy_zero(); // We already added it to pools, just accounting

    // Emit crank event
    event::emit(SubsidyCranked {
        escrow_id: object::uid_to_inner(&escrow.id),
        proposal_id: escrow.proposal_id,
        crank_number: escrow.cranks_completed,
        total_cranks: escrow.total_cranks,
        amount_per_amm,
        outcome_count,
        keeper_fee,
        keeper: tx_context::sender(ctx),
        timestamp: now,
    });

    // Return keeper fee
    coin::from_balance(keeper_fee_balance, ctx)
}

/// Finalize escrow (after proposal ends or all cranks completed)
/// Returns remaining balance to DAO treasury
public fun finalize_escrow<StableType>(
    escrow: &mut SubsidyEscrow<StableType>,
    ctx: &mut TxContext,
): Coin<StableType> {
    assert!(!escrow.finalized, EProposalFinalized);

    escrow.finalized = true;
    let remaining = escrow.stable_balance.value();

    // Emit finalization event
    event::emit(SubsidyFinalized {
        escrow_id: object::uid_to_inner(&escrow.id),
        proposal_id: escrow.proposal_id,
        cranks_completed: escrow.cranks_completed,
        remaining_balance: remaining,
    });

    // Extract all remaining balance
    let remaining_balance = escrow.stable_balance.withdraw_all();
    coin::from_balance(remaining_balance, ctx)
}

/// Destroy escrow (only after finalization)
public fun destroy_escrow<StableType>(escrow: SubsidyEscrow<StableType>) {
    let SubsidyEscrow {
        id,
        proposal_id: _,
        amm_ids: _,
        stable_balance,
        total_subsidy: _,
        cranks_completed: _,
        total_cranks: _,
        keeper_fee_base_bps: _,
        last_crank_time: _,
        finalized,
    } = escrow;

    assert!(finalized, EProposalFinalized);
    assert!(stable_balance.value() == 0, EInsufficientBalance);

    stable_balance.destroy_zero();
    object::delete(id);
}

// === Internal Helper Functions ===

/// Inject subsidy proportionally into conditional AMM reserves
/// Maintains current price ratio to avoid manipulation
///
/// CRITICAL: Must add proportionally to both reserves to maintain price!
fun inject_subsidy_proportional(
    pool: &mut LiquidityPool,
    total_subsidy: u64,
    clock: &Clock,
) {
    // Get current reserves
    let (asset_reserve, stable_reserve) = conditional_amm::get_reserves(pool);
    let total_reserves = asset_reserve + stable_reserve;

    // Calculate proportional split (maintains current price ratio)
    let stable_ratio = math::mul_div_to_64(stable_reserve, 1_000_000, total_reserves);

    let stable_add = math::mul_div_to_64(total_subsidy, stable_ratio, 1_000_000);
    let asset_add = total_subsidy - stable_add;

    // Add to reserves (directly mutates pool state)
    // Note: This increases k, benefiting existing LPs
    conditional_amm::add_subsidy_to_reserves(pool, asset_add, stable_add);

    // Update TWAP observation after reserve change
    conditional_amm::update_twap_observation(pool, clock);
}

// === Entry Functions ===

/// Entry function: Create subsidy escrow and share
public entry fun create_and_share_escrow<StableType>(
    proposal_id: ID,
    amm_ids: vector<ID>,
    stable_coins: Coin<StableType>,
    crank_steps: u64,
    keeper_fee_base_bps: u64,
    ctx: &mut TxContext,
) {
    let config = new_subsidy_config_custom(
        true,
        stable_coins.value(),
        crank_steps,
        keeper_fee_base_bps,
        MIN_CRANK_INTERVAL_MS,
    );

    let escrow = create_escrow(
        proposal_id,
        amm_ids,
        stable_coins,
        &config,
        ctx,
    );

    transfer::share_object(escrow);
}

/// Entry function: Crank subsidy (keeper calls this)
public entry fun crank_subsidy_entry<AssetType, StableType>(
    escrow: &mut SubsidyEscrow<StableType>,
    proposal_id: ID,
    conditional_pools: &mut vector<LiquidityPool>,
    clock: &Clock,
    ctx: &mut TxContext,
) {
    let keeper_fee_coin = crank_subsidy<AssetType, StableType>(
        escrow,
        proposal_id,
        conditional_pools,
        clock,
        ctx,
    );

    // Transfer keeper fee to caller
    transfer::public_transfer(keeper_fee_coin, tx_context::sender(ctx));
}

/// Entry function: Finalize escrow and return remaining to sender
public entry fun finalize_escrow_entry<StableType>(
    escrow: &mut SubsidyEscrow<StableType>,
    ctx: &mut TxContext,
) {
    let remaining_coin = finalize_escrow(escrow, ctx);
    transfer::public_transfer(remaining_coin, tx_context::sender(ctx));
}

// === Test-Only Functions ===

#[test_only]
public fun create_test_escrow<StableType>(
    proposal_id: ID,
    amm_ids: vector<ID>,
    total_subsidy: u64,
    total_cranks: u64,
    ctx: &mut TxContext,
): SubsidyEscrow<StableType> {
    SubsidyEscrow<StableType> {
        id: object::new(ctx),
        proposal_id,
        amm_ids,
        stable_balance: balance::create_for_testing(total_subsidy),
        total_subsidy,
        cranks_completed: 0,
        total_cranks,
        keeper_fee_base_bps: DEFAULT_KEEPER_FEE_BPS,
        last_crank_time: option::none(),
        finalized: false,
    }
}

#[test_only]
public fun destroy_test_escrow<StableType>(escrow: SubsidyEscrow<StableType>) {
    let SubsidyEscrow {
        id,
        proposal_id: _,
        amm_ids: _,
        stable_balance,
        total_subsidy: _,
        cranks_completed: _,
        total_cranks: _,
        keeper_fee_base_bps: _,
        last_crank_time: _,
        finalized: _,
    } = escrow;

    balance::destroy_for_testing(stable_balance);
    object::delete(id);
}
/// Protocol-level liquidity subsidy system for conditional AMMs
///
/// Architecture:
/// - Protocol config: X SUI per outcome per crank
/// - Total subsidy = X × outcome_count × crank_steps
/// - Funded from DAO treasury when proposal enters TRADING
/// - Keepers crank portions into conditional AMMs over time
/// - Remaining balance returns to treasury when finalized
///
/// Economics Example:
/// - Protocol config: 0.01 SUI per outcome per crank
/// - Proposal: 2 outcomes, 100 cranks
/// - Total subsidy: 0.01 × 2 × 100 = 2 SUI from treasury
/// - Keeper fee: 0.1 SUI per crank (flat)
/// - Per crank: (2 SUI / 100) - 0.1 SUI = -0.08 SUI ❌ TOO LOW!
/// - Better config: 0.1 SUI per outcome per crank
/// - Total: 0.1 × 2 × 100 = 20 SUI
/// - Per crank: (20 / 100) - 0.1 = 0.1 SUI to AMMs ✅
///
/// Security:
/// - Escrow tracks proposal_id and amm_ids to prevent cranking wrong markets
/// - Only during trading period (before finalization)
/// - Gradual drip prevents MEV/manipulation
module futarchy_markets::liquidity_subsidy_protocol;

use std::option::{Self, Option};
use sui::object::{Self, UID, ID};
use sui::balance::{Self, Balance};
use sui::coin::{Self, Coin};
use sui::clock::{Self, Clock};
use sui::tx_context::{Self, TxContext};
use sui::sui::SUI;
use sui::transfer;
use sui::event;
use futarchy_markets::conditional_amm::{Self, LiquidityPool};
use futarchy_one_shot_utils::math;

// === Errors ===
const ESubsidyExhausted: u64 = 0;           // All cranks completed
const EProposalMismatch: u64 = 1;           // Escrow not for this proposal
const EAmmMismatch: u64 = 2;                // AMM ID not in escrow's tracked list
const EInsufficientBalance: u64 = 3;        // Not enough SUI in escrow
const ETooEarlyCrank: u64 = 4;              // Cranking too fast (min interval not met)
const EProposalFinalized: u64 = 5;          // Cannot crank after finalization
const EInvalidConfig: u64 = 6;              // Invalid subsidy config
const EZeroSubsidy: u64 = 7;                // Subsidy amount is zero

// === Protocol Constants ===
const DEFAULT_CRANK_STEPS: u64 = 100;                       // Default number of crank iterations
const DEFAULT_SUBSIDY_PER_OUTCOME_PER_CRANK: u64 = 100_000_000;  // 0.1 SUI per outcome per crank
const DEFAULT_KEEPER_FEE_PER_CRANK: u64 = 100_000_000;      // 0.1 SUI per crank (flat)
const MIN_CRANK_INTERVAL_MS: u64 = 300_000;                 // 5 minutes minimum between cranks

// === Structs ===

/// Protocol-level configuration for liquidity subsidy system
/// Typically stored in protocol admin registry or DAO config
public struct ProtocolSubsidyConfig has store, copy, drop {
    enabled: bool,                              // If true, subsidies are enabled
    subsidy_per_outcome_per_crank: u64,         // SUI amount per outcome per crank
    crank_steps: u64,                           // Total cranks allowed (default: 100)
    keeper_fee_per_crank: u64,                  // Flat SUI fee per crank (default: 0.1 SUI)
    min_crank_interval_ms: u64,                 // Minimum time between cranks
}

/// Escrow holding DAO treasury funds for gradual subsidy dripping
/// Created when proposal enters trading state
public struct SubsidyEscrow has key, store {
    id: UID,
    proposal_id: ID,                            // Which proposal this subsidizes
    dao_id: ID,                                 // Which DAO this belongs to (for refund)
    amm_ids: vector<ID>,                        // Allowed AMM IDs (security check)
    subsidy_balance: Balance<SUI>,              // DAO treasury funds to drip feed
    total_subsidy: u64,                         // Original treasury amount
    cranks_completed: u64,                      // How many cranks done
    total_cranks: u64,                          // Total cranks allowed
    keeper_fee_per_crank: u64,                  // Flat keeper fee
    last_crank_time: Option<u64>,              // Last crank timestamp (for rate limiting)
    finalized: bool,                            // If true, no more cranks allowed
}

// === Events ===

/// Emitted when subsidy escrow is created
public struct SubsidyEscrowCreated has copy, drop {
    escrow_id: ID,
    proposal_id: ID,
    dao_id: ID,
    total_subsidy: u64,
    total_cranks: u64,
    outcome_count: u64,
    subsidy_per_outcome_per_crank: u64,
}

/// Emitted when keeper cranks subsidy into AMMs
public struct SubsidyCranked has copy, drop {
    escrow_id: ID,
    proposal_id: ID,
    crank_number: u64,
    total_cranks: u64,
    subsidy_distributed: u64,       // Amount added to AMMs (after keeper fee)
    amount_per_amm: u64,
    outcome_count: u64,
    keeper_fee: u64,
    keeper: address,
    timestamp: u64,
}

/// Emitted when escrow is finalized (returns remainder to treasury)
public struct SubsidyFinalized has copy, drop {
    escrow_id: ID,
    proposal_id: ID,
    dao_id: ID,
    cranks_completed: u64,
    remaining_balance: u64,         // Returned to DAO treasury
    timestamp: u64,
}

// === Public Functions ===

/// Create default protocol subsidy config (enabled with sensible defaults)
public fun new_protocol_config(): ProtocolSubsidyConfig {
    ProtocolSubsidyConfig {
        enabled: true,
        subsidy_per_outcome_per_crank: DEFAULT_SUBSIDY_PER_OUTCOME_PER_CRANK,
        crank_steps: DEFAULT_CRANK_STEPS,
        keeper_fee_per_crank: DEFAULT_KEEPER_FEE_PER_CRANK,
        min_crank_interval_ms: MIN_CRANK_INTERVAL_MS,
    }
}

/// Create custom protocol subsidy config
public fun new_protocol_config_custom(
    enabled: bool,
    subsidy_per_outcome_per_crank: u64,
    crank_steps: u64,
    keeper_fee_per_crank: u64,
    min_crank_interval_ms: u64,
): ProtocolSubsidyConfig {
    assert!(crank_steps > 0, EInvalidConfig);

    ProtocolSubsidyConfig {
        enabled,
        subsidy_per_outcome_per_crank,
        crank_steps,
        keeper_fee_per_crank,
        min_crank_interval_ms,
    }
}

/// Calculate total subsidy needed for a proposal
/// Formula: subsidy_per_outcome_per_crank × outcome_count × crank_steps
public fun calculate_total_subsidy(
    config: &ProtocolSubsidyConfig,
    outcome_count: u64,
): u64 {
    config.subsidy_per_outcome_per_crank * outcome_count * config.crank_steps
}

// === Getters for ProtocolSubsidyConfig ===
public fun protocol_enabled(config: &ProtocolSubsidyConfig): bool { config.enabled }
public fun subsidy_per_outcome_per_crank(config: &ProtocolSubsidyConfig): u64 { config.subsidy_per_outcome_per_crank }
public fun crank_steps(config: &ProtocolSubsidyConfig): u64 { config.crank_steps }
public fun keeper_fee_per_crank(config: &ProtocolSubsidyConfig): u64 { config.keeper_fee_per_crank }
public fun min_crank_interval_ms(config: &ProtocolSubsidyConfig): u64 { config.min_crank_interval_ms }

// === Getters for SubsidyEscrow ===
public fun escrow_proposal_id(escrow: &SubsidyEscrow): ID { escrow.proposal_id }
public fun escrow_dao_id(escrow: &SubsidyEscrow): ID { escrow.dao_id }
public fun escrow_total_subsidy(escrow: &SubsidyEscrow): u64 { escrow.total_subsidy }
public fun escrow_cranks_completed(escrow: &SubsidyEscrow): u64 { escrow.cranks_completed }
public fun escrow_total_cranks(escrow: &SubsidyEscrow): u64 { escrow.total_cranks }
public fun escrow_remaining_balance(escrow: &SubsidyEscrow): u64 { escrow.subsidy_balance.value() }
public fun escrow_is_finalized(escrow: &SubsidyEscrow): bool { escrow.finalized }

// === Setters for ProtocolSubsidyConfig (protocol admin only) ===
public fun set_enabled(config: &mut ProtocolSubsidyConfig, enabled: bool) {
    config.enabled = enabled;
}

public fun set_subsidy_per_outcome_per_crank(config: &mut ProtocolSubsidyConfig, amount: u64) {
    config.subsidy_per_outcome_per_crank = amount;
}

public fun set_crank_steps(config: &mut ProtocolSubsidyConfig, steps: u64) {
    assert!(steps > 0, EInvalidConfig);
    config.crank_steps = steps;
}

public fun set_keeper_fee_per_crank(config: &mut ProtocolSubsidyConfig, fee: u64) {
    config.keeper_fee_per_crank = fee;
}

public fun set_min_crank_interval_ms(config: &mut ProtocolSubsidyConfig, interval: u64) {
    config.min_crank_interval_ms = interval;
}

/// Create subsidy escrow when proposal enters trading
/// Called by proposal lifecycle when transitioning to TRADING state
/// Withdraws from DAO treasury based on protocol config
///
/// ## Arguments
/// - `proposal_id`: ID of the proposal being subsidized
/// - `dao_id`: ID of the DAO (for refund tracking)
/// - `amm_ids`: Vector of conditional AMM IDs (for security validation)
/// - `treasury_coins`: Coins from DAO treasury (calculated amount)
/// - `config`: Protocol subsidy configuration
/// - `ctx`: Transaction context
public fun create_escrow(
    proposal_id: ID,
    dao_id: ID,
    amm_ids: vector<ID>,
    treasury_coins: Coin<SUI>,
    config: &ProtocolSubsidyConfig,
    ctx: &mut TxContext,
): SubsidyEscrow {
    let total_subsidy = treasury_coins.value();
    assert!(total_subsidy > 0, EZeroSubsidy);

    let escrow_id = object::new(ctx);
    let outcome_count = amm_ids.length();

    // Validate subsidy amount matches expected
    let expected_subsidy = calculate_total_subsidy(config, outcome_count);
    assert!(total_subsidy == expected_subsidy, EInvalidConfig);

    // Emit creation event
    event::emit(SubsidyEscrowCreated {
        escrow_id: object::uid_to_inner(&escrow_id),
        proposal_id,
        dao_id,
        total_subsidy,
        total_cranks: config.crank_steps,
        outcome_count,
        subsidy_per_outcome_per_crank: config.subsidy_per_outcome_per_crank,
    });

    SubsidyEscrow {
        id: escrow_id,
        proposal_id,
        dao_id,
        amm_ids,
        subsidy_balance: coin::into_balance(treasury_coins),
        total_subsidy,
        cranks_completed: 0,
        total_cranks: config.crank_steps,
        keeper_fee_per_crank: config.keeper_fee_per_crank,
        last_crank_time: option::none(),
        finalized: false,
    }
}

/// Crank subsidy into conditional AMMs (permissionless keeper function)
///
/// ## Flow:
/// 1. Verify escrow matches proposal and AMMs
/// 2. Calculate crank amount (remaining_balance / remaining_cranks)
/// 3. Calculate keeper fee (flat 0.1 SUI per crank)
/// 4. Split remaining SUI equally across all conditional AMMs
/// 5. Add to each AMM's reserves proportionally (maintains price)
/// 6. Pay keeper fee
/// 7. Update escrow state
///
/// ## Arguments
/// - `escrow`: Subsidy escrow to crank from
/// - `proposal_id`: Proposal ID (security check)
/// - `conditional_pools`: Vector of conditional AMM pools (must match escrow.amm_ids)
/// - `clock`: For timestamp and rate limiting
/// - `ctx`: Transaction context (to pay keeper)
///
/// ## Returns
/// - Keeper fee coin
public fun crank_subsidy(
    escrow: &mut SubsidyEscrow,
    proposal_id: ID,
    conditional_pools: &mut vector<LiquidityPool>,
    clock: &Clock,
    ctx: &mut TxContext,
): Coin<SUI> {
    // Security checks
    assert!(escrow.proposal_id == proposal_id, EProposalMismatch);
    assert!(!escrow.finalized, EProposalFinalized);
    assert!(escrow.cranks_completed < escrow.total_cranks, ESubsidyExhausted);

    // Rate limiting: ensure minimum interval between cranks
    let now = clock.timestamp_ms();
    if (escrow.last_crank_time.is_some()) {
        let last_crank = *escrow.last_crank_time.borrow();
        assert!(now >= last_crank + MIN_CRANK_INTERVAL_MS, ETooEarlyCrank);
    };

    // Verify AMM IDs match escrow
    let outcome_count = conditional_pools.length();
    assert!(outcome_count == escrow.amm_ids.length(), EAmmMismatch);

    let mut i = 0;
    while (i < outcome_count) {
        let pool = vector::borrow(conditional_pools, i);
        let pool_id = conditional_amm::get_id(pool);
        let expected_id = *vector::borrow(&escrow.amm_ids, i);
        assert!(pool_id == expected_id, EAmmMismatch);
        i = i + 1;
    };

    // Calculate crank amount (evenly distribute remaining balance across remaining cranks)
    let remaining_cranks = escrow.total_cranks - escrow.cranks_completed;
    let current_balance = escrow.subsidy_balance.value();
    let crank_amount = current_balance / remaining_cranks;
    assert!(crank_amount > 0, EInsufficientBalance);

    // Calculate keeper fee: FLAT per crank (0.1 SUI default)
    // This is correct because keeper does ONE transaction for ALL AMMs
    let keeper_fee = math::min(escrow.keeper_fee_per_crank, crank_amount);

    // Amount to distribute to AMMs (after keeper fee)
    let subsidy_amount = crank_amount - keeper_fee;

    // Split subsidy equally across all conditional AMMs
    let amount_per_amm = subsidy_amount / outcome_count;

    // Add to each conditional AMM's reserves proportionally
    let mut j = 0;
    while (j < outcome_count) {
        let pool = vector::borrow_mut(conditional_pools, j);

        // Add reserves proportionally to maintain current price
        inject_subsidy_proportional(pool, amount_per_amm, clock);

        j = j + 1;
    };

    // Update escrow state
    escrow.cranks_completed = escrow.cranks_completed + 1;
    escrow.last_crank_time = option::some(now);

    // Extract keeper fee from escrow
    let keeper_fee_balance = escrow.subsidy_balance.split(keeper_fee);

    // Extract subsidy amount that was distributed
    let subsidy_balance = escrow.subsidy_balance.split(subsidy_amount);
    subsidy_balance.destroy_zero(); // We already added it to pools, just accounting

    // Emit crank event
    event::emit(SubsidyCranked {
        escrow_id: object::uid_to_inner(&escrow.id),
        proposal_id: escrow.proposal_id,
        crank_number: escrow.cranks_completed,
        total_cranks: escrow.total_cranks,
        subsidy_distributed: subsidy_amount,
        amount_per_amm,
        outcome_count,
        keeper_fee,
        keeper: tx_context::sender(ctx),
        timestamp: now,
    });

    // Return keeper fee
    coin::from_balance(keeper_fee_balance, ctx)
}

/// Finalize escrow and return remaining balance to DAO treasury
/// Called after proposal ends (win or lose)
public fun finalize_escrow(
    escrow: &mut SubsidyEscrow,
    clock: &Clock,
    ctx: &mut TxContext,
): Coin<SUI> {
    assert!(!escrow.finalized, EProposalFinalized);

    escrow.finalized = true;
    let remaining = escrow.subsidy_balance.value();

    // Emit finalization event
    event::emit(SubsidyFinalized {
        escrow_id: object::uid_to_inner(&escrow.id),
        proposal_id: escrow.proposal_id,
        dao_id: escrow.dao_id,
        cranks_completed: escrow.cranks_completed,
        remaining_balance: remaining,
        timestamp: clock.timestamp_ms(),
    });

    // Extract all remaining balance (return to DAO treasury)
    let remaining_balance = escrow.subsidy_balance.withdraw_all();
    coin::from_balance(remaining_balance, ctx)
}

/// Destroy escrow (only after finalization)
public fun destroy_escrow(escrow: SubsidyEscrow) {
    let SubsidyEscrow {
        id,
        proposal_id: _,
        dao_id: _,
        amm_ids: _,
        subsidy_balance,
        total_subsidy: _,
        cranks_completed: _,
        total_cranks: _,
        keeper_fee_per_crank: _,
        last_crank_time: _,
        finalized,
    } = escrow;

    assert!(finalized, EProposalFinalized);
    assert!(subsidy_balance.value() == 0, EInsufficientBalance);

    subsidy_balance.destroy_zero();
    object::delete(id);
}

// === Internal Helper Functions ===

/// Inject subsidy proportionally into conditional AMM reserves
/// Maintains current price ratio to avoid manipulation
///
/// CRITICAL: Must add proportionally to both reserves to maintain price!
fun inject_subsidy_proportional(
    pool: &mut LiquidityPool,
    total_subsidy: u64,
    clock: &Clock,
) {
    // Get current reserves
    let (asset_reserve, stable_reserve) = conditional_amm::get_reserves(pool);
    let total_reserves = asset_reserve + stable_reserve;

    // Calculate proportional split (maintains current price ratio)
    let stable_ratio = math::mul_div_to_64(stable_reserve, 1_000_000, total_reserves);

    let stable_add = math::mul_div_to_64(total_subsidy, stable_ratio, 1_000_000);
    let asset_add = total_subsidy - stable_add;

    // Add to reserves (directly mutates pool state)
    // Note: This increases k, benefiting existing LPs
    conditional_amm::add_subsidy_to_reserves(pool, asset_add, stable_add);

    // Update TWAP observation after reserve change
    conditional_amm::update_twap_observation(pool, clock);
}

// === Entry Functions ===

/// Entry function: Create subsidy escrow and share
public entry fun create_and_share_escrow(
    proposal_id: ID,
    dao_id: ID,
    amm_ids: vector<ID>,
    treasury_coins: Coin<SUI>,
    subsidy_per_outcome_per_crank: u64,
    crank_steps: u64,
    keeper_fee_per_crank: u64,
    ctx: &mut TxContext,
) {
    let config = new_protocol_config_custom(
        true,
        subsidy_per_outcome_per_crank,
        crank_steps,
        keeper_fee_per_crank,
        MIN_CRANK_INTERVAL_MS,
    );

    let escrow = create_escrow(
        proposal_id,
        dao_id,
        amm_ids,
        treasury_coins,
        &config,
        ctx,
    );

    transfer::share_object(escrow);
}

/// Entry function: Crank subsidy (keeper calls this)
public entry fun crank_subsidy_entry(
    escrow: &mut SubsidyEscrow,
    proposal_id: ID,
    conditional_pools: &mut vector<LiquidityPool>,
    clock: &Clock,
    ctx: &mut TxContext,
) {
    let keeper_fee_coin = crank_subsidy(
        escrow,
        proposal_id,
        conditional_pools,
        clock,
        ctx,
    );

    // Transfer keeper fee to caller
    transfer::public_transfer(keeper_fee_coin, tx_context::sender(ctx));
}

/// Entry function: Finalize and return remainder to DAO treasury
public entry fun finalize_escrow_entry(
    escrow: &mut SubsidyEscrow,
    clock: &Clock,
    ctx: &mut TxContext,
) {
    let remaining_coin = finalize_escrow(escrow, clock, ctx);

    // Transfer to DAO treasury (caller must be authorized)
    // In production, verify caller has permission to receive DAO funds
    transfer::public_transfer(remaining_coin, tx_context::sender(ctx));
}

// === Test-Only Functions ===

#[test_only]
public fun create_test_escrow(
    proposal_id: ID,
    dao_id: ID,
    amm_ids: vector<ID>,
    total_subsidy: u64,
    total_cranks: u64,
    ctx: &mut TxContext,
): SubsidyEscrow {
    SubsidyEscrow {
        id: object::new(ctx),
        proposal_id,
        dao_id,
        amm_ids,
        subsidy_balance: balance::create_for_testing(total_subsidy),
        total_subsidy,
        cranks_completed: 0,
        total_cranks,
        keeper_fee_per_crank: DEFAULT_KEEPER_FEE_PER_CRANK,
        last_crank_time: option::none(),
        finalized: false,
    }
}

#[test_only]
public fun destroy_test_escrow(escrow: SubsidyEscrow) {
    let SubsidyEscrow {
        id,
        proposal_id: _,
        dao_id: _,
        amm_ids: _,
        subsidy_balance,
        total_subsidy: _,
        cranks_completed: _,
        total_cranks: _,
        keeper_fee_per_crank: _,
        last_crank_time: _,
        finalized: _,
    } = escrow;

    balance::destroy_for_testing(subsidy_balance);
    object::delete(id);
}
/// Proposer-fee-funded liquidity subsidy system for conditional AMMs
///
/// Architecture:
/// 1. Proposer pays proposal fee (proposal_fee_per_outcome × outcome_count)
/// 2. Instead of going to FeeManager, fee funds SubsidyEscrow for THEIR proposal
/// 3. Keepers crank portions of subsidy into conditional AMMs over time
/// 4. If proposal PASSES: Refund remaining subsidy to proposer from DAO treasury
/// 5. If proposal FAILS: Keep subsidy (spam tax)
///
/// Economics:
/// - Proposer invests in their own proposal's market depth
/// - Good proposals get refunded (incentive alignment)
/// - Bad proposals lose fee (spam prevention)
/// - DAO treasury only pays refunds for winning proposals
///
/// Security:
/// - Escrow tracks proposal_id and amm_ids to prevent cranking wrong markets
/// - Only during trading period (before finalization)
/// - Gradual drip prevents MEV/manipulation
/// - If treasury empty, refund silently fails (proposer still pays, no grief)
module futarchy_markets::liquidity_subsidy_v2;

use std::option::{Self, Option};
use sui::object::{Self, UID, ID};
use sui::balance::{Self, Balance};
use sui::coin::{Self, Coin};
use sui::clock::{Self, Clock};
use sui::tx_context::{Self, TxContext};
use sui::sui::SUI;
use sui::transfer;
use sui::event;
use futarchy_markets::conditional_amm::{Self, LiquidityPool};
use futarchy_one_shot_utils::math;

// === Errors ===
const ESubsidyExhausted: u64 = 0;           // All cranks completed
const EProposalMismatch: u64 = 1;           // Escrow not for this proposal
const EAmmMismatch: u64 = 2;                // AMM ID not in escrow's tracked list
const EInsufficientBalance: u64 = 3;        // Not enough SUI in escrow
const ETooEarlyCrank: u64 = 4;              // Cranking too fast (min interval not met)
const EProposalFinalized: u64 = 5;          // Cannot crank after finalization
const EInvalidConfig: u64 = 6;              // Invalid subsidy config
const EZeroSubsidy: u64 = 7;                // Subsidy amount is zero
const EAlreadyRefunded: u64 = 8;            // Refund already processed

// === Protocol Constants ===
const DEFAULT_CRANK_STEPS: u64 = 100;       // Default number of crank iterations
const KEEPER_FEE_PER_CRANK_SUI: u64 = 100_000_000;  // 0.1 SUI per crank (flat fee)
const MIN_CRANK_INTERVAL_MS: u64 = 300_000; // 5 minutes minimum between cranks

// === Structs ===

/// Configuration for liquidity subsidy system (stored in DAO config)
public struct SubsidyConfig has store, copy, drop {
    enabled: bool,                          // If true, proposer fees fund subsidies
    crank_steps: u64,                       // How many times keepers can crank (default: 100)
    keeper_fee_per_crank: u64,              // Flat SUI fee per crank (default: 0.1 SUI)
    min_crank_interval_ms: u64,             // Minimum time between cranks
    refund_on_pass: bool,                   // If true, refund proposer when proposal passes
}

/// Escrow holding proposer's fee for gradual subsidy dripping
/// Created when proposal enters trading state
public struct ProposerFeeEscrow has key, store {
    id: UID,
    proposal_id: ID,                        // Which proposal this subsidizes
    proposer: address,                      // Who paid the fee (for refund)
    amm_ids: vector<ID>,                    // Allowed AMM IDs (security check)
    subsidy_balance: Balance<SUI>,          // Proposer's fee to drip feed
    total_subsidy: u64,                     // Original fee amount
    cranks_completed: u64,                  // How many cranks done
    total_cranks: u64,                      // Total cranks allowed
    keeper_fee_per_crank: u64,              // Flat keeper fee
    last_crank_time: Option<u64>,          // Last crank timestamp (for rate limiting)
    refund_processed: bool,                 // If true, refund already done
    finalized: bool,                        // If true, no more cranks allowed
}

// === Events ===

/// Emitted when proposer fee escrow is created
public struct ProposerFeeEscrowCreated has copy, drop {
    escrow_id: ID,
    proposal_id: ID,
    proposer: address,
    total_subsidy: u64,
    total_cranks: u64,
    outcome_count: u64,
}

/// Emitted when keeper cranks subsidy into AMMs
public struct SubsidyCranked has copy, drop {
    escrow_id: ID,
    proposal_id: ID,
    crank_number: u64,
    total_cranks: u64,
    subsidy_distributed: u64,       // Amount added to AMMs (after keeper fee)
    amount_per_amm: u64,
    outcome_count: u64,
    keeper_fee: u64,
    keeper: address,
    timestamp: u64,
}

/// Emitted when proposer is refunded after proposal passes
public struct ProposerRefunded has copy, drop {
    escrow_id: ID,
    proposal_id: ID,
    proposer: address,
    refund_amount: u64,             // What was refunded
    from_treasury: bool,            // True if from treasury, false if escrow remainder
    timestamp: u64,
}

/// Emitted when subsidy is finalized without refund (proposal failed)
public struct SubsidyBurned has copy, drop {
    escrow_id: ID,
    proposal_id: ID,
    burned_amount: u64,             // Fee kept as spam tax
    timestamp: u64,
}

// === Public Functions ===

/// Create default subsidy config (enabled, proposer-funded)
public fun new_subsidy_config(): SubsidyConfig {
    SubsidyConfig {
        enabled: true,
        crank_steps: DEFAULT_CRANK_STEPS,
        keeper_fee_per_crank: KEEPER_FEE_PER_CRANK_SUI,
        min_crank_interval_ms: MIN_CRANK_INTERVAL_MS,
        refund_on_pass: true,
    }
}

/// Create custom subsidy config
public fun new_subsidy_config_custom(
    enabled: bool,
    crank_steps: u64,
    keeper_fee_per_crank: u64,
    min_crank_interval_ms: u64,
    refund_on_pass: bool,
): SubsidyConfig {
    assert!(crank_steps > 0, EInvalidConfig);

    SubsidyConfig {
        enabled,
        crank_steps,
        keeper_fee_per_crank,
        min_crank_interval_ms,
        refund_on_pass,
    }
}

// === Getters for SubsidyConfig ===
public fun subsidy_enabled(config: &SubsidyConfig): bool { config.enabled }
public fun crank_steps(config: &SubsidyConfig): u64 { config.crank_steps }
public fun keeper_fee_per_crank(config: &SubsidyConfig): u64 { config.keeper_fee_per_crank }
public fun min_crank_interval_ms(config: &SubsidyConfig): u64 { config.min_crank_interval_ms }
public fun refund_on_pass(config: &SubsidyConfig): bool { config.refund_on_pass }

// === Getters for ProposerFeeEscrow ===
public fun escrow_proposal_id(escrow: &ProposerFeeEscrow): ID { escrow.proposal_id }
public fun escrow_proposer(escrow: &ProposerFeeEscrow): address { escrow.proposer }
public fun escrow_total_subsidy(escrow: &ProposerFeeEscrow): u64 { escrow.total_subsidy }
public fun escrow_cranks_completed(escrow: &ProposerFeeEscrow): u64 { escrow.cranks_completed }
public fun escrow_total_cranks(escrow: &ProposerFeeEscrow): u64 { escrow.total_cranks }
public fun escrow_remaining_balance(escrow: &ProposerFeeEscrow): u64 { escrow.subsidy_balance.value() }
public fun escrow_is_finalized(escrow: &ProposerFeeEscrow): bool { escrow.finalized }
public fun escrow_refund_processed(escrow: &ProposerFeeEscrow): bool { escrow.refund_processed }

/// Create proposer fee escrow when proposal enters trading
/// Called by proposal lifecycle when transitioning to TRADING state
///
/// ## Arguments
/// - `proposal_id`: ID of the proposal being subsidized
/// - `proposer`: Address who paid the fee (for refund)
/// - `amm_ids`: Vector of conditional AMM IDs (for security validation)
/// - `proposer_fee`: Proposer's fee (instead of going to FeeManager)
/// - `config`: Subsidy configuration (crank steps, keeper fee, etc.)
/// - `ctx`: Transaction context
public fun create_escrow(
    proposal_id: ID,
    proposer: address,
    amm_ids: vector<ID>,
    proposer_fee: Coin<SUI>,
    config: &SubsidyConfig,
    ctx: &mut TxContext,
): ProposerFeeEscrow {
    let total_subsidy = proposer_fee.value();
    assert!(total_subsidy > 0, EZeroSubsidy);

    let escrow_id = object::new(ctx);
    let outcome_count = amm_ids.length();

    // Emit creation event
    event::emit(ProposerFeeEscrowCreated {
        escrow_id: object::uid_to_inner(&escrow_id),
        proposal_id,
        proposer,
        total_subsidy,
        total_cranks: config.crank_steps,
        outcome_count,
    });

    ProposerFeeEscrow {
        id: escrow_id,
        proposal_id,
        proposer,
        amm_ids,
        subsidy_balance: coin::into_balance(proposer_fee),
        total_subsidy,
        cranks_completed: 0,
        total_cranks: config.crank_steps,
        keeper_fee_per_crank: config.keeper_fee_per_crank,
        last_crank_time: option::none(),
        refund_processed: false,
        finalized: false,
    }
}

/// Crank subsidy into conditional AMMs (permissionless keeper function)
///
/// ## Flow:
/// 1. Verify escrow matches proposal and AMMs
/// 2. Calculate crank amount (remaining_balance / remaining_cranks)
/// 3. Calculate keeper fee (flat 0.1 SUI per crank)
/// 4. Split remaining SUI equally across all conditional AMMs
/// 5. Add to each AMM's reserves proportionally (maintains price)
/// 6. Pay keeper fee
/// 7. Update escrow state
///
/// ## Arguments
/// - `escrow`: Proposer fee escrow to crank from
/// - `proposal_id`: Proposal ID (security check)
/// - `conditional_pools`: Vector of conditional AMM pools (must match escrow.amm_ids)
/// - `clock`: For timestamp and rate limiting
/// - `ctx`: Transaction context (to pay keeper)
///
/// ## Returns
/// - Keeper fee coin
public fun crank_subsidy(
    escrow: &mut ProposerFeeEscrow,
    proposal_id: ID,
    conditional_pools: &mut vector<LiquidityPool>,
    clock: &Clock,
    ctx: &mut TxContext,
): Coin<SUI> {
    // Security checks
    assert!(escrow.proposal_id == proposal_id, EProposalMismatch);
    assert!(!escrow.finalized, EProposalFinalized);
    assert!(escrow.cranks_completed < escrow.total_cranks, ESubsidyExhausted);

    // Rate limiting: ensure minimum interval between cranks
    let now = clock.timestamp_ms();
    if (escrow.last_crank_time.is_some()) {
        let last_crank = *escrow.last_crank_time.borrow();
        assert!(now >= last_crank + MIN_CRANK_INTERVAL_MS, ETooEarlyCrank);
    };

    // Verify AMM IDs match escrow
    let outcome_count = conditional_pools.length();
    assert!(outcome_count == escrow.amm_ids.length(), EAmmMismatch);

    let mut i = 0;
    while (i < outcome_count) {
        let pool = vector::borrow(conditional_pools, i);
        let pool_id = conditional_amm::get_id(pool);
        let expected_id = *vector::borrow(&escrow.amm_ids, i);
        assert!(pool_id == expected_id, EAmmMismatch);
        i = i + 1;
    };

    // Calculate crank amount (evenly distribute remaining balance across remaining cranks)
    let remaining_cranks = escrow.total_cranks - escrow.cranks_completed;
    let current_balance = escrow.subsidy_balance.value();
    let crank_amount = current_balance / remaining_cranks;
    assert!(crank_amount > 0, EInsufficientBalance);

    // Calculate keeper fee: FLAT per crank (0.1 SUI default)
    // This is correct because keeper does ONE transaction for ALL AMMs
    let keeper_fee = math::min(escrow.keeper_fee_per_crank, crank_amount);

    // Amount to distribute to AMMs (after keeper fee)
    let subsidy_amount = crank_amount - keeper_fee;

    // Split subsidy equally across all conditional AMMs
    let amount_per_amm = subsidy_amount / outcome_count;

    // Add to each conditional AMM's reserves proportionally
    let mut j = 0;
    while (j < outcome_count) {
        let pool = vector::borrow_mut(conditional_pools, j);

        // Add reserves proportionally to maintain current price
        inject_subsidy_proportional(pool, amount_per_amm, clock);

        j = j + 1;
    };

    // Update escrow state
    escrow.cranks_completed = escrow.cranks_completed + 1;
    escrow.last_crank_time = option::some(now);

    // Extract keeper fee from escrow
    let keeper_fee_balance = escrow.subsidy_balance.split(keeper_fee);

    // Extract subsidy amount that was distributed
    let subsidy_balance = escrow.subsidy_balance.split(subsidy_amount);
    subsidy_balance.destroy_zero(); // We already added it to pools, just accounting

    // Emit crank event
    event::emit(SubsidyCranked {
        escrow_id: object::uid_to_inner(&escrow.id),
        proposal_id: escrow.proposal_id,
        crank_number: escrow.cranks_completed,
        total_cranks: escrow.total_cranks,
        subsidy_distributed: subsidy_amount,
        amount_per_amm,
        outcome_count,
        keeper_fee,
        keeper: tx_context::sender(ctx),
        timestamp: now,
    });

    // Return keeper fee
    coin::from_balance(keeper_fee_balance, ctx)
}

/// Refund proposer after proposal passes
/// Tries to refund from DAO treasury first, then from escrow remainder
/// If treasury empty, silently fails (proposer still paid fee, no grief)
///
/// ## Arguments
/// - `escrow`: Proposer fee escrow
/// - `treasury_refund`: Optional coin from DAO treasury (if available)
/// - `clock`: For timestamp
/// - `ctx`: Transaction context
///
/// ## Returns
/// - Refund coin to proposer (may be zero if treasury empty)
public fun refund_proposer(
    escrow: &mut ProposerFeeEscrow,
    treasury_refund: Option<Coin<SUI>>,  // From DAO treasury if available
    clock: &Clock,
    ctx: &mut TxContext,
): Coin<SUI> {
    assert!(!escrow.refund_processed, EAlreadyRefunded);

    escrow.refund_processed = true;
    escrow.finalized = true;

    // Calculate refund amount
    let escrow_remainder = escrow.subsidy_balance.value();
    let mut total_refund = escrow_remainder;
    let mut from_treasury = false;

    // If treasury provided refund, use it
    let mut refund_coin = if (treasury_refund.is_some()) {
        from_treasury = true;
        let treasury_coin = option::destroy_some(treasury_refund);
        total_refund = total_refund + treasury_coin.value();

        // Combine treasury refund + escrow remainder
        if (escrow_remainder > 0) {
            let escrow_coin = coin::from_balance(escrow.subsidy_balance.withdraw_all(), ctx);
            treasury_coin.join(escrow_coin);
        };

        treasury_coin
    } else {
        // No treasury refund, just return escrow remainder (if any)
        if (escrow_remainder > 0) {
            coin::from_balance(escrow.subsidy_balance.withdraw_all(), ctx)
        } else {
            coin::zero(ctx)
        }
    };

    // Emit refund event
    if (total_refund > 0) {
        event::emit(ProposerRefunded {
            escrow_id: object::uid_to_inner(&escrow.id),
            proposal_id: escrow.proposal_id,
            proposer: escrow.proposer,
            refund_amount: total_refund,
            from_treasury,
            timestamp: clock.timestamp_ms(),
        });
    };

    refund_coin
}

/// Burn remaining subsidy (proposal failed, keep fee as spam tax)
/// Returns remaining balance to protocol revenue
public fun burn_subsidy(
    escrow: &mut ProposerFeeEscrow,
    clock: &Clock,
    ctx: &mut TxContext,
): Coin<SUI> {
    assert!(!escrow.finalized, EProposalFinalized);

    escrow.finalized = true;
    let burned_amount = escrow.subsidy_balance.value();

    // Emit burn event
    if (burned_amount > 0) {
        event::emit(SubsidyBurned {
            escrow_id: object::uid_to_inner(&escrow.id),
            proposal_id: escrow.proposal_id,
            burned_amount,
            timestamp: clock.timestamp_ms(),
        });
    };

    // Extract all remaining balance as "burned" (goes to protocol revenue)
    let burned_balance = escrow.subsidy_balance.withdraw_all();
    coin::from_balance(burned_balance, ctx)
}

/// Destroy escrow (only after finalization)
public fun destroy_escrow(escrow: ProposerFeeEscrow) {
    let ProposerFeeEscrow {
        id,
        proposal_id: _,
        proposer: _,
        amm_ids: _,
        subsidy_balance,
        total_subsidy: _,
        cranks_completed: _,
        total_cranks: _,
        keeper_fee_per_crank: _,
        last_crank_time: _,
        refund_processed: _,
        finalized,
    } = escrow;

    assert!(finalized, EProposalFinalized);
    assert!(subsidy_balance.value() == 0, EInsufficientBalance);

    subsidy_balance.destroy_zero();
    object::delete(id);
}

// === Internal Helper Functions ===

/// Inject subsidy proportionally into conditional AMM reserves
/// Maintains current price ratio to avoid manipulation
///
/// CRITICAL: Must add proportionally to both reserves to maintain price!
fun inject_subsidy_proportional(
    pool: &mut LiquidityPool,
    total_subsidy: u64,
    clock: &Clock,
) {
    // Get current reserves
    let (asset_reserve, stable_reserve) = conditional_amm::get_reserves(pool);
    let total_reserves = asset_reserve + stable_reserve;

    // Calculate proportional split (maintains current price ratio)
    let stable_ratio = math::mul_div_to_64(stable_reserve, 1_000_000, total_reserves);

    let stable_add = math::mul_div_to_64(total_subsidy, stable_ratio, 1_000_000);
    let asset_add = total_subsidy - stable_add;

    // Add to reserves (directly mutates pool state)
    // Note: This increases k, benefiting existing LPs
    conditional_amm::add_subsidy_to_reserves(pool, asset_add, stable_add);

    // Update TWAP observation after reserve change
    conditional_amm::update_twap_observation(pool, clock);
}

// === Entry Functions ===

/// Entry function: Create proposer fee escrow and share
public entry fun create_and_share_escrow(
    proposal_id: ID,
    proposer: address,
    amm_ids: vector<ID>,
    proposer_fee: Coin<SUI>,
    crank_steps: u64,
    keeper_fee_per_crank: u64,
    refund_on_pass: bool,
    ctx: &mut TxContext,
) {
    let config = new_subsidy_config_custom(
        true,
        crank_steps,
        keeper_fee_per_crank,
        MIN_CRANK_INTERVAL_MS,
        refund_on_pass,
    );

    let escrow = create_escrow(
        proposal_id,
        proposer,
        amm_ids,
        proposer_fee,
        &config,
        ctx,
    );

    transfer::share_object(escrow);
}

/// Entry function: Crank subsidy (keeper calls this)
public entry fun crank_subsidy_entry(
    escrow: &mut ProposerFeeEscrow,
    proposal_id: ID,
    conditional_pools: &mut vector<LiquidityPool>,
    clock: &Clock,
    ctx: &mut TxContext,
) {
    let keeper_fee_coin = crank_subsidy(
        escrow,
        proposal_id,
        conditional_pools,
        clock,
        ctx,
    );

    // Transfer keeper fee to caller
    transfer::public_transfer(keeper_fee_coin, tx_context::sender(ctx));
}

/// Entry function: Refund proposer (when proposal passes)
public entry fun refund_proposer_entry(
    escrow: &mut ProposerFeeEscrow,
    treasury_refund: Option<Coin<SUI>>,
    clock: &Clock,
    ctx: &mut TxContext,
) {
    let refund_coin = refund_proposer(escrow, treasury_refund, clock, ctx);

    // Transfer refund to proposer
    if (refund_coin.value() > 0) {
        transfer::public_transfer(refund_coin, escrow.proposer);
    } else {
        refund_coin.destroy_zero();
    }
}

// === Test-Only Functions ===

#[test_only]
public fun create_test_escrow(
    proposal_id: ID,
    proposer: address,
    amm_ids: vector<ID>,
    total_subsidy: u64,
    total_cranks: u64,
    ctx: &mut TxContext,
): ProposerFeeEscrow {
    ProposerFeeEscrow {
        id: object::new(ctx),
        proposal_id,
        proposer,
        amm_ids,
        subsidy_balance: balance::create_for_testing(total_subsidy),
        total_subsidy,
        cranks_completed: 0,
        total_cranks,
        keeper_fee_per_crank: KEEPER_FEE_PER_CRANK_SUI,
        last_crank_time: option::none(),
        refund_processed: false,
        finalized: false,
    }
}

#[test_only]
public fun destroy_test_escrow(escrow: ProposerFeeEscrow) {
    let ProposerFeeEscrow {
        id,
        proposal_id: _,
        proposer: _,
        amm_ids: _,
        subsidy_balance,
        total_subsidy: _,
        cranks_completed: _,
        total_cranks: _,
        keeper_fee_per_crank: _,
        last_crank_time: _,
        refund_processed: _,
        finalized: _,
    } = escrow;

    balance::destroy_for_testing(subsidy_balance);
    object::delete(id);
}
/// ============================================================================
/// FUTARCHY ORACLE - WRITE-THROUGH TWAP FOR PREDICTION MARKETS
/// ============================================================================
/// 
/// PURPOSE: Core oracle for futarchy decision-making and proposal resolution
/// 
/// USED BY:
/// - Conditional AMMs during proposals (outcome evaluation)
/// - Proposal resolution (determining winners based on TWAP)
/// - SpotAMM for governance TWAP (base fair value)
/// - NOT for lending protocols (use ring_buffer_oracle instead)
/// 
/// KEY FEATURES:
/// - Write-through pattern (MUST update before reading)
/// - Price capping to prevent manipulation
/// - Complex window-based accumulation
/// - Designed specifically for futarchy mechanics
/// - Does NOT merge with ring buffer data (separate concerns)
/// 
/// BEHAVIOR:
/// - During proposals: Each conditional AMM maintains its own oracle
/// - After finalization: Winning outcome's TWAP fills gap in spot oracle
/// - Ring buffer handles continuous feeds, this handles governance
/// 
/// WHY IT EXISTS:
/// Futarchy needs precise, manipulation-resistant price discovery during
/// proposals. This oracle enforces atomic write-then-read to ensure prices
/// are always fresh and prevents time-based manipulation attacks.
/// The separation from ring_buffer_oracle ensures governance decisions
/// cannot be influenced by lending protocol requirements.
/// 
/// ============================================================================

module futarchy_markets::oracle;

use futarchy_one_shot_utils::math;
use futarchy_one_shot_utils::constants;
use std::u128;
use std::u64;
use sui::clock::Clock;
use sui::event;

// === Introduction ===
// Crankless Time Weighted Average Price (TWAP) Oracle

// === Constants ===
// Constants moved to constants module
// Using constants::twap_price_cap_window(), constants::one_week_ms(), constants::ppm_denominator()

// === Errors ===
const ETimestampRegression: u64 = 0;
const ETwapNotStarted: u64 = 1;
const EZeroPeriod: u64 = 2;
const EZeroInitialization: u64 = 3;
const EZeroStep: u64 = 4;
const ELongDelay: u64 = 5;
const EStaleTwap: u64 = 6;
const EOverflowVRamp: u64 = 7;
const EOverflowVFlat: u64 = 8;
const EOverflowSDevMag: u64 = 9;
const EOverflowBasePriceSumFinal: u64 = 10;
const EOverflowVSumPricesAdd: u64 = 11;
const EInternalTwapError: u64 = 12;
const ENoneFullWindowTwapDelay: u64 = 13;
const EMarketNotStarted: u64 = 14;
const EMarketAlreadyStarted: u64 = 15;
const EInvalidCapPpm: u64 = 16;
const EStepOverflow: u64 = 17;

// === Structs ===
public struct Oracle has key, store {
    id: UID,
    last_price: u128,
    last_timestamp: u64,
    total_cumulative_price: u256,
    // TWAP calculation fields - using u256 for overflow protection
    // Max TWAP accumulation is U256 Max ≈1.16 x 10^77
    // Max TWAP daily accumulation:
    //     Max price observation = u64::max_value!() x 1_000_000_000_000;
    //     Milliseconds a day (7 x 24 × 3,600 × 1,000) * max price observation
    //     Allows for 1.04×10 ^ 37 days of accumulation.
    last_window_end_cumulative_price: u256,
    last_window_end: u64,
    last_window_twap: u128,
    twap_start_delay: u64,
    // Reduces attacker advantage with surprise proposals
    twap_cap_step: u64,
    // Scaled relative maximum step size for TWAP calculations
    market_start_time: Option<u64>,
    twap_initialization_price: u128,
}

// === Events ===

public struct PriceEvent has copy, drop {
    last_price: u128,
}

// === Public Functions ===
public fun new_oracle(
    twap_initialization_price: u128,
    twap_start_delay: u64,
    twap_cap_ppm: u64,
    ctx: &mut TxContext,
): Oracle {
    assert!(twap_initialization_price > 0, EZeroInitialization);
    assert!(twap_cap_ppm > 0, EZeroStep);
    assert!(twap_cap_ppm <= constants::ppm_denominator(), EInvalidCapPpm);
    assert!(twap_start_delay < constants::one_week_ms(), ELongDelay); // One week in milliseconds
    assert!((twap_start_delay % constants::twap_price_cap_window()) == 0, ENoneFullWindowTwapDelay);
    
    // Calculate the absolute step from PPM and initialization price
    // Use checked multiplication to avoid overflow
    let step_u128 = if (twap_cap_ppm > 0 && twap_initialization_price > (u128::max_value!() / (twap_cap_ppm as u128))) {
        // Would overflow, use max u64 as step
        (u64::max_value!() as u128)
    } else {
        twap_initialization_price * (twap_cap_ppm as u128) / (constants::ppm_denominator() as u128)
    };
    assert!(step_u128 <= (std::u64::max_value!() as u128), EStepOverflow);
    let mut twap_cap_step = step_u128 as u64;
    // Ensure step is at least 1 to avoid division by zero
    if (twap_cap_step == 0) {
        twap_cap_step = 1;
    };

    Oracle {
        id: object::new(ctx),
        last_price: twap_initialization_price,
        last_timestamp: 0, // set to current time when trading starts
        total_cumulative_price: 0,
        last_window_end_cumulative_price: 0,
        last_window_end: 0, // set to current time when trading starts
        last_window_twap: twap_initialization_price,
        twap_start_delay: twap_start_delay,
        twap_cap_step: twap_cap_step,
        market_start_time: option::none(), // nullable so that TWAP is not valid if not properly initialized
        twap_initialization_price: twap_initialization_price,
    }
}

// === Private Functions ===
fun one_step_cap_price_change(twap_base: u128, new_price: u128, twap_cap_step: u64): u128 {
    if (new_price > twap_base) {
        // Cap upward movement: min(new_price, saturating_add(twap_base, max_change))
        u128::min(new_price, math::saturating_add(twap_base, (twap_cap_step as u128)))
    } else {
        // Cap downward movement: max(new_price, saturating_sub(twap_base, max_change))
        u128::max(new_price, math::saturating_sub(twap_base, (twap_cap_step as u128)))
    }
}

// Called before swaps, LP events and before reading TWAP
public fun write_observation(oracle: &mut Oracle, timestamp: u64, price: u128) {
    // Sanity time checks
    assert!(oracle.market_start_time.is_some(), EMarketNotStarted);
    let market_start_time_val = *oracle.market_start_time.borrow();
    assert!(timestamp >= oracle.last_timestamp, ETimestampRegression);

    let delay_threshold = market_start_time_val + oracle.twap_start_delay;
    // --- Case 0: No time has passed ---
    if (timestamp == oracle.last_timestamp) {
        // If last_price update is not needed here, just return.
        // twap_accumulate would also do nothing if called with 0 duration.
        return
    };

    // --- Case 1: Current observation interval is entirely BEFORE delay_threshold ---
    if (oracle.last_timestamp < delay_threshold && timestamp < delay_threshold) {
        twap_accumulate(oracle, timestamp, price);
        return
    };

    // --- Case 2: Current observation interval CROSSES (or starts at and goes beyond) delay_threshold ---
    if (oracle.last_timestamp <= delay_threshold && timestamp >= delay_threshold) {
        // Part A: Process segment up to delay_threshold.
        if (delay_threshold > oracle.last_timestamp) {
            twap_accumulate(oracle, delay_threshold, price);
        };

        // Part B: RESET accumulators and mark the true start of the accumulation period.
        oracle.total_cumulative_price = 0;
        oracle.last_window_end_cumulative_price = 0;
        oracle.last_window_end = delay_threshold;

        // Part C: Process segment from delay_threshold to current `timestamp`.
        // This uses the fresh accumulators.
        if (timestamp > delay_threshold) {
            // Ensure there's a duration for this segment
            // twap_accumulate will use oracle.last_timestamp (which is delay_threshold)
            twap_accumulate(oracle, timestamp, price);
        };
        return
    };

    // --- Case 3: Current observation interval is entirely AT or AFTER delay_threshold ---
    if (oracle.last_timestamp >= delay_threshold) {
        twap_accumulate(oracle, timestamp, price);
        return
    }
}

fun twap_accumulate(oracle: &mut Oracle, timestamp: u64, price: u128) {
    // --- Input Validation ---
    // Ensure timestamp is not regressing
    assert!(timestamp >= oracle.last_timestamp, ETimestampRegression);
    // Ensure initial state is consistent (last_timestamp should not be before the window end it relates to)
    // This is a pre-condition check, assuming the state was valid before this call.
    assert!(oracle.last_timestamp >= oracle.last_window_end, ETimestampRegression);

    // --- Handle Edge Case: No time passed ---
    let time_since_last_update = timestamp - oracle.last_timestamp;

    // --- Stage 1: Accumulate for the initial partial window segment ---
    // This segment starts at oracle.last_timestamp and ends at the first of:
    // 1. The next window boundary (relative to oracle.last_window_end).
    // 2. The final input timestamp.

    let diff_from_last_boundary = oracle.last_timestamp - oracle.last_window_end;
    let elapsed_in_current_segment = diff_from_last_boundary % constants::twap_price_cap_window();

    let time_to_next_boundary = constants::twap_price_cap_window() - elapsed_in_current_segment;

    let duration_stage1 = std::u64::min(
        time_to_next_boundary, // Limit by the time until the next window boundary
        time_since_last_update, // Limit by the total time available until the target timestamp
    );

    if (duration_stage1 > 0) {
        let end_timestamp_stage1 = oracle.last_timestamp + duration_stage1;
        intra_window_accumulation(
            oracle, // Passes mutable reference, state will be updated
            price,
            duration_stage1,
            end_timestamp_stage1, // This timestamp becomes the new oracle.last_timestamp
        );
        // After this call, oracle.last_timestamp is updated to end_timestamp_stage1.
        // If end_timestamp_stage1 hit a window boundary, oracle.last_window_end and TWAP state are also updated.
    };

    // --- Stage 2: Process all full windows that fit *after* Stage 1 ended ---
    // The starting point for these full windows is the current oracle.last_timestamp
    // (which is the end timestamp of the segment processed in Stage 1).

    let time_remaining_after_stage1 = timestamp - oracle.last_timestamp; // Use updated oracle.last_timestamp

    if (time_remaining_after_stage1 >= constants::twap_price_cap_window()) {
        let num_full_windows = time_remaining_after_stage1 / constants::twap_price_cap_window();

        // Calculate the end timestamp after processing these full windows.
        // Start from the *current* oracle.last_timestamp (end of Stage 1 segment).
        let end_timestamp_stage2 = oracle.last_timestamp + num_full_windows * constants::twap_price_cap_window();

        multi_full_window_accumulation(
            oracle, // Passes mutable reference, state will be updated
            price,
            num_full_windows,
            end_timestamp_stage2, // This timestamp becomes the new oracle.last_timestamp and oracle.last_window_end
        );
        // After this call, oracle.last_timestamp and oracle.last_window_end are updated to end_timestamp_stage2.
        // The oracle's TWAP state (last_window_twap, cumulative_price) is also updated for these full windows.
    };

    // --- Stage 3: Process any remaining partial window after Stage 2 ended ---
    // The starting point is the current oracle.last_timestamp
    // (which is the end timestamp of the segment processed in Stage 2, or Stage 1 if Stage 2 was skipped).

    let duration_stage3 = timestamp - oracle.last_timestamp; // Use updated oracle.last_timestamp

    // If duration_stage3 > 0, there is time left to accumulate up to the final timestamp.
    if (duration_stage3 > 0) {
        intra_window_accumulation(
            oracle, // Passes mutable reference, state will be updated
            price,
            duration_stage3,
            timestamp, // The end timestamp for this final segment is the target timestamp
        );
        // After this call, oracle.last_timestamp is updated to the final input timestamp.
        // If the final timestamp hits a window boundary, oracle.last_window_end and TWAP state are also updated.
    };
    assert!(oracle.last_timestamp == timestamp, EInternalTwapError); // Assuming an internal error code
}

fun intra_window_accumulation(
    oracle: &mut Oracle,
    price: u128,
    additional_time_to_include: u64,
    timestamp: u64,
) {
    let capped_price = one_step_cap_price_change(
        oracle.last_window_twap,
        price,
        oracle.twap_cap_step,
    );

    // Add accumulation for the partial period within the current (still open) window
    let scaled_price = (capped_price as u256);
    let price_contribution = scaled_price * (additional_time_to_include as u256);
    oracle.total_cumulative_price = oracle.total_cumulative_price + price_contribution;

    let time_since_last_window_end = timestamp - oracle.last_window_end;
    oracle.last_timestamp = timestamp;
    oracle.last_price = (scaled_price as u128);

    event::emit(PriceEvent {
        last_price: oracle.last_price,
    });

    if (time_since_last_window_end == constants::twap_price_cap_window()) {
        // Update last window data on window boundary
        oracle.last_window_end = timestamp;
        oracle.last_window_twap = (
            (
                (oracle.total_cumulative_price - oracle.last_window_end_cumulative_price) / (constants::twap_price_cap_window() as u256),
            ) as u128,
        );
        oracle.last_window_end_cumulative_price = oracle.total_cumulative_price
    }
}

fun multi_full_window_accumulation(
    oracle: &mut Oracle,
    price: u128,
    num_new_windows: u64, // N_W
    timestamp: u64,
) {
    // Notation: v_ = value, n_ = number/count, k_ = index, s_ = sum, g_ = gap
    // G_abs = |P - B|
    let g_abs: u128;
    if (price > oracle.last_window_twap) {
        g_abs = price - oracle.last_window_twap;
    } else {
        g_abs = oracle.last_window_twap - price;
    };

    let k_cap_idx_u128: u128;
    if (g_abs == 0) {
        k_cap_idx_u128 = 0;
    } else if (oracle.twap_cap_step == 0) {
        // If step is 0 (from very small PPM), treat as unlimited steps
        k_cap_idx_u128 = (u64::max_value!() as u128);
    } else {
        k_cap_idx_u128 = (g_abs - 1) / (oracle.twap_cap_step as u128) + 1;
    };

    let k_cap_idx: u64;
    if (k_cap_idx_u128 > (u64::max_value!() as u128)) {
        k_cap_idx = u64::max_value!();
    } else {
        k_cap_idx = k_cap_idx_u128 as u64;
    };

    let k_ramp_limit: u64;
    if (k_cap_idx == 0) {
        k_ramp_limit = 0;
    } else {
        k_ramp_limit = k_cap_idx - 1;
    };

    // N_ramp_terms = min(N_W, k_ramp_limit)
    let n_ramp_terms = std::u64::min(num_new_windows, k_ramp_limit); // n_ramp_terms is u64

    // V_ramp = \Delta_M * N_ramp_terms * (N_ramp_terms + 1) / 2
    let v_ramp: u128;
    if (n_ramp_terms == 0) {
        v_ramp = 0;
    } else {
        let nrt_u128 = n_ramp_terms as u128;
        let sum_indices_part: u128;
        // Calculate nrt_u128 * (nrt_u128 + 1) / 2 safely to avoid overflow.
        // Max nrt_u128 is std::u64::MAX (~2^64).
        // (nrt_u128/2) * (nrt_u128+1) OR ((nrt_u128+1)/2) * nrt_u128 will be ~2^63 * 2^64 = 2^127, which fits u128.
        if (nrt_u128 % 2 == 0) {
            sum_indices_part = (nrt_u128 / 2) * (nrt_u128 + 1);
        } else {
            sum_indices_part = ((nrt_u128 + 1) / 2) * nrt_u128;
        };

        // Check for overflow: delta_max_per_step * sum_indices_part
        if (
            sum_indices_part > 0 && (oracle.twap_cap_step as u128) > 0 && (oracle.twap_cap_step as u128) > u128::max_value!() / sum_indices_part
        ) {
            abort (EOverflowVRamp)
        };
        v_ramp = (oracle.twap_cap_step as u128) * sum_indices_part;
    };

    // V_flat = G_abs * (N_W - N_ramp_terms)
    let num_flat_terms = num_new_windows - n_ramp_terms; // u64
    let v_flat: u128;
    if (num_flat_terms == 0) {
        v_flat = 0;
    } else {
        let nft_u128 = num_flat_terms as u128;
        // Check for overflow: g_abs * nft_u128
        if (nft_u128 > 0 && g_abs > 0 && g_abs > u128::max_value!() / nft_u128) {
            abort (EOverflowVFlat)
        };
        v_flat = g_abs * nft_u128;
    };

    // S_dev_mag = V_ramp + V_flat
    // Check for overflow: v_ramp + v_flat
    if (v_ramp > u128::max_value!() - v_flat) {
        // Equivalent to v_ramp + v_flat > u128::max_value!()
        abort (EOverflowSDevMag)
    };
    let s_dev_mag = v_ramp + v_flat;

    // V_sum_prices = N_W * B + sign(P-B) * S_dev_mag
    let base_price_sum: u128;
    let nw_u128 = num_new_windows as u128;
    // Check for overflow: oracle.last_window_twap * nw_u128
    if (
        nw_u128 > 0 && oracle.last_window_twap > 0 && oracle.last_window_twap > u128::max_value!() / nw_u128
    ) {
        abort (EOverflowBasePriceSumFinal)
    };
    base_price_sum = oracle.last_window_twap * nw_u128;

    let v_sum_prices: u128;
    if (price >= oracle.last_window_twap) {
        // sign(P-B) is 0 or 1
        // Check for overflow: base_price_sum + s_dev_mag
        if (base_price_sum > u128::max_value!() - s_dev_mag) {
            abort (EOverflowVSumPricesAdd)
        };
        v_sum_prices = base_price_sum + s_dev_mag;
    } else {
        // sign(P-B) is -1
        // Since P'_i = B - dev_i, and we assume price (P) >= 0,
        // then P'_i >= 0 (as B - dev_i >= P >= 0).
        // So sum of P'_i (which is V_sum_prices) must be >= 0.
        // This also implies N_W * B >= S_dev_mag.
        // Thus, base_price_sum >= s_dev_mag, and subtraction will not underflow below zero.
        v_sum_prices = base_price_sum - s_dev_mag;
    };

    // P'_N_W = B + sign(P-B) * min(N_W * \Delta_M, G_abs)
    let p_n_w_effective: u128;

    // Calculate N_W * \Delta_M
    // delta_max_per_step is > 0 here. num_new_windows > 0.
    // No overflow possible: num_new_windows is u64, twap_cap_step is u64
    let nw_times_delta_m = (num_new_windows as u128) * (oracle.twap_cap_step as u128);

    let deviation_for_p_n_w = std::u128::min(nw_times_delta_m, g_abs);

    if (price >= oracle.last_window_twap) {
        p_n_w_effective = math::saturating_add(oracle.last_window_twap, deviation_for_p_n_w);
    } else {
        // price < oracle.last_window_twap
        p_n_w_effective = math::saturating_sub(oracle.last_window_twap, deviation_for_p_n_w);
    };

    oracle.last_timestamp = timestamp;
    oracle.last_window_end = timestamp;
    let cumulative_price_contribution = (v_sum_prices as u256) * (constants::twap_price_cap_window() as u256);
    oracle.last_window_end_cumulative_price =
        oracle.total_cumulative_price + cumulative_price_contribution;
    oracle.total_cumulative_price = oracle.total_cumulative_price + cumulative_price_contribution;
    oracle.last_price = p_n_w_effective;

    event::emit(PriceEvent {
        last_price: oracle.last_price,
    });

    oracle.last_window_twap = p_n_w_effective;
}

/// ARCHITECTURAL DECISION: Mutation-Required TWAP Oracle
/// 
/// This oracle REQUIRES write_observation() before get_twap() in the same transaction.
/// The assertion `current_time == oracle.last_timestamp` is INTENTIONAL.
/// 
/// Why this differs from read-only TWAP patterns:
/// - Stale prices are attack vectors, not features
/// - Interpolation adds complexity and manipulation surface  
/// - The AMM determines prices; the oracle just tracks them
/// - Every TWAP read MUST reflect current AMM state
/// 
/// This design makes it IMPOSSIBLE to:
/// ✗ Read stale/manipulated TWAPs
/// ✗ Forget to update before critical operations
/// ✗ Have price inconsistency within a transaction
/// 
/// This pattern differs from typical read-only oracles by design.
/// Serving stale TWAPs for "cleaner interfaces" is how protocols get exploited.
/// 
/// The AMM's get_twap() handles the update + read atomically. 
/// The oracle just validates freshness. This is correct.
public fun get_twap(oracle: &Oracle, clock: &Clock): u128 {
    assert!(oracle.market_start_time.is_some(), EMarketNotStarted);
    let market_start_time_val = *oracle.market_start_time.borrow();
    let current_time = clock.timestamp_ms();

    // REQUIRED: Caller must have called write_observation() in this same transaction
    // This ensures TWAP is always fresh and prevents stale price exploitation
    assert!(current_time == oracle.last_timestamp, EStaleTwap);

    // Time checks
    assert!(oracle.last_timestamp != 0, ETimestampRegression);
    assert!(current_time - market_start_time_val >= oracle.twap_start_delay, ETwapNotStarted);
    assert!(current_time >= market_start_time_val, ETimestampRegression);

    // Calculate period
    let period = ( current_time - market_start_time_val) - oracle.twap_start_delay;
    assert!(period > 0, EZeroPeriod);

    // Calculate TWAP - dividing cumulative price by period gives average price
    // Safe cast: For reasonable token prices over max 7-day proposals, 
    // TWAP will be far below u128::MAX (even 10^18 price × 7 days / period ≈ 10^15)
    let twap = (oracle.total_cumulative_price) / (period as u256);

    (twap as u128)
}

public fun set_oracle_start_time(oracle: &mut Oracle, market_start_time_param: u64) {
    // Prevent re-initialization
    assert!(oracle.market_start_time.is_none(), EMarketAlreadyStarted);

    oracle.market_start_time = option::some(market_start_time_param);
    oracle.last_window_end = market_start_time_param;
    oracle.last_timestamp = market_start_time_param;
}

// === View Functions ===
public fun last_price(oracle: &Oracle): u128 {
    oracle.last_price
}

public fun last_timestamp(oracle: &Oracle): u64 {
    oracle.last_timestamp
}

public fun config(oracle: &Oracle): (u64, u64) {
    (oracle.twap_start_delay, oracle.twap_cap_step)
}

public fun market_start_time(oracle: &Oracle): Option<u64> {
    oracle.market_start_time
}

public fun twap_initialization_price(oracle: &Oracle): u128 {
    oracle.twap_initialization_price
}

public fun total_cumulative_price(oracle: &Oracle): u256 {
    oracle.total_cumulative_price
}

public fun id(o: &Oracle): &UID {
    &o.id
}

// === Test Functions ===
#[test_only]
use std::debug;

#[test_only]
public fun debug_print_state(oracle: &Oracle) {
    debug::print(&b"Oracle State:");
    debug::print(&oracle.last_price);
    debug::print(&oracle.last_timestamp);
    debug::print(&oracle.total_cumulative_price);
}

#[test_only]
public fun debug_get_state(oracle: &Oracle): (u128, u64, u256) {
    (oracle.last_price, oracle.last_timestamp, oracle.total_cumulative_price)
}

#[test_only]
public fun test_oracle(ctx: &mut TxContext): Oracle {
    new_oracle(
        10000, // twap_initialization_price
        60_000, // twap_start_delay
        1000, // twap_cap_ppm (0.1% of initialization price)
        ctx,
    )
}

#[test_only]
public fun destroy_for_testing(oracle: Oracle) {
    let Oracle {
        id,
        last_price: _,
        last_timestamp: _,
        total_cumulative_price: _,
        last_window_end: _,
        last_window_end_cumulative_price: _,
        last_window_twap: _,
        twap_start_delay: _,
        twap_cap_step: _,
        market_start_time: _,
        twap_initialization_price: _,
    } = oracle;
    id.delete();
}

#[test_only]
public fun debug_get_window_twap(oracle: &Oracle): u128 {
    oracle.last_window_twap
}

#[test_only]
public fun is_twap_valid(oracle: &Oracle, min_period: u64, clock: &Clock): bool {
    let current_time = clock.timestamp_ms();
    current_time >= oracle.last_timestamp + min_period
}

#[test_only]
public fun debug_get_full_state(
    oracle: &Oracle,
): (
    u128, // last_price
    u64, // last_timestamp
    u256, // total_cumulative_price
    u256, // last_window_end_cumulative_price
    u64, // last_window_end
    u128, // last_window_twap
    Option<u64>, // market_start_time
    u128, // twap_initialization_price
    u64, // twap_start_delay
    u64, // twap_cap_step
) {
    (
        oracle.last_price,
        oracle.last_timestamp,
        oracle.total_cumulative_price,
        oracle.last_window_end_cumulative_price,
        oracle.last_window_end,
        oracle.last_window_twap,
        oracle.market_start_time,
        oracle.twap_initialization_price,
        oracle.twap_start_delay,
        oracle.twap_cap_step,
    )
}

#[test_only]
public fun set_last_timestamp_for_testing(oracle: &mut Oracle, new_last_timestamp: u64) {
    oracle.last_timestamp = new_last_timestamp;
}

#[test_only]
public fun set_last_window_end_for_testing(oracle: &mut Oracle, new_last_window_end: u64) {
    oracle.last_window_end = new_last_window_end;
}

#[test_only]
public fun set_last_window_twap_for_testing(oracle: &mut Oracle, new_last_window_twap: u128) {
    oracle.last_window_twap = new_last_window_twap;
}

#[test_only]
public fun set_cumulative_prices_for_testing(
    oracle: &mut Oracle,
    total_cumulative_price: u256,
    last_window_end_cumulative_price: u256,
) {
    oracle.total_cumulative_price = total_cumulative_price;
    oracle.last_window_end_cumulative_price = last_window_end_cumulative_price;
}

#[test_only]
public fun call_twap_accumulate_for_testing(oracle: &mut Oracle, timestamp: u64, price: u128) {
    twap_accumulate(oracle, timestamp, price);
}

#[test_only]
public fun get_last_window_end_cumulative_price_for_testing(oracle: &Oracle): u256 {
    oracle.last_window_end_cumulative_price
}

#[test_only]
public fun get_total_cumulative_price_for_testing(oracle: &Oracle): u256 {
    oracle.total_cumulative_price
}

#[test_only]
public fun get_last_window_end_for_testing(oracle: &Oracle): u64 {
    oracle.last_window_end
}

#[test_only]
public fun call_intra_window_accumulation_for_testing(
    oracle: &mut Oracle,
    price: u128,
    additional_time_to_include: u64,
    timestamp: u64,
) {
    intra_window_accumulation(
        oracle,
        price,
        additional_time_to_include,
        timestamp,
    );
}

#[test_only]
public fun call_multi_full_window_accumulation_for_testing(
    oracle: &mut Oracle,
    price: u128,
    num_new_windows: u64,
    timestamp: u64,
) {
    multi_full_window_accumulation(
        oracle,
        price,
        num_new_windows,
        timestamp,
    );
}
/// Proposal creation with integrated market initialization strategies
///
/// This module enables DAOs to atomically seed prediction markets with asymmetric liquidity
/// during proposal creation. This creates initial price signals (e.g., "we think this will pass")
/// while maintaining front-run protection via single-transaction PTB execution.
///
/// ## Market Initialization Strategies
///
/// ### 1. Conditional Raise (Mint → Swap → Deposit)
/// - **Purpose:** Simulate raising capital by selling DAO tokens in a conditional market
/// - **Flow:** Mint asset tokens → Sell in YES market → Get stable coins → Deposit to treasury
/// - **Effect:** Makes YES tokens cheaper (bearish on YES = bullish on proposal passing)
/// - **Use Case:** DAO wants to signal confidence that proposal will pass and raise funds if it does
///
/// ### 2. Conditional Buyback (Withdraw → Swap → Burn/Deposit)
/// - **Purpose:** Simulate buying back DAO tokens across multiple outcome markets
/// - **Flow:** Withdraw stable → Buy asset tokens in outcome AMMs → Burn or vault the assets
/// - **Effect:** Makes asset tokens more expensive in chosen outcomes (bullish on those outcomes)
/// - **Use Case:** DAO wants to signal which outcomes it prefers with treasury funds
/// - **Flexibility:** Per-outcome amounts via `vector<u64>` (e.g., [0, 1000, 500] for 3 outcomes)
///
/// ## Atomic Execution (Front-Run Protection)
///
/// All operations happen in a single PTB transaction:
/// 1. Create proposal (PREMARKET state)
/// 2. Create escrow and AMM pools
/// 3. Execute Intent (mint/withdraw) → get coins
/// 4. Execute market init strategy → conditional swaps
/// 5. Return proceeds to vault
/// 6. Finalize proposal (→ REVIEW state)
///
/// No intermediate state is exposed, preventing sandwich attacks or front-running.
///
/// ## Constraint: Zero Review Period Only
///
/// **Market init proposals ONLY work with `review_period_ms = 0`**
///
/// ```move
/// assert!(review_period_ms == 0, EMarketInitRequiresZeroReview);
/// ```
///
/// **Why this constraint:**
/// - ✅ Atomic execution (create + init + trading in one PTB)
/// - ✅ Front-run proof (everything happens in one transaction)
/// - ✅ No queue blocking issues
/// - ✅ No commit-reveal complexity
/// - ✅ No SEAL dependencies
/// - ✅ No timing edge cases
///
/// **Trade-off:**
/// - No premarket research period
/// - Traders must analyze quickly or after market starts
/// - Worth it for simplicity and security
///
/// **Note:** DAOs can set high queue fees (e.g., $1k min_fee) to keep the queue clear,
/// making the reservation slot more often available for market init proposals with premarket.
///
/// ## PTB Example: Conditional Raise (Mint + Swap + Deposit)
///
/// ```typescript
/// const tx = new Transaction();
///
/// // 0. Get market_op_review_period_ms from DAO config (not regular review period!)
/// const marketOpReviewPeriod = dao_config.market_op_review_period_ms();
///
/// // 1. Create proposal in PREMARKET state
/// // IMPORTANT: Use market_op_review_period_ms as the review_period parameter!
/// const proposalId = tx.moveCall({
///   target: 'futarchy_markets::proposal::new_premarket',
///   arguments: [
///     /* ... other params ... */,
///     marketOpReviewPeriod,  // ← Use market op review period, not regular!
///     /* ... */
///   ],
/// });
///
/// // 2. Create escrow for market
/// const escrow = tx.moveCall({
///   target: 'futarchy_markets::proposal::create_escrow_for_market',
///   arguments: [proposalId, clock],
/// });
///
/// // 3. Register treasury caps and create AMM pools
/// // ... (existing liquidity initialization flow)
///
/// // 4. Execute mint Intent to get asset coins
/// const mintedCoins = tx.moveCall({
///   target: 'account_actions::currency::execute_mint', // or similar
///   arguments: [account, mintAmount, /* ... */],
/// });
///
/// // 5. Execute conditional raise strategy
/// const stableCoins = tx.moveCall({
///   target: 'futarchy_markets::proposal_with_market_init::execute_raise_on_proposal',
///   arguments: [proposalId, escrow, mintedCoins, raiseConfig, clock],
///   typeArguments: [AssetType, StableType, AssetConditionalCoin, StableConditionalCoin],
/// });
///
/// // 6. Deposit stable coins back to DAO vault
/// tx.moveCall({
///   target: 'account_actions::vault::do_deposit',
///   arguments: [account, stableCoins, auth],
/// });
///
/// // 7. Finalize proposal (transitions to REVIEW state)
/// tx.moveCall({
///   target: 'futarchy_markets::proposal::finalize_market_setup',
///   arguments: [proposalId, /* ... */],
/// });
/// ```
///
/// ## PTB Example: Conditional Buyback (Withdraw + Swap + Burn/Deposit)
///
/// ```typescript
/// const tx = new Transaction();
///
/// // Steps 1-3: Same as above (create proposal, escrow, pools)
///
/// // 4. Execute withdraw Intent to get stable coins
/// const withdrawnStable = tx.moveCall({
///   target: 'account_actions::vault::execute_withdraw',
///   arguments: [account, withdrawAmount, /* ... */],
/// });
///
/// // 5. Execute conditional buyback strategy
/// const assetCoins = tx.moveCall({
///   target: 'futarchy_markets::proposal_with_market_init::execute_buyback_on_proposal',
///   arguments: [proposalId, escrow, withdrawnStable, buybackConfig, clock],
///   typeArguments: [AssetType, StableType, AssetConditionalCoin, StableConditionalCoin],
/// });
///
/// // 6. Merge and burn/deposit asset coins
/// const mergedAsset = tx.moveCall({
///   target: 'futarchy_markets::proposal_with_market_init::merge_asset_coins',
///   arguments: [assetCoins],
/// });
///
/// tx.moveCall({
///   target: 'account_actions::currency::burn', // or deposit back to vault
///   arguments: [account, mergedAsset, /* ... */],
/// });
///
/// // 7. Finalize proposal
/// tx.moveCall({
///   target: 'futarchy_markets::proposal::finalize_market_setup',
///   arguments: [proposalId, /* ... */],
/// });
/// ```
module futarchy_markets::proposal_with_market_init;

use futarchy_markets::proposal::{Self, Proposal};
use futarchy_markets::coin_escrow::{Self, TokenEscrow};
use futarchy_markets::market_init_strategies::{
    Self,
    ConditionalRaiseConfig,
    ConditionalBuybackConfig
};
use futarchy_markets::market_init_helpers;
use sui::coin::{Self, Coin};
use sui::clock::Clock;

// === Errors ===
const EInvalidRaiseConfig: u64 = 0;
const EInvalidBuybackConfig: u64 = 1;

// === Conditional Raise Integration ===

/// Execute conditional raise strategy during proposal creation
///
/// This function should be called AFTER the market AMM pools are created but BEFORE
/// the proposal transitions to REVIEW state.
///
/// Flow:
/// 1. Caller has already built and executed mint Intent → has minted coins
/// 2. This function takes those coins and executes conditional raise strategy
/// 3. Strategy returns STABLE coins which caller must deposit back to DAO vault
///
/// ## Parameters
/// - `proposal`: The proposal (must be in PREMARKET state, after AMMs created)
/// - `escrow`: Token escrow for the proposal
/// - `minted_coins`: Asset coins obtained from executing mint Intent
/// - `config`: Conditional raise configuration
/// - `clock`: For timestamp operations
/// - `ctx`: Transaction context
///
/// ## Returns
/// - Stable coins to be deposited back to DAO vault (caller's responsibility)
public fun execute_raise_on_proposal<AssetType, StableType, AssetConditionalCoin, StableConditionalCoin>(
    proposal: &mut Proposal<AssetType, StableType>,
    escrow: &mut TokenEscrow<AssetType, StableType>,
    minted_coins: Coin<AssetType>,
    config: ConditionalRaiseConfig,
    clock: &Clock,
    ctx: &mut TxContext,
): Coin<StableType> {
    let outcome_count = proposal::outcome_count(proposal);

    // Validate config before execution
    assert!(
        market_init_helpers::validate_raise_config(&config, outcome_count),
        EInvalidRaiseConfig
    );

    // Execute the strategy
    market_init_strategies::execute_conditional_raise<AssetType, StableType, AssetConditionalCoin, StableConditionalCoin>(
        proposal,
        escrow,
        minted_coins,
        config,
        outcome_count,
        clock,
        ctx,
    )
}

// === Conditional Buyback Integration ===

/// Execute conditional buyback strategy during proposal creation
///
/// This function should be called AFTER the market AMM pools are created but BEFORE
/// the proposal transitions to REVIEW state.
///
/// Flow:
/// 1. Caller has already built and executed withdraw Intent → has withdrawn stable
/// 2. This function takes those coins and executes conditional buyback strategy
/// 3. Strategy returns ASSET coins which caller can burn or deposit back to vault
///
/// ## Parameters
/// - `proposal`: The proposal (must be in PREMARKET state, after AMMs created)
/// - `escrow`: Token escrow for the proposal
/// - `withdrawn_stable`: Stable coins obtained from executing withdraw Intent
/// - `config`: Conditional buyback configuration (per-outcome amounts)
/// - `clock`: For timestamp operations
/// - `ctx`: Transaction context
///
/// ## Returns
/// - Vector of asset coins (one per outcome, some may be zero-value)
/// - Caller can burn these or deposit to vault
public fun execute_buyback_on_proposal<AssetType, StableType, AssetConditionalCoin, StableConditionalCoin>(
    proposal: &mut Proposal<AssetType, StableType>,
    escrow: &mut TokenEscrow<AssetType, StableType>,
    withdrawn_stable: Coin<StableType>,
    config: ConditionalBuybackConfig,
    clock: &Clock,
    ctx: &mut TxContext,
): vector<Coin<AssetType>> {
    let outcome_count = proposal::outcome_count(proposal);

    // Validate config before execution
    assert!(
        market_init_helpers::validate_buyback_config(&config, outcome_count),
        EInvalidBuybackConfig
    );

    // Execute the strategy
    market_init_strategies::execute_conditional_buyback<AssetType, StableType, AssetConditionalCoin, StableConditionalCoin>(
        proposal,
        escrow,
        withdrawn_stable,
        config,
        outcome_count,
        clock,
        ctx,
    )
}

// === Helper: Merge Asset Coins ===

/// Helper to merge multiple asset coins into a single coin
///
/// Takes the vector of asset coins returned from buyback and merges them
/// into a single coin for easier handling by caller.
///
/// Uses Sui's built-in `join_vec` method for efficient merging.
public fun merge_asset_coins<AssetType>(
    mut asset_coins: vector<Coin<AssetType>>,
    ctx: &mut TxContext,
): Coin<AssetType> {
    if (asset_coins.is_empty()) {
        asset_coins.destroy_empty();
        return coin::zero<AssetType>(ctx)
    };

    let mut base = asset_coins.pop_back();
    base.join_vec(asset_coins);  // Uses Sui's join_vec
    base
}
/// Market initialization strategies for futarchy prediction markets
/// Provides different ways to seed initial liquidity and create price discovery mechanisms
///
/// These strategies execute during proposal creation using coins obtained via Intent execution:
/// 1. Proposal creation builds Intent for mint/withdraw
/// 2. Intent executes immediately via Executable
/// 3. Resulting coins are passed to these strategy functions
/// 4. Strategy performs conditional swaps to create asymmetric markets
module futarchy_markets::market_init_strategies;

use futarchy_markets::swap;
use futarchy_markets::coin_escrow::{Self, TokenEscrow};
use futarchy_markets::proposal::Proposal;
use sui::coin::{Self, Coin};
use sui::balance;
use sui::clock::Clock;
use sui::object::ID;

// === Errors ===
const EInvalidOutcome: u64 = 0;
const EZeroAmount: u64 = 1;
const EExcessiveSlippage: u64 = 2;
const EAmountMismatch: u64 = 3;
const EInvalidConfig: u64 = 4;

// === Strategy Configuration Structs ===

/// Configuration for conditional raise market initialization
/// Mints tokens and sells them in one outcome's AMM to simulate raising capital
public struct ConditionalRaiseConfig has store, drop, copy {
    target_outcome: u8,        // Which outcome gets the mint+swap (usually 1 for YES)
    mint_amount: u64,          // How much to mint
    min_stable_out: u64,       // Minimum STABLE received (slippage protection)
}

/// Configuration for conditional buyback market initialization
/// Withdraws treasury and buys tokens across multiple outcome AMMs
/// Allows customized buyback amounts per outcome to create asymmetric markets
public struct ConditionalBuybackConfig has store, drop, copy {
    // Per-outcome buyback amounts (index = outcome, value = STABLE to spend)
    // Example: [0, 1000, 500] means:
    //   - Outcome 0: no buyback
    //   - Outcome 1: buy 1000 STABLE worth of tokens
    //   - Outcome 2: buy 500 STABLE worth of tokens
    outcome_amounts: vector<u64>,
    // Minimum asset tokens received per outcome (slippage protection)
    // Must have same length as outcome_amounts
    min_asset_outs: vector<u64>,
}

// === Constructor Functions ===

/// Create conditional raise configuration
public fun new_conditional_raise_config(
    target_outcome: u8,
    mint_amount: u64,
    min_stable_out: u64,
): ConditionalRaiseConfig {
    assert!(mint_amount > 0, EZeroAmount);
    assert!(min_stable_out > 0, EZeroAmount);

    ConditionalRaiseConfig {
        target_outcome,
        mint_amount,
        min_stable_out,
    }
}

/// Create conditional buyback configuration with per-outcome amounts
public fun new_conditional_buyback_config(
    outcome_amounts: vector<u64>,
    min_asset_outs: vector<u64>,
): ConditionalBuybackConfig {
    assert!(outcome_amounts.length() > 0, EZeroAmount);
    assert!(outcome_amounts.length() == min_asset_outs.length(), EAmountMismatch);

    // Validate at least one outcome has non-zero buyback
    let mut has_buyback = false;
    let mut i = 0;
    while (i < outcome_amounts.length()) {
        if (*outcome_amounts.borrow(i) > 0) {
            has_buyback = true;
        };
        i = i + 1;
    };
    assert!(has_buyback, EZeroAmount);

    ConditionalBuybackConfig {
        outcome_amounts,
        min_asset_outs,
    }
}

// === Getter Functions ===

// ConditionalRaiseConfig getters
public fun raise_target_outcome(config: &ConditionalRaiseConfig): u8 {
    config.target_outcome
}

public fun raise_mint_amount(config: &ConditionalRaiseConfig): u64 {
    config.mint_amount
}

public fun raise_min_stable_out(config: &ConditionalRaiseConfig): u64 {
    config.min_stable_out
}

// ConditionalBuybackConfig getters
public fun buyback_outcome_amounts(config: &ConditionalBuybackConfig): &vector<u64> {
    &config.outcome_amounts
}

public fun buyback_min_asset_outs(config: &ConditionalBuybackConfig): &vector<u64> {
    &config.min_asset_outs
}

public fun buyback_total_withdraw_amount(config: &ConditionalBuybackConfig): u64 {
    let mut total = 0;
    let mut i = 0;
    while (i < config.outcome_amounts.length()) {
        total = total + *config.outcome_amounts.borrow(i);
        i = i + 1;
    };
    total
}

// === Strategy 1: Conditional Raise ===

/// Execute conditional raise strategy
///
/// Flow:
/// 1. Deposit minted asset coins to escrow → get conditional asset
/// 2. Swap conditional asset → conditional stable in target outcome's AMM
/// 3. Burn conditional stable and withdraw spot stable
/// 4. Return spot stable (caller deposits back to DAO vault)
///
/// ## Parameters
/// - `proposal`: The proposal being initialized
/// - `escrow`: Token escrow for conditional token minting/burning
/// - `minted_coins`: Asset coins obtained from mint intent execution
/// - `config`: Strategy configuration (target outcome, amounts, slippage)
/// - `outcome_count`: Total number of outcomes (for validation)
/// - `clock`: For timestamp-based operations
/// - `ctx`: Transaction context
///
/// ## Returns
/// - Spot stable coins (to be deposited to DAO vault by caller)
public fun execute_conditional_raise<AssetType, StableType, AssetConditionalCoin, StableConditionalCoin>(
    proposal: &mut Proposal<AssetType, StableType>,
    escrow: &mut TokenEscrow<AssetType, StableType>,
    minted_coins: Coin<AssetType>,
    config: ConditionalRaiseConfig,
    outcome_count: u64,
    clock: &Clock,
    ctx: &mut TxContext,
): Coin<StableType> {
    // Validate configuration
    assert!((config.target_outcome as u64) < outcome_count, EInvalidOutcome);
    assert!(config.target_outcome >= 1, EInvalidOutcome); // Outcome 0 is REJECT
    assert!(minted_coins.value() == config.mint_amount, EAmountMismatch);

    // Step 1: Deposit spot asset to escrow → mint conditional asset for target outcome
    let conditional_asset = coin_escrow::deposit_asset_and_mint_conditional<AssetType, StableType, AssetConditionalCoin>(
        escrow,
        (config.target_outcome as u64),
        minted_coins,
        ctx,
    );

    // Step 2: Swap conditional asset → conditional stable in AMM
    // This uses swap.move which:
    // - Burns conditional asset coins
    // - Updates AMM reserves (sell asset, making it cheaper)
    // - Mints conditional stable coins (output)
    let session = swap::begin_swap_session(proposal);
    let conditional_stable = swap::swap_asset_to_stable<AssetType, StableType, AssetConditionalCoin, StableConditionalCoin>(
        &session,
        proposal,
        escrow,
        (config.target_outcome as u64),
        conditional_asset,
        config.min_stable_out,
        clock,
        ctx,
    );
    swap::finalize_swap_session(session, proposal, escrow, clock);

    // Validate slippage protection
    let conditional_amount = conditional_stable.value();
    assert!(conditional_amount >= config.min_stable_out, EExcessiveSlippage);

    // Step 3: Burn conditional stable coins
    coin_escrow::burn_conditional_stable<AssetType, StableType, StableConditionalCoin>(
        escrow,
        (config.target_outcome as u64),
        conditional_stable,
    );

    // Step 4: Withdraw equivalent spot stable from escrow
    let spot_stable = coin_escrow::withdraw_stable_balance<AssetType, StableType>(
        escrow,
        conditional_amount,
        ctx,
    );

    // Return spot stable to caller (will be deposited to DAO vault)
    spot_stable
}

// === Strategy 2: Conditional Buyback ===

/// Execute conditional buyback strategy across multiple outcomes
///
/// Flow (per outcome with non-zero buyback):
/// 1. Split withdrawn stable for this outcome
/// 2. Deposit spot stable → get conditional stable
/// 3. Swap conditional stable → conditional asset in AMM
/// 4. Burn conditional asset and withdraw spot asset
/// 5. Collect all spot assets and return
///
/// ## Parameters
/// - `proposal`: The proposal being initialized
/// - `escrow`: Token escrow for conditional token minting/burning
/// - `withdrawn_stable`: Stable coins obtained from vault withdraw intent
/// - `config`: Strategy configuration (per-outcome amounts and slippage)
/// - `outcome_count`: Total number of outcomes (for validation)
/// - `clock`: For timestamp-based operations
/// - `ctx`: Transaction context
///
/// ## Returns
/// - Vector of spot asset coins (one per outcome, some may be zero-value)
/// - Caller can burn these or deposit to vault
public fun execute_conditional_buyback<AssetType, StableType, AssetConditionalCoin, StableConditionalCoin>(
    proposal: &mut Proposal<AssetType, StableType>,
    escrow: &mut TokenEscrow<AssetType, StableType>,
    withdrawn_stable: Coin<StableType>,
    config: ConditionalBuybackConfig,
    outcome_count: u64,
    clock: &Clock,
    ctx: &mut TxContext,
): vector<Coin<AssetType>> {
    // Validate configuration
    assert!(config.outcome_amounts.length() == outcome_count, EInvalidConfig);

    let total_amount = buyback_total_withdraw_amount(&config);
    assert!(withdrawn_stable.value() == total_amount, EAmountMismatch);

    // Convert withdrawn stable to balance for splitting
    let mut stable_balance = withdrawn_stable.into_balance();
    let mut asset_coins = vector::empty<Coin<AssetType>>();

    // Begin swap session once for all swaps in this function
    let session = swap::begin_swap_session(proposal);

    // Process each outcome
    let mut outcome_idx = 0;
    while (outcome_idx < config.outcome_amounts.length()) {
        let outcome_amount = *config.outcome_amounts.borrow(outcome_idx);
        let min_asset_out = *config.min_asset_outs.borrow(outcome_idx);

        if (outcome_amount > 0) {
            // Step 1: Split stable for this outcome
            let outcome_stable_balance = stable_balance.split(outcome_amount);
            let outcome_stable_coin = coin::from_balance(outcome_stable_balance, ctx);

            // Step 2: Deposit spot stable → mint conditional stable for this outcome
            let conditional_stable = coin_escrow::deposit_stable_and_mint_conditional<AssetType, StableType, StableConditionalCoin>(
                escrow,
                outcome_idx,
                outcome_stable_coin,
                ctx,
            );

            // Step 3: Swap conditional stable → conditional asset in AMM
            let conditional_asset = swap::swap_stable_to_asset<AssetType, StableType, AssetConditionalCoin, StableConditionalCoin>(
                &session,
                proposal,
                escrow,
                outcome_idx,
                conditional_stable,
                min_asset_out,
                clock,
                ctx,
            );

            // Validate slippage protection
            let conditional_amount = conditional_asset.value();
            assert!(conditional_amount >= min_asset_out, EExcessiveSlippage);

            // Step 4: Burn conditional asset coins
            coin_escrow::burn_conditional_asset<AssetType, StableType, AssetConditionalCoin>(
                escrow,
                outcome_idx,
                conditional_asset,
            );

            // Step 5: Withdraw equivalent spot asset from escrow
            let spot_asset = coin_escrow::withdraw_asset_balance<AssetType, StableType>(
                escrow,
                conditional_amount,
                ctx,
            );

            asset_coins.push_back(spot_asset);
        } else {
            // No buyback for this outcome, push zero coin
            asset_coins.push_back(coin::zero<AssetType>(ctx));
        };

        outcome_idx = outcome_idx + 1;
    };

    // Finalize swap session after all swaps complete
    swap::finalize_swap_session(session, proposal, escrow, clock);

    // Ensure all stable was used
    assert!(stable_balance.value() == 0, EAmountMismatch);
    stable_balance.destroy_zero();

    // Return asset coins per outcome (caller can burn or deposit to vault)
    asset_coins
}
/// Helper functions for building market initialization Intents
///
/// These helpers calculate Intent parameters for conditional raise and buyback strategies.
/// The actual Intent execution is done via PTB composition using Account Protocol functions.
///
/// ## Review Period Enforcement
///
/// When creating a proposal with market init, use `market_op_review_period_ms` from DaoConfig
/// as the review_period parameter (NOT the regular review_period_ms). This allows DAOs to set
/// a shorter (or zero) review period for market initialization operations.
///
/// The enforcement happens automatically in the proposal state machine - it uses whatever
/// review_period was passed during proposal creation.
module futarchy_markets::market_init_helpers;

use futarchy_markets::market_init_strategies::{
    ConditionalRaiseConfig,
    ConditionalBuybackConfig,
    Self as strategies
};

// === Helper Functions for Conditional Raise ===

/// Get the mint amount needed for a conditional raise strategy
///
/// This is the amount that should be minted via a mint Intent.
public fun raise_mint_amount(config: &ConditionalRaiseConfig): u64 {
    strategies::raise_mint_amount(config)
}

/// Get the target outcome for a conditional raise
///
/// This is the outcome index where the mint+swap will execute.
public fun raise_target_outcome(config: &ConditionalRaiseConfig): u8 {
    strategies::raise_target_outcome(config)
}

/// Get the minimum stable output for slippage protection
public fun raise_min_stable_out(config: &ConditionalRaiseConfig): u64 {
    strategies::raise_min_stable_out(config)
}

// === Helper Functions for Conditional Buyback ===

/// Get the total withdraw amount needed for a conditional buyback strategy
///
/// This is the amount that should be withdrawn from vault via a withdraw Intent.
/// It's the sum of all per-outcome buyback amounts.
public fun buyback_total_withdraw_amount(config: &ConditionalBuybackConfig): u64 {
    strategies::buyback_total_withdraw_amount(config)
}

/// Get the per-outcome buyback amounts
///
/// Returns a reference to the vector of amounts to spend in each outcome's AMM.
public fun buyback_outcome_amounts(config: &ConditionalBuybackConfig): &vector<u64> {
    strategies::buyback_outcome_amounts(config)
}

/// Get the per-outcome minimum asset outputs for slippage protection
public fun buyback_min_asset_outs(config: &ConditionalBuybackConfig): &vector<u64> {
    strategies::buyback_min_asset_outs(config)
}

// === Config Construction Helpers ===

/// Create a conditional raise config with validation
///
/// ## Parameters
/// - `target_outcome`: Which outcome AMM to trade in (usually 1 for YES)
/// - `mint_amount`: Amount of asset tokens to mint
/// - `min_stable_out`: Minimum STABLE to receive (slippage protection)
public fun new_raise_config(
    target_outcome: u8,
    mint_amount: u64,
    min_stable_out: u64,
): ConditionalRaiseConfig {
    strategies::new_conditional_raise_config(
        target_outcome,
        mint_amount,
        min_stable_out,
    )
}

/// Create a conditional buyback config with per-outcome amounts
///
/// ## Parameters
/// - `outcome_amounts`: Vector of STABLE amounts to spend per outcome
///   Example: [0, 1000, 500] for 3 outcomes
/// - `min_asset_outs`: Vector of minimum asset outputs per outcome (slippage)
public fun new_buyback_config(
    outcome_amounts: vector<u64>,
    min_asset_outs: vector<u64>,
): ConditionalBuybackConfig {
    strategies::new_conditional_buyback_config(
        outcome_amounts,
        min_asset_outs,
    )
}

// === Validation Helpers ===

/// Validate that a raise config is compatible with outcome count
///
/// Returns true if the target outcome is valid for the given outcome count.
public fun validate_raise_config(config: &ConditionalRaiseConfig, outcome_count: u64): bool {
    let target = (strategies::raise_target_outcome(config) as u64);
    target < outcome_count && target >= 1  // Outcome 0 is REJECT
}

/// Validate that a buyback config is compatible with outcome count
///
/// Returns true if the config has the correct number of outcomes.
public fun validate_buyback_config(config: &ConditionalBuybackConfig, outcome_count: u64): bool {
    let amounts = strategies::buyback_outcome_amounts(config);
    amounts.length() == outcome_count
}
module futarchy_markets::swap;

use futarchy_markets::coin_escrow::{Self, TokenEscrow};
use futarchy_markets::market_state::MarketState;
use futarchy_markets::proposal::{Self, Proposal};
use futarchy_markets::early_resolve;
use futarchy_markets::swap_position_registry::{Self, SwapPositionRegistry};
use futarchy_one_shot_utils::math;
use std::option::{Self, Option};
use sui::clock::Clock;
use sui::coin::{Self, Coin};
use sui::object::{Self, ID};

// === Introduction ===
// Swap functions for TreasuryCap-based conditional coins
// Swaps work by: burn input → update AMM reserves → mint output
//
// Hot potato pattern ensures early resolve metrics are updated once per PTB:
// 1. begin_swap_session() - creates SwapSession hot potato
// 2. swap_*() - validates session, performs swaps
// 3. finalize_swap_session() - consumes hot potato, updates metrics ONCE

// === Errors ===
const EInvalidOutcome: u64 = 0;
const EWrongTokenType: u64 = 1;
const EWrongOutcome: u64 = 2;
const EInvalidState: u64 = 3;
const EMarketIdMismatch: u64 = 4;
const EInsufficientOutput: u64 = 5;
const ESessionMismatch: u64 = 6;

// === Constants ===
const STATE_TRADING: u8 = 2; // Must match proposal.move STATE_TRADING

// === Structs ===

/// Hot potato that enforces early resolve metrics update at end of swap session
/// No abilities = must be consumed by finalize_swap_session()
public struct SwapSession {
    proposal_id: ID,  // Track which proposal this session is for
}

// === Session Management ===

/// Begin a swap session (creates hot potato)
/// Must be called before any swaps in a PTB
///
/// Creates a hot potato that must be consumed by finalize_swap_session().
/// This ensures metrics are updated exactly once after all swaps complete.
public fun begin_swap_session<AssetType, StableType>(
    proposal: &Proposal<AssetType, StableType>,
): SwapSession {
    SwapSession {
        proposal_id: object::id(proposal),
    }
}

/// Finalize swap session (consumes hot potato and updates metrics)
/// Must be called at end of PTB to consume the SwapSession
/// This is where early resolve metrics are updated ONCE for efficiency
///
/// **Idempotency Guarantee:** update_early_resolve_metrics is idempotent when called
/// multiple times at the same timestamp with unchanged state. If winner hasn't flipped,
/// the second call is a no-op (just gas cost, no state changes). This ensures correctness
/// even if accidentally called multiple times in same PTB.
///
/// **Flip Recalculation:** This function recalculates the winning outcome from current
/// AMM prices AFTER all swaps complete, ensuring flip detection happens exactly once
/// per transaction with up-to-date market state.
public fun finalize_swap_session<AssetType, StableType>(
    session: SwapSession,
    proposal: &mut Proposal<AssetType, StableType>,
    escrow: &mut TokenEscrow<AssetType, StableType>,
    clock: &Clock,
) {
    let SwapSession { proposal_id } = session;
    assert!(proposal_id == object::id(proposal), ESessionMismatch);

    // Update early resolve metrics once per session (efficient!)
    // Recalculates winner from current prices after all swaps complete
    // Get market_state from escrow to pass to early_resolve
    let market_state = coin_escrow::get_market_state_mut(escrow);
    early_resolve::update_metrics(proposal, market_state, clock);
}

// === Core Swap Functions ===

/// Swap conditional asset coins to conditional stable coins
/// Uses TreasuryCap system: burn input → AMM calculation → mint output
/// Requires valid SwapSession to ensure metrics are updated at end of PTB
public fun swap_asset_to_stable<AssetType, StableType, AssetConditionalCoin, StableConditionalCoin>(
    session: &SwapSession,
    proposal: &mut Proposal<AssetType, StableType>,
    escrow: &mut TokenEscrow<AssetType, StableType>,
    outcome_idx: u64,
    asset_in: Coin<AssetConditionalCoin>,
    min_amount_out: u64,
    clock: &Clock,
    ctx: &mut TxContext,
): Coin<StableConditionalCoin> {
    // Validate session matches proposal
    assert!(session.proposal_id == object::id(proposal), ESessionMismatch);

    assert!(proposal::state(proposal) == STATE_TRADING, EInvalidState);
    assert!(outcome_idx < proposal::outcome_count(proposal), EInvalidOutcome);

    let amount_in = asset_in.value();

    // Burn input conditional asset coins
    coin_escrow::burn_conditional_asset<AssetType, StableType, AssetConditionalCoin>(
        escrow,
        outcome_idx,
        asset_in,
    );

    // Calculate swap through AMM (access pools from market_state)
    let market_state = coin_escrow::get_market_state_mut(escrow);
    let market_id = futarchy_markets::market_state::market_id(market_state);
    let pool = futarchy_markets::market_state::get_pool_mut_by_outcome(market_state, (outcome_idx as u8));
    let amount_out = pool.swap_asset_to_stable(
        market_id,
        amount_in,
        min_amount_out,
        clock,
        ctx
    );

    assert!(amount_out >= min_amount_out, EInsufficientOutput);

    // Mint output conditional stable coins
    coin_escrow::mint_conditional_stable<AssetType, StableType, StableConditionalCoin>(
        escrow,
        outcome_idx,
        amount_out,
        ctx,
    )
}

/// Entry function wrapper for asset to stable swap
/// Creates session, swaps, finalizes session (all in one call)
public entry fun swap_asset_to_stable_entry<AssetType, StableType, AssetConditionalCoin, StableConditionalCoin>(
    proposal: &mut Proposal<AssetType, StableType>,
    escrow: &mut TokenEscrow<AssetType, StableType>,
    outcome_idx: u64,
    asset_in: Coin<AssetConditionalCoin>,
    min_amount_out: u64,
    clock: &Clock,
    ctx: &mut TxContext,
) {
    // Begin session (create hot potato)
    let session = begin_swap_session(proposal);

    // Perform swap
    let stable_out = swap_asset_to_stable<AssetType, StableType, AssetConditionalCoin, StableConditionalCoin>(
        &session,
        proposal,
        escrow,
        outcome_idx,
        asset_in,
        min_amount_out,
        clock,
        ctx,
    );

    // Finalize session (consume hot potato, update metrics)
    finalize_swap_session(session, proposal, escrow, clock);

    // Transfer output to sender
    transfer::public_transfer(stable_out, ctx.sender());
}

/// Swap conditional stable coins to conditional asset coins
/// Requires valid SwapSession to ensure metrics are updated at end of PTB
public fun swap_stable_to_asset<AssetType, StableType, AssetConditionalCoin, StableConditionalCoin>(
    session: &SwapSession,
    proposal: &mut Proposal<AssetType, StableType>,
    escrow: &mut TokenEscrow<AssetType, StableType>,
    outcome_idx: u64,
    stable_in: Coin<StableConditionalCoin>,
    min_amount_out: u64,
    clock: &Clock,
    ctx: &mut TxContext,
): Coin<AssetConditionalCoin> {
    // Validate session matches proposal
    assert!(session.proposal_id == object::id(proposal), ESessionMismatch);

    assert!(proposal::state(proposal) == STATE_TRADING, EInvalidState);
    assert!(outcome_idx < proposal::outcome_count(proposal), EInvalidOutcome);

    let amount_in = stable_in.value();

    // Burn input conditional stable coins
    coin_escrow::burn_conditional_stable<AssetType, StableType, StableConditionalCoin>(
        escrow,
        outcome_idx,
        stable_in,
    );

    // Calculate swap through AMM (access pools from market_state)
    let market_state = coin_escrow::get_market_state_mut(escrow);
    let market_id = futarchy_markets::market_state::market_id(market_state);
    let pool = futarchy_markets::market_state::get_pool_mut_by_outcome(market_state, (outcome_idx as u8));
    let amount_out = pool.swap_stable_to_asset(
        market_id,
        amount_in,
        min_amount_out,
        clock,
        ctx
    );

    assert!(amount_out >= min_amount_out, EInsufficientOutput);

    // Mint output conditional asset coins
    coin_escrow::mint_conditional_asset<AssetType, StableType, AssetConditionalCoin>(
        escrow,
        outcome_idx,
        amount_out,
        ctx,
    )
}

/// Entry function wrapper for stable to asset swap
/// Creates session, swaps, finalizes session (all in one call)
public entry fun swap_stable_to_asset_entry<AssetType, StableType, AssetConditionalCoin, StableConditionalCoin>(
    proposal: &mut Proposal<AssetType, StableType>,
    escrow: &mut TokenEscrow<AssetType, StableType>,
    outcome_idx: u64,
    stable_in: Coin<StableConditionalCoin>,
    min_amount_out: u64,
    clock: &Clock,
    ctx: &mut TxContext,
) {
    // Begin session (create hot potato)
    let session = begin_swap_session(proposal);

    // Perform swap
    let asset_out = swap_stable_to_asset<AssetType, StableType, AssetConditionalCoin, StableConditionalCoin>(
        &session,
        proposal,
        escrow,
        outcome_idx,
        stable_in,
        min_amount_out,
        clock,
        ctx,
    );

    // Finalize session (consume hot potato, update metrics)
    finalize_swap_session(session, proposal, escrow, clock);

    // Transfer output to sender
    transfer::public_transfer(asset_out, ctx.sender());
}

// === Batched Swap Entry Functions ===

/// Batch swap asset to stable across multiple outcomes in a single transaction
/// Efficient for M-of-N trading: metrics updated once after all swaps complete
///
/// **Gas Efficiency:** For M swaps, this is ~3× more efficient than M separate transactions
/// because metrics are calculated once instead of M times.
public entry fun swap_multiple_asset_to_stable_entry<AssetType, StableType, AssetConditionalCoin, StableConditionalCoin>(
    proposal: &mut Proposal<AssetType, StableType>,
    escrow: &mut TokenEscrow<AssetType, StableType>,
    outcome_indices: vector<u64>,
    mut assets_in: vector<Coin<AssetConditionalCoin>>,
    min_amounts_out: vector<u64>,
    clock: &Clock,
    ctx: &mut TxContext,
) {
    assert!(outcome_indices.length() == assets_in.length(), EInsufficientOutput);
    assert!(outcome_indices.length() == min_amounts_out.length(), EInsufficientOutput);

    // Begin session once for all swaps
    let session = begin_swap_session(proposal);

    // Transfer outputs as we go (Coins don't have drop ability)
    let sender = ctx.sender();
    let mut i = 0;
    while (i < outcome_indices.length()) {
        let stable_out = swap_asset_to_stable<AssetType, StableType, AssetConditionalCoin, StableConditionalCoin>(
            &session,
            proposal,
            escrow,
            *outcome_indices.borrow(i),
            vector::pop_back(&mut assets_in),
            *min_amounts_out.borrow(i),
            clock,
            ctx,
        );
        transfer::public_transfer(stable_out, sender);
        i = i + 1;
    };

    // Finalize session - metrics updated once after all swaps
    finalize_swap_session(session, proposal, escrow, clock);

    // Clean up empty vector
    vector::destroy_empty(assets_in);
}

/// Batch swap stable to asset across multiple outcomes in a single transaction
/// Efficient for M-of-N trading: metrics updated once after all swaps complete
public entry fun swap_multiple_stable_to_asset_entry<AssetType, StableType, AssetConditionalCoin, StableConditionalCoin>(
    proposal: &mut Proposal<AssetType, StableType>,
    escrow: &mut TokenEscrow<AssetType, StableType>,
    outcome_indices: vector<u64>,
    mut stables_in: vector<Coin<StableConditionalCoin>>,
    min_amounts_out: vector<u64>,
    clock: &Clock,
    ctx: &mut TxContext,
) {
    assert!(outcome_indices.length() == stables_in.length(), EInsufficientOutput);
    assert!(outcome_indices.length() == min_amounts_out.length(), EInsufficientOutput);

    // Begin session once for all swaps
    let session = begin_swap_session(proposal);

    // Transfer outputs as we go (Coins don't have drop ability)
    let sender = ctx.sender();
    let mut i = 0;
    while (i < outcome_indices.length()) {
        let asset_out = swap_stable_to_asset<AssetType, StableType, AssetConditionalCoin, StableConditionalCoin>(
            &session,
            proposal,
            escrow,
            *outcome_indices.borrow(i),
            vector::pop_back(&mut stables_in),
            *min_amounts_out.borrow(i),
            clock,
            ctx,
        );
        transfer::public_transfer(asset_out, sender);
        i = i + 1;
    };

    // Finalize session - metrics updated once after all swaps
    finalize_swap_session(session, proposal, escrow, clock);

    // Clean up empty vector
    vector::destroy_empty(stables_in);
}

// REMOVED: Multi-coin merge functions
// Users should merge coins in PTB using coin::join() before calling swap functions
// This keeps contract logic simple and gas-efficient

// REMOVED: create_and_swap_* functions
// These functions relied on ConditionalToken's merge_many() and split_and_return() operations
// which don't exist for native Sui Coin<T> types.
//
// With TreasuryCap-based conditional coins, users should:
// 1. Deposit spot tokens to mint conditional coins for a specific outcome
// 2. Use coin::split() and coin::join() for merging/splitting
// 3. Call swap functions directly with the conditional coins
//
// The frontend/SDK can compose these operations in PTBs as needed.

// === DEX Aggregator Compatibility Functions ===
//
// For DEX aggregators (like Aftermath), swaps during active proposals are problematic:
// - Input: 1 coin type (USDC)
// - Output: Multiple conditional coin types (Cond0_SUI + Cond1_SUI)
// - Aggregators expect single output type
//
// SOLUTION:
// 1. Smart recombination: Immediately recombine matching amounts to spot
// 2. Registry storage: Store remainder conditional coins in SwapPositionRegistry
// 3. Permissionless cranking: Anyone can settle positions after proposal resolves

/// Entry function wrapper: Swaps and uses registry by default
/// For DEX aggregators - always stores conditionals in registry
public entry fun swap_stable_to_asset_with_registry_2<AssetType, StableType, Cond0Asset, Cond1Asset, Cond0Stable, Cond1Stable>(
    proposal: &mut Proposal<AssetType, StableType>,
    escrow: &mut TokenEscrow<AssetType, StableType>,
    registry: &mut SwapPositionRegistry<AssetType, StableType>,
    stable_in: Coin<StableType>,
    min_asset_out: u64,
    clock: &Clock,
    ctx: &mut TxContext,
) {
    let session = begin_swap_session(proposal);

    // Determine routing strategy
    let outcome_0_amount = stable_in.value() / 2;
    let _outcome_1_amount = stable_in.value() - outcome_0_amount;

    // Split input for each outcome
    let stable_for_0 = if (outcome_0_amount > 0) {
        stable_in.split(outcome_0_amount, ctx)
    } else {
        coin::zero<StableType>(ctx)
    };
    let stable_for_1 = stable_in;

    // Swap in each conditional pool
    let cond_asset_0 = if (stable_for_0.value() > 0) {
        let cond_stable = coin_escrow::deposit_stable_and_mint_conditional<AssetType, StableType, Cond0Stable>(
            escrow, 0, stable_for_0, ctx
        );
        let amount_in = cond_stable.value();
        coin_escrow::burn_conditional_stable(escrow, 0, cond_stable);
        let market_state = coin_escrow::get_market_state_mut(escrow);
        let pool = futarchy_markets::market_state::get_pool_mut_by_outcome(market_state, 0);
        let market_id = futarchy_markets::market_state::market_id(market_state);
        let amount_out = pool.swap_stable_to_asset(market_id, amount_in, 0, clock, ctx);
        coin_escrow::mint_conditional_asset<AssetType, StableType, Cond0Asset>(escrow, 0, amount_out, ctx)
    } else {
        coin::destroy_zero(stable_for_0);
        coin::zero<Cond0Asset>(ctx)
    };

    let cond_asset_1 = if (stable_for_1.value() > 0) {
        let cond_stable = coin_escrow::deposit_stable_and_mint_conditional<AssetType, StableType, Cond1Stable>(
            escrow, 1, stable_for_1, ctx
        );
        let amount_in = cond_stable.value();
        coin_escrow::burn_conditional_stable(escrow, 1, cond_stable);
        let market_state = coin_escrow::get_market_state_mut(escrow);
        let pool = futarchy_markets::market_state::get_pool_mut_by_outcome(market_state, 1);
        let market_id = futarchy_markets::market_state::market_id(market_state);
        let amount_out = pool.swap_stable_to_asset(market_id, amount_in, 0, clock, ctx);
        coin_escrow::mint_conditional_asset<AssetType, StableType, Cond1Asset>(escrow, 1, amount_out, ctx)
    } else {
        coin::destroy_zero(stable_for_1);
        coin::zero<Cond1Asset>(ctx)
    };

    // Smart recombination
    let amount_0 = cond_asset_0.value();
    let amount_1 = cond_asset_1.value();
    let min_amount = math::min(amount_0, amount_1);

    let spot_asset = if (min_amount > 0) {
        let to_burn_0 = cond_asset_0.split(min_amount, ctx);
        let to_burn_1 = cond_asset_1.split(min_amount, ctx);
        coin_escrow::burn_conditional_asset(escrow, 0, to_burn_0);
        coin_escrow::burn_conditional_asset(escrow, 1, to_burn_1);
        coin_escrow::withdraw_asset_balance(escrow, min_amount, ctx)
    } else {
        coin::zero<AssetType>(ctx)
    };

    // Store remainders in registry
    let proposal_id = object::id(proposal);
    let owner = ctx.sender();

    if (cond_asset_0.value() > 0) {
        swap_position_registry::store_conditional_asset(
            registry, owner, proposal_id, 0, cond_asset_0, clock, ctx
        );
    } else {
        coin::destroy_zero(cond_asset_0);
    };

    if (cond_asset_1.value() > 0) {
        swap_position_registry::store_conditional_asset(
            registry, owner, proposal_id, 1, cond_asset_1, clock, ctx
        );
    } else {
        coin::destroy_zero(cond_asset_1);
    };

    finalize_swap_session(session, proposal, escrow, clock);

    // Verify min output
    assert!(spot_asset.value() >= min_asset_out, EInsufficientOutput);

    // Transfer spot asset to user
    if (spot_asset.value() > 0) {
        transfer::public_transfer(spot_asset, ctx.sender());
    } else {
        coin::destroy_zero(spot_asset);
    };
}
/// ============================================================================
/// N-OUTCOME ARBITRAGE MATH - EFFICIENT B-PARAMETERIZATION
/// ============================================================================
///
/// IMPROVEMENTS IMPLEMENTED (Mathematician's Suggestions):
/// ✅ 1. B-parameterization - No square roots, cleaner math
/// ✅ 2. Active-set pruning - 40-60% gas reduction
/// ✅ 3. Early exit checks - Skip calculation when no arbitrage exists
/// ✅ 4. Bidirectional solving - Catches all opportunities
/// ✅ 5. Min profit threshold - Simple profitability check
///
/// MATH FOUNDATION:
///
/// Instead of searching for optimal input x, we search for optimal output b.
/// For constant product AMMs with quantum liquidity constraint:
///
/// x(b) = max_i [b × A_i / (T_i - b × B_i)]  (no square root!)
/// F(b) = b - x(b)                            (profit function)
///
/// Where:
///   T_i = (R_i_stable × α_i) × (R_spot_asset × β)
///   A_i = R_i_asset × R_spot_stable
///   B_i = β × (R_i_asset + α_i × R_spot_asset)
///
/// Domain: b ∈ [0, U_b) where U_b = min_i(T_i/B_i)
///
/// ============================================================================

module futarchy_markets::arbitrage_math;

use futarchy_markets::spot_amm::{Self, SpotAMM};
use futarchy_markets::conditional_amm::{Self, LiquidityPool};
use futarchy_one_shot_utils::math;

// === Errors ===
const ETooManyConditionals: u64 = 0;

// === Constants ===
const MAX_CONDITIONALS: u64 = 50; // Protocol limit - O(N²) with pruning stays performant
const BPS_SCALE: u64 = 10000;     // Basis points scale

// Gas cost estimates (with active-set pruning):
//   N=10:  ~11k gas  ✅ Instant
//   N=20:  ~18k gas  ✅ Very fast
//   N=50:  ~111k gas ✅ Fast (new limit)
//   N=100: ~417k gas ⚠️ Expensive (use off-chain dev_inspect)
//
// Complexity: O(N²) from pruning + O(log U_b × N_pruned) from search
// Pruning typically reduces N to 2-3 active outcomes

// === Public API ===

/// Compute optimal arbitrage with bidirectional search
/// Returns (optimal_amount, expected_profit, is_spot_to_cond)
///
/// Tries both directions:
/// - Spot → Conditional (buy from spot, sell to conditionals)
/// - Conditional → Spot (buy from conditionals, sell to spot)
///
/// Returns the more profitable direction
public fun compute_optimal_arbitrage_bidirectional<AssetType, StableType>(
    spot: &SpotAMM<AssetType, StableType>,
    conditionals: &vector<LiquidityPool>,
    min_profit: u64,  // Minimum acceptable profit threshold
): (u64, u128, bool) {
    // Try Spot → Conditional arbitrage
    let (x_stc, profit_stc) = compute_optimal_spot_to_conditional(
        spot,
        conditionals,
        min_profit,
    );

    // Try Conditional → Spot arbitrage
    let (x_cts, profit_cts) = compute_optimal_conditional_to_spot(
        spot,
        conditionals,
        min_profit,
    );

    // Return more profitable direction
    if (profit_stc >= profit_cts) {
        (x_stc, profit_stc, true)  // Spot → Conditional
    } else {
        (x_cts, profit_cts, false) // Conditional → Spot
    }
}

/// Compute optimal Spot → Conditional arbitrage using b-parameterization
/// More efficient than x-parameterization (no square roots)
public fun compute_optimal_spot_to_conditional<AssetType, StableType>(
    spot: &SpotAMM<AssetType, StableType>,
    conditionals: &vector<LiquidityPool>,
    min_profit: u64,
): (u64, u128) {
    let num_conditionals = vector::length(conditionals);
    if (num_conditionals == 0) return (0, 0);

    assert!(num_conditionals <= MAX_CONDITIONALS, ETooManyConditionals);

    // Get spot reserves and fee
    let (spot_asset, spot_stable) = spot_amm::get_reserves(spot);
    let spot_fee_bps = spot_amm::get_fee_bps(spot);

    // Build T, A, B constants
    let (ts, as_vals, bs) = build_tab_constants(
        spot_asset,
        spot_stable,
        spot_fee_bps,
        conditionals,
    );

    // OPTIMIZATION 1: Early exit - check if arbitrage is obviously impossible
    if (early_exit_check_spot_to_cond(&ts, &as_vals)) {
        return (0, 0)
    };

    // OPTIMIZATION 2: Prune dominated outcomes (40-60% gas reduction)
    let (ts_pruned, as_pruned, bs_pruned) = prune_dominated(ts, as_vals, bs);

    if (vector::length(&ts_pruned) == 0) return (0, 0);

    // OPTIMIZATION 3: B-parameterization search (no square roots)
    let (b_star, profit) = optimal_b_search(&ts_pruned, &as_pruned, &bs_pruned);

    // Check min profit threshold
    if (profit < (min_profit as u128)) {
        return (0, 0)
    };

    // Convert b* to x* (input amount needed)
    let x_star = x_required_for_b(&ts_pruned, &as_pruned, &bs_pruned, b_star);

    (x_star, profit)
}

/// Compute optimal Conditional → Spot arbitrage using b-parameterization
/// Buy from all conditionals, recombine, sell to spot
///
/// **Strategy:**
/// 1. Buy b conditional assets from EACH conditional pool (costs stable)
/// 2. Recombine b complete sets → b base assets
/// 3. Sell b base assets to spot → get stable output
/// 4. Profit: spot_output - total_cost_from_all_conditionals
///
/// **Math:**
/// - Cost from pool i: c_i(b) = (R_i_stable * b) / ((R_i_asset - b) * α_i)
/// - Total cost: C(b) = Σ_i c_i(b) (must buy from ALL pools!)
/// - Spot output: S(b) = (R_spot_stable * b * β) / (R_spot_asset + b * β)
/// - Profit: F(b) = S(b) - C(b)
/// - Domain: b ∈ [0, min_i(R_i_asset))
///
/// **Key Difference from Spot→Cond:**
/// - Spot→Cond: max_i constraint (bottleneck is worst pool)
/// - Cond→Spot: sum_i constraint (need to buy from ALL pools)
public fun compute_optimal_conditional_to_spot<AssetType, StableType>(
    spot: &SpotAMM<AssetType, StableType>,
    conditionals: &vector<LiquidityPool>,
    min_profit: u64,
): (u64, u128) {
    let num_conditionals = vector::length(conditionals);
    if (num_conditionals == 0) return (0, 0);

    assert!(num_conditionals <= MAX_CONDITIONALS, ETooManyConditionals);

    // Get spot reserves and fee
    let (spot_asset, spot_stable) = spot_amm::get_reserves(spot);
    let spot_fee_bps = spot_amm::get_fee_bps(spot);
    let beta = BPS_SCALE - spot_fee_bps;

    // Find upper bound: min_i(R_i_asset) - can't buy more than smallest pool has
    // Also limited by spot asset liquidity (can't sell more than spot can absorb)
    let mut upper_bound = spot_asset;
    let mut i = 0;
    while (i < num_conditionals) {
        let conditional = vector::borrow(conditionals, i);
        let (cond_asset, _cond_stable) = conditional_amm::get_reserves(conditional);
        if (cond_asset < upper_bound) {
            upper_bound = cond_asset;
        };
        i = i + 1;
    };

    // Need reasonable liquidity for arbitrage
    if (upper_bound < 100) return (0, 0);

    // Use 95% of upper bound to avoid edge case issues near boundary
    let max_b = ((upper_bound as u128) * 95) / 100;
    if (max_b > (std::u64::max_value!() as u128)) {
        return (0, 0) // Overflow protection
    };
    let max_b_u64 = (max_b as u64);

    // Ternary search for optimal b
    let mut best_b = 0u64;
    let mut best_profit = 0u128;
    let mut left = 0u64;
    let mut right = max_b_u64;

    while (right - left > 9) {
        let third = (right - left) / 3;
        let m1 = left + third;
        let m2 = right - third;

        let profit_m1 = profit_conditional_to_spot(
            spot_asset, spot_stable, beta,
            conditionals, m1
        );
        let profit_m2 = profit_conditional_to_spot(
            spot_asset, spot_stable, beta,
            conditionals, m2
        );

        if (profit_m1 >= profit_m2) {
            right = m2;
        } else {
            left = m1;
        }
    };

    // Final scan on small window
    let mut b = left;
    while (b <= right) {
        let profit = profit_conditional_to_spot(
            spot_asset, spot_stable, beta,
            conditionals, b
        );
        if (profit > best_profit) {
            best_profit = profit;
            best_b = b;
        };
        b = b + 1;
    };

    // Check min profit threshold
    if (best_profit < (min_profit as u128)) {
        return (0, 0)
    };

    (best_b, best_profit)
}

/// Original x-parameterization interface (for compatibility)
/// Now uses b-parameterization internally for efficiency
public fun compute_optimal_spot_arbitrage<AssetType, StableType>(
    spot: &SpotAMM<AssetType, StableType>,
    conditionals: &vector<LiquidityPool>,
    is_asset_to_stable: bool,
): (u64, u128) {
    // Use new bidirectional solver with 0 min_profit
    let (amount, profit, is_spot_to_cond) = compute_optimal_arbitrage_bidirectional(
        spot,
        conditionals,
        0,  // No min profit for compatibility
    );

    // Return based on direction match
    if (is_asset_to_stable == is_spot_to_cond) {
        (amount, profit)
    } else {
        (0, 0)  // Direction mismatch
    }
}

// === Core B-Parameterization Functions ===

/// Find optimal b using discrete search
/// b is the recombinable stable output (what we get from min of all conditionals)
fun optimal_b_search(
    ts: &vector<u128>,
    as_vals: &vector<u128>,
    bs: &vector<u128>,
): (u64, u128) {
    let n = vector::length(ts);
    if (n == 0) return (0, 0);

    // Calculate upper bound: U_b = min_i(T_i / B_i)
    let ub = upper_bound_b(ts, bs);
    if (ub == 0) return (0, 0);

    // Discrete ternary search on b ∈ [0, U_b]
    let mut left = 0u64;
    let mut right = ub;

    while (right - left > 9) {
        let third = (right - left) / 3;
        let m1 = left + third;
        let m2 = right - third;

        let profit_m1 = profit_at_b(ts, as_vals, bs, m1);
        let profit_m2 = profit_at_b(ts, as_vals, bs, m2);

        if (profit_m1 >= profit_m2) {
            right = m2;
        } else {
            left = m1;
        }
    };

    // Final scan on small window
    let mut best_b = left;
    let mut best_profit = profit_at_b(ts, as_vals, bs, best_b);

    let mut b = left + 1;
    while (b <= right) {
        let profit = profit_at_b(ts, as_vals, bs, b);
        if (profit > best_profit) {
            best_profit = profit;
            best_b = b;
        };
        b = b + 1;
    };

    (best_b, best_profit)
}

/// Calculate profit at given b value
/// F(b) = b - x(b) where x(b) = max_i x_i(b)
fun profit_at_b(
    ts: &vector<u128>,
    as_vals: &vector<u128>,
    bs: &vector<u128>,
    b: u64,
): u128 {
    let x = x_required_for_b(ts, as_vals, bs, b);
    if (b > x) {
        ((b - x) as u128)
    } else {
        0
    }
}

/// Calculate input x required to achieve output b
/// x(b) = max_i [b × A_i / (T_i - b × B_i)]
///
/// OVERFLOW PROTECTION: Checks for u128 overflow on b × B_i and b × A_i
fun x_required_for_b(
    ts: &vector<u128>,
    as_vals: &vector<u128>,
    bs: &vector<u128>,
    b: u64,
): u64 {
    let n = vector::length(ts);
    if (n == 0) return 0;

    let b_u128 = (b as u128);
    let mut x_max = 0u128;

    let mut i = 0;
    while (i < n) {
        let ti = *vector::borrow(ts, i);
        let ai = *vector::borrow(as_vals, i);
        let bi = *vector::borrow(bs, i);

        // OVERFLOW FIX #1: Check b × B_i overflow before calculating denominator
        let b_bi_product = if (bi > 0 && b_u128 > std::u128::max_value!() / bi) {
            // Overflow would occur - this pool is dominated, skip it
            i = i + 1;
            continue
        } else {
            b_u128 * bi
        };

        // x_i(b) = ceil(b × A_i / (T_i - b × B_i))
        if (ti <= b_bi_product) {
            // Denominator would be <= 0, skip this pool
            i = i + 1;
            continue
        };

        let denom = ti - b_bi_product;

        // OVERFLOW FIX #2: Check b × A_i overflow before calculating numerator
        let numerator = if (ai > std::u128::max_value!() / b_u128) {
            // Overflow would occur - this pool requires maximum input
            // Return saturated max as this pool is the bottleneck
            return std::u64::max_value!()
        } else {
            b_u128 * ai
        };

        let xi = div_ceil(numerator, denom);

        if (xi > x_max) {
            x_max = xi;
        };

        i = i + 1;
    };

    // Saturate to u64
    if (x_max > (std::u64::max_value!() as u128)) {
        std::u64::max_value!()
    } else {
        (x_max as u64)
    }
}

/// Upper bound on b: floor(min_i (T_i - 1) / B_i)
/// SECURITY FIX: Treat ti <= 1 as ub_i = 0 (not skip) to avoid inflating U_b
fun upper_bound_b(ts: &vector<u128>, bs: &vector<u128>): u64 {
    let n = vector::length(ts);
    if (n == 0) return 0;

    let mut ub: u128 = std::u64::max_value!() as u128;

    let mut i = 0;
    while (i < n) {
        let ti = *vector::borrow(ts, i);
        let bi = *vector::borrow(bs, i);

        // FIX: If ti <= 1 or bi == 0, treat as ub_i = 0 (not skip!)
        // Skipping incorrectly inflates the upper bound
        let ub_i = if (bi == 0 || ti <= 1) {
            0u128
        } else {
            (ti - 1) / bi
        };

        if (ub_i < ub) {
            ub = ub_i;
        };

        i = i + 1;
    };

    if (ub > (std::u64::max_value!() as u128)) {
        std::u64::max_value!()
    } else {
        (ub as u64)
    }
}

// === Optimization Functions ===

/// Early exit check: if all conditionals are cheaper than spot, no Spot→Cond arbitrage
/// Check: if min_i(T_i/A_i) <= 1, return true (exit early)
fun early_exit_check_spot_to_cond(ts: &vector<u128>, as_vals: &vector<u128>): bool {
    let n = vector::length(ts);
    let mut i = 0;
    while (i < n) {
        let ti = *vector::borrow(ts, i);
        let ai = *vector::borrow(as_vals, i);

        // If T_i <= A_i, conditional i is cheaper/equal to spot
        if (ti <= ai) {
            return true  // No profitable arbitrage
        };

        i = i + 1;
    };
    false  // All conditionals expensive, arbitrage may be possible
}

/// Safe cross-product comparison: Check if a * b <= c * d without overflow
/// OVERFLOW PROTECTION: Avoids u128 × u128 overflow by using division
///
/// Returns true if a/c <= d/b (equivalent to a×b <= c×d when all positive)
/// This loses some precision but avoids overflow for large values
fun safe_cross_product_le(a: u128, b: u128, c: u128, d: u128): bool {
    // Handle zero cases
    if (c == 0 && d == 0) return true;   // Both ratios undefined, treat as equal
    if (c == 0) return false;            // a/0 is infinite, not <= d/b
    if (d == 0) return a == 0;           // a/c <= 0/b only if a == 0

    // Try exact comparison if no overflow risk (heuristic check)
    // If both products fit in u128, use exact comparison
    let max_safe = 340282366920938463463374607431768211455u128 / 2; // u128::MAX / 2
    if (a < max_safe && b < max_safe && c < max_safe && d < max_safe) {
        // Safe to multiply directly
        return a * b <= c * d
    };

    // Fall back to division-based comparison (loses precision but avoids overflow)
    let quotient_ab = a / c;
    let quotient_cd = d / b;

    if (quotient_ab < quotient_cd) return true;
    if (quotient_ab > quotient_cd) return false;

    // Quotients equal - check remainders to break tie
    let rem_a = a % c;
    let rem_d = d % b;

    // rem_a / c <= rem_d / b  =>  rem_a * b <= rem_d * c
    // This can still overflow, but less likely since remainders are smaller
    if (rem_a < max_safe && rem_d < max_safe) {
        rem_a * b <= rem_d * c
    } else {
        // Even remainders might overflow - give up and assume equal
        true
    }
}

/// Prune dominated outcomes to reduce search space
/// Outcome j is dominated by i if: T_i/A_i ≤ T_j/A_j AND T_i/B_i ≤ T_j/B_j
/// Then s_j(x) ≥ s_i(x) for all x ≥ 0, so drop j
///
/// OVERFLOW PROTECTION: Uses safe_cross_product_le() to avoid u128 × u128 overflow
fun prune_dominated(
    ts: vector<u128>,
    as_vals: vector<u128>,
    bs: vector<u128>,
): (vector<u128>, vector<u128>, vector<u128>) {
    let n = vector::length(&ts);
    if (n <= 1) return (ts, as_vals, bs);

    let mut keep = vector::empty<bool>();
    let mut i = 0;
    while (i < n) {
        vector::push_back(&mut keep, true);
        i = i + 1;
    };

    // Check each pair
    let mut p = 0;
    while (p < n) {
        if (!*vector::borrow(&keep, p)) {
            p = p + 1;
            continue
        };

        let mut q = p + 1;
        while (q < n) {
            if (!*vector::borrow(&keep, q)) {
                q = q + 1;
                continue
            };

            let tp = *vector::borrow(&ts, p);
            let ap = *vector::borrow(&as_vals, p);
            let bp = *vector::borrow(&bs, p);

            let tq = *vector::borrow(&ts, q);
            let aq = *vector::borrow(&as_vals, q);
            let bq = *vector::borrow(&bs, q);

            // OVERFLOW FIX: Use safe comparison instead of direct multiplication
            // Check if p dominates q: T_p/A_p ≤ T_q/A_q AND T_p/B_p ≤ T_q/B_q
            let ta_check = safe_cross_product_le(tp, aq, tq, ap);
            let tb_check = safe_cross_product_le(tp, bq, tq, bp);

            if (ta_check && tb_check) {
                // p dominates q (p is always cheaper/equal), drop q
                *vector::borrow_mut(&mut keep, q) = false;
            } else {
                // Check if q dominates p
                let ta_check_rev = safe_cross_product_le(tq, ap, tp, aq);
                let tb_check_rev = safe_cross_product_le(tq, bp, tp, bq);

                if (ta_check_rev && tb_check_rev) {
                    // q dominates p, drop p
                    *vector::borrow_mut(&mut keep, p) = false;
                    break  // p is dropped, move to next p
                }
            };

            q = q + 1;
        };

        p = p + 1;
    };

    // Build pruned vectors
    let mut ts_pruned = vector::empty<u128>();
    let mut as_pruned = vector::empty<u128>();
    let mut bs_pruned = vector::empty<u128>();

    let mut k = 0;
    while (k < n) {
        if (*vector::borrow(&keep, k)) {
            vector::push_back(&mut ts_pruned, *vector::borrow(&ts, k));
            vector::push_back(&mut as_pruned, *vector::borrow(&as_vals, k));
            vector::push_back(&mut bs_pruned, *vector::borrow(&bs, k));
        };
        k = k + 1;
    };

    (ts_pruned, as_pruned, bs_pruned)
}

// === TAB Constants (Same as Before) ===

fun build_tab_constants(
    spot_asset_reserve: u64,
    spot_stable_reserve: u64,
    spot_fee_bps: u64,
    conditionals: &vector<LiquidityPool>,
): (vector<u128>, vector<u128>, vector<u128>) {
    let num_conditionals = vector::length(conditionals);
    let mut ts_vec = vector::empty<u128>();
    let mut as_vec = vector::empty<u128>();
    let mut bs_vec = vector::empty<u128>();

    let beta = BPS_SCALE - spot_fee_bps;

    let mut i = 0;
    while (i < num_conditionals) {
        let conditional = vector::borrow(conditionals, i);
        let (cond_asset, cond_stable) = conditional_amm::get_reserves(conditional);
        let cond_fee_bps = conditional_amm::get_fee_bps(conditional);
        let alpha_i = BPS_SCALE - cond_fee_bps;

        // T_i = (cond_stable * alpha_i / 10000) * (spot_asset * beta / 10000)
        let t1 = math::mul_div_to_128(cond_stable, alpha_i, BPS_SCALE);
        let t2 = math::mul_div_to_128(spot_asset_reserve, beta, BPS_SCALE);

        // OVERFLOW FIX: Check t1 × t2 overflow and saturate if needed
        let t1_u128 = (t1 as u128);
        let t2_u128 = (t2 as u128);
        let ti = if (t2_u128 > 0 && t1_u128 > std::u128::max_value!() / t2_u128) {
            // Overflow - saturate to max u128
            // This pool has extremely large reserves, treat as infinite liquidity
            std::u128::max_value!()
        } else {
            t1_u128 * t2_u128
        };

        // A_i = cond_asset * spot_stable
        let ai = (cond_asset as u128) * (spot_stable_reserve as u128);

        // B_i = beta * (cond_asset + alpha_i * spot_asset / 10000) / 10000
        let alpha_spot = math::mul_div_to_128(spot_asset_reserve, alpha_i, BPS_SCALE);
        let temp = (cond_asset as u128) + alpha_spot;
        // Type fix: Cast BPS_SCALE to u128 for division
        let bi = (temp * (beta as u128)) / (BPS_SCALE as u128);

        vector::push_back(&mut ts_vec, ti);
        vector::push_back(&mut as_vec, ai);
        vector::push_back(&mut bs_vec, bi);

        i = i + 1;
    };

    (ts_vec, as_vec, bs_vec)
}

// === Simulation Functions (For Verification) ===

/// Calculate arbitrage profit for specific amount (simulation)
public fun calculate_spot_arbitrage_profit<AssetType, StableType>(
    spot: &SpotAMM<AssetType, StableType>,
    conditionals: &vector<LiquidityPool>,
    arbitrage_amount: u64,
    is_asset_to_stable: bool,
): u128 {
    simulate_spot_to_conditional_profit(spot, conditionals, arbitrage_amount, is_asset_to_stable)
}

fun simulate_spot_to_conditional_profit<AssetType, StableType>(
    spot: &SpotAMM<AssetType, StableType>,
    conditionals: &vector<LiquidityPool>,
    arbitrage_amount: u64,
    is_asset_to_stable: bool,
): u128 {
    let spot_output = if (is_asset_to_stable) {
        spot_amm::simulate_swap_stable_to_asset(spot, arbitrage_amount)
    } else {
        spot_amm::simulate_swap_asset_to_stable(spot, arbitrage_amount)
    };

    if (spot_output == 0) return 0;

    let num_outcomes = vector::length(conditionals);
    let mut min_conditional_output = std::u64::max_value!();

    let mut i = 0;
    while (i < num_outcomes) {
        let conditional = vector::borrow(conditionals, i);

        let cond_output = if (is_asset_to_stable) {
            conditional_amm::simulate_swap_asset_to_stable(conditional, spot_output)
        } else {
            conditional_amm::simulate_swap_stable_to_asset(conditional, spot_output)
        };

        min_conditional_output = math::min(min_conditional_output, cond_output);
        i = i + 1;
    };

    if (min_conditional_output > arbitrage_amount) {
        ((min_conditional_output - arbitrage_amount) as u128)
    } else {
        0
    }
}

fun simulate_conditional_to_spot_profit<AssetType, StableType>(
    spot: &SpotAMM<AssetType, StableType>,
    conditionals: &vector<LiquidityPool>,
    arbitrage_amount: u64,
): u128 {
    // Simplified simulation for Conditional → Spot direction
    // In practice, this requires more complex complete set acquisition

    let num_outcomes = vector::length(conditionals);
    if (num_outcomes == 0) return 0;

    // For each conditional, simulate buying with arbitrage_amount
    let mut total_cost = 0u128;
    let mut i = 0;

    while (i < num_outcomes) {
        let conditional = vector::borrow(conditionals, i);
        // Assume we need to buy conditional tokens
        // This is simplified - real implementation needs complete set logic
        total_cost = total_cost + (arbitrage_amount as u128);
        i = i + 1;
    };

    // Simulate selling recombined to spot
    let spot_output = spot_amm::simulate_swap_asset_to_stable(spot, arbitrage_amount);

    if ((spot_output as u128) > total_cost) {
        (spot_output as u128) - total_cost
    } else {
        0
    }
}

/// Conditional arbitrage (legacy compatibility)
public fun calculate_conditional_arbitrage_profit<AssetType, StableType>(
    spot: &SpotAMM<AssetType, StableType>,
    conditionals: &vector<LiquidityPool>,
    swapped_outcome_idx: u8,
    arbitrage_amount: u64,
    is_asset_to_stable: bool,
): u128 {
    let swapped_conditional = vector::borrow(conditionals, (swapped_outcome_idx as u64));

    let cond_output = if (is_asset_to_stable) {
        conditional_amm::simulate_swap_stable_to_asset(swapped_conditional, arbitrage_amount)
    } else {
        conditional_amm::simulate_swap_asset_to_stable(swapped_conditional, arbitrage_amount)
    };

    if (cond_output == 0) return 0;

    let spot_output = if (is_asset_to_stable) {
        spot_amm::simulate_swap_asset_to_stable(spot, cond_output)
    } else {
        spot_amm::simulate_swap_stable_to_asset(spot, cond_output)
    };

    if (spot_output > arbitrage_amount) {
        ((spot_output - arbitrage_amount) as u128)
    } else {
        0
    }
}

// === Helper Functions ===

/// Ceiling division: ceil(a / b)
fun div_ceil(a: u128, b: u128): u128 {
    if (b == 0) return 0;
    if (a == 0) return 0;
    ((a - 1) / b) + 1
}

// === Conditional → Spot Helper Functions ===

/// Calculate profit for Conditional → Spot arbitrage at given b
/// F(b) = S(b) - C(b)
/// where:
/// - S(b) = spot output from selling b base assets
/// - C(b) = total cost to buy b conditional assets from all pools
fun profit_conditional_to_spot(
    spot_asset: u64,
    spot_stable: u64,
    beta: u64,  // spot fee multiplier (BPS_SCALE - fee_bps)
    conditionals: &vector<LiquidityPool>,
    b: u64,
): u128 {
    if (b == 0) return 0;

    // Calculate spot revenue: S(b) = spot output from selling b base assets
    let spot_revenue = calculate_spot_revenue(spot_asset, spot_stable, beta, b);

    // Calculate total cost from all conditional pools: C(b) = Σ_i c_i(b)
    let total_cost = calculate_conditional_cost(conditionals, b);

    // Profit: S(b) - C(b)
    if (spot_revenue > total_cost) {
        spot_revenue - total_cost
    } else {
        0
    }
}

/// Calculate revenue from selling b base assets to spot
/// S(b) = (R_spot_stable * b * β) / (R_spot_asset * BPS_SCALE + b * β)
///
/// Derivation:
/// - Before swap: (R_spot_asset, R_spot_stable)
/// - Add b assets (after fee: b * β / BPS_SCALE)
/// - Remove stable_out
/// - Constant product: R_spot_asset * R_spot_stable = (R_spot_asset + b*β/BPS_SCALE) * (R_spot_stable - stable_out)
/// - Solving: stable_out = R_spot_stable * (b*β/BPS_SCALE) / (R_spot_asset + b*β/BPS_SCALE)
/// - Simplify: stable_out = (R_spot_stable * b * β) / (R_spot_asset * BPS_SCALE + b * β)
fun calculate_spot_revenue(
    spot_asset: u64,
    spot_stable: u64,
    beta: u64,
    b: u64,
): u128 {
    let b_u128 = (b as u128);
    let beta_u128 = (beta as u128);
    let spot_stable_u128 = (spot_stable as u128);
    let spot_asset_u128 = (spot_asset as u128);

    // Numerator: R_spot_stable * b * β
    // Check overflow on b * β
    if (beta_u128 > 0 && b_u128 > std::u128::max_value!() / beta_u128) {
        return std::u128::max_value!() // Saturate
    };
    let b_beta = b_u128 * beta_u128;

    // Check overflow on spot_stable * (b * β)
    if (spot_stable_u128 > std::u128::max_value!() / b_beta) {
        return std::u128::max_value!() // Saturate
    };
    let numerator = spot_stable_u128 * b_beta;

    // Denominator: R_spot_asset * BPS_SCALE + b * β
    let spot_asset_scaled = spot_asset_u128 * (BPS_SCALE as u128);
    let denominator = spot_asset_scaled + b_beta;

    if (denominator == 0) return 0;

    numerator / denominator
}

/// Calculate total cost to buy b conditional assets from all pools
/// C(b) = Σ_i c_i(b) where c_i(b) = (R_i_stable * b * BPS_SCALE) / ((R_i_asset - b) * α_i)
///
/// Derivation for pool i:
/// - Before swap: (R_i_asset, R_i_stable)
/// - Add stable_in (after fee: stable_in * α_i / BPS_SCALE)
/// - Remove b assets
/// - Constant product: R_i_asset * R_i_stable = (R_i_asset - b) * (R_i_stable + stable_in*α_i/BPS_SCALE)
/// - Solving: stable_in = (R_i_stable * b * BPS_SCALE) / ((R_i_asset - b) * α_i)
fun calculate_conditional_cost(
    conditionals: &vector<LiquidityPool>,
    b: u64,
): u128 {
    let num_conditionals = vector::length(conditionals);
    let mut total_cost = 0u128;
    let b_u128 = (b as u128);

    let mut i = 0;
    while (i < num_conditionals) {
        let conditional = vector::borrow(conditionals, i);
        let (cond_asset, cond_stable) = conditional_amm::get_reserves(conditional);
        let cond_fee_bps = conditional_amm::get_fee_bps(conditional);
        let alpha = BPS_SCALE - cond_fee_bps;

        // Skip if b >= R_i_asset (can't buy more than pool has)
        if (b >= cond_asset) {
            // This makes arbitrage impossible - need b from ALL pools
            return std::u128::max_value!() // Infinite cost
        };

        // Cost from pool i: c_i(b) = (R_i_stable * b * BPS_SCALE) / ((R_i_asset - b) * α_i)
        let cond_asset_u128 = (cond_asset as u128);
        let cond_stable_u128 = (cond_stable as u128);
        let alpha_u128 = (alpha as u128);

        // Numerator: R_i_stable * b * BPS_SCALE
        // Check overflow on cond_stable * b
        if (cond_stable_u128 > 0 && b_u128 > std::u128::max_value!() / cond_stable_u128) {
            return std::u128::max_value!() // Infinite cost (overflow)
        };
        let stable_b = cond_stable_u128 * b_u128;

        // Check overflow on (cond_stable * b) * BPS_SCALE
        let bps_u128 = (BPS_SCALE as u128);
        if (stable_b > std::u128::max_value!() / bps_u128) {
            return std::u128::max_value!() // Infinite cost (overflow)
        };
        let numerator = stable_b * bps_u128;

        // Denominator: (R_i_asset - b) * α_i
        let asset_minus_b = cond_asset_u128 - b_u128;
        if (asset_minus_b == 0) {
            return std::u128::max_value!() // Division by zero (infinite cost)
        };

        // Check overflow on (R_i_asset - b) * α_i
        if (asset_minus_b > std::u128::max_value!() / alpha_u128) {
            // Denominator overflow means cost is very small - continue
            total_cost = total_cost + 0;
        } else {
            let denominator = asset_minus_b * alpha_u128;
            if (denominator == 0) {
                return std::u128::max_value!() // Infinite cost
            };

            let cost_i = numerator / denominator;

            // Add to total (check overflow)
            if (total_cost > std::u128::max_value!() - cost_i) {
                return std::u128::max_value!() // Saturate (total cost too high)
            };
            total_cost = total_cost + cost_i;
        };

        i = i + 1;
    };

    total_cost
}
/// ============================================================================
/// ARBITRAGE EXECUTOR - AUTOMATIC EQUILIBRIUM MAINTENANCE
/// ============================================================================
///
/// Provides composable arbitrage execution functions that run after swaps
/// to maintain price equilibrium and eliminate mint/redeem cycles.
///
/// ARCHITECTURE:
/// 1. User swaps in spot → creates arbitrage opportunity
/// 2. Call execute_spot_arbitrage() in same PTB
/// 3. System mints conditional → swaps → redeems → profits returned to user
///
/// USAGE IN PTB:
/// ```
/// // Spot swap with auto-arbitrage
/// let stable_out = spot_amm::swap_asset_to_stable(...);
/// let arb_profit = arbitrage_executor::execute_spot_arbitrage_asset_to_stable(...);
/// coin::join(&mut stable_out, arb_profit);
/// ```
///
/// ============================================================================

module futarchy_markets::arbitrage_executor;

use futarchy_markets::spot_amm::{Self, SpotAMM};
use futarchy_markets::coin_escrow::{Self, TokenEscrow};
use futarchy_markets::proposal::{Self, Proposal};
use futarchy_markets::swap::{Self, SwapSession};
use futarchy_markets::arbitrage_math;
use futarchy_markets::market_state;
use sui::coin::{Self, Coin};
use sui::clock::Clock;
use sui::tx_context::TxContext;
use sui::transfer;

// === Errors ===
const ENoArbitrageProfit: u64 = 0;
const EInsufficientProfit: u64 = 1;
const EInsufficientOutput: u64 = 2;
const EInvalidOutcomeCount: u64 = 3;

// === Spot → Conditional Arbitrage ===

/// Execute arbitrage after a spot asset→stable swap
///
/// Strategy:
/// 1. Validate profitability and slippage bounds
/// 2. Mint conditional tokens from spot (split complete set)
/// 3. Swap in ALL conditional pools with slippage protection
/// 4. Recombine conditional tokens back to spot (min output = profit)
/// 5. Return profit to caller
///
/// SECURITY: This function validates expected profit before execution
/// to prevent MEV attacks and ensure profitable arbitrage.
///
/// Returns: Coin<StableType> containing arbitrage profit
public fun execute_spot_arbitrage_asset_to_stable<
    AssetType,
    StableType,
    AssetConditionalCoin,
    StableConditionalCoin,
>(
    spot_pool: &mut SpotAMM<AssetType, StableType>,
    proposal: &mut Proposal<AssetType, StableType>,
    escrow: &mut TokenEscrow<AssetType, StableType>,
    swap_session: &SwapSession,
    stable_for_arb: Coin<StableType>,  // Spot stable to use for arbitrage
    min_profit_out: u64,  // Minimum acceptable profit (slippage protection)
    clock: &Clock,
    ctx: &mut TxContext,
): Coin<StableType> {
    let arb_amount = stable_for_arb.value();
    assert!(arb_amount > 0, ENoArbitrageProfit);

    // Validate outcome count (Issue #6: division by zero protection)
    // Audit fix: Require >= 2 for "ALL outcomes" logic (complete sets need multiple outcomes)
    let outcome_count = proposal::outcome_count(proposal);
    assert!(outcome_count >= 2, EInvalidOutcomeCount);

    // SECURITY ISSUE #1 FIX: Validate profit BEFORE execution
    // Get conditional pools for profit calculation
    let market_state = coin_escrow::get_market_state(escrow);
    let conditional_pools = market_state::borrow_amm_pools(market_state);

    // Calculate expected profit with current pool state
    let expected_profit = arbitrage_math::calculate_spot_arbitrage_profit(
        spot_pool,
        conditional_pools,
        arb_amount,
        false,  // stable→asset direction
    );

    // Ensure arbitrage is profitable with minimum threshold
    assert!(expected_profit >= (min_profit_out as u128), EInsufficientProfit);

    // SECURITY ISSUE #2 FIX: Add slippage protection
    // Calculate minimum acceptable output (95% of expected, 5% slippage tolerance)
    let expected_asset_out = spot_amm::simulate_swap_stable_to_asset(spot_pool, arb_amount);
    let min_asset_out = expected_asset_out * 9500 / 10000;  // 5% slippage

    // Step 1: Swap in spot (stable → asset) with slippage protection
    // User sold asset to spot, so we buy asset back
    let mut asset_from_spot = spot_amm::swap_stable_for_asset(
        spot_pool,
        stable_for_arb,
        min_asset_out,  // ✅ Proper slippage protection
        clock,
        ctx,
    );

    let asset_amount = asset_from_spot.value();

    // Step 2: Deposit asset into escrow and mint conditional assets for ALL outcomes
    // This splits the asset into N conditional tokens (one per outcome)
    // ISSUE #3 NOTE: Rounding - last outcome gets remainder to handle division rounding
    let mut conditional_assets = vector::empty<Coin<AssetConditionalCoin>>();
    let amount_for_outcome = asset_amount / outcome_count;

    // Handle all outcomes except the last
    let mut i = 0;
    while (i < outcome_count - 1) {
        // Split exact amount for this outcome
        let asset_for_outcome = coin::split(&mut asset_from_spot, amount_for_outcome, ctx);

        // Mint conditional asset for this outcome
        let conditional_asset = coin_escrow::deposit_asset_and_mint_conditional<
            AssetType,
            StableType,
            AssetConditionalCoin
        >(
            escrow,
            i,
            asset_for_outcome,
            ctx,
        );

        vector::push_back(&mut conditional_assets, conditional_asset);
        i = i + 1;
    };

    // Handle last outcome with remaining asset (handles any rounding)
    let last_conditional_asset = coin_escrow::deposit_asset_and_mint_conditional<
        AssetType,
        StableType,
        AssetConditionalCoin
    >(
        escrow,
        outcome_count - 1,
        asset_from_spot,
        ctx,
    );
    vector::push_back(&mut conditional_assets, last_conditional_asset);

    // Step 3: Swap conditional assets → conditional stables in ALL pools
    let mut conditional_stables = vector::empty<Coin<StableConditionalCoin>>();

    i = 0;
    while (i < outcome_count) {
        // CRITICAL FIX: Use swap_remove(0) instead of pop_back() to match forward index
        // pop_back() gets N-1, N-2, N-3... (reverse order)
        // But we swap in pools 0, 1, 2... (forward order)
        // This caused outcome mismatches where conditional tokens were swapped in wrong pools!
        let conditional_asset = vector::swap_remove(&mut conditional_assets, 0);

        // Swap in this outcome's pool
        let conditional_stable = swap::swap_asset_to_stable<
            AssetType,
            StableType,
            AssetConditionalCoin,
            StableConditionalCoin,
        >(
            swap_session,
            proposal,
            escrow,
            i,
            conditional_asset,
            0,  // min_amount_out (we checked profitability)
            clock,
            ctx,
        );

        vector::push_back(&mut conditional_stables, conditional_stable);
        i = i + 1;
    };

    vector::destroy_empty(conditional_assets);

    // Step 4: Find minimum conditional stable (quantum constraint)
    // We can only redeem the minimum amount across all outcomes
    let mut min_amount = std::u64::max_value!();
    i = 0;
    while (i < outcome_count) {
        let amount = vector::borrow(&conditional_stables, i).value();
        if (amount < min_amount) {
            min_amount = amount;
        };
        i = i + 1;
    };

    // Step 5: Burn equal amounts from ALL conditional stables (complete set redemption)
    // MEDIUM SEVERITY FIX: Collect excess tokens to form complete sets instead of creating dust

    // 5a. Collect excess tokens from all outcomes
    let mut excess_stables = vector::empty<Coin<StableConditionalCoin>>();
    i = 0;
    while (i < outcome_count) {
        let mut conditional_stable = vector::swap_remove(&mut conditional_stables, 0);
        let stable_value = conditional_stable.value();

        // Split excess if it exists
        if (stable_value > min_amount) {
            let excess = coin::split(&mut conditional_stable, stable_value - min_amount, ctx);
            vector::push_back(&mut excess_stables, excess);
        } else {
            // No excess - push empty coin to maintain vector alignment
            vector::push_back(&mut excess_stables, coin::zero<StableConditionalCoin>(ctx));
        };

        // Burn the minimum amount (complete set)
        coin_escrow::burn_conditional_stable<
            AssetType,
            StableType,
            StableConditionalCoin,
        >(
            escrow,
            i,
            conditional_stable,  // Now equal to min_amount
        );

        i = i + 1;
    };

    vector::destroy_empty(conditional_stables);

    // 5b. Form complete sets from excess and redeem (instead of creating dust!)
    // Find minimum excess across all outcomes
    let mut min_excess = std::u64::max_value!();
    i = 0;
    while (i < outcome_count) {
        let excess_value = vector::borrow(&excess_stables, i).value();
        if (excess_value < min_excess) {
            min_excess = excess_value;
        };
        i = i + 1;
    };

    // If we have excess complete sets, burn them and withdraw as base tokens
    if (min_excess > 0) {
        i = 0;
        while (i < outcome_count) {
            let mut excess_stable = vector::swap_remove(&mut excess_stables, 0);
            let excess_value = excess_stable.value();

            // Burn min_excess from each outcome (forms complete set)
            if (excess_value > min_excess) {
                let to_burn_excess = coin::split(&mut excess_stable, min_excess, ctx);

                coin_escrow::burn_conditional_stable<
                    AssetType,
                    StableType,
                    StableConditionalCoin,
                >(
                    escrow,
                    i,
                    to_burn_excess,
                );

                // Destroy any remaining dust (< 1 complete set, worthless)
                coin::destroy_zero(excess_stable);
            } else {
                // Burn all of it (no remaining dust)
                coin_escrow::burn_conditional_stable<
                    AssetType,
                    StableType,
                    StableConditionalCoin,
                >(
                    escrow,
                    i,
                    excess_stable,
                );
            };

            i = i + 1;
        };

        // Withdraw redeemed stable from burning excess complete sets
        let excess_redeemed = coin_escrow::withdraw_stable_balance(
            escrow,
            min_excess,
            ctx,
        );

        // Transfer redeemed base tokens to user (not worthless dust!)
        transfer::public_transfer(excess_redeemed, ctx.sender());
    } else {
        // No excess complete sets - just destroy empty coins
        while (!vector::is_empty(&excess_stables)) {
            let empty_excess = vector::pop_back(&mut excess_stables);
            coin::destroy_zero(empty_excess);
        };
    };

    vector::destroy_empty(excess_stables);

    // Step 6: Withdraw spot stable from escrow (complete set fully burned)
    // After burning min_amount from ALL outcomes, we can withdraw min_amount once
    let stable_profit = coin_escrow::withdraw_stable_balance(
        escrow,
        min_amount,
        ctx,
    );

    stable_profit
}

/// Execute arbitrage after a spot stable→asset swap
///
/// Similar to asset→stable but in reverse direction
///
/// SECURITY: This function validates expected profit before execution
/// to prevent MEV attacks and ensure profitable arbitrage.
public fun execute_spot_arbitrage_stable_to_asset<
    AssetType,
    StableType,
    AssetConditionalCoin,
    StableConditionalCoin,
>(
    spot_pool: &mut SpotAMM<AssetType, StableType>,
    proposal: &mut Proposal<AssetType, StableType>,
    escrow: &mut TokenEscrow<AssetType, StableType>,
    swap_session: &SwapSession,
    asset_for_arb: Coin<AssetType>,  // Spot asset to use for arbitrage
    min_profit_out: u64,  // Minimum acceptable profit (slippage protection)
    clock: &Clock,
    ctx: &mut TxContext,
): Coin<AssetType> {
    let arb_amount = asset_for_arb.value();
    assert!(arb_amount > 0, ENoArbitrageProfit);

    // Validate outcome count (Issue #6: division by zero protection)
    // Audit fix: Require >= 2 for "ALL outcomes" logic (complete sets need multiple outcomes)
    let outcome_count = proposal::outcome_count(proposal);
    assert!(outcome_count >= 2, EInvalidOutcomeCount);

    // SECURITY ISSUE #1 FIX: Validate profit BEFORE execution
    let market_state = coin_escrow::get_market_state(escrow);
    let conditional_pools = market_state::borrow_amm_pools(market_state);

    // Calculate expected profit with current pool state
    let expected_profit = arbitrage_math::calculate_spot_arbitrage_profit(
        spot_pool,
        conditional_pools,
        arb_amount,
        true,  // asset→stable direction
    );

    // Ensure arbitrage is profitable with minimum threshold
    assert!(expected_profit >= (min_profit_out as u128), EInsufficientProfit);

    // SECURITY ISSUE #2 FIX: Add slippage protection
    // Calculate minimum acceptable output (95% of expected, 5% slippage tolerance)
    let expected_stable_out = spot_amm::simulate_swap_asset_to_stable(spot_pool, arb_amount);
    let min_stable_out = expected_stable_out * 9500 / 10000;  // 5% slippage

    // Step 1: Swap in spot (asset → stable) with slippage protection
    let mut stable_from_spot = spot_amm::swap_asset_for_stable(
        spot_pool,
        asset_for_arb,
        min_stable_out,  // ✅ Proper slippage protection
        clock,
        ctx,
    );

    let stable_amount = stable_from_spot.value();

    // Step 2: Mint conditional stables for all outcomes
    // ISSUE #3 NOTE: Rounding - last outcome gets remainder to handle division rounding
    let mut conditional_stables = vector::empty<Coin<StableConditionalCoin>>();
    let amount_for_outcome = stable_amount / outcome_count;

    // Handle all outcomes except the last
    let mut i = 0;
    while (i < outcome_count - 1) {
        let stable_for_outcome = coin::split(&mut stable_from_spot, amount_for_outcome, ctx);

        let conditional_stable = coin_escrow::deposit_stable_and_mint_conditional<
            AssetType,
            StableType,
            StableConditionalCoin,
        >(
            escrow,
            i,
            stable_for_outcome,
            ctx,
        );

        vector::push_back(&mut conditional_stables, conditional_stable);
        i = i + 1;
    };

    // Handle last outcome with remaining stable (handles any rounding)
    let last_conditional_stable = coin_escrow::deposit_stable_and_mint_conditional<
        AssetType,
        StableType,
        StableConditionalCoin,
    >(
        escrow,
        outcome_count - 1,
        stable_from_spot,
        ctx,
    );
    vector::push_back(&mut conditional_stables, last_conditional_stable);

    // Step 3: Swap conditional stables → conditional assets
    let mut conditional_assets = vector::empty<Coin<AssetConditionalCoin>>();

    i = 0;
    while (i < outcome_count) {
        // CRITICAL FIX: Use swap_remove(0) to match forward index
        let conditional_stable = vector::swap_remove(&mut conditional_stables, 0);

        let conditional_asset = swap::swap_stable_to_asset<
            AssetType,
            StableType,
            AssetConditionalCoin,
            StableConditionalCoin,
        >(
            swap_session,
            proposal,
            escrow,
            i,
            conditional_stable,
            0,
            clock,
            ctx,
        );

        vector::push_back(&mut conditional_assets, conditional_asset);
        i = i + 1;
    };

    vector::destroy_empty(conditional_stables);

    // Step 4: Find minimum and redeem
    let mut min_amount = std::u64::max_value!();
    i = 0;
    while (i < outcome_count) {
        let amount = vector::borrow(&conditional_assets, i).value();
        if (amount < min_amount) {
            min_amount = amount;
        };
        i = i + 1;
    };

    // Step 5: Burn equal amounts from ALL conditional assets (complete set redemption)
    // MEDIUM SEVERITY FIX: Collect excess tokens to form complete sets instead of creating dust

    // 5a. Collect excess tokens from all outcomes
    let mut excess_assets = vector::empty<Coin<AssetConditionalCoin>>();
    i = 0;
    while (i < outcome_count) {
        let mut conditional_asset = vector::swap_remove(&mut conditional_assets, 0);
        let asset_value = conditional_asset.value();

        // Split excess if it exists
        if (asset_value > min_amount) {
            let excess = coin::split(&mut conditional_asset, asset_value - min_amount, ctx);
            vector::push_back(&mut excess_assets, excess);
        } else {
            // No excess - push empty coin to maintain vector alignment
            vector::push_back(&mut excess_assets, coin::zero<AssetConditionalCoin>(ctx));
        };

        // Burn the minimum amount (complete set)
        coin_escrow::burn_conditional_asset<
            AssetType,
            StableType,
            AssetConditionalCoin,
        >(
            escrow,
            i,
            conditional_asset,  // Now equal to min_amount
        );

        i = i + 1;
    };

    vector::destroy_empty(conditional_assets);

    // 5b. Form complete sets from excess and redeem (instead of creating dust!)
    // Find minimum excess across all outcomes
    let mut min_excess = std::u64::max_value!();
    i = 0;
    while (i < outcome_count) {
        let excess_value = vector::borrow(&excess_assets, i).value();
        if (excess_value < min_excess) {
            min_excess = excess_value;
        };
        i = i + 1;
    };

    // If we have excess complete sets, burn them and withdraw as base tokens
    if (min_excess > 0) {
        i = 0;
        while (i < outcome_count) {
            let mut excess_asset = vector::swap_remove(&mut excess_assets, 0);
            let excess_value = excess_asset.value();

            // Burn min_excess from each outcome (forms complete set)
            if (excess_value > min_excess) {
                let to_burn_excess = coin::split(&mut excess_asset, min_excess, ctx);

                coin_escrow::burn_conditional_asset<
                    AssetType,
                    StableType,
                    AssetConditionalCoin,
                >(
                    escrow,
                    i,
                    to_burn_excess,
                );

                // Destroy any remaining dust (< 1 complete set, worthless)
                coin::destroy_zero(excess_asset);
            } else {
                // Burn all of it (no remaining dust)
                coin_escrow::burn_conditional_asset<
                    AssetType,
                    StableType,
                    AssetConditionalCoin,
                >(
                    escrow,
                    i,
                    excess_asset,
                );
            };

            i = i + 1;
        };

        // Withdraw redeemed asset from burning excess complete sets
        let excess_redeemed = coin_escrow::withdraw_asset_balance(
            escrow,
            min_excess,
            ctx,
        );

        // Transfer redeemed base tokens to user (not worthless dust!)
        transfer::public_transfer(excess_redeemed, ctx.sender());
    } else {
        // No excess complete sets - just destroy empty coins
        while (!vector::is_empty(&excess_assets)) {
            let empty_excess = vector::pop_back(&mut excess_assets);
            coin::destroy_zero(empty_excess);
        };
    };

    vector::destroy_empty(excess_assets);

    // Step 6: Withdraw spot asset from escrow (complete set fully burned)
    // After burning min_amount from ALL outcomes, we can withdraw min_amount once
    let asset_profit = coin_escrow::withdraw_asset_balance(
        escrow,
        min_amount,
        ctx,
    );

    asset_profit
}

// === Optimal Arbitrage (With Bidirectional Solver Integration) ===

/// Execute optimal arbitrage automatically using bidirectional solver
///
/// **NEW AUTONOMOUS ARBITRAGE:**
/// 1. Uses bidirectional solver to find optimal amount and direction
/// 2. Automatically splits coin to exact optimal amount
/// 3. Executes arbitrage with optimal parameters
/// 4. Returns (profit, unused_coin) for capital efficiency
///
/// **Advantages over manual execution:**
/// - No off-chain calculation needed
/// - Automatically finds best direction (Spot→Cond or Cond→Spot)
/// - Optimal capital utilization
/// - Single atomic transaction
///
/// Returns: (arbitrage_profit, unused_coin)
public fun execute_optimal_spot_arbitrage<
    AssetType,
    StableType,
    AssetConditionalCoin,
    StableConditionalCoin,
>(
    spot_pool: &mut SpotAMM<AssetType, StableType>,
    proposal: &mut Proposal<AssetType, StableType>,
    escrow: &mut TokenEscrow<AssetType, StableType>,
    swap_session: &SwapSession,
    mut max_stable_coin: Coin<StableType>,  // Maximum stable willing to use
    mut max_asset_coin: Coin<AssetType>,    // Maximum asset willing to use
    min_profit_threshold: u64,              // Minimum profit to execute
    clock: &Clock,
    ctx: &mut TxContext,
): (Coin<StableType>, Coin<AssetType>) {
    // Validate outcome count
    let outcome_count = proposal::outcome_count(proposal);
    assert!(outcome_count >= 2, EInvalidOutcomeCount);

    // Get conditional pools for solver
    let market_state = coin_escrow::get_market_state(escrow);
    let conditional_pools = market_state::borrow_amm_pools(market_state);

    // STEP 1: Use bidirectional solver to find optimal arbitrage
    let (optimal_amount, expected_profit, is_spot_to_cond) =
        arbitrage_math::compute_optimal_arbitrage_bidirectional(
            spot_pool,
            conditional_pools,
            min_profit_threshold,
        );

    // If no profitable arbitrage, return coins unchanged
    if (optimal_amount == 0 || expected_profit < (min_profit_threshold as u128)) {
        return (max_stable_coin, max_asset_coin)
    };

    // STEP 2: Execute in the profitable direction
    if (is_spot_to_cond) {
        // Spot → Conditional direction (stable → asset → conditionals → stable)
        let max_stable = max_stable_coin.value();

        // Clamp optimal amount to available stable
        let arb_amount = if (optimal_amount > max_stable) {
            max_stable
        } else {
            optimal_amount
        };

        // Split exact amount needed for arbitrage
        let stable_for_arb = coin::split(&mut max_stable_coin, arb_amount, ctx);

        // Execute arbitrage
        let mut profit = execute_spot_arbitrage_asset_to_stable<
            AssetType,
            StableType,
            AssetConditionalCoin,
            StableConditionalCoin,
        >(
            spot_pool,
            proposal,
            escrow,
            swap_session,
            stable_for_arb,
            min_profit_threshold,
            clock,
            ctx,
        );

        // Join profit with any unused stable remainder
        coin::join(&mut profit, max_stable_coin);

        // Return (total_stable, unused_asset)
        (profit, max_asset_coin)
    } else {
        // Conditional → Spot direction (asset → stable → conditionals → asset)
        let max_asset = max_asset_coin.value();

        // Clamp optimal amount to available asset
        let arb_amount = if (optimal_amount > max_asset) {
            max_asset
        } else {
            optimal_amount
        };

        // Split exact amount needed for arbitrage
        let asset_for_arb = coin::split(&mut max_asset_coin, arb_amount, ctx);

        // Execute arbitrage (returns asset profit)
        let mut asset_profit = execute_spot_arbitrage_stable_to_asset<
            AssetType,
            StableType,
            AssetConditionalCoin,
            StableConditionalCoin,
        >(
            spot_pool,
            proposal,
            escrow,
            swap_session,
            asset_for_arb,
            min_profit_threshold,
            clock,
            ctx,
        );

        // Join profit with any unused asset remainder
        coin::join(&mut asset_profit, max_asset_coin);

        // Return (unused_stable, total_asset)
        (max_stable_coin, asset_profit)
    }
}


// ============================================================================
// UI-DRIVEN ARBITRAGE - USER-PROVIDED CALCULATIONS
// ============================================================================
//
// MOTIVATION:
// The onchain arbitrage solver (arbitrage_math.move) is powerful but costs gas:
// - N=10 conditionals: ~11k gas for solver computation
// - N=20 conditionals: ~18k gas for solver computation
//
// For users who want to:
// 1. Save gas by calculating optimal amounts offchain (UI/SDK)
// 2. Review arbitrage parameters before execution
// 3. Set custom slippage tolerances
// 4. Use their own arbitrage strategies
//
// ARCHITECTURE:
// These functions bypass the onchain solver and directly call the executor
// functions with user-provided amounts. All security validation is preserved.
//
// GAS SAVINGS:
// - Auto-arb (onchain solver): ~26k gas total (~11k solver + ~15k execution)
// - UI-driven (offchain calc): ~18k gas total (~3k validation + ~15k execution)
// - Savings: ~8k gas (31% reduction)
//
// SECURITY MODEL:
// ✅ Same security as auto-arb:
//    - Profit validation (min_profit_out checked before execution)
//    - Slippage protection (5% tolerance on all swaps)
//    - Complete set redemption (no value extraction)
//    - K-invariant guards (prevents AMM manipulation)
//
// ⚠️  User can provide suboptimal amounts:
//    - User's own loss if amount is not optimal
//    - Protocol is protected (validation prevents negative profit)
//    - Users should use trusted UI calculations
//
// WHEN TO USE:
// - Use auto-arb (execute_optimal_spot_arbitrage) for:
//   * Convenience (no offchain calculation needed)
//   * Guaranteed optimality (onchain solver finds best amount)
//   * When gas cost is less important than optimal profit
//
// - Use UI-driven (execute_user_arbitrage_*) for:
//   * Gas savings (skip solver, calculate offchain)
//   * Custom strategies (user wants specific amounts)
//   * Transparency (user reviews amounts before execution)
//   * High-frequency arbitrage (gas optimization matters)
//
// VERSION COMPATIBILITY:
// Added: 2025-10-11 (Version 1.0)
// - No version field needed yet (additive change, backwards compatible)
// - Future versions may add version field to AMM structs for state migrations
// - Current functions work with all existing AMM pools (no upgrade required)
//
// EXAMPLE USAGE (Frontend/SDK):
// ```typescript
// // 1. Calculate optimal arbitrage offchain (same math as Move)
// const { optimalAmount, expectedProfit, isSpotToCond } =
//   calculateOptimalArbitrageBidirectional(spotReserves, conditionalReserves);
//
// // 2. User reviews and sets slippage
// const userSlippage = 0.05; // 5%
// const minProfitOut = Math.floor(expectedProfit * (1 - userSlippage));
//
// // 3. Build PTB for execution
// const tx = new Transaction();
// if (isSpotToCond) {
//   const stableCoin = tx.splitCoins(userStable, [optimalAmount]);
//   const profitCoin = tx.moveCall({
//     target: `${pkg}::arbitrage_executor::execute_user_arbitrage_spot_to_cond`,
//     arguments: [spotPool, proposal, escrow, swapSession, stableCoin,
//                 tx.pure.u64(minProfitOut), clock],
//     typeArguments: [AssetType, StableType, AssetCond, StableCond]
//   });
//   tx.transferObjects([profitCoin], userAddress);
// }
// ```
//
// ============================================================================

/// Execute user-provided arbitrage: Spot → Conditional direction
///
/// User provides the arbitrage amount calculated offchain (via UI/SDK).
/// This skips the onchain solver to save ~8k gas.
///
/// # Flow
/// Stable input → Swap to asset in spot → Split to conditionals →
/// Swap in all conditional pools → Recombine to stable → Return profit
///
/// # Arguments
/// * `stable_for_arb` - Amount of stable to arbitrage (user-provided, not validated for optimality)
/// * `min_profit_out` - Minimum acceptable profit (slippage protection, validated onchain)
///
/// # Gas Savings
/// - Saves ~8k gas by skipping onchain solver computation
/// - ~31% gas reduction vs execute_optimal_spot_arbitrage
///
/// # Security
/// ✅ All security checks from execute_spot_arbitrage_asset_to_stable apply:
/// - Validates min_profit_out BEFORE execution (line 94)
/// - Slippage protection on spot swap (line 99)
/// - Complete set redemption with excess handling (lines 200-313)
/// - K-invariant guards on all AMM operations
///
/// ⚠️  User can provide suboptimal amount (their own loss, protocol protected)
///
/// # Returns
/// Coin<StableType> containing arbitrage profit
///
/// # Example (PTB)
/// ```move
/// // User calculated optimal_amount offchain
/// let stable_coin = coin::split(&mut user_stable, optimal_amount, ctx);
/// let profit = execute_user_arbitrage_spot_to_cond(
///     spot_pool, proposal, escrow, session,
///     stable_coin,
///     min_profit_out,  // User's slippage tolerance
///     clock, ctx
/// );
/// coin::join(&mut user_stable, profit);
/// ```
///
/// Added: 2025-10-11 for UI-driven arbitrage feature
public fun execute_user_arbitrage_spot_to_cond<
    AssetType,
    StableType,
    AssetConditionalCoin,
    StableConditionalCoin,
>(
    spot_pool: &mut SpotAMM<AssetType, StableType>,
    proposal: &mut Proposal<AssetType, StableType>,
    escrow: &mut TokenEscrow<AssetType, StableType>,
    swap_session: &SwapSession,
    stable_for_arb: Coin<StableType>,
    min_profit_out: u64,
    clock: &Clock,
    ctx: &mut TxContext,
): Coin<StableType> {
    // Directly execute arbitrage with user-provided amount
    // (Same executor function used by execute_optimal_spot_arbitrage)
    // All security validation happens inside execute_spot_arbitrage_asset_to_stable
    execute_spot_arbitrage_asset_to_stable<
        AssetType,
        StableType,
        AssetConditionalCoin,
        StableConditionalCoin,
    >(
        spot_pool,
        proposal,
        escrow,
        swap_session,
        stable_for_arb,
        min_profit_out,
        clock,
        ctx,
    )
}


/// Execute user-provided arbitrage: Conditional → Spot direction
///
/// User provides the arbitrage amount calculated offchain (via UI/SDK).
/// This skips the onchain solver to save ~8k gas.
///
/// # Flow
/// Asset input → Swap to stable in spot → Split to conditionals →
/// Swap in all conditional pools → Recombine to asset → Return profit
///
/// # Arguments
/// * `asset_for_arb` - Amount of asset to arbitrage (user-provided, not validated for optimality)
/// * `min_profit_out` - Minimum acceptable profit (slippage protection, validated onchain)
///
/// # Gas Savings
/// - Saves ~8k gas by skipping onchain solver computation
/// - ~31% gas reduction vs execute_optimal_spot_arbitrage
///
/// # Security
/// ✅ All security checks from execute_spot_arbitrage_stable_to_asset apply:
/// - Validates min_profit_out BEFORE execution (line 358)
/// - Slippage protection on spot swap (line 363)
/// - Complete set redemption with excess handling (lines 456-558)
/// - K-invariant guards on all AMM operations
///
/// ⚠️  User can provide suboptimal amount (their own loss, protocol protected)
///
/// # Returns
/// Coin<AssetType> containing arbitrage profit
///
/// # Example (PTB)
/// ```move
/// // User calculated optimal_amount offchain
/// let asset_coin = coin::split(&mut user_asset, optimal_amount, ctx);
/// let profit = execute_user_arbitrage_cond_to_spot(
///     spot_pool, proposal, escrow, session,
///     asset_coin,
///     min_profit_out,  // User's slippage tolerance
///     clock, ctx
/// );
/// coin::join(&mut user_asset, profit);
/// ```
///
/// Added: 2025-10-11 for UI-driven arbitrage feature
public fun execute_user_arbitrage_cond_to_spot<
    AssetType,
    StableType,
    AssetConditionalCoin,
    StableConditionalCoin,
>(
    spot_pool: &mut SpotAMM<AssetType, StableType>,
    proposal: &mut Proposal<AssetType, StableType>,
    escrow: &mut TokenEscrow<AssetType, StableType>,
    swap_session: &SwapSession,
    asset_for_arb: Coin<AssetType>,
    min_profit_out: u64,
    clock: &Clock,
    ctx: &mut TxContext,
): Coin<AssetType> {
    // Directly execute arbitrage with user-provided amount
    // (Same executor function used by execute_optimal_spot_arbitrage)
    // All security validation happens inside execute_spot_arbitrage_stable_to_asset
    execute_spot_arbitrage_stable_to_asset<
        AssetType,
        StableType,
        AssetConditionalCoin,
        StableConditionalCoin,
    >(
        spot_pool,
        proposal,
        escrow,
        swap_session,
        asset_for_arb,
        min_profit_out,
        clock,
        ctx,
    )
}


// ============================================================================
// FUTURE UPGRADES - VERSION FIELD CONSIDERATION
// ============================================================================
//
// CURRENT STATE (Version 1.0):
// - No version field in AMM structs (SpotAMM, LiquidityPool)
// - All functions work with all existing pools
// - Additive changes only (new functions, no state migrations)
//
// RECOMMENDATION FOR FUTURE:
// If we need state migrations (e.g., changing fee structures, adding new
// oracle types, modifying reserve calculations), add version field:
//
// ```move
// public struct SpotAMM<phantom AssetType, phantom StableType> has key, store {
//     id: UID,
//     asset_reserve: Balance<AssetType>,
//     stable_reserve: Balance<StableType>,
//     // ... existing fields ...
//
//     // VERSION FIELD (add in next upgrade that changes state)
//     version: u8,  // Current: 1, Future upgrades: 2, 3, etc.
// }
// ```
//
// WHEN TO ADD VERSION FIELD:
// ✅ State migration needed (changing struct fields)
// ✅ Breaking changes to calculation logic
// ✅ Need conditional logic based on pool version
//
// ❌ NOT needed for this upgrade (additive change only)
// ❌ NOT needed for adding new public functions
// ❌ NOT needed for gas optimizations
//
// MIGRATION PATTERN (for future reference):
// ```move
// public fun some_future_function<AssetType, StableType>(
//     pool: &mut SpotAMM<AssetType, StableType>,
//     ...
// ) {
//     if (pool.version == 1) {
//         // V1 logic (backwards compatibility)
//     } else if (pool.version == 2) {
//         // V2 logic (new behavior)
//     }
// }
// ```
//
// ============================================================================


// === Conditional → Spot Arbitrage (Complex) ===
// NOTE: Pure Conditional→Spot arbitrage (without spot pool interaction) is complex:
// - Requires acquiring tokens from ALL outcome markets to form complete sets
// - Need external liquidity source or multi-step swaps
// - Current implementation handles this via execute_spot_arbitrage_stable_to_asset
//   (swaps in spot first, then uses conditionals)
//
// For direct conditional→spot routing without spot interaction, see swap_coordinator.move

/// ============================================================================
/// ARBITRAGE ENTRY POINTS - Phase 3 Implementation
/// ============================================================================
///
/// Provides aggregator-friendly interfaces and MEV bot entry points
/// for the deterministic arbitrage solver (arbitrage_math.move).
///
/// INTERFACES:
/// 1. get_quote() - Quote for aggregators (Aftermath, Cetus, etc.)
/// 2. simulate_arbitrage() - Profit simulation for MEV bots
///
/// NOTE: Actual execution requires TokenEscrow integration for:
/// - Minting/burning conditional tokens
/// - Complete set operations (split/recombine)
///
/// This module provides the MATH layer that other modules can call.
/// Full execution is handled by swap.move + coin_escrow.move.
///
/// ============================================================================

module futarchy_markets::arbitrage_entry;

use futarchy_markets::arbitrage_math;
use futarchy_markets::spot_amm::{Self, SpotAMM};
use futarchy_markets::conditional_amm::LiquidityPool;

// === Structs ===

/// Quote result for aggregators
///
/// **IMPORTANT**: This quote shows the direct swap output and available arbitrage
/// opportunity, but does NOT claim the user receives the arbitrage profit.
/// The arbitrage profit is calculated on CURRENT pool state, but if user swaps first,
/// the pool state changes and the actual arbitrage profit will differ.
///
/// Use `direct_output` for accurate user output prediction.
/// Use `expected_arb_profit` to understand available arbitrage (for MEV bots, not users).
public struct SwapQuote has drop, copy {
    amount_in: u64,
    direct_output: u64,          // Output user receives from direct swap
    optimal_arb_amount: u64,     // Optimal amount to arbitrage (on current state)
    expected_arb_profit: u128,   // Arbitrage profit available (on current state, not added to user output!)
    is_arb_available: bool,      // Whether arbitrage opportunity exists
}

// === Aggregator Interface ===

/// Get swap quote with arbitrage opportunity analysis
/// Aggregators can use this to compare futarchy vs other DEXes
///
/// Returns SwapQuote with:
/// - Direct swap output (what user actually receives)
/// - Available arbitrage profit (for MEV bots, NOT added to user output)
///
/// **CRITICAL**: The arbitrage profit is calculated on CURRENT pool state.
/// If user swaps first, pool state changes, and actual arbitrage differs.
/// DO NOT add direct_output + expected_arb_profit - they are not independent!
///
/// **Usage:**
/// ```move
/// let quote = get_quote_asset_to_stable(spot, conditionals, 1000000);
/// // User receives: quote.direct_output (arbitrage profit goes to arbitrageur)
/// if (quote.is_arb_available) {
///     // MEV bot can capture quote.expected_arb_profit (approximately)
/// }
/// ```
public fun get_quote_asset_to_stable<AssetType, StableType>(
    spot: &SpotAMM<AssetType, StableType>,
    conditionals: &vector<LiquidityPool>,
    amount_in: u64,
): SwapQuote {
    // 1. Calculate direct swap output (what user actually receives)
    let direct_output = spot_amm::simulate_swap_asset_to_stable(spot, amount_in);

    // 2. Calculate optimal arbitrage using NEW EFFICIENT BIDIRECTIONAL SOLVER
    // ✅ Uses b-parameterization (no sqrt)
    // ✅ Active-set pruning (40-60% gas reduction)
    // ✅ Early exit checks
    // ✅ Checks both directions automatically
    let (optimal_arb_amount, expected_arb_profit, _is_spot_to_cond) =
        arbitrage_math::compute_optimal_arbitrage_bidirectional(
            spot,
            conditionals,
            0,  // No min profit for quote (show all opportunities)
        );

    // 3. Check if arbitrage opportunity exists (for MEV bots, not user profit!)
    let is_arb_available = optimal_arb_amount > 0 && expected_arb_profit > 0;

    SwapQuote {
        amount_in,
        direct_output,        // User receives this
        optimal_arb_amount,   // Arbitrage amount (on current state)
        expected_arb_profit,  // Arbitrage profit (for MEV bot, NOT user!)
        is_arb_available,     // Whether arbitrage exists
    }
}

/// Get swap quote for stable → asset direction
public fun get_quote_stable_to_asset<AssetType, StableType>(
    spot: &SpotAMM<AssetType, StableType>,
    conditionals: &vector<LiquidityPool>,
    amount_in: u64,
): SwapQuote {
    let direct_output = spot_amm::simulate_swap_stable_to_asset(spot, amount_in);

    // Use NEW EFFICIENT BIDIRECTIONAL SOLVER (same as above)
    let (optimal_arb_amount, expected_arb_profit, _is_spot_to_cond) =
        arbitrage_math::compute_optimal_arbitrage_bidirectional(
            spot,
            conditionals,
            0,  // No min profit for quote
        );

    let is_arb_available = optimal_arb_amount > 0 && expected_arb_profit > 0;

    SwapQuote {
        amount_in,
        direct_output,        // User receives this
        optimal_arb_amount,   // Arbitrage amount (on current state)
        expected_arb_profit,  // Arbitrage profit (for MEV bot, NOT user!)
        is_arb_available,     // Whether arbitrage exists
    }
}

// === MEV Bot Interface ===

/// Simulate pure arbitrage with minimum profit threshold
/// MEV bots can call this to check if arbitrage is profitable
///
/// Returns:
/// - optimal_amount: Optimal amount to arbitrage
/// - expected_profit: Expected profit (after min_profit check)
/// - is_spot_to_cond: Direction (true = Spot→Cond, false = Cond→Spot)
///
/// **NEW FEATURES:**
/// ✅ Bidirectional search (finds best direction automatically)
/// ✅ Min profit threshold (don't execute if profit < threshold)
/// ✅ 40-60% more efficient (pruning + early exits + no sqrt)
///
/// **Usage:**
/// ```move
/// let (amount, profit, direction) = simulate_pure_arbitrage_with_min_profit(
///     spot, conditionals, 10000  // min 10k profit
/// );
/// if (profit > 0) {
///     // Execute arbitrage PTB in the profitable direction
///     execute_arbitrage(...);
/// }
/// ```
public fun simulate_pure_arbitrage_with_min_profit<AssetType, StableType>(
    spot: &SpotAMM<AssetType, StableType>,
    conditionals: &vector<LiquidityPool>,
    min_profit: u64,
): (u64, u128, bool) {
    arbitrage_math::compute_optimal_arbitrage_bidirectional(
        spot,
        conditionals,
        min_profit,
    )
}

/// Legacy interface: Simulate arbitrage in specific direction (asset→stable)
/// NOTE: New code should use simulate_pure_arbitrage_with_min_profit for bidirectional search
public fun simulate_pure_arbitrage_asset_to_stable<AssetType, StableType>(
    spot: &SpotAMM<AssetType, StableType>,
    conditionals: &vector<LiquidityPool>,
): (u64, u128) {
    let (amount, profit, is_spot_to_cond) = arbitrage_math::compute_optimal_arbitrage_bidirectional(
        spot,
        conditionals,
        0,  // No min profit
    );

    // Return only if direction matches (asset_to_stable = spot_to_cond)
    if (is_spot_to_cond) {
        (amount, profit)
    } else {
        (0, 0)
    }
}

/// Legacy interface: Simulate arbitrage in specific direction (stable→asset)
/// NOTE: New code should use simulate_pure_arbitrage_with_min_profit for bidirectional search
public fun simulate_pure_arbitrage_stable_to_asset<AssetType, StableType>(
    spot: &SpotAMM<AssetType, StableType>,
    conditionals: &vector<LiquidityPool>,
): (u64, u128) {
    let (amount, profit, is_spot_to_cond) = arbitrage_math::compute_optimal_arbitrage_bidirectional(
        spot,
        conditionals,
        0,  // No min profit
    );

    // Return only if direction matches (stable_to_asset = cond_to_spot)
    if (!is_spot_to_cond) {
        (amount, profit)
    } else {
        (0, 0)
    }
}

// === Quote Getters ===

public fun quote_amount_in(quote: &SwapQuote): u64 {
    quote.amount_in
}

public fun quote_direct_output(quote: &SwapQuote): u64 {
    quote.direct_output
}

public fun quote_optimal_arb_amount(quote: &SwapQuote): u64 {
    quote.optimal_arb_amount
}

public fun quote_expected_arb_profit(quote: &SwapQuote): u128 {
    quote.expected_arb_profit
}

public fun quote_is_arb_available(quote: &SwapQuote): bool {
    quote.is_arb_available
}

/// Get arbitrage profit in basis points relative to direct output
/// Returns 0 if no arbitrage available
/// NOTE: This is the MEV bot's potential profit, NOT added to user output!
public fun quote_arb_profit_bps(quote: &SwapQuote): u64 {
    if (quote.is_arb_available && quote.direct_output > 0) {
        // BPS = (arb_profit / direct_output) * 10000
        // This shows the relative size of arbitrage opportunity
        // FIX: Proper precedence - divide in u128, then downcast
        (((quote.expected_arb_profit as u128) * 10000) / (quote.direct_output as u128)) as u64
    } else {
        0
    }
}

// === Future: Execution Functions ===
//
// NOTE: Actual execution requires TokenEscrow integration.
// These will be implemented in Phase 4 after testing.
//
// Future functions:
// - execute_swap_with_arbitrage<AssetType, StableType>()
// - execute_pure_arbitrage<AssetType, StableType>()
//
// Required components:
// - coin_escrow::split_to_conditionals()
// - coin_escrow::recombine_from_conditionals()
// - swap::swap_asset_to_stable() for conditional markets
//
/// Registry of pre-created "blank" coin types that can be used for conditional tokens
/// Solves the problem that coin types can't be created dynamically in Sui
/// Allows proposal creators to acquire coin pairs without requiring two transactions
module futarchy_markets::coin_registry;

use sui::{
    coin::{TreasuryCap, CoinMetadata, Coin},
    sui::SUI,
    event,
    clock::Clock,
    dynamic_field,
};
use futarchy_markets::coin_validation;

// === Errors ===
const ENoCoinSetsAvailable: u64 = 0;
const EInsufficientFee: u64 = 1;
const EInvalidCoinSet: u64 = 2;
const ERegistryNotEmpty: u64 = 3;
const ERegistryFull: u64 = 4;
const ENotEnoughCoins: u64 = 5;

// === Constants ===
const MAX_COIN_SETS: u64 = 100_000;

// === Structs ===

/// A single coin set ready for use as conditional tokens
/// Contains both TreasuryCap and CoinMetadata for one coin type
public struct CoinSet<phantom T> has store {
    treasury_cap: TreasuryCap<T>,
    metadata: CoinMetadata<T>,
    owner: address,  // Who deposited this set and gets paid
    fee: u64,        // Fee in SUI to acquire this set
}

/// Global registry storing available coin sets
/// Permissionless - anyone can add coin sets
/// Uses dynamic fields to store different CoinSet<T> types
public struct CoinRegistry has key {
    id: UID,
    // CoinSets stored as dynamic fields with cap_id as key
    // Dynamic fields allow storing different CoinSet<T> types
    total_sets: u64,
}

// === Events ===

public struct CoinSetDeposited has copy, drop {
    registry_id: ID,
    cap_id: ID,
    owner: address,
    fee: u64,
    timestamp: u64,
}

public struct CoinSetTaken has copy, drop {
    registry_id: ID,
    cap_id: ID,
    taker: address,
    fee_paid: u64,
    owner_paid: address,
    timestamp: u64,
}

// === Admin Functions ===

/// Create a new coin registry (admin/one-time setup)
public fun create_registry(ctx: &mut TxContext): CoinRegistry {
    CoinRegistry {
        id: object::new(ctx),
        total_sets: 0,
    }
}

/// Share the registry to make it publicly accessible
public entry fun share_registry(registry: CoinRegistry) {
    transfer::share_object(registry);
}

/// Destroy an empty registry
public fun destroy_empty_registry(registry: CoinRegistry) {
    let CoinRegistry { id, total_sets } = registry;
    assert!(total_sets == 0, ERegistryNotEmpty);
    id.delete();
}

// === Deposit Functions ===

/// Deposit a coin set into the registry
/// Validates that the coin meets all requirements for conditional tokens
public fun deposit_coin_set<T>(
    registry: &mut CoinRegistry,
    treasury_cap: TreasuryCap<T>,
    metadata: CoinMetadata<T>,
    fee: u64,
    clock: &Clock,
    ctx: &TxContext,
) {
    // Check registry not full
    assert!(registry.total_sets < MAX_COIN_SETS, ERegistryFull);

    // Validate coin meets requirements
    coin_validation::validate_conditional_coin(&treasury_cap, &metadata);

    let cap_id = object::id(&treasury_cap);
    let owner = ctx.sender();

    // Create coin set
    let coin_set = CoinSet {
        treasury_cap,
        metadata,
        owner,
        fee,
    };

    // Store in registry as dynamic field
    dynamic_field::add(&mut registry.id, cap_id, coin_set);
    registry.total_sets = registry.total_sets + 1;

    // Emit event
    event::emit(CoinSetDeposited {
        registry_id: object::id(registry),
        cap_id,
        owner,
        fee,
        timestamp: clock.timestamp_ms(),
    });
}

/// Deposit a coin set via entry function (transfers ownership)
public entry fun deposit_coin_set_entry<T>(
    registry: &mut CoinRegistry,
    treasury_cap: TreasuryCap<T>,
    metadata: CoinMetadata<T>,
    fee: u64,
    clock: &Clock,
    ctx: &TxContext,
) {
    deposit_coin_set(registry, treasury_cap, metadata, fee, clock, ctx);
}

// === Take Functions ===

/// Take a coin set from registry and transfer caps to sender
/// Returns the remaining payment coin for chaining multiple takes in a PTB
/// Call this N times in a PTB for N outcomes
public fun take_coin_set<T>(
    registry: &mut CoinRegistry,
    cap_id: ID,
    mut fee_payment: Coin<SUI>,
    clock: &Clock,
    ctx: &mut TxContext,
): Coin<SUI> {
    // Check exists
    assert!(dynamic_field::exists_with_type<ID, CoinSet<T>>(&registry.id, cap_id), ENoCoinSetsAvailable);

    // Remove from registry
    let coin_set: CoinSet<T> = dynamic_field::remove(&mut registry.id, cap_id);

    // Validate fee
    assert!(fee_payment.value() >= coin_set.fee, EInsufficientFee);

    // Split exact payment
    let payment = fee_payment.split(coin_set.fee, ctx);

    // Pay owner
    transfer::public_transfer(payment, coin_set.owner);

    // Update total count
    registry.total_sets = registry.total_sets - 1;

    // Emit event
    event::emit(CoinSetTaken {
        registry_id: object::id(registry),
        cap_id,
        taker: ctx.sender(),
        fee_paid: coin_set.fee,
        owner_paid: coin_set.owner,
        timestamp: clock.timestamp_ms(),
    });

    // Return caps to sender (they become owned objects)
    let CoinSet { treasury_cap, metadata, owner: _, fee: _ } = coin_set;
    transfer::public_transfer(treasury_cap, ctx.sender());
    transfer::public_transfer(metadata, ctx.sender());

    // Return remaining payment for next take
    fee_payment
}

// === View Functions ===

/// Get total number of coin sets in registry
public fun total_sets(registry: &CoinRegistry): u64 {
    registry.total_sets
}

/// Check if a specific coin set is available
public fun has_coin_set(registry: &CoinRegistry, cap_id: ID): bool {
    dynamic_field::exists_(&registry.id, cap_id)
}

/// Get fee for a specific coin set
public fun get_fee<T>(registry: &CoinRegistry, cap_id: ID): u64 {
    let coin_set: &CoinSet<T> = dynamic_field::borrow(&registry.id, cap_id);
    coin_set.fee
}

/// Get owner of a specific coin set
public fun get_owner<T>(registry: &CoinRegistry, cap_id: ID): address {
    let coin_set: &CoinSet<T> = dynamic_field::borrow(&registry.id, cap_id);
    coin_set.owner
}

// === Helper Functions for Proposals ===

/// Validate coin set in registry without removing it
public fun validate_coin_set_in_registry(
    registry: &CoinRegistry,
    cap_id: ID,
): bool {
    dynamic_field::exists_(&registry.id, cap_id)
}
module futarchy_markets::proposal;

use futarchy_markets::conditional_amm::{Self, LiquidityPool};
use futarchy_markets::coin_escrow::{Self, TokenEscrow};
use futarchy_markets::liquidity_initialize;
use futarchy_markets::market_state;
use futarchy_markets::coin_validation;
use std::ascii::String as AsciiString;
use std::string::{Self, String};
use std::type_name;
use std::option;
use std::type_name::TypeName;
use std::vector;
use sui::balance::{Balance};
use sui::clock::Clock;
use sui::coin::{Coin, TreasuryCap, CoinMetadata};
use sui::event;
use sui::bag::{Self, Bag};
use futarchy_types::action_specs::{Self, InitActionSpecs};
use futarchy_core::dao_config::{Self, ConditionalCoinConfig};

// === Introduction ===
// This defines the core proposal logic and details

// === Errors ===

const EInvalidAmount: u64 = 1;
const EInvalidState: u64 = 2;
const EAssetLiquidityTooLow: u64 = 4;
const EStableLiquidityTooLow: u64 = 5;
const EPoolNotFound: u64 = 6;
const EOutcomeOutOfBounds: u64 = 7;
const EInvalidOutcomeVectors: u64 = 8;
const ESpotTwapNotReady: u64 = 9;
const ETooManyOutcomes: u64 = 10;
const EInvalidOutcome: u64 = 11;
const ENotFinalized: u64 = 12;
const ETwapNotSet: u64 = 13;
const ETooManyActions: u64 = 14;
const EInvalidConditionalCoinCount: u64 = 15;
const EConditionalCoinAlreadySet: u64 = 16;
const ENotLiquidityProvider: u64 = 17;

// === Constants ===

const STATE_PREMARKET: u8 = 0; // Proposal exists, outcomes can be added/mutated. No market yet.
const STATE_REVIEW: u8 = 1;    // Market is initialized and locked for review. Not yet trading.
const STATE_TRADING: u8 = 2;   // Market is live and trading.
const STATE_FINALIZED: u8 = 3; // Market has resolved.

// Outcome constants for TWAP calculation
const OUTCOME_ACCEPTED: u64 = 0;
const OUTCOME_REJECTED: u64 = 1;

// === Structs ===

/// Key for storing conditional coin caps in Bag
/// Each outcome has 2 coins: asset-conditional and stable-conditional
public struct ConditionalCoinKey has store, copy, drop {
    outcome_index: u64,
    is_asset: bool,  // true for asset, false for stable
}

/// Configuration for proposal timing and periods
public struct ProposalTiming has store {
    created_at: u64,
    market_initialized_at: Option<u64>,
    review_period_ms: u64,
    trading_period_ms: u64,
    last_twap_update: u64,
    twap_start_delay: u64,
}

/// Configuration for liquidity requirements
public struct LiquidityConfig has store {
    min_asset_liquidity: u64,
    min_stable_liquidity: u64,
    asset_amounts: vector<u64>,
    stable_amounts: vector<u64>,
    uses_dao_liquidity: bool,
}

/// TWAP (Time-Weighted Average Price) configuration
public struct TwapConfig has store {
    twap_prices: vector<u128>,
    twap_initial_observation: u128,
    twap_step_max: u64,
    twap_threshold: u64,
}

/// Early resolution metrics for tracking proposal stability
/// Tracks when winner last flipped across ALL N markets
/// Simple design: just track last flip time, no exponential decay
public struct EarlyResolveMetrics has store {
    // Winner tracking (computed from ALL N markets)
    current_winner_index: u64,      // Which outcome is currently winning
    last_flip_time_ms: u64,         // When did winner last change
}

/// Outcome-related data
public struct OutcomeData has store {
    outcome_count: u64,
    outcome_messages: vector<String>,
    outcome_creators: vector<address>,
    outcome_creator_fees: vector<u64>,  // Track fees paid by each outcome creator (for refunds)
    intent_specs: vector<Option<InitActionSpecs>>,  // Changed from intent_keys to intent_specs
    actions_per_outcome: vector<u64>,
    winning_outcome: Option<u64>,
}

/// Core proposal object that owns AMM pools
public struct Proposal<phantom AssetType, phantom StableType> has key, store {
    id: UID,
    /// The logical ID of the proposal from the priority queue.
    queued_proposal_id: ID,
    state: u8,
    dao_id: ID,
    proposer: address, // The original proposer.
    liquidity_provider: Option<address>,
    withdraw_only_mode: bool, // When true, return liquidity to provider instead of auto-reinvesting

    // Market-related fields (pools now live in MarketState)
    escrow_id: Option<ID>,
    market_state_id: Option<ID>,

    // Conditional coin capabilities (stored dynamically per outcome)
    conditional_treasury_caps: Bag,  // Stores TreasuryCap<ConditionalCoinType> per outcome
    conditional_metadata: Bag,        // Stores CoinMetadata<ConditionalCoinType> per outcome
    
    // Proposal content
    title: String,
    details: vector<String>,
    metadata: String,
    
    // Grouped configurations
    timing: ProposalTiming,
    liquidity_config: LiquidityConfig,
    twap_config: TwapConfig,
    early_resolve_metrics: Option<EarlyResolveMetrics>,
    outcome_data: OutcomeData,
    
    // Fee-related fields
    amm_total_fee_bps: u64,
    fee_escrow: Balance<StableType>,
    treasury_address: address,

    // Policy enforcement fields (CRITICAL SECURITY)
    // One entry per outcome - each outcome's IntentSpec (batch of intents) can have different policy requirements
    //
    // IMPORTANT: These fields "lock in" the policy requirements that were active when the proposal was created.
    // This ensures that if the DAO changes its policies via another proposal, it won't brick execution of
    // in-flight proposals that were created under the old policy.
    //
    /// Policy modes per outcome: 0=DAO_ONLY, 1=COUNCIL_ONLY, 2=DAO_OR_COUNCIL, 3=DAO_AND_COUNCIL
    policy_modes: vector<u8>,
    /// Required council ID per outcome (if any)
    required_council_ids: vector<Option<ID>>,
    /// Council approval proof per outcome (ApprovedIntentSpec ID if mode required it)
    council_approval_proofs: vector<Option<ID>>,
}

/// A scoped witness proving that a particular (proposal, outcome) had an IntentSpec.
/// Only mintable by the module that has &mut Proposal and consumes the slot.
/// This prevents cross-proposal cancellation attacks.
///
/// After IntentSpec refactor: This witness proves ownership of a proposal outcome slot,
/// used for cleanup and lifecycle management.
public struct CancelWitness has drop {
    proposal: address,
    outcome_index: u64,
}

// Getter functions for CancelWitness
public fun cancel_witness_proposal(witness: &CancelWitness): address {
    witness.proposal
}

public fun cancel_witness_outcome_index(witness: &CancelWitness): u64 {
    witness.outcome_index
}

// === Events ===

public struct ProposalCreated has copy, drop {
    proposal_id: ID,
    dao_id: ID,
    proposer: address,
    outcome_count: u64,
    outcome_messages: vector<String>,
    created_at: u64,
    asset_type: AsciiString,
    stable_type: AsciiString,
    review_period_ms: u64,
    trading_period_ms: u64,
    title: String,
    metadata: String,
}

public struct ProposalMarketInitialized has copy, drop {
    proposal_id: ID,
    dao_id: ID,
    market_state_id: ID,
    escrow_id: ID,
    timestamp: u64,
}

public struct ProposalOutcomeMutated has copy, drop {
    proposal_id: ID,
    dao_id: ID,
    outcome_idx: u64,
    old_creator: address,
    new_creator: address,
    timestamp: u64,
}

public struct ProposalOutcomeAdded has copy, drop {
    proposal_id: ID,
    dao_id: ID,
    new_outcome_idx: u64,
    creator: address,
    timestamp: u64,
}

// Early resolution events moved to early_resolve.move

// === Public Functions ===

/// Creates all on-chain objects for a futarchy market when a proposal is activated from the queue.
/// This is the main entry point for creating a full proposal with market infrastructure.
#[allow(lint(share_owned))]
public fun initialize_market<AssetType, StableType>(
    // Proposal ID (generated when adding to queue)
    proposal_id: ID,
    // Market parameters from DAO
    dao_id: ID,
    review_period_ms: u64,
    trading_period_ms: u64,
    min_asset_liquidity: u64,
    min_stable_liquidity: u64,
    twap_start_delay: u64,
    twap_initial_observation: u128,
    twap_step_max: u64,
    twap_threshold: u64,
    amm_total_fee_bps: u64,
    max_outcomes: u64, // DAO's configured max outcomes
    treasury_address: address,
    // Proposal specific parameters
    title: String,
    metadata: String,
    initial_outcome_messages: vector<String>,
    initial_outcome_details: vector<String>,
    asset_coin: Coin<AssetType>,
    stable_coin: Coin<StableType>,
    proposer: address, // The original proposer from the queue
    proposer_fee_paid: u64, // Fee paid by proposer (for tracking refunds)
    uses_dao_liquidity: bool,
    fee_escrow: Balance<StableType>, // DAO fees if any
    mut intent_spec_for_yes: Option<InitActionSpecs>, // Intent spec for YES outcome
    clock: &Clock,
    ctx: &mut TxContext,
): (ID, ID, u8) {

    // Create a new proposal UID
    let id = object::new(ctx);
    let actual_proposal_id = object::uid_to_inner(&id);
    let outcome_count = initial_outcome_messages.length();

    // Validate outcome count
    assert!(outcome_count == initial_outcome_details.length(), EInvalidOutcomeVectors);
    assert!(outcome_count <= max_outcomes, ETooManyOutcomes);

    // Liquidity is split evenly among all outcomes
    let total_asset_liquidity = asset_coin.value();
    let total_stable_liquidity = stable_coin.value();
    assert!(total_asset_liquidity > 0 && total_stable_liquidity > 0, EInvalidAmount);
    
    let asset_per_outcome = total_asset_liquidity / outcome_count;
    let stable_per_outcome = total_stable_liquidity / outcome_count;
    
    // Calculate remainders from integer division
    let asset_remainder = total_asset_liquidity % outcome_count;
    let stable_remainder = total_stable_liquidity % outcome_count;
    
    // Distribute liquidity evenly, with remainder going to first outcomes
    let mut initial_asset_amounts = vector::empty<u64>();
    let mut initial_stable_amounts = vector::empty<u64>();
    let mut i = 0;
    while (i < outcome_count) {
        // Add 1 extra token to first 'remainder' outcomes
        let asset_amount = if (i < asset_remainder) { asset_per_outcome + 1 } else { asset_per_outcome };
        let stable_amount = if (i < stable_remainder) { stable_per_outcome + 1 } else { stable_per_outcome };
        
        vector::push_back(&mut initial_asset_amounts, asset_amount);
        vector::push_back(&mut initial_stable_amounts, stable_amount);
        i = i + 1;
    };

    // Validate minimum liquidity requirements
    assert!(asset_per_outcome >= min_asset_liquidity, EAssetLiquidityTooLow);
    assert!(stable_per_outcome >= min_stable_liquidity, EStableLiquidityTooLow);

    // Initialize outcome creators to the original proposer
    let outcome_creators = vector::tabulate!(outcome_count, |_| proposer);

    // Create market state
    let market_state = market_state::new(
        actual_proposal_id,  // Use the actual proposal ID, not the parameter
        dao_id, 
        outcome_count, 
        initial_outcome_messages, 
        clock, 
        ctx
    );
    let market_state_id = object::id(&market_state);

    // Create escrow
    let mut escrow = coin_escrow::new<AssetType, StableType>(market_state, ctx);
    let escrow_id = object::id(&escrow);

    // Create AMM pools and initialize liquidity
    let mut asset_balance = asset_coin.into_balance();
    let mut stable_balance = stable_coin.into_balance();
    
    // Quantum liquidity: the same liquidity backs all outcomes conditionally
    // We only need the MAX amount across outcomes since they share the same underlying liquidity
    let mut max_asset = 0u64;
    let mut max_stable = 0u64;
    let mut j = 0;
    while (j < outcome_count) {
        let asset_amt = *initial_asset_amounts.borrow(j);
        let stable_amt = *initial_stable_amounts.borrow(j);
        if (asset_amt > max_asset) { max_asset = asset_amt };
        if (stable_amt > max_stable) { max_stable = stable_amt };
        j = j + 1;
    };
    
    // Extract the exact amount needed for quantum liquidity
    let asset_total = asset_balance.value();
    let stable_total = stable_balance.value();
    
    let asset_for_pool = if (asset_total > max_asset) {
        asset_balance.split(max_asset)
    } else {
        asset_balance.split(asset_total)
    };
    
    let stable_for_pool = if (stable_total > max_stable) {
        stable_balance.split(max_stable)
    } else {
        stable_balance.split(stable_total)
    };
    
    // Return excess to proposer if any
    if (asset_balance.value() > 0) {
        transfer::public_transfer(asset_balance.into_coin(ctx), proposer);
    } else {
        asset_balance.destroy_zero();
    };
    
    if (stable_balance.value() > 0) {
        transfer::public_transfer(stable_balance.into_coin(ctx), proposer);
    } else {
        stable_balance.destroy_zero();
    };
    
    let amm_pools = liquidity_initialize::create_outcome_markets(
        &mut escrow,
        outcome_count,
        initial_asset_amounts,
        initial_stable_amounts,
        twap_start_delay,
        twap_initial_observation,
        twap_step_max,
        amm_total_fee_bps,
        asset_for_pool,
        stable_for_pool,
        clock,
        ctx
    );

    // Move pools to MarketState (architectural fix: pools belong to market, not proposal)
    let market_state = coin_escrow::get_market_state_mut(&mut escrow);
    market_state::set_amm_pools(market_state, amm_pools);

    // Prepare intent_specs and actions_per_outcome
    let mut intent_specs = vector::tabulate!(outcome_count, |_| option::none<InitActionSpecs>());
    let mut actions_per_outcome = vector::tabulate!(outcome_count, |_| 0);

    // Store the intent spec for YES outcome at index 0 if provided
    if (intent_spec_for_yes.is_some()) {
        let spec = intent_spec_for_yes.extract();
        let actions_count = action_specs::action_count(&spec);
        *vector::borrow_mut(&mut intent_specs, 0) = option::some(spec);
        *vector::borrow_mut(&mut actions_per_outcome, 0) = actions_count;
    };

    // Create proposal object
    let proposal = Proposal<AssetType, StableType> {
        id,
        queued_proposal_id: proposal_id,
        state: STATE_REVIEW, // Start in REVIEW state since market is initialized
        dao_id,
        proposer,
        liquidity_provider: option::some(ctx.sender()),
        withdraw_only_mode: false,
        escrow_id: option::some(escrow_id),
        market_state_id: option::some(market_state_id),
        conditional_treasury_caps: bag::new(ctx),
        conditional_metadata: bag::new(ctx),
        title,
        details: initial_outcome_details,
        metadata,
        timing: ProposalTiming {
            created_at: clock.timestamp_ms(),
            market_initialized_at: option::some(clock.timestamp_ms()),
            review_period_ms,
            trading_period_ms,
            last_twap_update: 0,
            twap_start_delay,
        },
        liquidity_config: LiquidityConfig {
            min_asset_liquidity,
            min_stable_liquidity,
            asset_amounts: initial_asset_amounts,
            stable_amounts: initial_stable_amounts,
            uses_dao_liquidity,
        },
        twap_config: TwapConfig {
            twap_prices: vector::empty(),
            twap_initial_observation,
            twap_step_max,
            twap_threshold,
        },
        early_resolve_metrics: option::none(),  // Early resolution disabled by default
        outcome_data: OutcomeData {
            outcome_count,
            outcome_messages: initial_outcome_messages,
            outcome_creators,
            outcome_creator_fees: {
                // Track actual fees paid by each outcome creator
                // Outcome 0 (reject): 0 fee
                // Outcome 1+ (proposer's outcomes): proposer_fee_paid divided by (outcome_count - 1)
                let mut fees = vector::empty();
                fees.push_back(0u64); // Outcome 0 (reject) - no fee
                let mut i = 1u64;
                while (i < outcome_count) {
                    fees.push_back(proposer_fee_paid); // Each outcome tracks the proposer's fee
                    i = i + 1;
                };
                fees
            },
            intent_specs,
            actions_per_outcome,
            winning_outcome: option::none(),
        },
        amm_total_fee_bps,
        fee_escrow,
        treasury_address,
        // Policy enforcement - Policy data will be set when IntentSpecs are attached
        // For now, initialize with empty/default values (these MUST be set before market activation)
        policy_modes: vector::tabulate!(outcome_count, |_| 0u8),  // Default: DAO_ONLY
        required_council_ids: vector::tabulate!(outcome_count, |_| option::none()),
        council_approval_proofs: vector::tabulate!(outcome_count, |_| option::none()),
    };

    event::emit(ProposalCreated {
        proposal_id: actual_proposal_id,
        dao_id,
        proposer,
        outcome_count,
        outcome_messages: initial_outcome_messages,
        created_at: clock.timestamp_ms(),
        asset_type: type_name::with_defining_ids<AssetType>().into_string(),
        stable_type: type_name::with_defining_ids<StableType>().into_string(),
        review_period_ms,
        trading_period_ms,
        title,
        metadata,
    });

    transfer::public_share_object(proposal);
    transfer::public_share_object(escrow);

    // Return the actual on-chain proposal ID, not the queue ID
    (actual_proposal_id, market_state_id, STATE_REVIEW)
}

// The create function has been removed as it's not used in production.
// All proposals are created through initialize_market which properly handles proposal IDs
// generated from the priority queue.

/// Create a PREMARKET proposal without market/escrow/liquidity.
/// This reserves the proposal "as next" without consuming DAO/proposer liquidity.
#[allow(lint(share_owned))]
public fun new_premarket<AssetType, StableType>(
    // Proposal ID originating from queue
    proposal_id_from_queue: ID,
    dao_id: ID,
    review_period_ms: u64,
    trading_period_ms: u64,
    min_asset_liquidity: u64,
    min_stable_liquidity: u64,
    twap_start_delay: u64,
    twap_initial_observation: u128,
    twap_step_max: u64,
    twap_threshold: u64,
    amm_total_fee_bps: u64,
    max_outcomes: u64, // DAO's configured max outcomes
    treasury_address: address,
    title: String,
    metadata: String,
    outcome_messages: vector<String>,
    outcome_details: vector<String>,
    proposer: address,
    uses_dao_liquidity: bool,
    fee_escrow: Balance<StableType>,
    intent_spec_for_yes: Option<InitActionSpecs>,
    clock: &Clock,
    ctx: &mut TxContext,
): ID {
    let id = object::new(ctx);
    let actual_proposal_id = object::uid_to_inner(&id);
    let outcome_count = outcome_messages.length();
    
    // Validate outcome count
    assert!(outcome_count <= max_outcomes, ETooManyOutcomes);
    
    let proposal = Proposal<AssetType, StableType> {
        id,
        queued_proposal_id: proposal_id_from_queue,
        state: STATE_PREMARKET,
        dao_id,
        proposer,
        liquidity_provider: option::none(),
        withdraw_only_mode: false,
        escrow_id: option::none(),
        market_state_id: option::none(),
        conditional_treasury_caps: bag::new(ctx),
        conditional_metadata: bag::new(ctx),
        title,
        details: outcome_details,
        metadata,
        timing: ProposalTiming {
            created_at: clock.timestamp_ms(),
            market_initialized_at: option::none(),
            review_period_ms,
            trading_period_ms,
            last_twap_update: 0,
            twap_start_delay,
        },
        liquidity_config: LiquidityConfig {
            min_asset_liquidity,
            min_stable_liquidity,
            asset_amounts: vector::empty(),
            stable_amounts: vector::empty(),
            uses_dao_liquidity,
        },
        twap_config: TwapConfig {
            twap_prices: vector::empty(),
            twap_initial_observation,
            twap_step_max,
            twap_threshold,
        },
        early_resolve_metrics: option::none(),  // Early resolution disabled by default
        outcome_data: OutcomeData {
            outcome_count,
            outcome_messages,
            outcome_creators: vector::tabulate!(outcome_count, |_| proposer),
            outcome_creator_fees: vector::tabulate!(outcome_count, |_| 0u64),  // Initialize with 0 fees
            intent_specs: vector::tabulate!(outcome_count, |_| option::none<InitActionSpecs>()),
            actions_per_outcome: vector::tabulate!(outcome_count, |_| 0),
            winning_outcome: option::none(),
        },
        amm_total_fee_bps,
        fee_escrow,
        treasury_address,
        // Policy enforcement - Policy data will be set when IntentSpecs are attached
        // For now, initialize with empty/default values (these MUST be set before market activation)
        policy_modes: vector::tabulate!(outcome_count, |_| 0u8),  // Default: DAO_ONLY
        required_council_ids: vector::tabulate!(outcome_count, |_| option::none()),
        council_approval_proofs: vector::tabulate!(outcome_count, |_| option::none()),
    };

    transfer::public_share_object(proposal);
    actual_proposal_id
}

/// Initialize market/escrow/AMMs for a PREMARKET proposal.
/// Consumes provided coins, sets state to REVIEW, and readies the market for the review timer.
#[allow(lint(share_owned, self_transfer))]
/// Step 1: Create escrow with market state (called first in PTB)
/// Returns unshared escrow for cap registration
public fun create_escrow_for_market<AssetType, StableType>(
    proposal: &Proposal<AssetType, StableType>,
    clock: &Clock,
    ctx: &mut TxContext,
): TokenEscrow<AssetType, StableType> {
    assert!(proposal.state == STATE_PREMARKET, EInvalidState);

    // Create market state
    let ms = market_state::new(
        object::id(proposal),
        proposal.dao_id,
        proposal.outcome_data.outcome_count,
        proposal.outcome_data.outcome_messages,
        clock,
        ctx
    );

    // Create and return escrow (not yet shared)
    coin_escrow::new<AssetType, StableType>(ms, ctx)
}

/// Step 2: Extract conditional coin caps from proposal and register with escrow
/// Must be called once per outcome (PTB calls this N times with different type parameters)
public fun register_outcome_caps_with_escrow<AssetType, StableType, AssetConditionalCoin, StableConditionalCoin>(
    proposal: &mut Proposal<AssetType, StableType>,
    escrow: &mut TokenEscrow<AssetType, StableType>,
    outcome_index: u64,
) {
    assert!(proposal.state == STATE_PREMARKET, EInvalidState);

    // Extract TreasuryCaps from proposal bags
    let asset_key = ConditionalCoinKey { outcome_index, is_asset: true };
    let stable_key = ConditionalCoinKey { outcome_index, is_asset: false };

    let asset_cap: TreasuryCap<AssetConditionalCoin> =
        bag::remove(&mut proposal.conditional_treasury_caps, asset_key);
    let stable_cap: TreasuryCap<StableConditionalCoin> =
        bag::remove(&mut proposal.conditional_treasury_caps, stable_key);

    // Register with escrow
    coin_escrow::register_conditional_caps(escrow, outcome_index, asset_cap, stable_cap);
}

/// Step 3: Initialize market with pre-configured escrow
/// Called after create_escrow_for_market() and N calls to register_outcome_caps_with_escrow()
#[allow(lint(share_owned, self_transfer))]
public fun initialize_market_with_escrow<AssetType, StableType>(
    proposal: &mut Proposal<AssetType, StableType>,
    mut escrow: TokenEscrow<AssetType, StableType>,
    asset_coin: Coin<AssetType>,
    stable_coin: Coin<StableType>,
    clock: &Clock,
    ctx: &mut TxContext,
): ID {
    assert!(proposal.state == STATE_PREMARKET, EInvalidState);

    let outcome_count = proposal.outcome_data.outcome_count;

    // Evenly split liquidity across outcomes
    let total_asset_liquidity = asset_coin.value();
    let total_stable_liquidity = stable_coin.value();
    assert!(total_asset_liquidity > 0 && total_stable_liquidity > 0, EInvalidAmount);

    let asset_per = total_asset_liquidity / outcome_count;
    let stable_per = total_stable_liquidity / outcome_count;
    assert!(asset_per >= proposal.liquidity_config.min_asset_liquidity, EAssetLiquidityTooLow);
    assert!(stable_per >= proposal.liquidity_config.min_stable_liquidity, EStableLiquidityTooLow);

    let asset_remainder = total_asset_liquidity % outcome_count;
    let stable_remainder = total_stable_liquidity % outcome_count;

    let mut initial_asset_amounts = vector::empty<u64>();
    let mut initial_stable_amounts = vector::empty<u64>();
    let mut i = 0;
    while (i < outcome_count) {
        let a = if (i < asset_remainder) { asset_per + 1 } else { asset_per };
        let s = if (i < stable_remainder) { stable_per + 1 } else { stable_per };
        vector::push_back(&mut initial_asset_amounts, a);
        vector::push_back(&mut initial_stable_amounts, s);
        i = i + 1;
    };

    let escrow_id = object::id(&escrow);
    let market_state_id = coin_escrow::market_state_id(&escrow);
    
    // Determine quantum liquidity amounts
    let mut asset_balance = asset_coin.into_balance();
    let mut stable_balance = stable_coin.into_balance();
    
    let mut max_asset = 0u64;
    let mut max_stable = 0u64;
    i = 0;
    while (i < outcome_count) {
        let a = *initial_asset_amounts.borrow(i);
        let s = *initial_stable_amounts.borrow(i);
        if (a > max_asset) { max_asset = a };
        if (s > max_stable) { max_stable = s };
        i = i + 1;
    };
    
    let asset_total = asset_balance.value();
    let stable_total = stable_balance.value();
    
    let asset_for_pool = if (asset_total > max_asset) {
        asset_balance.split(max_asset)
    } else {
        asset_balance.split(asset_total)
    };
    
    let stable_for_pool = if (stable_total > max_stable) {
        stable_balance.split(max_stable)
    } else {
        stable_balance.split(stable_total)
    };
    
    // Return any excess to liquidity provider (the activator who supplied coins)
    let sender = ctx.sender();
    if (asset_balance.value() > 0) {
        transfer::public_transfer(asset_balance.into_coin(ctx), sender);
    } else {
        asset_balance.destroy_zero();
    };
    
    if (stable_balance.value() > 0) {
        transfer::public_transfer(stable_balance.into_coin(ctx), sender);
    } else {
        stable_balance.destroy_zero();
    };
    
    // Create outcome markets (TreasuryCaps already registered with escrow)
    let amm_pools = liquidity_initialize::create_outcome_markets(
        &mut escrow,
        proposal.outcome_data.outcome_count,
        initial_asset_amounts,
        initial_stable_amounts,
        proposal.timing.twap_start_delay,
        proposal.twap_config.twap_initial_observation,
        proposal.twap_config.twap_step_max,
        proposal.amm_total_fee_bps,
        asset_for_pool,
        stable_for_pool,
        clock,
        ctx
    );

    // Move pools to MarketState (architectural fix: pools belong to market, not proposal)
    let market_state = coin_escrow::get_market_state_mut(&mut escrow);
    market_state::set_amm_pools(market_state, amm_pools);

    // Update proposal's liquidity amounts
    proposal.liquidity_config.asset_amounts = initial_asset_amounts;
    proposal.liquidity_config.stable_amounts = initial_stable_amounts;

    // Initialize market fields: PREMARKET → REVIEW
    initialize_market_fields(
        proposal,
        market_state_id,
        escrow_id,
        clock.timestamp_ms(),
        sender
    );
    
    transfer::public_share_object(escrow);
    market_state_id
}

/// Internal function: Adds a new outcome during the premarket phase.
/// max_outcomes: The DAO's configured maximum number of outcomes allowed
/// fee_paid: The fee paid by the outcome creator (for potential refund if their outcome wins)
///
/// SECURITY: This is an internal function. Fee payment must be validated before calling.
/// External callers MUST use entry functions that collect actual Coin<SUI> payments.
public fun add_outcome<AssetType, StableType>(
    proposal: &mut Proposal<AssetType, StableType>,
    message: String,
    detail: String,
    asset_amount: u64,
    stable_amount: u64,
    creator: address,
    fee_paid: u64,
    max_outcomes: u64,
    clock: &Clock,
) {
    // SECURITY: Only allow adding outcomes in PREMARKET state
    assert!(proposal.state == STATE_PREMARKET, EInvalidState);

    // Check that we're not exceeding the maximum number of outcomes
    assert!(proposal.outcome_data.outcome_count < max_outcomes, ETooManyOutcomes);

    proposal.outcome_data.outcome_messages.push_back(message);
    proposal.details.push_back(detail);
    proposal.liquidity_config.asset_amounts.push_back(asset_amount);
    proposal.liquidity_config.stable_amounts.push_back(stable_amount);
    proposal.outcome_data.outcome_creators.push_back(creator);
    proposal.outcome_data.outcome_creator_fees.push_back(fee_paid);  // Track the fee paid

    // Initialize action count for new outcome
    proposal.outcome_data.actions_per_outcome.push_back(0);

    // Initialize IntentSpec slot as empty
    proposal.outcome_data.intent_specs.push_back(option::none());

    // CRITICAL SECURITY: Initialize policy fields with default values
    // These MUST be updated when IntentSpec is attached via set_intent_spec_for_outcome
    proposal.policy_modes.push_back(0u8);  // Default: DAO_ONLY
    proposal.required_council_ids.push_back(option::none());
    proposal.council_approval_proofs.push_back(option::none());

    let new_idx = proposal.outcome_data.outcome_count;
    proposal.outcome_data.outcome_count = new_idx + 1;

    event::emit(ProposalOutcomeAdded {
        proposal_id: get_id(proposal),
        dao_id: get_dao_id(proposal),
        new_outcome_idx: new_idx,
        creator,
        timestamp: clock.timestamp_ms(),
    });
}

/// SECURE entry function: Adds outcome with actual fee collection
/// This collects the fee payment and stores it in the proposal's fee escrow
/// for later refund if the outcome wins.
public entry fun add_outcome_with_fee<AssetType, StableType>(
    proposal: &mut Proposal<AssetType, StableType>,
    fee_payment: Coin<StableType>,
    message: String,
    detail: String,
    asset_amount: u64,
    stable_amount: u64,
    max_outcomes: u64,
    clock: &Clock,
    ctx: &mut TxContext,
) {
    use sui::coin;

    // Get the actual fee paid
    let fee_paid = fee_payment.value();

    // SECURITY: Deposit fee into proposal's escrow (for later refund)
    // This ensures fees are tracked per-proposal, not mixed with protocol revenue
    proposal.fee_escrow.join(fee_payment.into_balance());

    // Add the outcome with validated fee
    add_outcome(
        proposal,
        message,
        detail,
        asset_amount,
        stable_amount,
        ctx.sender(),
        fee_paid,
        max_outcomes,
        clock,
    );
}

/// Initializes the market-related fields of the proposal.
/// Pools are now stored in MarketState, not Proposal
public fun initialize_market_fields<AssetType, StableType>(
    proposal: &mut Proposal<AssetType, StableType>,
    market_state_id: ID,
    escrow_id: ID,
    initialized_at: u64,
    liquidity_provider: address,
) {
    assert!(proposal.state == STATE_PREMARKET, EInvalidState);

    // Use option::fill to replace None with Some value
    option::fill(&mut proposal.market_state_id, market_state_id);
    option::fill(&mut proposal.escrow_id, escrow_id);
    // amm_pools removed - now stored in MarketState
    // LP caps no longer needed - using conditional tokens
    option::fill(&mut proposal.timing.market_initialized_at, initialized_at);
    option::fill(&mut proposal.liquidity_provider, liquidity_provider);
    proposal.state = STATE_REVIEW; // Advance state to REVIEW
}

/// Emits the ProposalMarketInitialized event
public fun emit_market_initialized(
    proposal_id: ID,
    dao_id: ID,
    market_state_id: ID,
    escrow_id: ID,
    timestamp: u64,
) {
    event::emit(ProposalMarketInitialized {
        proposal_id,
        dao_id,
        market_state_id,
        escrow_id,
        timestamp,
    });
}

/// Takes the escrowed fee balance out of the proposal, leaving a zero balance behind.
public fun take_fee_escrow<AssetType, StableType>(
    proposal: &mut Proposal<AssetType, StableType>,
): Balance<StableType> {
    let fee_balance = &mut proposal.fee_escrow;
    let amount = fee_balance.value();
    sui::balance::split(fee_balance, amount)
}

/// Get TWAPs from all pools via MarketState
/// Returns a reference to that oracle; aborts if not found.
public fun get_twaps_for_proposal<AssetType, StableType>(
    proposal: &mut Proposal<AssetType, StableType>,
    escrow: &mut TokenEscrow<AssetType, StableType>,
    clock: &Clock,
): vector<u128> {
    let market_state = coin_escrow::get_market_state_mut(escrow);
    let pools = market_state::borrow_amm_pools_mut(market_state);
    let mut twaps = vector[];
    let mut i = 0;
    while (i < pools.length()) {
        let pool = &mut pools[i];
        let twap = pool.get_twap(clock);
        twaps.push_back(twap);
        i = i + 1;
    };
    twaps
}

/// Calculate current winner by INSTANT PRICE (fast flip detection)
/// Returns (winner_index, winner_price, spread)
/// Used for flip detection - faster than TWAP
public fun calculate_current_winner_by_price<AssetType, StableType>(
    proposal: &mut Proposal<AssetType, StableType>,
    escrow: &mut TokenEscrow<AssetType, StableType>,
): (u64, u128, u128) {
    let market_state = coin_escrow::get_market_state_mut(escrow);
    let pools = market_state::borrow_amm_pools_mut(market_state);
    let outcome_count = pools.length();

    assert!(outcome_count >= 2, EInvalidOutcome);

    // Get instant prices from all pools
    let mut winner_idx = 0u64;
    let mut winner_price = conditional_amm::get_current_price(&pools[0]);
    let mut second_price = 0u128;

    let mut i = 1u64;
    while (i < outcome_count) {
        let current_price = conditional_amm::get_current_price(&pools[i]);

        if (current_price > winner_price) {
            // New winner
            second_price = winner_price;
            winner_price = current_price;
            winner_idx = i;
        } else if (current_price > second_price) {
            // New second place
            second_price = current_price;
        };

        i = i + 1;
    };

    // Calculate spread (winner - second)
    let spread = if (winner_price > second_price) {
        winner_price - second_price
    } else {
        0u128
    };

    (winner_idx, winner_price, spread)
}

/// Calculate current winner by TWAP (for final resolution - manipulation resistant)
/// Returns (winner_index, winner_twap, spread)
/// Used for final resolution - slower but more secure
public fun calculate_current_winner<AssetType, StableType>(
    proposal: &mut Proposal<AssetType, StableType>,
    escrow: &mut TokenEscrow<AssetType, StableType>,
    clock: &Clock,
): (u64, u128, u128) {
    // Get TWAPs from all markets
    let twaps = get_twaps_for_proposal(proposal, escrow, clock);
    let outcome_count = twaps.length();

    assert!(outcome_count >= 2, EInvalidOutcome);  // Need at least 2 outcomes

    // Find highest and second-highest TWAPs
    let mut winner_idx = 0u64;
    let mut winner_twap = *twaps.borrow(0);
    let mut second_twap = 0u128;

    let mut i = 1u64;
    while (i < outcome_count) {
        let current_twap = *twaps.borrow(i);

        if (current_twap > winner_twap) {
            // New winner found
            second_twap = winner_twap;
            winner_twap = current_twap;
            winner_idx = i;
        } else if (current_twap > second_twap) {
            // New second place
            second_twap = current_twap;
        };

        i = i + 1;
    };

    // Calculate spread (winner - second)
    let spread = if (winner_twap > second_twap) {
        winner_twap - second_twap
    } else {
        0u128
    };

    (winner_idx, winner_twap, spread)
}

// Early resolve functions removed to avoid circular dependencies.
// Callers should use early_resolve::update_metrics() and early_resolve::check_eligibility() directly.

// === Private Functions ===

fun get_pool_mut(pools: &mut vector<LiquidityPool>, outcome_idx: u8): &mut LiquidityPool {
    let mut i = 0;
    let len = pools.length();
    while (i < len) {
        let pool = &mut pools[i];
        if (pool.get_outcome_idx() == outcome_idx) {
            return pool
        };
        i = i + 1;
    };
    abort EPoolNotFound
}

// === View Functions ===

public fun is_finalized<AssetType, StableType>(proposal: &Proposal<AssetType, StableType>): bool {
    proposal.state == STATE_FINALIZED
}

public fun get_twap_prices<AssetType, StableType>(
    proposal: &Proposal<AssetType, StableType>,
): &vector<u128> {
    &proposal.twap_config.twap_prices
}

public fun get_last_twap_update<AssetType, StableType>(
    proposal: &Proposal<AssetType, StableType>,
): u64 {
    proposal.timing.last_twap_update
}

/// Get TWAP for a specific outcome by index
public fun get_twap_by_outcome<AssetType, StableType>(
    proposal: &Proposal<AssetType, StableType>,
    outcome_index: u64,
): u128 {
    // Add defensive checks
    assert!(proposal.state == STATE_FINALIZED, ENotFinalized);
    let twap_prices = &proposal.twap_config.twap_prices;
    assert!(!twap_prices.is_empty(), ETwapNotSet);
    assert!(outcome_index < twap_prices.length(), EOutcomeOutOfBounds);
    *twap_prices.borrow(outcome_index)
}

/// Get the TWAP of the winning outcome
public fun get_winning_twap<AssetType, StableType>(
    proposal: &Proposal<AssetType, StableType>,
): u128 {
    // Add defensive checks
    assert!(proposal.state == STATE_FINALIZED, ENotFinalized);
    assert!(proposal.outcome_data.winning_outcome.is_some(), EInvalidState);
    assert!(!proposal.twap_config.twap_prices.is_empty(), ETwapNotSet);
    let winning_outcome = *proposal.outcome_data.winning_outcome.borrow();
    get_twap_by_outcome(proposal, winning_outcome)
}

public fun state<AssetType, StableType>(proposal: &Proposal<AssetType, StableType>): u8 {
    proposal.state
}

public fun get_winning_outcome<AssetType, StableType>(
    proposal: &Proposal<AssetType, StableType>,
): u64 {
    assert!(proposal.outcome_data.winning_outcome.is_some(), EInvalidState);
    *proposal.outcome_data.winning_outcome.borrow()
}

/// Checks if winning outcome has been set
public fun is_winning_outcome_set<AssetType, StableType>(
    proposal: &Proposal<AssetType, StableType>,
): bool {
    proposal.outcome_data.winning_outcome.is_some()
}

/// Returns the treasury address where fees for failed proposals are sent.
public fun treasury_address<AssetType, StableType>(
    proposal: &Proposal<AssetType, StableType>,
): address {
    proposal.treasury_address
}

public fun get_id<AssetType, StableType>(proposal: &Proposal<AssetType, StableType>): ID {
    proposal.id.to_inner()
}

public fun escrow_id<AssetType, StableType>(proposal: &Proposal<AssetType, StableType>): ID {
    assert!(proposal.escrow_id.is_some(), EInvalidState);
    *proposal.escrow_id.borrow()
}

public fun market_state_id<AssetType, StableType>(proposal: &Proposal<AssetType, StableType>): ID {
    assert!(proposal.market_state_id.is_some(), EInvalidState);
    *proposal.market_state_id.borrow()
}

public fun get_market_initialized_at<AssetType, StableType>(proposal: &Proposal<AssetType, StableType>): u64 {
    assert!(proposal.timing.market_initialized_at.is_some(), EInvalidState);
    *proposal.timing.market_initialized_at.borrow()
}

public fun outcome_count<AssetType, StableType>(proposal: &Proposal<AssetType, StableType>): u64 {
    proposal.outcome_data.outcome_count
}

/// Alias for outcome_count for better readability
public fun get_num_outcomes<AssetType, StableType>(proposal: &Proposal<AssetType, StableType>): u64 {
    proposal.outcome_data.outcome_count
}

public fun proposer<AssetType, StableType>(proposal: &Proposal<AssetType, StableType>): address {
    proposal.proposer
}

public fun created_at<AssetType, StableType>(proposal: &Proposal<AssetType, StableType>): u64 {
    proposal.timing.created_at
}

public fun get_details<AssetType, StableType>(proposal: &Proposal<AssetType, StableType>): &vector<String> {
    &proposal.details
}

public fun get_metadata<AssetType, StableType>(
    proposal: &Proposal<AssetType, StableType>,
): &String {
    &proposal.metadata
}

public fun get_amm_pool_ids<AssetType, StableType>(
    proposal: &Proposal<AssetType, StableType>,
    escrow: &TokenEscrow<AssetType, StableType>,
): vector<ID> {
    let mut ids = vector[];
    let mut i = 0;
    let market_state = coin_escrow::get_market_state(escrow);
    let pools = market_state::borrow_amm_pools(market_state);
    let len = pools.length();
    while (i < len) {
        let pool = &pools[i];
        ids.push_back(pool.get_id());
        i = i + 1;
    };
    ids
}

public fun get_pool_mut_by_outcome<AssetType, StableType>(
    proposal: &mut Proposal<AssetType, StableType>,
    escrow: &mut TokenEscrow<AssetType, StableType>,
    outcome_idx: u8,
): &mut LiquidityPool {
    assert!((outcome_idx as u64) < proposal.outcome_data.outcome_count, EOutcomeOutOfBounds);
    let market_state = coin_escrow::get_market_state_mut(escrow);
    let pools_mut = market_state::borrow_amm_pools_mut(market_state);
    get_pool_mut(pools_mut, outcome_idx)
}

public fun get_pool_by_outcome<AssetType, StableType>(
    proposal: &Proposal<AssetType, StableType>,
    escrow: &TokenEscrow<AssetType, StableType>,
    outcome_idx: u8,
): &LiquidityPool {
    assert!((outcome_idx as u64) < proposal.outcome_data.outcome_count, EOutcomeOutOfBounds);
    let market_state = coin_escrow::get_market_state(escrow);
    let pools = market_state::borrow_amm_pools(market_state);
    let mut i = 0;
    let len = pools.length();
    while (i < len) {
        let pool = &pools[i];
        if (pool.get_outcome_idx() == outcome_idx) {
            return pool
        };
        i = i + 1;
    };
    abort EPoolNotFound
}

// LP caps no longer needed - using conditional tokens for LP

// Pool and LP cap getter no longer needed - using conditional tokens for LP

public fun get_state<AssetType, StableType>(proposal: &Proposal<AssetType, StableType>): u8 {
    proposal.state
}

public fun get_dao_id<AssetType, StableType>(proposal: &Proposal<AssetType, StableType>): ID {
    proposal.dao_id
}

// === Policy Enforcement Getters ===

/// Get PolicyRequirement ID for a specific outcome
/// Caller can use this ID to fetch the PolicyRequirement shared object and read policy data
public fun get_policy_mode_for_outcome<AssetType, StableType>(
    proposal: &Proposal<AssetType, StableType>,
    outcome_idx: u64
): u8 {
    *vector::borrow(&proposal.policy_modes, outcome_idx)
}

public fun get_required_council_id_for_outcome<AssetType, StableType>(
    proposal: &Proposal<AssetType, StableType>,
    outcome_idx: u64
): Option<ID> {
    *vector::borrow(&proposal.required_council_ids, outcome_idx)
}

public fun get_council_approval_proof_for_outcome<AssetType, StableType>(
    proposal: &Proposal<AssetType, StableType>,
    outcome_idx: u64
): Option<ID> {
    *vector::borrow(&proposal.council_approval_proofs, outcome_idx)
}

// === End Policy Enforcement Getters ===

public fun proposal_id<AssetType, StableType>(proposal: &Proposal<AssetType, StableType>): ID {
    proposal.id.to_inner()
}

public fun get_amm_pools<AssetType, StableType>(
    proposal: &Proposal<AssetType, StableType>,
    escrow: &TokenEscrow<AssetType, StableType>,
): &vector<LiquidityPool> {
    let market_state = coin_escrow::get_market_state(escrow);
    market_state::borrow_amm_pools(market_state)
}

public fun get_amm_pools_mut<AssetType, StableType>(
    proposal: &mut Proposal<AssetType, StableType>,
    escrow: &mut TokenEscrow<AssetType, StableType>,
): &mut vector<LiquidityPool> {
    let market_state = coin_escrow::get_market_state_mut(escrow);
    market_state::borrow_amm_pools_mut(market_state)
}

public fun get_created_at<AssetType, StableType>(proposal: &Proposal<AssetType, StableType>): u64 {
    proposal.timing.created_at
}

public fun get_review_period_ms<AssetType, StableType>(
    proposal: &Proposal<AssetType, StableType>,
): u64 {
    proposal.timing.review_period_ms
}

public fun get_trading_period_ms<AssetType, StableType>(
    proposal: &Proposal<AssetType, StableType>,
): u64 {
    proposal.timing.trading_period_ms
}

public fun get_twap_threshold<AssetType, StableType>(
    proposal: &Proposal<AssetType, StableType>,
): u64 {
    proposal.twap_config.twap_threshold
}

public fun get_twap_start_delay<AssetType, StableType>(proposal: &Proposal<AssetType, StableType>): u64 {
    proposal.timing.twap_start_delay
}

public fun get_twap_initial_observation<AssetType, StableType>(proposal: &Proposal<AssetType, StableType>): u128 {
    proposal.twap_config.twap_initial_observation
}

public fun get_twap_step_max<AssetType, StableType>(proposal: &Proposal<AssetType, StableType>): u64 {
    proposal.twap_config.twap_step_max
}

public fun uses_dao_liquidity<AssetType, StableType>(proposal: &Proposal<AssetType, StableType>): bool {
    proposal.liquidity_config.uses_dao_liquidity
}

public fun get_amm_total_fee_bps<AssetType, StableType>(
    proposal: &Proposal<AssetType, StableType>,
): u64 {
    proposal.amm_total_fee_bps
}


/// Returns the parameters needed to initialize the market after the premarket phase.
public fun get_market_init_params<AssetType, StableType>(proposal: &Proposal<AssetType, StableType>): (u64, &vector<String>, &vector<u64>, &vector<u64>) {
    (
        proposal.outcome_data.outcome_count,
        &proposal.outcome_data.outcome_messages,
        &proposal.liquidity_config.asset_amounts,
        &proposal.liquidity_config.stable_amounts,
    )
}

// === Package Functions ===

/// Advances the proposal state based on elapsed time
/// Transitions from REVIEW to TRADING when review period ends
/// Returns true if state was changed
public fun advance_state<AssetType, StableType>(
    proposal: &mut Proposal<AssetType, StableType>,
    escrow: &mut TokenEscrow<AssetType, StableType>,
    clock: &Clock,
): bool {
    let current_time = clock.timestamp_ms();
    // Use market_initialized_at for timing calculations instead of created_at
    // This ensures premarket proposals get proper review/trading periods after initialization
    let base_timestamp = if (proposal.timing.market_initialized_at.is_some()) {
        *proposal.timing.market_initialized_at.borrow()
    } else {
        // Fallback to created_at if market not initialized (shouldn't happen in normal flow)
        proposal.timing.created_at
    };
    
    // Check if we should transition from REVIEW to TRADING
    if (proposal.state == STATE_REVIEW) {
        let review_end = base_timestamp + proposal.timing.review_period_ms;
        if (current_time >= review_end) {
            proposal.state = STATE_TRADING;
            
            // Start trading in the market state
            let market = coin_escrow::get_market_state_mut(escrow);
            market_state::start_trading(market, proposal.timing.trading_period_ms, clock);

            // Extract market_id and trading_start_time before borrowing pools
            let market_id = market_state::market_id(market);
            let trading_start_time = market_state::get_trading_start(market);

            // Set oracle start time for all pools when trading begins
            let pools = market_state::borrow_amm_pools_mut(market);
            let mut i = 0;
            while (i < pools.length()) {
                let pool = &mut pools[i];
                conditional_amm::set_oracle_start_time(pool, market_id, trading_start_time);
                i = i + 1;
            };

            return true
        };
    };
    
    // Check if we should transition from TRADING to ended
    if (proposal.state == STATE_TRADING) {
        let trading_end = base_timestamp + proposal.timing.review_period_ms + proposal.timing.trading_period_ms;
        if (current_time >= trading_end) {
            // End trading in the market state
            let market = coin_escrow::get_market_state_mut(escrow);
            if (market_state::is_trading_active(market)) {
                market_state::end_trading(market, clock);
            };
            // Note: Full finalization requires calculating winner and is done separately
            return true
        };
    };
    
    false
}

public fun set_state<AssetType, StableType>(
    proposal: &mut Proposal<AssetType, StableType>,
    new_state: u8,
) {
    proposal.state = new_state;
}

public fun set_twap_prices<AssetType, StableType>(
    proposal: &mut Proposal<AssetType, StableType>,
    twap_prices: vector<u128>,
) {
    proposal.twap_config.twap_prices = twap_prices;
}

public fun set_last_twap_update<AssetType, StableType>(
    proposal: &mut Proposal<AssetType, StableType>,
    timestamp: u64,
) {
    proposal.timing.last_twap_update = timestamp;
}

public fun set_winning_outcome<AssetType, StableType>(
    proposal: &mut Proposal<AssetType, StableType>,
    outcome: u64,
) {
    proposal.outcome_data.winning_outcome = option::some(outcome);
}

/// Finalize the proposal with the winning outcome computed on-chain
/// This combines computing the winner from TWAP, setting the winning outcome and updating state atomically
/// @deprecated Use proposal_lifecycle::finalize_proposal_market instead - this version lacks critical intent cleanup
#[test_only]
public fun finalize_proposal<AssetType, StableType>(
    proposal: &mut Proposal<AssetType, StableType>,
    escrow: &mut TokenEscrow<AssetType, StableType>,
    clock: &Clock,
) {
    // Ensure we're in a state that can be finalized
    assert!(proposal.state == STATE_TRADING || proposal.state == STATE_REVIEW, EInvalidState);
    
    // If still in trading, end trading first
    if (proposal.state == STATE_TRADING) {
        let market = coin_escrow::get_market_state_mut(escrow);
        if (market_state::is_trading_active(market)) {
            market_state::end_trading(market, clock);
        };
    };
    
    // Critical fix: Compute the winning outcome on-chain from TWAP prices
    // Get TWAP prices from all pools
    let twap_prices = get_twaps_for_proposal(proposal, escrow, clock);

    // For a simple YES/NO proposal, compare the YES TWAP to the threshold
    let winning_outcome = if (twap_prices.length() >= 2) {
        let yes_twap = *twap_prices.borrow(OUTCOME_ACCEPTED);
        let threshold = get_twap_threshold(proposal);
        
        // If YES TWAP exceeds threshold, YES wins
        if (yes_twap > (threshold as u128)) {
            OUTCOME_ACCEPTED
        } else {
            OUTCOME_REJECTED
        }
    } else {
        // For single-outcome or other configs, default to first outcome
        // This should be revisited based on your specific requirements
        0
    };
    
    // Set the winning outcome
    proposal.outcome_data.winning_outcome = option::some(winning_outcome);
    
    // Update state to finalized
    proposal.state = STATE_FINALIZED;
    
    // Finalize the market state
    let market = coin_escrow::get_market_state_mut(escrow);
    market_state::finalize(market, winning_outcome, clock);
}

public fun get_outcome_creators<AssetType, StableType>(proposal: &Proposal<AssetType, StableType>): &vector<address> {
    &proposal.outcome_data.outcome_creators
}

/// Get the address of the creator for a specific outcome
public fun get_outcome_creator<AssetType, StableType>(
    proposal: &Proposal<AssetType, StableType>,
    outcome_index: u64
): address {
    assert!(outcome_index < proposal.outcome_data.outcome_count, EOutcomeOutOfBounds);
    *vector::borrow(&proposal.outcome_data.outcome_creators, outcome_index)
}

/// Get the fee paid by the creator for a specific outcome
public fun get_outcome_creator_fee<AssetType, StableType>(
    proposal: &Proposal<AssetType, StableType>,
    outcome_index: u64
): u64 {
    assert!(outcome_index < proposal.outcome_data.outcome_count, EOutcomeOutOfBounds);
    *vector::borrow(&proposal.outcome_data.outcome_creator_fees, outcome_index)
}

/// Get all outcome creator fees
public fun get_outcome_creator_fees<AssetType, StableType>(
    proposal: &Proposal<AssetType, StableType>
): &vector<u64> {
    &proposal.outcome_data.outcome_creator_fees
}

/// Get early resolve metrics (if enabled)
public fun get_early_resolve_metrics<AssetType, StableType>(
    proposal: &Proposal<AssetType, StableType>,
): &Option<EarlyResolveMetrics> {
    &proposal.early_resolve_metrics
}

// time_until_eligible() removed to avoid circular dependencies.
// Callers should use early_resolve::time_until_eligible() directly.

// === Package-Level Accessors for early_resolve Module ===

/// Check if proposal has early resolve metrics initialized
/// Used by early_resolve module to validate metrics exist before processing
public(package) fun has_early_resolve_metrics<AssetType, StableType>(
    proposal: &Proposal<AssetType, StableType>
): bool {
    proposal.early_resolve_metrics.is_some()
}

/// Borrow early resolve metrics immutably
/// Used by early_resolve module to read current metrics state
public(package) fun borrow_early_resolve_metrics<AssetType, StableType>(
    proposal: &Proposal<AssetType, StableType>
): &EarlyResolveMetrics {
    proposal.early_resolve_metrics.borrow()
}

/// Borrow early resolve metrics mutably
/// Used by early_resolve module to update flip tracking
public(package) fun borrow_early_resolve_metrics_mut<AssetType, StableType>(
    proposal: &mut Proposal<AssetType, StableType>
): &mut EarlyResolveMetrics {
    proposal.early_resolve_metrics.borrow_mut()
}

/// Get proposal start time for early resolve calculations
/// Returns market_initialized_at if available, otherwise created_at
public(package) fun get_start_time_for_early_resolve<AssetType, StableType>(
    proposal: &Proposal<AssetType, StableType>
): u64 {
    if (proposal.timing.market_initialized_at.is_some()) {
        *proposal.timing.market_initialized_at.borrow()
    } else {
        proposal.timing.created_at
    }
}

// === Field Accessors for EarlyResolveMetrics ===

/// Get current winner index from metrics
public(package) fun metrics_current_winner(metrics: &EarlyResolveMetrics): u64 {
    metrics.current_winner_index
}

/// Get last flip time from metrics
public(package) fun metrics_last_flip_time_ms(metrics: &EarlyResolveMetrics): u64 {
    metrics.last_flip_time_ms
}

/// Set current winner index in metrics
public(package) fun metrics_set_current_winner(metrics: &mut EarlyResolveMetrics, winner_idx: u64) {
    metrics.current_winner_index = winner_idx;
}

/// Set last flip time in metrics
public(package) fun metrics_set_last_flip_time_ms(metrics: &mut EarlyResolveMetrics, time_ms: u64) {
    metrics.last_flip_time_ms = time_ms;
}

/// Create new EarlyResolveMetrics
public(package) fun new_early_resolve_metrics(
    initial_winner: u64,
    current_time_ms: u64,
): EarlyResolveMetrics {
    EarlyResolveMetrics {
        current_winner_index: initial_winner,
        last_flip_time_ms: current_time_ms,
    }
}

public fun get_liquidity_provider<AssetType, StableType>(proposal: &Proposal<AssetType, StableType>): Option<address> {
    proposal.liquidity_provider
}

public fun get_proposer<AssetType, StableType>(proposal: &Proposal<AssetType, StableType>): address {
    proposal.proposer
}

/// Check if this proposal's liquidity is in withdraw-only mode
public fun is_withdraw_only<AssetType, StableType>(proposal: &Proposal<AssetType, StableType>): bool {
    proposal.withdraw_only_mode
}

/// Set withdraw-only mode - prevents auto-reinvestment in next proposal
/// Only callable by the liquidity provider
public entry fun set_withdraw_only_mode<AssetType, StableType>(
    proposal: &mut Proposal<AssetType, StableType>,
    withdraw_only: bool,
    ctx: &TxContext,
) {
    assert!(proposal.liquidity_provider.is_some(), ENotLiquidityProvider);
    let provider = *proposal.liquidity_provider.borrow();
    assert!(tx_context::sender(ctx) == provider, ENotLiquidityProvider);
    proposal.withdraw_only_mode = withdraw_only;
}

public fun get_outcome_messages<AssetType, StableType>(proposal: &Proposal<AssetType, StableType>): &vector<String> {
    &proposal.outcome_data.outcome_messages
}

/// Get the intent spec for a specific outcome
public fun get_intent_spec_for_outcome<AssetType, StableType>(
    proposal: &Proposal<AssetType, StableType>,
    outcome_index: u64
): &Option<InitActionSpecs> {
    vector::borrow(&proposal.outcome_data.intent_specs, outcome_index)
}


/// Take (move out) the intent spec for a specific outcome and clear the slot.
public fun take_intent_spec_for_outcome<AssetType, StableType>(
    proposal: &mut Proposal<AssetType, StableType>,
    outcome_index: u64
): Option<InitActionSpecs> {
    assert!(outcome_index < proposal.outcome_data.outcome_count, EOutcomeOutOfBounds);
    let slot = vector::borrow_mut(&mut proposal.outcome_data.intent_specs, outcome_index);
    let old_value = *slot;
    *slot = option::none();
    old_value
}

/// Mint a scoped cancel witness by taking (moving) the spec out of the slot.
/// Returns None if no spec was set for that outcome.
/// This witness can only be created once per (proposal, outcome) pair.
public fun make_cancel_witness<AssetType, StableType>(
    proposal: &mut Proposal<AssetType, StableType>,
    outcome_index: u64
): option::Option<CancelWitness> {
    assert!(outcome_index < proposal.outcome_data.outcome_count, EOutcomeOutOfBounds);
    let addr = object::uid_to_address(&proposal.id);
    let mut spec_opt = take_intent_spec_for_outcome(proposal, outcome_index);
    if (option::is_some(&spec_opt)) {
        // Spec exists, create witness
        option::destroy_some(spec_opt);
        option::some(CancelWitness {
            proposal: addr,
            outcome_index,
        })
    } else {
        option::none<CancelWitness>()
    }
}

/// Set the intent spec for a specific outcome and track action count
/// Set IntentSpec for an outcome with policy enforcement
/// This function:
/// 1. Validates the IntentSpec action count
/// 2. Stores the IntentSpec in the outcome slot
/// 3. Stores PolicyRequirement ID for policy enforcement
///
/// CRITICAL SECURITY: PolicyRequirement ID must be provided by the caller
/// who has already analyzed the IntentSpec against the DAO's policy registry
/// and created a PolicyRequirement shared object
public fun set_intent_spec_for_outcome<AssetType, StableType>(
    proposal: &mut Proposal<AssetType, StableType>,
    outcome_index: u64,
    intent_spec: InitActionSpecs,
    max_actions_per_outcome: u64,
    policy_mode: u8,
    required_council_id: Option<ID>,
    council_approval_proof: Option<ID>,
) {
    assert!(outcome_index < proposal.outcome_data.outcome_count, EOutcomeOutOfBounds);

    let spec_slot = vector::borrow_mut(&mut proposal.outcome_data.intent_specs, outcome_index);
    let action_count = vector::borrow_mut(&mut proposal.outcome_data.actions_per_outcome, outcome_index);

    // Get action count from the spec
    let num_actions = action_specs::action_count(&intent_spec);

    // Check outcome limit only
    assert!(num_actions <= max_actions_per_outcome, ETooManyActions);

    // Set the intent spec and update count
    *spec_slot = option::some(intent_spec);
    *action_count = num_actions;

    // CRITICAL SECURITY: Store policy data for this outcome
    let mode_slot = vector::borrow_mut(&mut proposal.policy_modes, outcome_index);
    *mode_slot = policy_mode;
    let council_slot = vector::borrow_mut(&mut proposal.required_council_ids, outcome_index);
    *council_slot = required_council_id;
    let proof_slot = vector::borrow_mut(&mut proposal.council_approval_proofs, outcome_index);
    *proof_slot = council_approval_proof;
}


/// Check if an outcome has an intent spec
public fun has_intent_spec<AssetType, StableType>(
    proposal: &Proposal<AssetType, StableType>,
    outcome_index: u64
): bool {
    assert!(outcome_index < proposal.outcome_data.outcome_count, EOutcomeOutOfBounds);
    option::is_some(vector::borrow(&proposal.outcome_data.intent_specs, outcome_index))
}

/// Get the number of actions for a specific outcome
public fun get_actions_for_outcome<AssetType, StableType>(
    proposal: &Proposal<AssetType, StableType>,
    outcome_index: u64
): u64 {
    assert!(outcome_index < proposal.outcome_data.outcome_count, EOutcomeOutOfBounds);
    *vector::borrow(&proposal.outcome_data.actions_per_outcome, outcome_index)
}

/// Clear the intent spec for an outcome and reset action count
public fun clear_intent_spec_for_outcome<AssetType, StableType>(
    proposal: &mut Proposal<AssetType, StableType>,
    outcome_index: u64,
) {
    assert!(outcome_index < proposal.outcome_data.outcome_count, EOutcomeOutOfBounds);

    let spec_slot = vector::borrow_mut(&mut proposal.outcome_data.intent_specs, outcome_index);
    let action_count = vector::borrow_mut(&mut proposal.outcome_data.actions_per_outcome, outcome_index);

    if (option::is_some(spec_slot)) {
        // Clear the intent spec
        *spec_slot = option::none();

        // Reset this outcome's action count
        *action_count = 0;
    };
}


/// Emits the ProposalOutcomeMutated event
public fun emit_outcome_mutated(
    proposal_id: ID,
    dao_id: ID,
    outcome_idx: u64,
    old_creator: address,
    new_creator: address,
    timestamp: u64,
) {
    event::emit(ProposalOutcomeMutated {
        proposal_id,
        dao_id,
        outcome_idx,
        old_creator,
        new_creator,
        timestamp,
    });
}

public fun set_outcome_creator<AssetType, StableType>(
    proposal: &mut Proposal<AssetType, StableType>,
    outcome_idx: u64,
    creator: address,
) {
    assert!(outcome_idx < proposal.outcome_data.outcome_count, EOutcomeOutOfBounds);
    let creator_ref = vector::borrow_mut(&mut proposal.outcome_data.outcome_creators, outcome_idx);
    *creator_ref = creator;
}

public fun get_details_mut<AssetType, StableType>(proposal: &mut Proposal<AssetType, StableType>): &mut vector<String> {
    &mut proposal.details
}

// === Test Functions ===

#[test_only]
/// Create a minimal proposal for testing
public fun new_for_testing<AssetType, StableType>(
    dao_id: address,
    proposer: address,
    liquidity_provider: Option<address>,
    title: String,
    metadata: String,
    outcome_messages: vector<String>,
    outcome_details: vector<String>,
    outcome_creators: vector<address>,
    outcome_count: u8,
    review_period_ms: u64,
    trading_period_ms: u64,
    min_asset_liquidity: u64,
    min_stable_liquidity: u64,
    twap_start_delay: u64,
    twap_initial_observation: u128,
    twap_step_max: u64,
    twap_threshold: u64,
    amm_total_fee_bps: u64,
    winning_outcome: Option<u64>,
    fee_escrow: Balance<StableType>,
    treasury_address: address,
    intent_specs: vector<Option<InitActionSpecs>>,
    ctx: &mut TxContext
): Proposal<AssetType, StableType> {
    Proposal {
        id: object::new(ctx),
        dao_id: object::id_from_address(dao_id),
        queued_proposal_id: object::id_from_address(@0x0),
        state: STATE_PREMARKET,
        proposer,
        liquidity_provider,
        withdraw_only_mode: false,
        escrow_id: option::none(),
        market_state_id: option::none(),
        conditional_treasury_caps: bag::new(ctx),
        conditional_metadata: bag::new(ctx),
        title,
        details: outcome_details,
        metadata,
        timing: ProposalTiming {
            created_at: 0,
            market_initialized_at: option::none(),
            review_period_ms,
            trading_period_ms,
            last_twap_update: 0,
            twap_start_delay,
        },
        liquidity_config: LiquidityConfig {
            min_asset_liquidity,
            min_stable_liquidity,
            asset_amounts: vector::empty(),
            stable_amounts: vector::empty(),
            uses_dao_liquidity: false,
        },
        twap_config: TwapConfig {
            twap_prices: vector::empty(),
            twap_initial_observation,
            twap_step_max,
            twap_threshold,
        },
        early_resolve_metrics: option::none(),  // Early resolution disabled by default
        outcome_data: OutcomeData {
            outcome_count: outcome_count as u64,
            outcome_messages,
            outcome_creators,
            outcome_creator_fees: vector::tabulate!(outcome_count as u64, |_| 0u64),  // Initialize with 0 fees
            intent_specs,
            actions_per_outcome: vector::tabulate!(outcome_count as u64, |_| 0),
            winning_outcome,
        },
        amm_total_fee_bps,
        fee_escrow,
        treasury_address,
        policy_modes: vector::tabulate!(outcome_count as u64, |_| 0u8),
        required_council_ids: vector::tabulate!(outcome_count as u64, |_| option::none()),
        council_approval_proofs: vector::tabulate!(outcome_count as u64, |_| option::none()),
    }
}

#[test_only]
/// Gets a mutable reference to the token escrow of the proposal
public fun test_get_coin_escrow<AssetType, StableType>(
    escrow: &mut coin_escrow::TokenEscrow<AssetType, StableType>,
): &mut coin_escrow::TokenEscrow<AssetType, StableType> {
    escrow
}

#[test_only]
/// Gets the market state through the token escrow
public fun test_get_market_state<AssetType, StableType>(
    escrow: &coin_escrow::TokenEscrow<AssetType, StableType>,
): &market_state::MarketState {
    escrow.get_market_state()
}


// === Additional View Functions ===

/// Get proposal ID
public fun id<AssetType, StableType>(proposal: &Proposal<AssetType, StableType>): ID {
    object::id(proposal)
}

/// Get proposal address (for testing)
public fun id_address<AssetType, StableType>(proposal: &Proposal<AssetType, StableType>): address {
    object::uid_to_address(&proposal.id)
}

// === Conditional Coin Management ===

/// Add a conditional coin treasury cap and metadata to proposal
/// Must be called once per outcome per side (asset/stable)
/// The coin will be validated and its metadata updated according to DAO config
public fun add_conditional_coin<AssetType, StableType, ConditionalCoinType>(
    proposal: &mut Proposal<AssetType, StableType>,
    outcome_index: u64,
    is_asset: bool,  // true for asset-conditional, false for stable-conditional
    mut treasury_cap: TreasuryCap<ConditionalCoinType>,
    mut metadata: CoinMetadata<ConditionalCoinType>,
    coin_config: &ConditionalCoinConfig,
    asset_type_name: &String,  // Name of AssetType (e.g., "SUI")
    stable_type_name: &String, // Name of StableType (e.g., "USDC")
) {
    assert!(proposal.state == STATE_PREMARKET, EInvalidState);
    assert!(outcome_index < proposal.outcome_data.outcome_count, EOutcomeOutOfBounds);

    // Create key for this conditional coin
    let key = ConditionalCoinKey { outcome_index, is_asset };

    // Check not already set
    assert!(!bag::contains(&proposal.conditional_treasury_caps, key), EConditionalCoinAlreadySet);

    // Validate coin meets requirements
    coin_validation::validate_conditional_coin(&treasury_cap, &metadata);

    // Update metadata with DAO naming pattern: c_<outcome>_<ASSET|STABLE>
    update_conditional_coin_metadata(
        &mut metadata,
        coin_config,
        outcome_index,
        if (is_asset) { asset_type_name } else { stable_type_name },
    );

    // Store in bags
    bag::add(&mut proposal.conditional_treasury_caps, key, treasury_cap);
    bag::add(&mut proposal.conditional_metadata, key, metadata);
}

/// Update conditional coin metadata with DAO naming pattern
/// Pattern: c_<outcome_index>_<ASSET_NAME>
fun update_conditional_coin_metadata<ConditionalCoinType>(
    metadata: &mut CoinMetadata<ConditionalCoinType>,
    coin_config: &ConditionalCoinConfig,
    outcome_index: u64,
    base_coin_name: &String,
) {
    use std::ascii;
    use sui::url;

    // Build name: prefix + outcome_index + _ + base_coin_name
    let mut name_bytes = vector::empty<u8>();

    // Add prefix (e.g., "c_") if configured
    let prefix_opt = dao_config::coin_name_prefix(coin_config);
    if (prefix_opt.is_some()) {
        let prefix = prefix_opt.destroy_some();
        let prefix_bytes = ascii::as_bytes(&prefix);
        let mut i = 0;
        while (i < prefix_bytes.length()) {
            name_bytes.push_back(*prefix_bytes.borrow(i));
            i = i + 1;
        };
    } else {
        prefix_opt.destroy_none();
    };

    // Add outcome index if configured
    if (dao_config::use_outcome_index(coin_config)) {
        // Convert outcome_index to string
        let index_str = u64_to_ascii(outcome_index);
        let index_bytes = ascii::as_bytes(&index_str);
        let mut i = 0;
        while (i < index_bytes.length()) {
            name_bytes.push_back(*index_bytes.borrow(i));
            i = i + 1;
        };
        name_bytes.push_back(95u8); // '_' character
    };

    // Add base coin name
    {
        let base_bytes = string::as_bytes(base_coin_name);
        let mut i = 0;
        while (i < base_bytes.length()) {
            name_bytes.push_back(*base_bytes.borrow(i));
            i = i + 1;
        };
    };

    // Update metadata (need to use coin::update_* functions if available)
    // For now, just validate - actual metadata update requires special capabilities
    // This will be handled when we integrate with coin framework properly
}

/// Helper: Convert u64 to ASCII string
fun u64_to_ascii(mut num: u64): AsciiString {
    use std::ascii;

    if (num == 0) {
        return ascii::string(b"0")
    };

    let mut digits = vector::empty<u8>();
    while (num > 0) {
        let digit = ((num % 10) as u8) + 48; // ASCII '0' = 48
        vector::push_back(&mut digits, digit);
        num = num / 10;
    };

    // Reverse digits
    vector::reverse(&mut digits);
    ascii::string(digits)
}
module futarchy_markets::fee;

use std::ascii::String as AsciiString;
use std::type_name::{Self, TypeName};
use sui::bcs;
use sui::balance::{Self, Balance};
use sui::clock::Clock;
use sui::coin::{Self, Coin};
use sui::dynamic_field;
use sui::event;
use sui::sui::SUI;
use std::u64;
use sui::table::{Self, Table};
use sui::transfer::{public_share_object, public_transfer};
use futarchy_core::dao_payment_tracker::{Self, DaoPaymentTracker};
use futarchy_core::dao_fee_collector;

// === Introduction ===
// Manages all fees earnt by the protocol. It is also the interface for admin fee withdrawal

// === Errors ===
const EInvalidPayment: u64 = 0;
const EStableTypeNotFound: u64 = 1;
const EBadWitness: u64 = 2;
const ERecurringFeeNotDue: u64 = 3;
const EWrongStableTypeForFee: u64 = 4;
const EInsufficientTreasuryBalance: u64 = 5;
const EArithmeticOverflow: u64 = 6;
const EInvalidAdminCap: u64 = 7;
const EInvalidRecoveryFee: u64 = 9;
const EFeeExceedsHardCap: u64 = 10;
const EWrongStableCoinType: u64 = 11;
const EFeeExceedsTenXCap: u64 = 12;

// === Constants ===
const DEFAULT_DAO_CREATION_FEE: u64 = 10_000;
const DEFAULT_PROPOSAL_CREATION_FEE_PER_OUTCOME: u64 = 1000;
const DEFAULT_VERIFICATION_FEE: u64 = 10_000; // Default fee for level 1
const DEFAULT_LAUNCHPAD_CREATION_FEE: u64 = 10_000_000_000; // 10 SUI to create a launchpad
const MONTHLY_FEE_PERIOD_MS: u64 = 2_592_000_000; // 30 days
const FEE_UPDATE_DELAY_MS: u64 = 15_552_000_000; // 6 months (180 days)
const MAX_FEE_COLLECTION_PERIOD_MS: u64 = 7_776_000_000; // 90 days (3 months) - max retroactive collection
const MAX_FEE_MULTIPLIER: u64 = 10; // Maximum 10x increase from baseline
const FEE_BASELINE_RESET_PERIOD_MS: u64 = 15_552_000_000; // 6 months - baseline resets after this
// Remove ABSOLUTE_MAX_MONTHLY_FEE in V3 this is jsut here to build up trust
// Dont want to limit fee as platform gets more mature
const ABSOLUTE_MAX_MONTHLY_FEE: u64 = 10_000_000_000; // 10,000 USDC (6 decimals)

// === Structs ===

public struct FEE has drop {}

public struct FeeManager has key, store {
    id: UID,
    admin_cap_id: ID,
    dao_creation_fee: u64,
    proposal_creation_fee_per_outcome: u64,
    verification_fees: Table<u8, u64>, // Dynamic table mapping level -> fee
    dao_monthly_fee: u64,
    pending_dao_monthly_fee: Option<u64>,
    pending_fee_effective_timestamp: Option<u64>,
    sui_balance: Balance<SUI>,
    recovery_fee: u64,  // Fee for dead-man switch recovery
    launchpad_creation_fee: u64,  // Fee for creating a launchpad
}

public struct FeeAdminCap has key, store {
    id: UID,
}

/// Stores fee amounts for a specific coin type
public struct CoinFeeConfig has store {
    coin_type: TypeName,
    decimals: u8,
    dao_monthly_fee: u64,
    dao_creation_fee: u64,
    proposal_creation_fee_per_outcome: u64,
    recovery_fee: u64,
    multisig_creation_fee: u64,  // One-time fee when creating a multisig
    multisig_monthly_fee: u64,   // Monthly fee per multisig owned by DAO
    verification_fees: Table<u8, u64>,
    // Pending updates with 6-month delay
    pending_monthly_fee: Option<u64>,
    pending_creation_fee: Option<u64>,
    pending_proposal_fee: Option<u64>,
    pending_recovery_fee: Option<u64>,
    pending_multisig_creation_fee: Option<u64>,
    pending_multisig_monthly_fee: Option<u64>,
    pending_fees_effective_timestamp: Option<u64>,
    // 10x cap tracking - baseline fees that reset every 6 months
    monthly_fee_baseline: u64,
    creation_fee_baseline: u64,
    proposal_fee_baseline: u64,
    recovery_fee_baseline: u64,
    multisig_creation_fee_baseline: u64,
    multisig_monthly_fee_baseline: u64,
    baseline_reset_timestamp: u64,
}

/// Tracks fee collection history for each DAO
public struct DaoFeeRecord has store {
    last_collection_timestamp: u64,
    total_collected: u64,
    last_fee_rate: u64,  // Fee rate at last collection to prevent retroactive increases
}


// === Events ===
public struct FeesWithdrawn has copy, drop {
    amount: u64,
    recipient: address,
    timestamp: u64,
}

public struct DAOCreationFeeUpdated has copy, drop {
    old_fee: u64,
    new_fee: u64,
    admin: address,
    timestamp: u64,
}

public struct ProposalCreationFeeUpdated has copy, drop {
    old_fee: u64,
    new_fee_per_outcome: u64,
    admin: address,
    timestamp: u64,
}

public struct VerificationFeeUpdated has copy, drop {
    level: u8,
    old_fee: u64,
    new_fee: u64,
    admin: address,
    timestamp: u64,
}

public struct VerificationLevelAdded has copy, drop {
    level: u8,
    fee: u64,
    admin: address,
    timestamp: u64,
}

public struct VerificationLevelRemoved has copy, drop {
    level: u8,
    admin: address,
    timestamp: u64,
}

public struct DAOCreationFeeCollected has copy, drop {
    amount: u64,
    payer: address,
    timestamp: u64,
}

public struct ProposalCreationFeeCollected has copy, drop {
    amount: u64,
    payer: address,
    timestamp: u64,
}

public struct LaunchpadCreationFeeCollected has copy, drop {
    amount: u64,
    payer: address,
    timestamp: u64,
}

public struct VerificationFeeCollected has copy, drop {
    level: u8,
    amount: u64,
    payer: address,
    timestamp: u64,
}

public struct StableFeesCollected has copy, drop {
    amount: u64,
    stable_type: AsciiString,
    proposal_id: ID,
    timestamp: u64,
}

public struct StableFeesWithdrawn has copy, drop {
    amount: u64,
    stable_type: AsciiString,
    recipient: address,
    timestamp: u64,
}

public struct DaoMonthlyFeeUpdated has copy, drop {
    old_fee: u64,
    new_fee: u64,
    admin: address,
    timestamp: u64,
}

public struct DaoMonthlyFeePending has copy, drop {
    current_fee: u64,
    pending_fee: u64,
    effective_timestamp: u64,
    admin: address,
    timestamp: u64,
}

public struct DaoPlatformFeeCollected has copy, drop {
    dao_id: ID,
    amount: u64,
    stable_type: AsciiString,
    collector: address,
    timestamp: u64,
}

public struct RecoveryFeeUpdated has copy, drop {
    old_fee: u64,
    new_fee: u64,
    admin: address,
    timestamp: u64,
}

public struct RecoveryRequested has copy, drop {
    dao_id: ID,
    council_id: ID,
    fee: u64,
    requester: address,
    timestamp: u64,
}

public struct RecoveryExecuted has copy, drop {
    dao_id: ID,
    new_council_id: ID,
    timestamp: u64,
}

public struct MultisigCreationFeeCollected has copy, drop {
    dao_id: ID,
    multisig_id: ID,
    amount: u64,
    stable_type: AsciiString,
    payer: address,
    timestamp: u64,
}


// === Public Functions ===
fun init(witness: FEE, ctx: &mut TxContext) {
    // Verify that the witness is valid and one-time only.
    assert!(sui::types::is_one_time_witness(&witness), EBadWitness);

    let fee_admin_cap = FeeAdminCap {
        id: object::new(ctx),
    };
    
    let mut verification_fees = table::new<u8, u64>(ctx);
    // Start with just level 1 by default
    table::add(&mut verification_fees, 1, DEFAULT_VERIFICATION_FEE);
    
    let fee_manager = FeeManager {
        id: object::new(ctx),
        admin_cap_id: object::id(&fee_admin_cap),
        dao_creation_fee: DEFAULT_DAO_CREATION_FEE,
        proposal_creation_fee_per_outcome: DEFAULT_PROPOSAL_CREATION_FEE_PER_OUTCOME,
        verification_fees,
        dao_monthly_fee: 10_000_000, // e.g. 10 of a 6-decimal stable coin
        pending_dao_monthly_fee: option::none(),
        pending_fee_effective_timestamp: option::none(),
        sui_balance: balance::zero<SUI>(),
        recovery_fee: 5_000_000_000, // 5 SUI default (~$5k equivalent)
        launchpad_creation_fee: DEFAULT_LAUNCHPAD_CREATION_FEE,
    };

    public_share_object(fee_manager);
    public_transfer(fee_admin_cap, ctx.sender());

    // Consuming the witness ensures one-time initialization.
    let _ = witness;
}

// === Package Functions ===
// Generic internal fee collection function
fun deposit_payment(fee_manager: &mut FeeManager, fee_amount: u64, payment: Coin<SUI>): u64 {
    // Verify payment
    let payment_amount = payment.value();
    assert!(payment_amount == fee_amount, EInvalidPayment);

    // Process payment
    let paid_balance = payment.into_balance();
    fee_manager.sui_balance.join(paid_balance);
    return payment_amount
    // Event emission will be handled by specific wrappers
}

// Function to collect DAO creation fee
public fun deposit_dao_creation_payment(
    fee_manager: &mut FeeManager,
    payment: Coin<SUI>,
    clock: &Clock,
    ctx: &TxContext,
) {
    let fee_amount = fee_manager.dao_creation_fee;

    let payment_amount = deposit_payment(fee_manager, fee_amount, payment);

    // Emit event
    event::emit(DAOCreationFeeCollected {
        amount: payment_amount,
        payer: ctx.sender(),
        timestamp: clock.timestamp_ms(),
    });
}

// Function to collect launchpad creation fee
public fun deposit_launchpad_creation_payment(
    fee_manager: &mut FeeManager,
    payment: Coin<SUI>,
    clock: &Clock,
    ctx: &TxContext,
) {
    let fee_amount = fee_manager.launchpad_creation_fee;

    let payment_amount = deposit_payment(fee_manager, fee_amount, payment);

    // Emit event
    event::emit(LaunchpadCreationFeeCollected {
        amount: payment_amount,
        payer: ctx.sender(),
        timestamp: clock.timestamp_ms(),
    });
}


// Function to collect proposal creation fee
public fun deposit_proposal_creation_payment(
    fee_manager: &mut FeeManager,
    payment: Coin<SUI>,
    outcome_count: u64,
    clock: &Clock,
    ctx: &TxContext,
) {
    // Use u128 arithmetic to prevent overflow
    let fee_amount_u128 = (fee_manager.proposal_creation_fee_per_outcome as u128) * (outcome_count as u128);
    
    // Check that result fits in u64
    assert!(fee_amount_u128 <= (u64::max_value!() as u128), EArithmeticOverflow); // u64::max_value()
    let fee_amount = (fee_amount_u128 as u64);

    // deposit_payment asserts the payment amount is exactly the fee_amount
    let payment_amount = deposit_payment(fee_manager, fee_amount, payment);

    // Emit event
    event::emit(ProposalCreationFeeCollected {
        amount: payment_amount,
        payer: ctx.sender(),
        timestamp: clock.timestamp_ms(),
    });
}


// Function to collect recovery fee for dead-man switch
public fun deposit_recovery_payment(
    fee_manager: &mut FeeManager,
    dao_id: ID,
    council_id: ID,
    payment: Coin<SUI>,
    clock: &Clock,
    ctx: &TxContext,
) {
    let fee_due = fee_manager.recovery_fee;
    assert!(payment.value() == fee_due, EInvalidPayment);
    let bal = payment.into_balance();
    fee_manager.sui_balance.join(bal);
    event::emit(RecoveryRequested {
        dao_id,
        council_id,
        fee: fee_due,
        requester: ctx.sender(),
        timestamp: clock.timestamp_ms(),
    });
}

// Function to collect verification fee for a specific level
public fun deposit_verification_payment(
    fee_manager: &mut FeeManager,
    payment: Coin<SUI>,
    verification_level: u8,
    clock: &Clock,
    ctx: &TxContext,
) {
    assert!(table::contains(&fee_manager.verification_fees, verification_level), EInvalidPayment);
    let fee_amount = *table::borrow(&fee_manager.verification_fees, verification_level);
    let payment_amount = deposit_payment(fee_manager, fee_amount, payment);

    // Emit event
    event::emit(VerificationFeeCollected {
        level: verification_level,
        amount: payment_amount,
        payer: ctx.sender(),
        timestamp: clock.timestamp_ms(),
    });
}

// === Admin Functions ===
// Admin function to withdraw fees
public entry fun withdraw_all_fees(
    fee_manager: &mut FeeManager,
    admin_cap: &FeeAdminCap,
    clock: &Clock,
    ctx: &mut TxContext,
) {
    // Verify the admin cap belongs to this fee manager
    assert!(object::id(admin_cap) == fee_manager.admin_cap_id, EInvalidAdminCap);
    let amount = fee_manager.sui_balance.value();
    let sender = ctx.sender();

    let withdrawal = fee_manager.sui_balance.split(amount).into_coin(ctx);

    event::emit(FeesWithdrawn {
        amount,
        recipient: sender,
        timestamp: clock.timestamp_ms(),
    });

    public_transfer(withdrawal, sender);
}

// Admin function to update DAO creation fee
public entry fun update_dao_creation_fee(
    fee_manager: &mut FeeManager,
    admin_cap: &FeeAdminCap,
    new_fee: u64,
    clock: &Clock,
    ctx: &mut TxContext,
) {
    assert!(object::id(admin_cap) == fee_manager.admin_cap_id, EInvalidAdminCap);
    let old_fee = fee_manager.dao_creation_fee;
    fee_manager.dao_creation_fee = new_fee;

    event::emit(DAOCreationFeeUpdated {
        old_fee,
        new_fee,
        admin: ctx.sender(),
        timestamp: clock.timestamp_ms(),
    });
}

// Admin function to update proposal creation fee
public entry fun update_proposal_creation_fee(
    fee_manager: &mut FeeManager,
    admin_cap: &FeeAdminCap,
    new_fee_per_outcome: u64,
    clock: &Clock,
    ctx: &mut TxContext,
) {
    assert!(object::id(admin_cap) == fee_manager.admin_cap_id, EInvalidAdminCap);
    let old_fee = fee_manager.proposal_creation_fee_per_outcome;
    fee_manager.proposal_creation_fee_per_outcome = new_fee_per_outcome;

    event::emit(ProposalCreationFeeUpdated {
        old_fee,
        new_fee_per_outcome,
        admin: ctx.sender(),
        timestamp: clock.timestamp_ms(),
    });
}

// Admin function to add a new verification level
public entry fun add_verification_level(
    fee_manager: &mut FeeManager,
    admin_cap: &FeeAdminCap,
    level: u8,
    fee: u64,
    clock: &Clock,
    ctx: &mut TxContext,
) {
    assert!(object::id(admin_cap) == fee_manager.admin_cap_id, EInvalidAdminCap);
    assert!(!table::contains(&fee_manager.verification_fees, level), EInvalidPayment);
    
    table::add(&mut fee_manager.verification_fees, level, fee);
    
    event::emit(VerificationLevelAdded {
        level,
        fee,
        admin: ctx.sender(),
        timestamp: clock.timestamp_ms(),
    });
}

// Admin function to remove a verification level
public entry fun remove_verification_level(
    fee_manager: &mut FeeManager,
    admin_cap: &FeeAdminCap,
    level: u8,
    clock: &Clock,
    ctx: &mut TxContext,
) {
    assert!(object::id(admin_cap) == fee_manager.admin_cap_id, EInvalidAdminCap);
    assert!(table::contains(&fee_manager.verification_fees, level), EInvalidPayment);
    
    table::remove(&mut fee_manager.verification_fees, level);
    
    event::emit(VerificationLevelRemoved {
        level,
        admin: ctx.sender(),
        timestamp: clock.timestamp_ms(),
    });
}

// Admin function to update verification fee for a specific level
public entry fun update_verification_fee(
    fee_manager: &mut FeeManager,
    admin_cap: &FeeAdminCap,
    level: u8,
    new_fee: u64,
    clock: &Clock,
    ctx: &mut TxContext,
) {
    assert!(object::id(admin_cap) == fee_manager.admin_cap_id, EInvalidAdminCap);
    assert!(table::contains(&fee_manager.verification_fees, level), EInvalidPayment);
    
    let old_fee = *table::borrow(&fee_manager.verification_fees, level);
    *table::borrow_mut(&mut fee_manager.verification_fees, level) = new_fee;

    event::emit(VerificationFeeUpdated {
        level,
        old_fee,
        new_fee,
        admin: ctx.sender(),
        timestamp: clock.timestamp_ms(),
    });
}

// Admin function to update recovery fee
public entry fun update_recovery_fee(
    fee_manager: &mut FeeManager,
    admin_cap: &FeeAdminCap,
    new_fee: u64,
    clock: &Clock,
    ctx: &TxContext,
) {
    assert!(object::id(admin_cap) == fee_manager.admin_cap_id, EInvalidAdminCap);
    let old_fee = fee_manager.recovery_fee;
    fee_manager.recovery_fee = new_fee;
    event::emit(RecoveryFeeUpdated {
        old_fee,
        new_fee,
        admin: ctx.sender(),
        timestamp: clock.timestamp_ms(),
    });
}

// View function for recovery fee
public fun get_recovery_fee(fee_manager: &FeeManager): u64 {
    fee_manager.recovery_fee
}

// Function removed to avoid circular dependency with treasury module
// This functionality should be moved to a separate module

/// Collect platform fee from a DAO's vault with 3-month retroactive limit
/// IMPORTANT: Uses the fee rate from when periods were incurred, not current rate
public fun collect_dao_platform_fee<StableType: drop>(
    fee_manager: &mut FeeManager,
    dao_id: ID,
    clock: &Clock,
    ctx: &mut TxContext,
): (u64, u64) { // Returns (fee_amount, periods_collected)
    let current_time = clock.timestamp_ms();
    
    // Apply pending fee if due (before we calculate anything)
    apply_pending_fee_if_due(fee_manager, clock);
    
    // Get current fee rate
    let current_fee_rate = fee_manager.dao_monthly_fee;
    
    // Get or create fee record for this DAO
    let record_key = dao_id;
    let (last_collection, last_rate, is_new) = if (dynamic_field::exists_(&fee_manager.id, record_key)) {
        let record: &DaoFeeRecord = dynamic_field::borrow(&fee_manager.id, record_key);
        (record.last_collection_timestamp, record.last_fee_rate, false)
    } else {
        // First time collecting from this DAO - initialize with current rate
        let new_record = DaoFeeRecord {
            last_collection_timestamp: current_time,
            total_collected: 0,
            last_fee_rate: current_fee_rate,
        };
        dynamic_field::add(&mut fee_manager.id, record_key, new_record);
        return (0, 0) // No retroactive fees on first collection
    };
    
    // Calculate how many periods we can collect
    let time_since_last = if (current_time > last_collection) {
        current_time - last_collection
    } else {
        0
    };
    
    // Cap at 3 months max
    let collectible_time = if (time_since_last > MAX_FEE_COLLECTION_PERIOD_MS) {
        MAX_FEE_COLLECTION_PERIOD_MS
    } else {
        time_since_last
    };
    
    // Calculate number of monthly periods to collect
    let periods_to_collect = collectible_time / MONTHLY_FEE_PERIOD_MS;
    
    if (periods_to_collect == 0) {
        return (0, 0)
    };
    
    // CRITICAL: Use the LOWER of last rate or current rate to prevent retroactive increases
    // DAOs benefit from fee decreases immediately but are protected from increases
    let fee_per_period = if (last_rate < current_fee_rate) {
        last_rate  // Protect DAO from retroactive fee increases
    } else {
        current_fee_rate  // Allow DAO to benefit from fee decreases
    };

    // Use u128 arithmetic to prevent overflow
    let total_fee_u128 = (fee_per_period as u128) * (periods_to_collect as u128);
    assert!(total_fee_u128 <= (u64::max_value!() as u128), EArithmeticOverflow);
    let total_fee = (total_fee_u128 as u64);
    
    // Update the record with new timestamp and current rate for future collections
    let record: &mut DaoFeeRecord = dynamic_field::borrow_mut(&mut fee_manager.id, record_key);
    record.last_collection_timestamp = current_time;
    record.total_collected = record.total_collected + total_fee;
    record.last_fee_rate = current_fee_rate;  // Store current rate for next time
    
    (total_fee, periods_to_collect)
}

/// Collect platform fee from DAO vault using DAO's own stablecoin
/// If the DAO doesn't have sufficient funds, debt is accumulated and DAO is blocked
/// If payment succeeds, resets ALL other coin debt for this DAO (forgiveness)
public fun collect_dao_platform_fee_with_dao_coin<StableType>(
    fee_manager: &mut FeeManager,
    payment_tracker: &mut DaoPaymentTracker,
    dao_id: ID,
    coin_type: TypeName,
    all_coin_types: vector<TypeName>,  // All coins to reset on success
    mut available_funds: Coin<StableType>,
    clock: &Clock,
    ctx: &mut TxContext,
): (Coin<StableType>, u64) { // Returns (remaining_funds, periods_collected)
    // CRITICAL: Verify type safety - ensure StableType matches the coin_type parameter
    assert!(
        type_name::get<StableType>() == coin_type,
        EWrongStableCoinType
    );
    
    // Apply any pending fee updates for this coin type
    apply_pending_coin_fees(fee_manager, coin_type, clock);
    
    // Get fee amount for this specific coin type
    let fee_amount = if (dynamic_field::exists_(&fee_manager.id, coin_type)) {
        let config: &CoinFeeConfig = dynamic_field::borrow(&fee_manager.id, coin_type);
        config.dao_monthly_fee
    } else {
        // Fallback to default fee if coin not configured
        fee_manager.dao_monthly_fee
    };
    
    // Calculate periods to collect
    let current_time = clock.timestamp_ms();
    let record_key = dao_id;
    
    // Get or create fee record
    let periods_to_collect = if (dynamic_field::exists_(&fee_manager.id, record_key)) {
        let record: &DaoFeeRecord = dynamic_field::borrow(&fee_manager.id, record_key);
        let time_since_last = if (current_time > record.last_collection_timestamp) {
            current_time - record.last_collection_timestamp
        } else {
            0
        };
        
        // Cap at 3 months max
        let collectible_time = if (time_since_last > MAX_FEE_COLLECTION_PERIOD_MS) {
            MAX_FEE_COLLECTION_PERIOD_MS
        } else {
            time_since_last
        };
        
        collectible_time / MONTHLY_FEE_PERIOD_MS
    } else {
        // First time - create record but don't collect
        let new_record = DaoFeeRecord {
            last_collection_timestamp: current_time,
            total_collected: 0,
            last_fee_rate: fee_amount,
        };
        dynamic_field::add(&mut fee_manager.id, record_key, new_record);
        0
    };
    
    if (periods_to_collect == 0 || fee_amount == 0) {
        // No fee due, return all funds
        return (available_funds, 0)
    };

    // Use u128 arithmetic to prevent overflow
    let total_fee_u128 = (fee_amount as u128) * (periods_to_collect as u128);
    assert!(total_fee_u128 <= (u64::max_value!() as u128), EArithmeticOverflow);
    let total_fee = (total_fee_u128 as u64);
    
    // Update the record
    let record: &mut DaoFeeRecord = dynamic_field::borrow_mut(&mut fee_manager.id, record_key);
    record.last_collection_timestamp = current_time;
    record.total_collected = record.total_collected + total_fee;
    record.last_fee_rate = fee_amount;
    
    // Check if DAO has enough funds
    let available_amount = available_funds.value();
    if (available_amount >= total_fee) {
        // PAYMENT SUCCESS - Full payment available
        let fee_coin = available_funds.split(total_fee, ctx);

        // Deposit the fee
        deposit_stable_fees(fee_manager, fee_coin.into_balance(), dao_id, clock);

        // CRITICAL: Reset ALL other coin payment timestamps (forgiveness mechanism)
        reset_dao_coin_debts(fee_manager, dao_id, all_coin_types, current_time);

        (available_funds, periods_to_collect)
    } else {
        // Insufficient funds - take what's available and accumulate debt
        let debt_amount = total_fee - available_amount;
        
        // Accumulate debt in the payment tracker
        dao_payment_tracker::accumulate_debt(payment_tracker, dao_id, debt_amount);
        
        // Take all available funds as partial payment
        if (available_amount > 0) {
            deposit_stable_fees(fee_manager, available_funds.into_balance(), dao_id, clock);
            // Return empty coin since all funds were taken
            (coin::zero<StableType>(ctx), periods_to_collect)
        } else {
            // No funds available, destroy the zero coin and return a new zero coin
            available_funds.destroy_zero();
            (coin::zero<StableType>(ctx), periods_to_collect)
        }
    }
}

public fun deposit_dao_platform_fee<StableType: drop>(
    fee_manager: &mut FeeManager,
    fee_coin: Coin<StableType>,
    dao_id: ID,
    clock: &Clock,
    ctx: &mut TxContext,
) {
    let amount = fee_coin.value();
    let stable_type_str = type_name::with_defining_ids<StableType>().into_string();
    
    deposit_stable_fees(fee_manager, fee_coin.into_balance(), dao_id, clock);
    
    // Emit platform fee collection event
    event::emit(DaoPlatformFeeCollected {
        dao_id,
        amount,
        stable_type: stable_type_str,
        collector: ctx.sender(),
        timestamp: clock.timestamp_ms(),
    });
}

/// Collect DAO platform fee with admin-approved discount
/// Admin can collect any amount between 0 and the full fee owed
public fun collect_dao_platform_fee_with_discount<StableType: drop>(
    fee_manager: &mut FeeManager,
    admin_cap: &FeeAdminCap,
    dao_id: ID,
    discount_amount: u64, // Amount to discount from the full fee
    clock: &Clock,
    ctx: &mut TxContext,
): (u64, u64) { // Returns (actual_fee_charged, periods_collected)
    // Verify admin cap
    assert!(fee_manager.admin_cap_id == object::id(admin_cap), EInvalidAdminCap);
    
    // Calculate the full fee owed
    let (full_fee, periods) = collect_dao_platform_fee<StableType>(fee_manager, dao_id, clock, ctx);
    
    // Apply discount (ensure we don't go negative)
    let actual_fee = if (discount_amount >= full_fee) {
        0 // Full discount (free)
    } else {
        full_fee - discount_amount
    };
    
    (actual_fee, periods)
}

public entry fun update_dao_monthly_fee(
    fee_manager: &mut FeeManager,
    admin_cap: &FeeAdminCap,
    new_fee: u64,
    clock: &Clock,
    ctx: &mut TxContext,
) {
    assert!(object::id(admin_cap) == fee_manager.admin_cap_id, EInvalidAdminCap);
    
    // V2 Hard cap enforcement - prevents excessive fees while protocol matures
    assert!(new_fee <= ABSOLUTE_MAX_MONTHLY_FEE, EFeeExceedsHardCap);
    
    let current_fee = fee_manager.dao_monthly_fee;
    let effective_timestamp = clock.timestamp_ms() + FEE_UPDATE_DELAY_MS;
    
    // Set the pending fee
    fee_manager.pending_dao_monthly_fee = option::some(new_fee);
    fee_manager.pending_fee_effective_timestamp = option::some(effective_timestamp);

    event::emit(DaoMonthlyFeePending {
        current_fee,
        pending_fee: new_fee,
        effective_timestamp,
        admin: ctx.sender(),
        timestamp: clock.timestamp_ms(),
    });
}

/// Apply pending fee if the delay period has passed
public fun apply_pending_fee_if_due(
    fee_manager: &mut FeeManager,
    clock: &Clock,
) {
    if (fee_manager.pending_dao_monthly_fee.is_some() && 
        fee_manager.pending_fee_effective_timestamp.is_some()) {
        
        let effective_timestamp = *fee_manager.pending_fee_effective_timestamp.borrow();
        
        if (clock.timestamp_ms() >= effective_timestamp) {
            let old_fee = fee_manager.dao_monthly_fee;
            let new_fee = *fee_manager.pending_dao_monthly_fee.borrow();
            
            // Apply the pending fee
            fee_manager.dao_monthly_fee = new_fee;
            
            // Clear pending fee data
            fee_manager.pending_dao_monthly_fee = option::none();
            fee_manager.pending_fee_effective_timestamp = option::none();
            
            event::emit(DaoMonthlyFeeUpdated {
                old_fee,
                new_fee,
                admin: @0x0, // System update, no specific admin
                timestamp: clock.timestamp_ms(),
            });
        }
    }
}

// === AMM Fees ===

// Structure to store stable coin balance information
public struct StableCoinBalance<phantom T> has store {
    balance: Balance<T>,
}

public struct StableFeeRegistry<phantom T> has copy, drop, store {}

// Modified stable fees storage with more structure
public fun deposit_stable_fees<StableType>(
    fee_manager: &mut FeeManager,
    fees: Balance<StableType>,
    proposal_id: ID,
    clock: &Clock,
) {
    let amount = fees.value();

    if (
        dynamic_field::exists_with_type<
            StableFeeRegistry<StableType>,
            StableCoinBalance<StableType>,
        >(&fee_manager.id, StableFeeRegistry<StableType> {})
    ) {
        let fee_balance_wrapper = dynamic_field::borrow_mut<
            StableFeeRegistry<StableType>,
            StableCoinBalance<StableType>,
        >(&mut fee_manager.id, StableFeeRegistry<StableType> {});
        fee_balance_wrapper.balance.join(fees);
    } else {
        let balance_wrapper = StableCoinBalance<StableType> {
            balance: fees,
        };
        dynamic_field::add(&mut fee_manager.id, StableFeeRegistry<StableType> {}, balance_wrapper);
    };

    let type_name = type_name::with_defining_ids<StableType>();
    let type_str = type_name.into_string();
    // Emit collection event
    event::emit(StableFeesCollected {
        amount,
        stable_type: type_str,
        proposal_id,
        timestamp: clock.timestamp_ms(),
    });
}

public entry fun withdraw_stable_fees<StableType>(
    fee_manager: &mut FeeManager,
    admin_cap: &FeeAdminCap,
    clock: &Clock,
    ctx: &mut TxContext,
) {
    // Verify the admin cap belongs to this fee manager
    assert!(object::id(admin_cap) == fee_manager.admin_cap_id, EInvalidAdminCap);
    
    // Check if the stable type exists in the registry
    if (!dynamic_field::exists_with_type<
            StableFeeRegistry<StableType>,
            StableCoinBalance<StableType>,
        >(
            &fee_manager.id,
            StableFeeRegistry<StableType> {},
        )
    ) {
        // No fees of this type have been collected, nothing to withdraw
        return
    };

    let fee_balance_wrapper = dynamic_field::borrow_mut<
        StableFeeRegistry<StableType>,
        StableCoinBalance<StableType>,
    >(&mut fee_manager.id, StableFeeRegistry<StableType> {});
    let amount = fee_balance_wrapper.balance.value();

    if (amount > 0) {
        let withdrawn = fee_balance_wrapper.balance.split(amount);
        let coin = withdrawn.into_coin(ctx);

        let type_name = type_name::with_defining_ids<StableType>();
        let type_str = type_name.into_string();
        // Emit withdrawal event
        event::emit(StableFeesWithdrawn {
            amount,
            stable_type: type_str,
            recipient: ctx.sender(),
            timestamp: clock.timestamp_ms(),
        });

        // Transfer to sender
        public_transfer(coin, ctx.sender());
    }
}

// === View Functions ===
public fun get_dao_creation_fee(fee_manager: &FeeManager): u64 {
    fee_manager.dao_creation_fee
}

public fun get_proposal_creation_fee_per_outcome(fee_manager: &FeeManager): u64 {
    fee_manager.proposal_creation_fee_per_outcome
}

public fun get_launchpad_creation_fee(fee_manager: &FeeManager): u64 {
    fee_manager.launchpad_creation_fee
}

public fun get_verification_fee_for_level(fee_manager: &FeeManager, level: u8): u64 {
    assert!(table::contains(&fee_manager.verification_fees, level), EInvalidPayment);
    *table::borrow(&fee_manager.verification_fees, level)
}

public fun has_verification_level(fee_manager: &FeeManager, level: u8): bool {
    table::contains(&fee_manager.verification_fees, level)
}

public fun get_dao_monthly_fee(fee_manager: &FeeManager): u64 {
    fee_manager.dao_monthly_fee
}

public fun get_pending_dao_monthly_fee(fee_manager: &FeeManager): Option<u64> {
    fee_manager.pending_dao_monthly_fee
}

public fun get_pending_fee_effective_timestamp(fee_manager: &FeeManager): Option<u64> {
    fee_manager.pending_fee_effective_timestamp
}

public fun get_sui_balance(fee_manager: &FeeManager): u64 {
    fee_manager.sui_balance.value()
}

public fun get_stable_fee_balance<StableType>(fee_manager: &FeeManager): u64 {
    if (
        dynamic_field::exists_with_type<
            StableFeeRegistry<StableType>,
            StableCoinBalance<StableType>,
        >(&fee_manager.id, StableFeeRegistry<StableType> {})
    ) {
        let balance_wrapper = dynamic_field::borrow<
            StableFeeRegistry<StableType>,
            StableCoinBalance<StableType>,
        >(&fee_manager.id, StableFeeRegistry<StableType> {});
        balance_wrapper.balance.value()
    } else {
        0
    }
}

/// Get the hard cap for monthly fees (V2 safety limit)
public fun get_max_monthly_fee_cap(): u64 {
    ABSOLUTE_MAX_MONTHLY_FEE
}

// === Coin-specific Fee Management ===

/// Add a new coin type with its fee configuration
public fun add_coin_fee_config(
    fee_manager: &mut FeeManager,
    admin_cap: &FeeAdminCap,
    coin_type: TypeName,
    decimals: u8,
    dao_monthly_fee: u64,
    dao_creation_fee: u64,
    proposal_fee_per_outcome: u64,
    recovery_fee: u64,
    multisig_creation_fee: u64,
    multisig_monthly_fee: u64,
    clock: &Clock,
    ctx: &mut TxContext,
) {
    assert!(object::id(admin_cap) == fee_manager.admin_cap_id, EInvalidAdminCap);

    // Create verification fees table
    let mut verification_fees = table::new<u8, u64>(ctx);
    // Add default verification levels
    table::add(&mut verification_fees, 1, DEFAULT_VERIFICATION_FEE);

    let config = CoinFeeConfig {
        coin_type,
        decimals,
        dao_monthly_fee,
        dao_creation_fee,
        proposal_creation_fee_per_outcome: proposal_fee_per_outcome,
        recovery_fee,
        multisig_creation_fee,
        multisig_monthly_fee,
        verification_fees,
        pending_monthly_fee: option::none(),
        pending_creation_fee: option::none(),
        pending_proposal_fee: option::none(),
        pending_recovery_fee: option::none(),
        pending_multisig_creation_fee: option::none(),
        pending_multisig_monthly_fee: option::none(),
        pending_fees_effective_timestamp: option::none(),
        // Initialize baselines to current fees
        monthly_fee_baseline: dao_monthly_fee,
        creation_fee_baseline: dao_creation_fee,
        proposal_fee_baseline: proposal_fee_per_outcome,
        recovery_fee_baseline: recovery_fee,
        multisig_creation_fee_baseline: multisig_creation_fee,
        multisig_monthly_fee_baseline: multisig_monthly_fee,
        baseline_reset_timestamp: clock.timestamp_ms(),
    };

    // Store using coin type as key
    dynamic_field::add(&mut fee_manager.id, coin_type, config);
}

/// Update monthly fee for a specific coin type (with 6-month delay and 10x cap)
public fun update_coin_monthly_fee(
    fee_manager: &mut FeeManager,
    admin_cap: &FeeAdminCap,
    coin_type: TypeName,
    new_fee: u64,
    clock: &Clock,
    ctx: &mut TxContext,
) {
    assert!(object::id(admin_cap) == fee_manager.admin_cap_id, EInvalidAdminCap);
    assert!(dynamic_field::exists_(&fee_manager.id, coin_type), EStableTypeNotFound);
    
    let config: &mut CoinFeeConfig = dynamic_field::borrow_mut(&mut fee_manager.id, coin_type);
    let current_time = clock.timestamp_ms();
    
    // Check if 6 months have passed since baseline was set - if so, reset baseline
    if (current_time >= config.baseline_reset_timestamp + FEE_BASELINE_RESET_PERIOD_MS) {
        config.monthly_fee_baseline = config.dao_monthly_fee;
        config.baseline_reset_timestamp = current_time;
    };
    
    // Enforce 10x cap from baseline
    assert!(
        new_fee <= config.monthly_fee_baseline * MAX_FEE_MULTIPLIER,
        EFeeExceedsTenXCap
    );
    
    // Allow immediate decrease, delayed increase
    if (new_fee <= config.dao_monthly_fee) {
        // Fee decrease - apply immediately
        config.dao_monthly_fee = new_fee;
    } else {
        // Fee increase - apply after delay
        let effective_timestamp = current_time + FEE_UPDATE_DELAY_MS;
        config.pending_monthly_fee = option::some(new_fee);
        config.pending_fees_effective_timestamp = option::some(effective_timestamp);
    };
}

/// Update creation fee for a specific coin type (with 6-month delay and 10x cap)
public fun update_coin_creation_fee(
    fee_manager: &mut FeeManager,
    admin_cap: &FeeAdminCap,
    coin_type: TypeName,
    new_fee: u64,
    clock: &Clock,
    ctx: &mut TxContext,
) {
    assert!(object::id(admin_cap) == fee_manager.admin_cap_id, EInvalidAdminCap);
    assert!(dynamic_field::exists_(&fee_manager.id, coin_type), EStableTypeNotFound);
    
    let config: &mut CoinFeeConfig = dynamic_field::borrow_mut(&mut fee_manager.id, coin_type);
    let current_time = clock.timestamp_ms();
    
    // Check if 6 months have passed since baseline was set - if so, reset baseline
    if (current_time >= config.baseline_reset_timestamp + FEE_BASELINE_RESET_PERIOD_MS) {
        config.creation_fee_baseline = config.dao_creation_fee;
        config.baseline_reset_timestamp = current_time;
    };
    
    // Enforce 10x cap from baseline
    assert!(
        new_fee <= config.creation_fee_baseline * MAX_FEE_MULTIPLIER,
        EFeeExceedsTenXCap
    );
    
    // Allow immediate decrease, delayed increase
    if (new_fee <= config.dao_creation_fee) {
        // Fee decrease - apply immediately
        config.dao_creation_fee = new_fee;
    } else {
        // Fee increase - apply after delay
        let effective_timestamp = current_time + FEE_UPDATE_DELAY_MS;
        config.pending_creation_fee = option::some(new_fee);
        config.pending_fees_effective_timestamp = option::some(effective_timestamp);
    };
}

/// Update proposal fee for a specific coin type (with 6-month delay and 10x cap)
public fun update_coin_proposal_fee(
    fee_manager: &mut FeeManager,
    admin_cap: &FeeAdminCap,
    coin_type: TypeName,
    new_fee_per_outcome: u64,
    clock: &Clock,
    ctx: &mut TxContext,
) {
    assert!(object::id(admin_cap) == fee_manager.admin_cap_id, EInvalidAdminCap);
    assert!(dynamic_field::exists_(&fee_manager.id, coin_type), EStableTypeNotFound);
    
    let config: &mut CoinFeeConfig = dynamic_field::borrow_mut(&mut fee_manager.id, coin_type);
    let current_time = clock.timestamp_ms();
    
    // Check if 6 months have passed since baseline was set - if so, reset baseline
    if (current_time >= config.baseline_reset_timestamp + FEE_BASELINE_RESET_PERIOD_MS) {
        config.proposal_fee_baseline = config.proposal_creation_fee_per_outcome;
        config.baseline_reset_timestamp = current_time;
    };
    
    // Enforce 10x cap from baseline
    assert!(
        new_fee_per_outcome <= config.proposal_fee_baseline * MAX_FEE_MULTIPLIER,
        EFeeExceedsTenXCap
    );
    
    // Allow immediate decrease, delayed increase
    if (new_fee_per_outcome <= config.proposal_creation_fee_per_outcome) {
        // Fee decrease - apply immediately
        config.proposal_creation_fee_per_outcome = new_fee_per_outcome;
    } else {
        // Fee increase - apply after delay
        let effective_timestamp = current_time + FEE_UPDATE_DELAY_MS;
        config.pending_proposal_fee = option::some(new_fee_per_outcome);
        config.pending_fees_effective_timestamp = option::some(effective_timestamp);
    };
}

/// Update recovery fee for a specific coin type (with 6-month delay and 10x cap)
public fun update_coin_recovery_fee(
    fee_manager: &mut FeeManager,
    admin_cap: &FeeAdminCap,
    coin_type: TypeName,
    new_fee: u64,
    clock: &Clock,
    ctx: &mut TxContext,
) {
    assert!(object::id(admin_cap) == fee_manager.admin_cap_id, EInvalidAdminCap);
    assert!(dynamic_field::exists_(&fee_manager.id, coin_type), EStableTypeNotFound);
    
    let config: &mut CoinFeeConfig = dynamic_field::borrow_mut(&mut fee_manager.id, coin_type);
    let current_time = clock.timestamp_ms();
    
    // Check if 6 months have passed since baseline was set - if so, reset baseline
    if (current_time >= config.baseline_reset_timestamp + FEE_BASELINE_RESET_PERIOD_MS) {
        config.recovery_fee_baseline = config.recovery_fee;
        config.baseline_reset_timestamp = current_time;
    };
    
    // Enforce 10x cap from baseline
    assert!(
        new_fee <= config.recovery_fee_baseline * MAX_FEE_MULTIPLIER,
        EFeeExceedsTenXCap
    );
    
    // Allow immediate decrease, delayed increase
    if (new_fee <= config.recovery_fee) {
        // Fee decrease - apply immediately
        config.recovery_fee = new_fee;
    } else {
        // Fee increase - apply after delay
        let effective_timestamp = current_time + FEE_UPDATE_DELAY_MS;
        config.pending_recovery_fee = option::some(new_fee);
        config.pending_fees_effective_timestamp = option::some(effective_timestamp);
    };
}

/// Apply pending fee updates if the delay has passed
public fun apply_pending_coin_fees(
    fee_manager: &mut FeeManager,
    coin_type: TypeName,
    clock: &Clock,
) {
    if (!dynamic_field::exists_(&fee_manager.id, coin_type)) {
        return
    };

    let config: &mut CoinFeeConfig = dynamic_field::borrow_mut(&mut fee_manager.id, coin_type);

    if (config.pending_fees_effective_timestamp.is_some()) {
        let effective_time = *config.pending_fees_effective_timestamp.borrow();

        if (clock.timestamp_ms() >= effective_time) {
            // Apply all pending fees
            if (config.pending_monthly_fee.is_some()) {
                config.dao_monthly_fee = *config.pending_monthly_fee.borrow();
                config.pending_monthly_fee = option::none();
            };

            if (config.pending_creation_fee.is_some()) {
                config.dao_creation_fee = *config.pending_creation_fee.borrow();
                config.pending_creation_fee = option::none();
            };

            if (config.pending_proposal_fee.is_some()) {
                config.proposal_creation_fee_per_outcome = *config.pending_proposal_fee.borrow();
                config.pending_proposal_fee = option::none();
            };

            if (config.pending_recovery_fee.is_some()) {
                config.recovery_fee = *config.pending_recovery_fee.borrow();
                config.pending_recovery_fee = option::none();
            };

            if (config.pending_multisig_creation_fee.is_some()) {
                config.multisig_creation_fee = *config.pending_multisig_creation_fee.borrow();
                config.pending_multisig_creation_fee = option::none();
            };

            if (config.pending_multisig_monthly_fee.is_some()) {
                config.multisig_monthly_fee = *config.pending_multisig_monthly_fee.borrow();
                config.pending_multisig_monthly_fee = option::none();
            };

            config.pending_fees_effective_timestamp = option::none();
        }
    }
}

/// Get fee config for a specific coin type
public fun get_coin_fee_config(
    fee_manager: &FeeManager,
    coin_type: TypeName,
): &CoinFeeConfig {
    assert!(dynamic_field::exists_(&fee_manager.id, coin_type), EStableTypeNotFound);
    dynamic_field::borrow(&fee_manager.id, coin_type)
}

/// Get monthly fee for a specific coin type
public fun get_coin_monthly_fee(
    fee_manager: &FeeManager,
    coin_type: TypeName,
): u64 {
    get_coin_fee_config(fee_manager, coin_type).dao_monthly_fee
}

// === Multisig Fee Management ===

/// Update multisig creation fee for a specific coin type (with 6-month delay and 10x cap)
public fun update_coin_multisig_creation_fee(
    fee_manager: &mut FeeManager,
    admin_cap: &FeeAdminCap,
    coin_type: TypeName,
    new_fee: u64,
    clock: &Clock,
    ctx: &mut TxContext,
) {
    assert!(object::id(admin_cap) == fee_manager.admin_cap_id, EInvalidAdminCap);
    assert!(dynamic_field::exists_(&fee_manager.id, coin_type), EStableTypeNotFound);

    let config: &mut CoinFeeConfig = dynamic_field::borrow_mut(&mut fee_manager.id, coin_type);
    let current_time = clock.timestamp_ms();

    // Check if 6 months have passed since baseline was set - if so, reset baseline
    if (current_time >= config.baseline_reset_timestamp + FEE_BASELINE_RESET_PERIOD_MS) {
        config.multisig_creation_fee_baseline = config.multisig_creation_fee;
        config.baseline_reset_timestamp = current_time;
    };

    // Enforce 10x cap from baseline
    assert!(
        new_fee <= config.multisig_creation_fee_baseline * MAX_FEE_MULTIPLIER,
        EFeeExceedsTenXCap
    );

    // Allow immediate decrease, delayed increase
    if (new_fee <= config.multisig_creation_fee) {
        // Fee decrease - apply immediately
        config.multisig_creation_fee = new_fee;
    } else {
        // Fee increase - apply after delay
        let effective_timestamp = current_time + FEE_UPDATE_DELAY_MS;
        config.pending_multisig_creation_fee = option::some(new_fee);
        config.pending_fees_effective_timestamp = option::some(effective_timestamp);
    };
}

/// Update multisig monthly fee for a specific coin type (with 6-month delay and 10x cap)
public fun update_coin_multisig_monthly_fee(
    fee_manager: &mut FeeManager,
    admin_cap: &FeeAdminCap,
    coin_type: TypeName,
    new_fee: u64,
    clock: &Clock,
    ctx: &mut TxContext,
) {
    assert!(object::id(admin_cap) == fee_manager.admin_cap_id, EInvalidAdminCap);
    assert!(dynamic_field::exists_(&fee_manager.id, coin_type), EStableTypeNotFound);

    let config: &mut CoinFeeConfig = dynamic_field::borrow_mut(&mut fee_manager.id, coin_type);
    let current_time = clock.timestamp_ms();

    // Check if 6 months have passed since baseline was set - if so, reset baseline
    if (current_time >= config.baseline_reset_timestamp + FEE_BASELINE_RESET_PERIOD_MS) {
        config.multisig_monthly_fee_baseline = config.multisig_monthly_fee;
        config.baseline_reset_timestamp = current_time;
    };

    // Enforce 10x cap from baseline
    assert!(
        new_fee <= config.multisig_monthly_fee_baseline * MAX_FEE_MULTIPLIER,
        EFeeExceedsTenXCap
    );

    // Allow immediate decrease, delayed increase
    if (new_fee <= config.multisig_monthly_fee) {
        // Fee decrease - apply immediately
        config.multisig_monthly_fee = new_fee;
    } else {
        // Fee increase - apply after delay
        let effective_timestamp = current_time + FEE_UPDATE_DELAY_MS;
        config.pending_multisig_monthly_fee = option::some(new_fee);
        config.pending_fees_effective_timestamp = option::some(effective_timestamp);
    };
}

/// Get multisig creation fee for a specific coin type
public fun get_coin_multisig_creation_fee(
    fee_manager: &FeeManager,
    coin_type: TypeName,
): u64 {
    get_coin_fee_config(fee_manager, coin_type).multisig_creation_fee
}

/// Get multisig monthly fee for a specific coin type
public fun get_coin_multisig_monthly_fee(
    fee_manager: &FeeManager,
    coin_type: TypeName,
): u64 {
    get_coin_fee_config(fee_manager, coin_type).multisig_monthly_fee
}

// === Multisig Fee Collection ===

/// Collect one-time multisig creation fee
public fun collect_multisig_creation_fee<StableType>(
    fee_manager: &mut FeeManager,
    dao_id: ID,
    multisig_id: ID,
    coin_type: TypeName,
    mut payment: Coin<StableType>,
    clock: &Clock,
    ctx: &mut TxContext,
): Coin<StableType> {
    // CRITICAL: Verify type safety
    assert!(
        type_name::get<StableType>() == coin_type,
        EWrongStableCoinType
    );

    // Apply any pending fee updates
    apply_pending_coin_fees(fee_manager, coin_type, clock);

    // Get fee amount for this coin type
    let fee_amount = if (dynamic_field::exists_(&fee_manager.id, coin_type)) {
        let config: &CoinFeeConfig = dynamic_field::borrow(&fee_manager.id, coin_type);
        config.multisig_creation_fee
    } else {
        // Fallback to 0 if coin not configured (no fee)
        0
    };

    if (fee_amount == 0) {
        return payment
    };

    // Check payment amount
    let payment_amount = payment.value();
    assert!(payment_amount >= fee_amount, EInvalidPayment);

    // Split fee from payment
    let fee_coin = payment.split(fee_amount, ctx);

    // Deposit fee
    deposit_stable_fees(fee_manager, fee_coin.into_balance(), dao_id, clock);

    // Emit event
    let stable_type_str = type_name::with_defining_ids<StableType>().into_string();
    event::emit(MultisigCreationFeeCollected {
        dao_id,
        multisig_id,
        amount: fee_amount,
        stable_type: stable_type_str,
        payer: ctx.sender(),
        timestamp: clock.timestamp_ms(),
    });

    // Return remaining payment
    payment
}

/// Reset payment timestamps for all coin types for a DAO
/// Called when ANY fee is successfully paid (forgiveness mechanism)
fun reset_dao_coin_debts(
    fee_manager: &mut FeeManager,
    dao_id: ID,
    coin_types: vector<TypeName>,
    current_time: u64,
) {
    let mut i = 0;
    while (i < coin_types.length()) {
        let coin_type = *coin_types.borrow(i);

        // DAO records are keyed directly by dao_id (single record per DAO)
        // But we need per-coin-type tracking, so we need composite keys too
        // For now, just reset the main DaoFeeRecord timestamp
        // TODO: Implement per-coin-type DAO records like multisigs
        if (dynamic_field::exists_(&fee_manager.id, dao_id)) {
            let record: &mut DaoFeeRecord = dynamic_field::borrow_mut(&mut fee_manager.id, dao_id);
            record.last_collection_timestamp = current_time;
        };

        i = i + 1;
    };
}

// === Multisig Fee Collection (Same Pattern as DAOs) ===

/// Multisig fee record - tracks per-coin-type payments
/// Key: (multisig_id, coin_type) as composite
public struct MultisigFeeRecord has store {
    multisig_id: ID,
    coin_type: TypeName,
    last_payment_timestamp: u64,
    total_paid: u64,
}

/// Collect monthly fee from a multisig for a specific coin type
/// If payment succeeds, resets ALL other coin debt for this multisig (forgiveness)
/// Returns (remaining_funds, periods_collected)
public fun collect_multisig_fee<StableType>(
    fee_manager: &mut FeeManager,
    multisig_id: ID,
    coin_type: TypeName,
    mut available_funds: Coin<StableType>,
    all_coin_types: vector<TypeName>,  // All coins to reset on success
    clock: &Clock,
    ctx: &mut TxContext,
): (Coin<StableType>, u64) {
    // CRITICAL: Verify type safety
    assert!(
        type_name::get<StableType>() == coin_type,
        EWrongStableCoinType
    );

    // Apply any pending fee updates
    apply_pending_coin_fees(fee_manager, coin_type, clock);

    // Get monthly fee for this coin type
    let monthly_fee = if (dynamic_field::exists_(&fee_manager.id, coin_type)) {
        let config: &CoinFeeConfig = dynamic_field::borrow(&fee_manager.id, coin_type);
        config.multisig_monthly_fee
    } else {
        0 // No fee if coin not configured
    };

    if (monthly_fee == 0) {
        return (available_funds, 0)
    };

    let current_time = clock.timestamp_ms();

    // Create composite key: multisig_id + coin_type
    let mut record_key_bytes = b"multisig_";
    let id_bytes = object::id_to_bytes(&multisig_id);
    vector::append(&mut record_key_bytes, id_bytes);
    let coin_type_bytes = bcs::to_bytes(&coin_type);
    vector::append(&mut record_key_bytes, coin_type_bytes);

    // Get or create fee record for this multisig + coin type
    let periods_to_collect = if (dynamic_field::exists_with_type<vector<u8>, MultisigFeeRecord>(&fee_manager.id, record_key_bytes)) {
        let record: &MultisigFeeRecord = dynamic_field::borrow(&fee_manager.id, record_key_bytes);
        let time_since_last = if (current_time > record.last_payment_timestamp) {
            current_time - record.last_payment_timestamp
        } else {
            0
        };

        // Cap at 3 months max
        let collectible_time = if (time_since_last > MAX_FEE_COLLECTION_PERIOD_MS) {
            MAX_FEE_COLLECTION_PERIOD_MS
        } else {
            time_since_last
        };

        collectible_time / MONTHLY_FEE_PERIOD_MS
    } else {
        // First time - create record but don't collect
        let new_record = MultisigFeeRecord {
            multisig_id,
            coin_type,
            last_payment_timestamp: current_time,
            total_paid: 0,
        };
        dynamic_field::add(&mut fee_manager.id, record_key_bytes, new_record);
        0
    };

    if (periods_to_collect == 0) {
        return (available_funds, 0)
    };

    // Use u128 arithmetic to prevent overflow
    let total_fee_u128 = (monthly_fee as u128) * (periods_to_collect as u128);
    assert!(total_fee_u128 <= (u64::max_value!() as u128), EArithmeticOverflow);
    let total_fee = (total_fee_u128 as u64);
    let available_amount = available_funds.value();

    if (available_amount >= total_fee) {
        // PAYMENT SUCCESS - Full payment available
        let fee_coin = available_funds.split(total_fee, ctx);

        // Deposit the fee
        deposit_stable_fees(fee_manager, fee_coin.into_balance(), multisig_id, clock);

        // Update this coin's record
        let record: &mut MultisigFeeRecord = dynamic_field::borrow_mut(&mut fee_manager.id, record_key_bytes);
        record.last_payment_timestamp = current_time;
        record.total_paid = record.total_paid + total_fee;

        // CRITICAL: Reset ALL other coin payment timestamps (forgiveness mechanism)
        reset_multisig_coin_debts(fee_manager, multisig_id, all_coin_types, current_time);

        // Emit success event
        let stable_type_str = type_name::with_defining_ids<StableType>().into_string();
        event::emit(DaoPlatformFeeCollected {  // Reuse DAO event for now
            dao_id: multisig_id,
            amount: total_fee,
            stable_type: stable_type_str,
            collector: ctx.sender(),
            timestamp: current_time,
        });

        (available_funds, periods_to_collect)
    } else {
        // PAYMENT FAILED - Insufficient funds, don't take anything
        // Multisig will be paused if ALL required coins fail
        (available_funds, 0)
    }
}

/// Reset payment timestamps for all coin types for a multisig
/// Called when ANY fee is successfully paid (forgiveness mechanism)
fun reset_multisig_coin_debts(
    fee_manager: &mut FeeManager,
    multisig_id: ID,
    coin_types: vector<TypeName>,
    current_time: u64,
) {
    let mut i = 0;
    while (i < coin_types.length()) {
        let coin_type = *coin_types.borrow(i);

        // Create composite key
        let mut record_key_bytes = b"multisig_";
        let id_bytes = object::id_to_bytes(&multisig_id);
        vector::append(&mut record_key_bytes, id_bytes);
        let coin_type_bytes = bcs::to_bytes(&coin_type);
        vector::append(&mut record_key_bytes, coin_type_bytes);

        // Reset timestamp if record exists
        if (dynamic_field::exists_with_type<vector<u8>, MultisigFeeRecord>(&fee_manager.id, record_key_bytes)) {
            let record: &mut MultisigFeeRecord = dynamic_field::borrow_mut(&mut fee_manager.id, record_key_bytes);
            record.last_payment_timestamp = current_time;
        };

        i = i + 1;
    };
}

/// Check if a multisig should be paused
/// ONLY pauses if ALL required coin types are overdue
public fun is_multisig_paused(
    fee_manager: &FeeManager,
    multisig_id: ID,
    required_coin_types: vector<TypeName>,
    clock: &Clock,
): bool {
    let current_time = clock.timestamp_ms();
    let mut all_overdue = true;

    let mut i = 0;
    while (i < required_coin_types.length()) {
        let coin_type = *required_coin_types.borrow(i);

        // Get monthly fee for this coin type
        let monthly_fee = if (dynamic_field::exists_(&fee_manager.id, coin_type)) {
            let config: &CoinFeeConfig = dynamic_field::borrow(&fee_manager.id, coin_type);
            config.multisig_monthly_fee
        } else {
            0
        };

        if (monthly_fee == 0) {
            // No fee required = not overdue
            all_overdue = false;
        } else {
            // Create composite key
            let mut record_key_bytes = b"multisig_";
            let id_bytes = object::id_to_bytes(&multisig_id);
            vector::append(&mut record_key_bytes, id_bytes);
            let coin_type_bytes = bcs::to_bytes(&coin_type);
            vector::append(&mut record_key_bytes, coin_type_bytes);

            if (!dynamic_field::exists_with_type<vector<u8>, MultisigFeeRecord>(&fee_manager.id, record_key_bytes)) {
                // No record = newly created = not overdue
                all_overdue = false;
            } else {
                let record: &MultisigFeeRecord = dynamic_field::borrow(&fee_manager.id, record_key_bytes);
                let time_since_last = if (current_time > record.last_payment_timestamp) {
                    current_time - record.last_payment_timestamp
                } else {
                    0
                };

                if (time_since_last < MONTHLY_FEE_PERIOD_MS) {
                    // This coin is current = not all overdue
                    all_overdue = false;
                };
            };
        };

        i = i + 1;
    };

    all_overdue
}

// ======== Test Functions ========
#[test_only]
public fun create_fee_manager_for_testing(ctx: &mut TxContext) {
    let admin_cap = FeeAdminCap {
        id: object::new(ctx),
    };
    
    let mut verification_fees = table::new<u8, u64>(ctx);
    // Start with just level 1 by default
    table::add(&mut verification_fees, 1, DEFAULT_VERIFICATION_FEE);
    
    let fee_manager = FeeManager {
        id: object::new(ctx),
        admin_cap_id: object::id(&admin_cap),
        dao_creation_fee: DEFAULT_DAO_CREATION_FEE,
        proposal_creation_fee_per_outcome: DEFAULT_PROPOSAL_CREATION_FEE_PER_OUTCOME,
        verification_fees,
        dao_monthly_fee: 10_000_000, // e.g. 10 of a 6-decimal stable coin
        pending_dao_monthly_fee: option::none(),
        pending_fee_effective_timestamp: option::none(),
        sui_balance: balance::zero<SUI>(),
        recovery_fee: 5_000_000_000, // 5 SUI default
        launchpad_creation_fee: DEFAULT_LAUNCHPAD_CREATION_FEE,
    };

    public_share_object(fee_manager);
    public_transfer(admin_cap, ctx.sender());
}
/// ============================================================================
/// SWAP COORDINATOR - UNIFIED ARBITRAGE AT ALL ENTRY POINTS
/// ============================================================================
///
/// Based on Solana's built-in arbitrage pattern (lines 620-836 in their impl)
///
/// ARCHITECTURE:
/// - High-level coordinator above AMMs
/// - No circular dependencies
/// - ACTUAL coin splitting and execution
/// - Dynamic optimization with profitability checks
///
/// HOW IT WORKS (Solana pattern):
/// 1. User submits swap transaction
/// 2. Coordinator splits input: direct path + arbitrage path
/// 3. Executes BOTH paths atomically:
///    - Direct: User amount through target pool
///    - Arbitrage: Route through profitable path (spot ↔ conditionals)
/// 4. Combines outputs and returns to user
/// 5. User gets: direct_output + arbitrage_profit
///
/// DYNAMIC OPTIMIZATION:
/// - Calculate expected profit before splitting
/// - Only arbitrage if profit > gas cost
/// - Use optimal split ratio (not fixed 10%)
/// - Quantum constraint: min across all conditional pools
///
/// ============================================================================

module futarchy_markets::swap_coordinator;

use futarchy_markets::spot_amm::{Self, SpotAMM};
use futarchy_markets::conditional_amm::{Self, LiquidityPool};
use futarchy_markets::market_state::MarketState;
use futarchy_markets::optimal_routing::{Self, PoolState, RoutingPlan};
use futarchy_one_shot_utils::math;
use sui::coin::{Self, Coin};
use sui::clock::Clock;

// === Errors ===
const EZeroAmount: u64 = 0;
const EInsufficientOutput: u64 = 1;
const EArbitrageCycleDetected: u64 = 2;
const EExcessConditionalCoins: u64 = 3;  // Abort if would create excess conditional coins (handle later)

// === Public Swap Functions ===

/// Swap SPOT asset for SPOT stable with optimal routing
///
/// This function calculates optimal routing across spot + conditional pools but currently
/// only executes spot-only swaps to avoid excess conditional coin management.
///
/// Routing through conditional pools would require:
/// 1. Split spot → conditional tokens (creates N conditional coins)
/// 2. Swap in conditional pools according to routing plan
/// 3. Recombine conditional stables to spot stable (excess coins from non-swapped outcomes)
/// 4. Return spot stable + transfer excess conditional coins to user
///
/// TODO: Full implementation requires TokenEscrow parameter for minting/burning conditional coins
public fun swap_asset_for_stable_in_spot<AssetType, StableType>(
    spot_pool: &mut SpotAMM<AssetType, StableType>,
    conditional_pools: &mut vector<LiquidityPool>,
    mut asset_in: Coin<AssetType>,
    min_stable_out: u64,
    clock: &Clock,
    ctx: &mut TxContext,
): Coin<StableType> {
    let amount_in = asset_in.value();
    assert!(amount_in > 0, EZeroAmount);

    // Build pool states for routing calculation
    let pool_states = build_pool_states_for_asset_to_stable(spot_pool, conditional_pools);

    // Calculate optimal routing plan
    let routing_plan = optimal_routing::calculate_optimal_asset_to_stable_routing(
        amount_in,
        &pool_states,
    );

    // Check if routing would use conditional pools
    let num_pools = optimal_routing::get_num_pools(&routing_plan);
    let mut routes_through_conditionals = false;
    let mut i = 1; // Skip index 0 (spot pool)
    while (i < num_pools) {
        let amount = optimal_routing::get_amount_for_pool(&routing_plan, i);
        if (amount > 0) {
            routes_through_conditionals = true;
        };
        i = i + 1;
    };

    // If routing uses conditionals, abort for now (need escrow for minting/burning)
    if (routes_through_conditionals) {
        // TODO: Implement with TokenEscrow parameter to handle:
        // 1. Deposit spot → mint conditional tokens
        // 2. Swap in conditional pools
        // 3. Recombine conditional stables → spot stable
        // 4. Transfer excess conditional tokens to user
        abort EExcessConditionalCoins
    };

    // Execute spot-only swap
    let mut empty_vec = vector::empty<LiquidityPool>();
    let output = spot_amm::swap_asset_for_stable(
        spot_pool,
        asset_in,
        min_stable_out,
        clock,
        ctx,
    );
    vector::destroy_empty(empty_vec);
    output
}

/// Swap SPOT stable for SPOT asset with optimal routing
///
/// This function calculates optimal routing across spot + conditional pools but currently
/// only executes spot-only swaps to avoid excess conditional coin management.
///
/// TODO: Full implementation requires TokenEscrow parameter for minting/burning conditional coins
public fun swap_stable_for_asset_in_spot<AssetType, StableType>(
    spot_pool: &mut SpotAMM<AssetType, StableType>,
    conditional_pools: &mut vector<LiquidityPool>,
    stable_in: Coin<StableType>,
    min_asset_out: u64,
    clock: &Clock,
    ctx: &mut TxContext,
): Coin<AssetType> {
    let amount_in = stable_in.value();
    assert!(amount_in > 0, EZeroAmount);

    // Build pool states for routing calculation
    let pool_states = build_pool_states_for_stable_to_asset(spot_pool, conditional_pools);

    // Calculate optimal routing plan
    let routing_plan = optimal_routing::calculate_optimal_stable_to_asset_routing(
        amount_in,
        &pool_states,
    );

    // Check if routing would use conditional pools
    let num_pools = optimal_routing::get_num_pools(&routing_plan);
    let mut routes_through_conditionals = false;
    let mut i = 1; // Skip index 0 (spot pool)
    while (i < num_pools) {
        let amount = optimal_routing::get_amount_for_pool(&routing_plan, i);
        if (amount > 0) {
            routes_through_conditionals = true;
        };
        i = i + 1;
    };

    // If routing uses conditionals, abort for now (need escrow for minting/burning)
    if (routes_through_conditionals) {
        // TODO: Implement with TokenEscrow parameter to handle:
        // 1. Deposit spot → mint conditional tokens
        // 2. Swap in conditional pools
        // 3. Recombine conditional assets → spot asset
        // 4. Transfer excess conditional tokens to user
        abort EExcessConditionalCoins
    };

    // Execute spot-only swap
    spot_amm::swap_stable_for_asset(
        spot_pool,
        stable_in,
        min_asset_out,
        clock,
        ctx,
    )
}

/// Swap CONDITIONAL asset for CONDITIONAL stable (same outcome pool)
///
/// This function calculates optimal routing including spot pool but currently only executes
/// direct conditional swaps to avoid complex complete-set burning requirements.
///
/// Routing conditional → spot → conditional would require:
/// 1. Acquiring other outcome's conditional tokens to form complete set
/// 2. Burning complete set → spot tokens
/// 3. Swapping in spot pool
/// 4. Minting new complete set → conditional tokens
/// 5. Returning desired outcome + excess tokens
///
/// TODO: Implement conditional → spot routing with complete set handling
public fun swap_asset_for_stable_in_conditional<AssetType, StableType>(
    conditional_pool: &mut LiquidityPool,
    spot_pool: &mut SpotAMM<AssetType, StableType>,
    _other_conditional_pools: &mut vector<LiquidityPool>,
    market_state: &MarketState,
    amount_in: u64,
    min_amount_out: u64,
    clock: &Clock,
    ctx: &TxContext,
): u64 {
    assert!(amount_in > 0, EZeroAmount);

    // Check if spot routing would be better (for future implementation)
    let (spot_asset, spot_stable) = spot_amm::get_reserves(spot_pool);
    let has_spot_liquidity = spot_asset > 0 && spot_stable > 0;

    if (has_spot_liquidity) {
        // Build pool states to compare conditional vs spot routing
        let (cond_asset, cond_stable) = conditional_amm::get_reserves(conditional_pool);

        // Create single-pool states for comparison
        let mut pool_states = vector::empty<PoolState>();
        vector::push_back(&mut pool_states, optimal_routing::new_pool_state(
            0, cond_asset, cond_stable, 30
        ));
        vector::push_back(&mut pool_states, optimal_routing::new_pool_state(
            1, spot_asset, spot_stable, 30
        ));

        // Calculate routing (would show if spot is better)
        let _routing_plan = optimal_routing::calculate_optimal_asset_to_stable_routing(
            amount_in,
            &pool_states,
        );

        // TODO: If routing plan prefers spot (index 1), execute spot routing:
        // 1. Acquire other outcomes to form complete set
        // 2. Burn → spot, swap, mint → conditional
        // 3. Return output + excess tokens
    };

    // Execute direct conditional swap
    let market_id = futarchy_markets::market_state::market_id(market_state);
    conditional_amm::swap_asset_to_stable(
        conditional_pool,
        market_id,
        amount_in,
        min_amount_out,
        clock,
        ctx,
    )
}

/// Swap CONDITIONAL stable for CONDITIONAL asset (same outcome pool)
///
/// This function calculates optimal routing including spot pool but currently only executes
/// direct conditional swaps to avoid complex complete-set burning requirements.
///
/// TODO: Implement conditional → spot routing with complete set handling
public fun swap_stable_for_asset_in_conditional<AssetType, StableType>(
    conditional_pool: &mut LiquidityPool,
    spot_pool: &mut SpotAMM<AssetType, StableType>,
    _other_conditional_pools: &mut vector<LiquidityPool>,
    market_state: &MarketState,
    amount_in: u64,
    min_amount_out: u64,
    clock: &Clock,
    ctx: &TxContext,
): u64 {
    assert!(amount_in > 0, EZeroAmount);

    // Check if spot routing would be better (for future implementation)
    let (spot_asset, spot_stable) = spot_amm::get_reserves(spot_pool);
    let has_spot_liquidity = spot_asset > 0 && spot_stable > 0;

    if (has_spot_liquidity) {
        // Build pool states to compare conditional vs spot routing
        let (cond_asset, cond_stable) = conditional_amm::get_reserves(conditional_pool);

        // Create single-pool states for comparison
        let mut pool_states = vector::empty<PoolState>();
        vector::push_back(&mut pool_states, optimal_routing::new_pool_state(
            0, cond_stable, cond_asset, 30  // Note: reversed for stable → asset
        ));
        vector::push_back(&mut pool_states, optimal_routing::new_pool_state(
            1, spot_stable, spot_asset, 30  // Note: reversed for stable → asset
        ));

        // Calculate routing (would show if spot is better)
        let _routing_plan = optimal_routing::calculate_optimal_stable_to_asset_routing(
            amount_in,
            &pool_states,
        );

        // TODO: If routing plan prefers spot (index 1), execute spot routing:
        // 1. Acquire other outcomes to form complete set
        // 2. Burn → spot, swap, mint → conditional
        // 3. Return output + excess tokens
    };

    // Execute direct conditional swap
    let market_id = futarchy_markets::market_state::market_id(market_state);
    conditional_amm::swap_stable_to_asset(
        conditional_pool,
        market_id,
        amount_in,
        min_amount_out,
        clock,
        ctx,
    )
}

// === Helper Functions for Routing ===

/// Build PoolState vector for optimal routing calculation (asset → stable)
fun build_pool_states_for_asset_to_stable<AssetType, StableType>(
    spot_pool: &SpotAMM<AssetType, StableType>,
    conditional_pools: &vector<LiquidityPool>,
): vector<PoolState> {
    let mut pool_states = vector::empty<PoolState>();

    // Add spot pool (index 0)
    let (spot_asset, spot_stable) = spot_amm::get_reserves(spot_pool);
    vector::push_back(&mut pool_states, optimal_routing::new_pool_state(
        0,           // pool_index
        spot_asset,  // asset_reserve
        spot_stable, // stable_reserve
        30,          // fee_bps (0.3% = 30 bps)
    ));

    // Add all conditional pools (index 1+)
    let num_conditionals = vector::length(conditional_pools);
    let mut i = 0;
    while (i < num_conditionals) {
        let conditional = vector::borrow(conditional_pools, i);
        let (cond_asset, cond_stable) = conditional_amm::get_reserves(conditional);

        vector::push_back(&mut pool_states, optimal_routing::new_pool_state(
            i + 1,       // pool_index (1, 2, 3...)
            cond_asset,  // asset_reserve
            cond_stable, // stable_reserve
            30,          // fee_bps
        ));

        i = i + 1;
    };

    pool_states
}

/// Build PoolState vector for optimal routing calculation (stable → asset)
fun build_pool_states_for_stable_to_asset<AssetType, StableType>(
    spot_pool: &SpotAMM<AssetType, StableType>,
    conditional_pools: &vector<LiquidityPool>,
): vector<PoolState> {
    // Same structure as asset → stable, just used for opposite direction
    build_pool_states_for_asset_to_stable(spot_pool, conditional_pools)
}

// NOTE: Conditional routing with coin bridging was explored but isn't practical
// due to Move's type system limitations (can't have Option<&mut T>).
//
// For conditional market routing, use swap.move module directly:
// 1. deposit_asset_and_mint_conditional() - spot → conditional
// 2. swap::swap_asset_to_stable() - conditional swap
// 3. burn_conditional_stable_and_withdraw() - conditional → spot
//
// The optimal_routing math module remains useful for:
// - Calculating optimal splits across multiple spot-like pools
// - Arbitrage profitability calculations
// - Future routing implementations with different architectures
/// NFT-based liquidity position tracking for Futarchy AMMs
/// Allows other protocols to discover and compose with LP positions
module futarchy_markets::position_nft;

use std::string::{Self, String};
use std::type_name::{Self, TypeName};
use std::option::{Self, Option};
use std::ascii;

use sui::object::{Self, UID, ID};
use sui::tx_context::{Self, TxContext};
use sui::transfer;
use sui::clock::{Self, Clock};
use sui::event;
use sui::display::{Self, Display};
use sui::package::{Self, Publisher};
use sui::vec_map::{Self, VecMap};

// === Errors ===
const EZeroAmount: u64 = 0;
const EPositionMismatch: u64 = 1;
const EInsufficientLiquidity: u64 = 2;
const ENotOwner: u64 = 3;

// === Display Constants ===
/// Default protocol image (used if no PositionImageConfig exists)
const DEFAULT_POSITION_NFT_IMAGE: vector<u8> = b"https://futarchy.app/images/lp-position-nft.png";

// === Structs ===

/// Mutable configuration for LP position NFT images
/// Allows protocol to update image URL via governance without redeployment
public struct PositionImageConfig has key {
    id: UID,
    /// Image URL for all LP position NFTs
    image_url: String,
}

/// One-time witness for creating PositionImageConfig
public struct POSITION_NFT has drop {}

/// NFT receipt for spot AMM liquidity position
/// Tradeable, composable with other DeFi protocols
public struct SpotLPPosition<phantom AssetType, phantom StableType> has key, store {
    id: UID,
    /// The spot pool this position is for
    pool_id: ID,
    /// Amount of LP shares this position represents
    lp_amount: u64,
    /// Display metadata
    name: String,
    description: String,
    image_url: String,
    /// Pool metadata for other protocols to read
    coin_type_asset: TypeName,
    coin_type_stable: TypeName,
    fee_bps: u64,
    /// Timestamps
    position_created_ms: u64,
    last_updated_ms: u64,
    /// Extensible metadata for future features (e.g., LP bonuses, loyalty tiers)
    metadata: VecMap<String, String>,
}

/// NFT receipt for conditional market liquidity position
/// Tracks LP position in a specific outcome's AMM
public struct ConditionalLPPosition<phantom AssetType, phantom StableType> has key, store {
    id: UID,
    /// The conditional pool this position is for
    pool_id: ID,
    /// The market (proposal) this belongs to
    market_id: ID,
    /// Which outcome (0, 1, 2, etc.)
    outcome_index: u8,
    /// Amount of LP shares
    lp_amount: u64,
    /// Display metadata
    name: String,
    description: String,
    image_url: String,
    /// Pool metadata
    coin_type_asset: TypeName,
    coin_type_stable: TypeName,
    fee_bps: u64,
    /// Proposal tracking
    proposal_id: ID,
    /// Updated when proposal finalizes
    is_winning_outcome: bool,
    /// Timestamps
    position_created_ms: u64,
    last_updated_ms: u64,
    /// Extensible metadata for future features (e.g., LP bonuses, loyalty tiers)
    metadata: VecMap<String, String>,
}

// === Events ===

public struct SpotPositionMinted has copy, drop {
    position_id: ID,
    pool_id: ID,
    owner: address,
    lp_amount: u64,
    timestamp_ms: u64,
}

public struct SpotPositionBurned has copy, drop {
    position_id: ID,
    pool_id: ID,
    owner: address,
    lp_amount: u64,
    timestamp_ms: u64,
}

public struct ConditionalPositionMinted has copy, drop {
    position_id: ID,
    pool_id: ID,
    market_id: ID,
    outcome_index: u8,
    owner: address,
    lp_amount: u64,
    timestamp_ms: u64,
}

public struct ConditionalPositionBurned has copy, drop {
    position_id: ID,
    pool_id: ID,
    market_id: ID,
    outcome_index: u8,
    owner: address,
    lp_amount: u64,
    timestamp_ms: u64,
}

// === Module Initialization ===

/// Initialize module - creates shared PositionImageConfig and publisher
fun init(otw: POSITION_NFT, ctx: &mut TxContext) {
    // Create shared image config with default image
    let config = PositionImageConfig {
        id: object::new(ctx),
        image_url: string::utf8(DEFAULT_POSITION_NFT_IMAGE),
    };
    transfer::share_object(config);

    // Create and transfer publisher for Display setup
    let publisher = package::claim(otw, ctx);
    transfer::public_transfer(publisher, ctx.sender());
}

// === Image Configuration Functions ===

/// Update the image URL for all future LP position NFTs
/// Package-private so it can only be called through governance actions
public(package) fun update_position_image(
    config: &mut PositionImageConfig,
    new_url: String,
) {
    config.image_url = new_url;
}

/// Get the current image URL from config
public fun get_image_url(config: &PositionImageConfig): String {
    config.image_url
}

// === Metadata Management Functions ===

/// Set a metadata key-value pair on a spot position
public fun set_spot_metadata<AssetType, StableType>(
    position: &mut SpotLPPosition<AssetType, StableType>,
    key: String,
    value: String,
) {
    if (vec_map::contains(&position.metadata, &key)) {
        let (_, _) = vec_map::remove(&mut position.metadata, &key);
    };
    vec_map::insert(&mut position.metadata, key, value);
}

/// Get a metadata value from a spot position
public fun get_spot_metadata<AssetType, StableType>(
    position: &SpotLPPosition<AssetType, StableType>,
    key: &String,
): Option<String> {
    if (vec_map::contains(&position.metadata, key)) {
        option::some(*vec_map::get(&position.metadata, key))
    } else {
        option::none()
    }
}

/// Set a metadata key-value pair on a conditional position
public fun set_conditional_metadata<AssetType, StableType>(
    position: &mut ConditionalLPPosition<AssetType, StableType>,
    key: String,
    value: String,
) {
    if (vec_map::contains(&position.metadata, &key)) {
        let (_, _) = vec_map::remove(&mut position.metadata, &key);
    };
    vec_map::insert(&mut position.metadata, key, value);
}

/// Get a metadata value from a conditional position
public fun get_conditional_metadata<AssetType, StableType>(
    position: &ConditionalLPPosition<AssetType, StableType>,
    key: &String,
): Option<String> {
    if (vec_map::contains(&position.metadata, key)) {
        option::some(*vec_map::get(&position.metadata, key))
    } else {
        option::none()
    }
}

// === Spot Position Functions ===

/// Mint a new spot LP position NFT
/// Called when user adds liquidity to spot pool
public fun mint_spot_position<AssetType, StableType>(
    pool_id: ID,
    lp_amount: u64,
    fee_bps: u64,
    clock: &Clock,
    ctx: &mut TxContext,
): SpotLPPosition<AssetType, StableType> {
    assert!(lp_amount > 0, EZeroAmount);

    let position_id = object::new(ctx);
    let timestamp = clock.timestamp_ms();

    // Build display strings
    let asset_type = type_name::get<AssetType>();
    let stable_type = type_name::get<StableType>();

    let name = string::utf8(b"Futarchy Spot LP Position");
    let description = format_spot_description(&asset_type, &stable_type, lp_amount);
    let image_url = string::utf8(DEFAULT_POSITION_NFT_IMAGE);

    event::emit(SpotPositionMinted {
        position_id: object::uid_to_inner(&position_id),
        pool_id,
        owner: ctx.sender(),
        lp_amount,
        timestamp_ms: timestamp,
    });

    SpotLPPosition {
        id: position_id,
        pool_id,
        lp_amount,
        name,
        description,
        image_url,
        coin_type_asset: asset_type,
        coin_type_stable: stable_type,
        fee_bps,
        position_created_ms: timestamp,
        last_updated_ms: timestamp,
        metadata: vec_map::empty(),  // Initialize empty metadata
    }
}

/// Increase liquidity in existing spot position
/// Called when user adds more liquidity to same pool
public fun increase_spot_position<AssetType, StableType>(
    position: &mut SpotLPPosition<AssetType, StableType>,
    pool_id: ID,
    additional_lp: u64,
    clock: &Clock,
) {
    assert!(position.pool_id == pool_id, EPositionMismatch);
    assert!(additional_lp > 0, EZeroAmount);

    position.lp_amount = position.lp_amount + additional_lp;
    position.last_updated_ms = clock.timestamp_ms();

    // Update description with new amount
    position.description = format_spot_description(
        &position.coin_type_asset,
        &position.coin_type_stable,
        position.lp_amount
    );
}

/// Decrease liquidity in spot position
/// Returns remaining LP amount (0 if position should be burned)
public fun decrease_spot_position<AssetType, StableType>(
    position: &mut SpotLPPosition<AssetType, StableType>,
    pool_id: ID,
    lp_to_remove: u64,
    clock: &Clock,
): u64 {
    assert!(position.pool_id == pool_id, EPositionMismatch);
    assert!(lp_to_remove > 0, EZeroAmount);
    assert!(position.lp_amount >= lp_to_remove, EInsufficientLiquidity);

    position.lp_amount = position.lp_amount - lp_to_remove;
    position.last_updated_ms = clock.timestamp_ms();

    if (position.lp_amount > 0) {
        // Update description with new amount
        position.description = format_spot_description(
            &position.coin_type_asset,
            &position.coin_type_stable,
            position.lp_amount
        );
    };

    position.lp_amount
}

/// Burn spot position NFT
/// Called when user removes all liquidity
public fun burn_spot_position<AssetType, StableType>(
    position: SpotLPPosition<AssetType, StableType>,
    clock: &Clock,
    ctx: &TxContext,
) {
    let SpotLPPosition {
        id,
        pool_id,
        lp_amount,
        name: _,
        description: _,
        image_url: _,
        coin_type_asset: _,
        coin_type_stable: _,
        fee_bps: _,
        position_created_ms: _,
        last_updated_ms: _,
        metadata: _,  // Metadata is dropped when position burns
    } = position;

    event::emit(SpotPositionBurned {
        position_id: object::uid_to_inner(&id),
        pool_id,
        owner: ctx.sender(),
        lp_amount,
        timestamp_ms: clock.timestamp_ms(),
    });

    object::delete(id);
}

// === Conditional Position Functions ===

/// Mint a new conditional LP position NFT
/// Called when user adds liquidity to a conditional market
public fun mint_conditional_position<AssetType, StableType>(
    pool_id: ID,
    market_id: ID,
    proposal_id: ID,
    outcome_index: u8,
    lp_amount: u64,
    fee_bps: u64,
    clock: &Clock,
    ctx: &mut TxContext,
): ConditionalLPPosition<AssetType, StableType> {
    assert!(lp_amount > 0, EZeroAmount);

    let position_id = object::new(ctx);
    let timestamp = clock.timestamp_ms();

    // Build display strings
    let asset_type = type_name::get<AssetType>();
    let stable_type = type_name::get<StableType>();

    let name = format_conditional_name(outcome_index);
    let description = format_conditional_description(
        &asset_type,
        &stable_type,
        outcome_index,
        lp_amount,
        proposal_id
    );
    let image_url = string::utf8(DEFAULT_POSITION_NFT_IMAGE);

    event::emit(ConditionalPositionMinted {
        position_id: object::uid_to_inner(&position_id),
        pool_id,
        market_id,
        outcome_index,
        owner: ctx.sender(),
        lp_amount,
        timestamp_ms: timestamp,
    });

    ConditionalLPPosition {
        id: position_id,
        pool_id,
        market_id,
        outcome_index,
        lp_amount,
        name,
        description,
        image_url,
        coin_type_asset: asset_type,
        coin_type_stable: stable_type,
        fee_bps,
        proposal_id,
        is_winning_outcome: false,
        position_created_ms: timestamp,
        last_updated_ms: timestamp,
        metadata: vec_map::empty(),  // Initialize empty metadata
    }
}

/// Mark conditional position as winning/losing when proposal finalizes
public fun mark_outcome_result<AssetType, StableType>(
    position: &mut ConditionalLPPosition<AssetType, StableType>,
    is_winner: bool,
) {
    position.is_winning_outcome = is_winner;
}

/// Increase liquidity in conditional position
public fun increase_conditional_position<AssetType, StableType>(
    position: &mut ConditionalLPPosition<AssetType, StableType>,
    pool_id: ID,
    additional_lp: u64,
    clock: &Clock,
) {
    assert!(position.pool_id == pool_id, EPositionMismatch);
    assert!(additional_lp > 0, EZeroAmount);

    position.lp_amount = position.lp_amount + additional_lp;
    position.last_updated_ms = clock.timestamp_ms();

    // Update description with new amount
    position.description = format_conditional_description(
        &position.coin_type_asset,
        &position.coin_type_stable,
        position.outcome_index,
        position.lp_amount,
        position.proposal_id
    );
}

/// Decrease liquidity in conditional position
/// Returns remaining LP amount (0 if position should be burned)
public fun decrease_conditional_position<AssetType, StableType>(
    position: &mut ConditionalLPPosition<AssetType, StableType>,
    pool_id: ID,
    lp_to_remove: u64,
    clock: &Clock,
): u64 {
    assert!(position.pool_id == pool_id, EPositionMismatch);
    assert!(lp_to_remove > 0, EZeroAmount);
    assert!(position.lp_amount >= lp_to_remove, EInsufficientLiquidity);

    position.lp_amount = position.lp_amount - lp_to_remove;
    position.last_updated_ms = clock.timestamp_ms();

    if (position.lp_amount > 0) {
        // Update description
        position.description = format_conditional_description(
            &position.coin_type_asset,
            &position.coin_type_stable,
            position.outcome_index,
            position.lp_amount,
            position.proposal_id
        );
    };

    position.lp_amount
}

/// Burn conditional position NFT
public fun burn_conditional_position<AssetType, StableType>(
    position: ConditionalLPPosition<AssetType, StableType>,
    clock: &Clock,
    ctx: &TxContext,
) {
    let ConditionalLPPosition {
        id,
        pool_id,
        market_id,
        outcome_index,
        lp_amount,
        name: _,
        description: _,
        image_url: _,
        coin_type_asset: _,
        coin_type_stable: _,
        fee_bps: _,
        proposal_id: _,
        is_winning_outcome: _,
        position_created_ms: _,
        last_updated_ms: _,
        metadata: _,  // Metadata is dropped when position burns
    } = position;

    event::emit(ConditionalPositionBurned {
        position_id: object::uid_to_inner(&id),
        pool_id,
        market_id,
        outcome_index,
        owner: ctx.sender(),
        lp_amount,
        timestamp_ms: clock.timestamp_ms(),
    });

    object::delete(id);
}

// === View Functions (for other protocols) ===

/// Get spot position details
public fun get_spot_position_info<AssetType, StableType>(
    position: &SpotLPPosition<AssetType, StableType>
): (ID, u64, TypeName, TypeName, u64) {
    (
        position.pool_id,
        position.lp_amount,
        position.coin_type_asset,
        position.coin_type_stable,
        position.fee_bps
    )
}

/// Get conditional position details
public fun get_conditional_position_info<AssetType, StableType>(
    position: &ConditionalLPPosition<AssetType, StableType>
): (ID, ID, u8, u64, TypeName, TypeName, u64, bool) {
    (
        position.pool_id,
        position.market_id,
        position.outcome_index,
        position.lp_amount,
        position.coin_type_asset,
        position.coin_type_stable,
        position.fee_bps,
        position.is_winning_outcome
    )
}

/// Get spot LP amount
public fun get_spot_lp_amount<AssetType, StableType>(
    position: &SpotLPPosition<AssetType, StableType>
): u64 {
    position.lp_amount
}

/// Get conditional LP amount
public fun get_conditional_lp_amount<AssetType, StableType>(
    position: &ConditionalLPPosition<AssetType, StableType>
): u64 {
    position.lp_amount
}

// === Helper Functions ===

fun format_spot_description(
    asset_type: &TypeName,
    stable_type: &TypeName,
    lp_amount: u64
): String {
    // Format: "LP Position: {lp_amount} shares in {Asset}/{Stable} pool"
    let mut desc = string::utf8(b"LP Position: ");
    string::append(&mut desc, u64_to_string(lp_amount));
    string::append(&mut desc, string::utf8(b" shares in "));
    string::append(&mut desc, string::from_ascii(type_name::into_string(*asset_type)));
    string::append(&mut desc, string::utf8(b"/"));
    string::append(&mut desc, string::from_ascii(type_name::into_string(*stable_type)));
    string::append(&mut desc, string::utf8(b" spot pool"));
    desc
}

fun format_conditional_description(
    asset_type: &TypeName,
    stable_type: &TypeName,
    outcome_index: u8,
    lp_amount: u64,
    proposal_id: ID
): String {
    // Format: "Conditional LP: {lp_amount} shares in Outcome {index} for Proposal {id}"
    let mut desc = string::utf8(b"Conditional LP: ");
    string::append(&mut desc, u64_to_string(lp_amount));
    string::append(&mut desc, string::utf8(b" shares in Outcome "));
    string::append(&mut desc, u8_to_string(outcome_index));
    string::append(&mut desc, string::utf8(b" ("));
    string::append(&mut desc, string::from_ascii(type_name::into_string(*asset_type)));
    string::append(&mut desc, string::utf8(b"/"));
    string::append(&mut desc, string::from_ascii(type_name::into_string(*stable_type)));
    string::append(&mut desc, string::utf8(b")"));
    desc
}

fun format_conditional_name(outcome_index: u8): String {
    let mut name = string::utf8(b"Futarchy Conditional LP - Outcome ");
    string::append(&mut name, u8_to_string(outcome_index));
    name
}

fun u64_to_string(value: u64): String {
    if (value == 0) return string::utf8(b"0");

    let mut buffer = vector::empty<u8>();
    let mut n = value;

    while (n > 0) {
        let digit = ((n % 10) as u8) + 48; // ASCII '0' = 48
        vector::push_back(&mut buffer, digit);
        n = n / 10;
    };

    vector::reverse(&mut buffer);
    string::utf8(buffer)
}

fun u8_to_string(value: u8): String {
    u64_to_string((value as u64))
}

// === Display Setup (one-time publisher call) ===

/// Initialize display for spot positions
public fun create_spot_display<AssetType, StableType>(
    publisher: &Publisher,
    ctx: &mut TxContext
): Display<SpotLPPosition<AssetType, StableType>> {
    let keys = vector[
        string::utf8(b"name"),
        string::utf8(b"description"),
        string::utf8(b"image_url"),
        string::utf8(b"pool_id"),
        string::utf8(b"lp_amount"),
        string::utf8(b"coin_type_asset"),
        string::utf8(b"coin_type_stable"),
        string::utf8(b"fee_bps"),
    ];

    let values = vector[
        string::utf8(b"{name}"),
        string::utf8(b"{description}"),
        string::utf8(b"{image_url}"),
        string::utf8(b"{pool_id}"),
        string::utf8(b"{lp_amount}"),
        string::utf8(b"{coin_type_asset}"),
        string::utf8(b"{coin_type_stable}"),
        string::utf8(b"{fee_bps}"),
    ];

    let mut display = display::new_with_fields<SpotLPPosition<AssetType, StableType>>(
        publisher,
        keys,
        values,
        ctx
    );

    display::update_version(&mut display);
    display
}

/// Initialize display for conditional positions
public fun create_conditional_display<AssetType, StableType>(
    publisher: &Publisher,
    ctx: &mut TxContext
): Display<ConditionalLPPosition<AssetType, StableType>> {
    let keys = vector[
        string::utf8(b"name"),
        string::utf8(b"description"),
        string::utf8(b"image_url"),
        string::utf8(b"pool_id"),
        string::utf8(b"market_id"),
        string::utf8(b"outcome_index"),
        string::utf8(b"lp_amount"),
        string::utf8(b"coin_type_asset"),
        string::utf8(b"coin_type_stable"),
        string::utf8(b"fee_bps"),
        string::utf8(b"is_winning_outcome"),
    ];

    let values = vector[
        string::utf8(b"{name}"),
        string::utf8(b"{description}"),
        string::utf8(b"{image_url}"),
        string::utf8(b"{pool_id}"),
        string::utf8(b"{market_id}"),
        string::utf8(b"{outcome_index}"),
        string::utf8(b"{lp_amount}"),
        string::utf8(b"{coin_type_asset}"),
        string::utf8(b"{coin_type_stable}"),
        string::utf8(b"{fee_bps}"),
        string::utf8(b"{is_winning_outcome}"),
    ];

    let mut display = display::new_with_fields<ConditionalLPPosition<AssetType, StableType>>(
        publisher,
        keys,
        values,
        ctx
    );

    display::update_version(&mut display);
    display
}

#[test_only]
public fun destroy_spot_position_for_testing<AssetType, StableType>(
    position: SpotLPPosition<AssetType, StableType>
) {
    let SpotLPPosition {
        id, pool_id: _, lp_amount: _, name: _, description: _, image_url: _,
        coin_type_asset: _, coin_type_stable: _, fee_bps: _,
        position_created_ms: _, last_updated_ms: _, metadata: _
    } = position;
    object::delete(id);
}

#[test_only]
public fun destroy_conditional_position_for_testing<AssetType, StableType>(
    position: ConditionalLPPosition<AssetType, StableType>
) {
    let ConditionalLPPosition {
        id, pool_id: _, market_id: _, outcome_index: _, lp_amount: _,
        name: _, description: _, image_url: _,
        coin_type_asset: _, coin_type_stable: _, fee_bps: _,
        proposal_id: _, is_winning_outcome: _,
        position_created_ms: _, last_updated_ms: _, metadata: _
    } = position;
    object::delete(id);
}
module futarchy_markets::spot_conditional_quoter;

use std::option::Option;
use futarchy_markets::conditional_amm::{Self, LiquidityPool};
use futarchy_markets::proposal::{Self, Proposal};
use futarchy_markets::coin_escrow::TokenEscrow;
use futarchy_markets::market_state::MarketState;
use futarchy_markets::spot_amm::{Self, SpotAMM};
use sui::clock::Clock;

// === Introduction ===
// This module provides quote functionality for spot token swaps through conditional AMMs.
// It simulates the routing process to provide accurate quotes without executing trades.
//
// Key features:
// - Provides accurate quotes for spot-to-spot swaps through conditional AMMs
// - Accounts for complete set minting/redemption costs
// - Simulates the full routing path without state changes
// - Returns both output amounts and price impact information

// === Errors ===
const EInvalidOutcome: u64 = 0;
const EZeroAmount: u64 = 1;
const EMarketNotActive: u64 = 2;
const EInsufficientLiquidity: u64 = 3;

// === Structs ===

/// Quote result for a spot swap
public struct SpotQuote has copy, drop {
    /// The expected output amount
    amount_out: u64,
    /// The effective price (amount_out / amount_in scaled by 1e9)
    effective_price: u64,
    /// The price impact percentage (scaled by 1e4, so 100 = 1%)
    price_impact_bps: u64,
    /// The outcome being traded through
    outcome: u64,
    /// Whether this is asset->stable (true) or stable->asset (false)
    is_asset_to_stable: bool,
}

/// Detailed quote with breakdown
public struct DetailedSpotQuote has copy, drop {
    /// Basic quote information
    quote: SpotQuote,
    /// Amount of conditional tokens created
    conditional_tokens_created: u64,
    /// Amount of conditional tokens that would be returned as excess
    excess_conditional_tokens: u64,
    /// The spot price before the trade
    spot_price_before: u64,
    /// The spot price after the trade
    spot_price_after: u64,
}

// === Public View Functions ===

/// Get a quote for swapping spot asset to spot stable through a specific outcome
public fun quote_spot_asset_to_stable<AssetType, StableType>(
    proposal: &Proposal<AssetType, StableType>,
    escrow: &TokenEscrow<AssetType, StableType>,
    outcome_idx: u64,
    amount_in: u64,
    clock: &Clock,
): SpotQuote {
    // Validate inputs
    assert!(amount_in > 0, EZeroAmount);
    assert!(outcome_idx < proposal.outcome_count(), EInvalidOutcome);
    
    // Verify market is active
    let market_state = escrow.get_market_state();
    assert!(market_state.is_trading_active(), EMarketNotActive);
    
    // Step 1: Complete set minting creates amount_in of each conditional token
    let conditional_asset_amount = amount_in;

    // Step 2: Get the AMM for this outcome
    let amm = proposal.get_pool_by_outcome(escrow, (outcome_idx as u8));
    
    // Step 3: Calculate swap output for asset -> stable
    let stable_out = conditional_amm::quote_swap_asset_to_stable(
        amm,
        conditional_asset_amount
    );
    
    // Step 4: Complete set redemption would give us stable_out spot tokens
    // (other outcomes would have excess conditional tokens returned)
    
    // Calculate effective price (scaled by 1e9 for precision)
    let effective_price = if (amount_in > 0) {
        (stable_out as u128) * 1_000_000_000 / (amount_in as u128)
    } else {
        0
    };
    
    // Calculate price impact
    let (asset_reserve, stable_reserve) = conditional_amm::get_reserves(amm);
    let spot_price_before = if (asset_reserve > 0) {
        (stable_reserve as u128) * 1_000_000_000 / (asset_reserve as u128)
    } else {
        0
    };
    
    let price_impact_bps = calculate_price_impact(
        spot_price_before as u64,
        effective_price as u64
    );
    
    SpotQuote {
        amount_out: stable_out,
        effective_price: effective_price as u64,
        price_impact_bps,
        outcome: outcome_idx,
        is_asset_to_stable: true,
    }
}

/// Get a quote for swapping spot stable to spot asset through a specific outcome
public fun quote_spot_stable_to_asset<AssetType, StableType>(
    proposal: &Proposal<AssetType, StableType>,
    escrow: &TokenEscrow<AssetType, StableType>,
    outcome_idx: u64,
    amount_in: u64,
    clock: &Clock,
): SpotQuote {
    // Validate inputs
    assert!(amount_in > 0, EZeroAmount);
    assert!(outcome_idx < proposal.outcome_count(), EInvalidOutcome);
    
    // Verify market is active
    let market_state = escrow.get_market_state();
    assert!(market_state.is_trading_active(), EMarketNotActive);
    
    // Step 1: Complete set minting creates amount_in of each conditional token
    let conditional_stable_amount = amount_in;

    // Step 2: Get the AMM for this outcome
    let amm = proposal.get_pool_by_outcome(escrow, (outcome_idx as u8));
    
    // Step 3: Calculate swap output for stable -> asset
    let asset_out = conditional_amm::quote_swap_stable_to_asset(
        amm,
        conditional_stable_amount
    );
    
    // Step 4: Complete set redemption would give us asset_out spot tokens
    
    // Calculate effective price (scaled by 1e9 for precision)
    let effective_price = if (amount_in > 0) {
        (asset_out as u128) * 1_000_000_000 / (amount_in as u128)
    } else {
        0
    };
    
    // Calculate price impact
    let (asset_reserve, stable_reserve) = conditional_amm::get_reserves(amm);
    let spot_price_before = if (stable_reserve > 0) {
        (asset_reserve as u128) * 1_000_000_000 / (stable_reserve as u128)
    } else {
        0
    };
    
    let price_impact_bps = calculate_price_impact(
        spot_price_before as u64,
        effective_price as u64
    );
    
    SpotQuote {
        amount_out: asset_out,
        effective_price: effective_price as u64,
        price_impact_bps,
        outcome: outcome_idx,
        is_asset_to_stable: false,
    }
}

/// Get a detailed quote with additional information
public fun quote_spot_asset_to_stable_detailed<AssetType, StableType>(
    proposal: &Proposal<AssetType, StableType>,
    escrow: &TokenEscrow<AssetType, StableType>,
    outcome_idx: u64,
    amount_in: u64,
    clock: &Clock,
): DetailedSpotQuote {
    // Get basic quote
    let quote = quote_spot_asset_to_stable(
        proposal,
        escrow,
        outcome_idx,
        amount_in,
        clock
    );
    
    // Get AMM for detailed calculations
    let amm = proposal.get_pool_by_outcome(escrow, (outcome_idx as u8));
    let (asset_reserve_before, stable_reserve_before) = conditional_amm::get_reserves(amm);

    // Calculate reserves after trade
    let asset_reserve_after = asset_reserve_before + amount_in;
    let stable_reserve_after = stable_reserve_before - quote.amount_out;
    
    // Calculate spot prices
    let spot_price_before = if (asset_reserve_before > 0) {
        (stable_reserve_before as u128) * 1_000_000_000 / (asset_reserve_before as u128)
    } else {
        0
    };
    
    let spot_price_after = if (asset_reserve_after > 0) {
        (stable_reserve_after as u128) * 1_000_000_000 / (asset_reserve_after as u128)
    } else {
        0
    };
    
    // Calculate excess tokens (all non-traded outcomes)
    let outcome_count = proposal.outcome_count();
    let excess_conditional_tokens = (outcome_count - 1) * amount_in;
    
    DetailedSpotQuote {
        quote,
        conditional_tokens_created: outcome_count * amount_in,
        excess_conditional_tokens,
        spot_price_before: spot_price_before as u64,
        spot_price_after: spot_price_after as u64,
    }
}

/// Get a detailed quote for stable to asset swap
public fun quote_spot_stable_to_asset_detailed<AssetType, StableType>(
    proposal: &Proposal<AssetType, StableType>,
    escrow: &TokenEscrow<AssetType, StableType>,
    outcome_idx: u64,
    amount_in: u64,
    clock: &Clock,
): DetailedSpotQuote {
    // Get basic quote
    let quote = quote_spot_stable_to_asset(
        proposal,
        escrow,
        outcome_idx,
        amount_in,
        clock
    );

    // Get AMM for detailed calculations
    let amm = proposal.get_pool_by_outcome(escrow, (outcome_idx as u8));
    let (asset_reserve_before, stable_reserve_before) = conditional_amm::get_reserves(amm);

    // Calculate reserves after trade
    let stable_reserve_after = stable_reserve_before + amount_in;
    let asset_reserve_after = asset_reserve_before - quote.amount_out;
    
    // Calculate spot prices
    let spot_price_before = if (stable_reserve_before > 0) {
        (asset_reserve_before as u128) * 1_000_000_000 / (stable_reserve_before as u128)
    } else {
        0
    };
    
    let spot_price_after = if (stable_reserve_after > 0) {
        (asset_reserve_after as u128) * 1_000_000_000 / (stable_reserve_after as u128)
    } else {
        0
    };
    
    // Calculate excess tokens
    let outcome_count = proposal.outcome_count();
    let excess_conditional_tokens = (outcome_count - 1) * amount_in;
    
    DetailedSpotQuote {
        quote,
        conditional_tokens_created: outcome_count * amount_in,
        excess_conditional_tokens,
        spot_price_before: spot_price_before as u64,
        spot_price_after: spot_price_after as u64,
    }
}

/// Find the best outcome to route a spot asset to stable swap through
public fun find_best_asset_to_stable_route<AssetType, StableType>(
    proposal: &Proposal<AssetType, StableType>,
    escrow: &TokenEscrow<AssetType, StableType>,
    amount_in: u64,
    clock: &Clock,
): (u64, SpotQuote) {
    assert!(amount_in > 0, EZeroAmount);
    
    let outcome_count = proposal.outcome_count();
    assert!(outcome_count > 0, EInvalidOutcome);
    
    let mut best_outcome = 0;
    let mut best_quote = quote_spot_asset_to_stable(
        proposal,
        escrow,
        0,
        amount_in,
        clock
    );
    
    let mut i = 1;
    while (i < outcome_count) {
        let quote = quote_spot_asset_to_stable(
            proposal,
            escrow,
            i,
            amount_in,
            clock
        );
        
        if (quote.amount_out > best_quote.amount_out) {
            best_outcome = i;
            best_quote = quote;
        };
        
        i = i + 1;
    };
    
    (best_outcome, best_quote)
}

/// Find the best outcome to route a spot stable to asset swap through
public fun find_best_stable_to_asset_route<AssetType, StableType>(
    proposal: &Proposal<AssetType, StableType>,
    escrow: &TokenEscrow<AssetType, StableType>,
    amount_in: u64,
    clock: &Clock,
): (u64, SpotQuote) {
    assert!(amount_in > 0, EZeroAmount);
    
    let outcome_count = proposal.outcome_count();
    assert!(outcome_count > 0, EInvalidOutcome);
    
    let mut best_outcome = 0;
    let mut best_quote = quote_spot_stable_to_asset(
        proposal,
        escrow,
        0,
        amount_in,
        clock
    );
    
    let mut i = 1;
    while (i < outcome_count) {
        let quote = quote_spot_stable_to_asset(
            proposal,
            escrow,
            i,
            amount_in,
            clock
        );
        
        if (quote.amount_out > best_quote.amount_out) {
            best_outcome = i;
            best_quote = quote;
        };
        
        i = i + 1;
    };
    
    (best_outcome, best_quote)
}

// === Helper Functions ===

/// Calculate price impact in basis points
fun calculate_price_impact(price_before: u64, effective_price: u64): u64 {
    if (price_before == 0) {
        return 0
    };
    
    let diff = if (effective_price > price_before) {
        effective_price - price_before
    } else {
        price_before - effective_price
    };
    
    // Calculate impact as basis points (1 bp = 0.01%)
    let impact = (diff as u128) * 10000 / (price_before as u128);
    impact as u64
}

// === Accessor Functions ===

public fun get_amount_out(quote: &SpotQuote): u64 {
    quote.amount_out
}

public fun get_effective_price(quote: &SpotQuote): u64 {
    quote.effective_price
}

public fun get_price_impact_bps(quote: &SpotQuote): u64 {
    quote.price_impact_bps
}

public fun get_outcome(quote: &SpotQuote): u64 {
    quote.outcome
}

public fun is_asset_to_stable(quote: &SpotQuote): bool {
    quote.is_asset_to_stable
}

public fun get_conditional_tokens_created(detailed: &DetailedSpotQuote): u64 {
    detailed.conditional_tokens_created
}

public fun get_excess_conditional_tokens(detailed: &DetailedSpotQuote): u64 {
    detailed.excess_conditional_tokens
}

public fun get_spot_price_before(detailed: &DetailedSpotQuote): u64 {
    detailed.spot_price_before
}

public fun get_spot_price_after(detailed: &DetailedSpotQuote): u64 {
    detailed.spot_price_after
}

// === Oracle Price Functions ===

/// Get combined oracle price from spot AMM
/// Uses get_twap_mut to ensure TWAP is up-to-date
public fun get_combined_oracle_price<AssetType, StableType>(
    spot_pool: &mut SpotAMM<AssetType, StableType>,
    clock: &Clock,
): u128 {
    // Return the spot AMM TWAP
    spot_amm::get_twap_mut(spot_pool, clock)
}

/// Check if a price meets a threshold condition
public fun check_price_threshold(
    price: u128,
    threshold: u128,
    is_above_threshold: bool,
): bool {
    if (is_above_threshold) {
        price >= threshold
    } else {
        price <= threshold
    }
}

/// Check if proposals can be created based on TWAP readiness
public fun can_create_proposal<AssetType, StableType>(
    spot_pool: &SpotAMM<AssetType, StableType>,
    clock: &Clock,
): bool {
    spot_amm::is_twap_ready(spot_pool, clock)
}

/// Get time until proposals are allowed (returns 0 if ready)
public fun time_until_proposals_allowed<AssetType, StableType>(
    spot_pool: &SpotAMM<AssetType, StableType>,
    clock: &Clock,
): u64 {
    // Check if TWAP is ready
    if (spot_amm::is_twap_ready(spot_pool, clock)) {
        return 0
    };
    
    // Calculate remaining time (simplified - assumes 3 days needed)
    259_200_000 // Return 3 days in ms as placeholder
}

/// Get initialization price for conditional AMMs
public fun get_initialization_price<AssetType, StableType>(
    spot_pool: &SpotAMM<AssetType, StableType>,
    clock: &Clock,
): u128 {
    spot_amm::get_twap_for_conditional_amm(spot_pool, clock)
}module futarchy_markets::liquidity_interact;

use futarchy_markets::conditional_amm;
use futarchy_markets::coin_escrow::{Self, TokenEscrow};
use futarchy_markets::fee::FeeManager;
use futarchy_markets::proposal::Proposal;
use sui::balance::Balance;
use sui::clock::Clock;
use sui::coin::{Self, Coin};
use sui::event;

// === Introduction ===
// Methods to interact with AMM liquidity and escrow balances using TreasuryCap-based conditional coins

// === Errors ===
const EInvalidOutcome: u64 = 0;
const EInvalidLiquidityTransfer: u64 = 1;
const EWrongOutcome: u64 = 2;
const EInvalidState: u64 = 3;
const EMarketIdMismatch: u64 = 4;
const EAssetReservesMismatch: u64 = 5;
const EStableReservesMismatch: u64 = 6;
const EInsufficientAmount: u64 = 7;
const EMinAmountNotMet: u64 = 8;

// === Events ===
public struct ProtocolFeesCollected has copy, drop {
    proposal_id: ID,
    winning_outcome: u64,
    fee_amount: u64,
    timestamp_ms: u64,
}

// === Liquidity Removal (After Finalization) ===

/// Empties the winning AMM pool and transfers the underlying liquidity to the original provider.
/// Called internally by `advance_stage` when a user-funded proposal finalizes.
///
/// IMPORTANT: With TreasuryCap-based conditional coins, this function:
/// 1. Removes liquidity from winning AMM pool (gets conditional coin amounts)
/// 2. Burns those conditional coins using TreasuryCaps
/// 3. Withdraws equivalent spot tokens from escrow
/// 4. Transfers spot tokens to liquidity provider
public fun empty_amm_and_return_to_provider<AssetType, StableType, AssetConditionalCoin, StableConditionalCoin>(
    proposal: &mut Proposal<AssetType, StableType>,
    escrow: &mut TokenEscrow<AssetType, StableType>,
    ctx: &mut TxContext,
) {
    assert!(proposal.is_finalized(), EInvalidState);
    assert!(!proposal.uses_dao_liquidity(), EInvalidState);

    let market_state = escrow.get_market_state();
    let winning_outcome = proposal.get_winning_outcome();
    market_state.assert_market_finalized();

    // Get winning pool from market_state and empty its liquidity (returns conditional coin amounts)
    let market_state = escrow.get_market_state_mut();
    let pool = futarchy_markets::market_state::get_pool_mut_by_outcome(market_state, (winning_outcome as u8));
    let (conditional_asset_amt, conditional_stable_amt) = pool.empty_all_amm_liquidity(ctx);

    // Burn the conditional coins (1:1 with spot due to quantum liquidity)
    let asset_coin = escrow.burn_conditional_asset_and_withdraw<AssetType, StableType, AssetConditionalCoin>(
        winning_outcome,
        conditional_asset_amt,
        ctx,
    );

    let stable_coin = escrow.burn_conditional_stable_and_withdraw<AssetType, StableType, StableConditionalCoin>(
        winning_outcome,
        conditional_stable_amt,
        ctx,
    );

    // Transfer spot tokens to provider
    let provider = *proposal.get_liquidity_provider().borrow();
    transfer::public_transfer(asset_coin, provider);
    transfer::public_transfer(stable_coin, provider);
}

/// Empties the winning AMM pool and returns the liquidity.
/// Called internally by `advance_stage` when a DAO-funded proposal finalizes.
/// Returns the asset and stable coins for the DAO to handle (e.g., deposit to vault).
public fun empty_amm_and_return_to_dao<AssetType, StableType, AssetConditionalCoin, StableConditionalCoin>(
    proposal: &mut Proposal<AssetType, StableType>,
    escrow: &mut TokenEscrow<AssetType, StableType>,
    ctx: &mut TxContext,
): (Coin<AssetType>, Coin<StableType>) {
    assert!(proposal.is_finalized(), EInvalidState);
    assert!(proposal.uses_dao_liquidity(), EInvalidState);

    let market_state = escrow.get_market_state();
    market_state.assert_market_finalized();

    let winning_outcome = proposal.get_winning_outcome();
    // Get winning pool from market_state
    let market_state = escrow.get_market_state_mut();
    let pool = futarchy_markets::market_state::get_pool_mut_by_outcome(market_state, (winning_outcome as u8));
    let (conditional_asset_amt, conditional_stable_amt) = pool.empty_all_amm_liquidity(ctx);

    // Burn conditional coins and withdraw spot tokens
    let asset_coin = escrow.burn_conditional_asset_and_withdraw<AssetType, StableType, AssetConditionalCoin>(
        winning_outcome,
        conditional_asset_amt,
        ctx,
    );

    let stable_coin = escrow.burn_conditional_stable_and_withdraw<AssetType, StableType, StableConditionalCoin>(
        winning_outcome,
        conditional_stable_amt,
        ctx,
    );

    (asset_coin, stable_coin)
}

// === Complete Set Minting/Redemption ===
// With TreasuryCap-based conditional coins, "complete set" operations work per-outcome

/// Mint a complete set of conditional coins for a specific outcome by depositing spot tokens
/// Deposits spot asset and mints conditional asset coin for the specified outcome
/// Returns the conditional asset coin
public fun mint_conditional_asset_for_outcome<AssetType, StableType, ConditionalCoinType>(
    escrow: &mut TokenEscrow<AssetType, StableType>,
    outcome_index: u64,
    spot_asset: Coin<AssetType>,
    ctx: &mut TxContext,
): Coin<ConditionalCoinType> {
    coin_escrow::deposit_asset_and_mint_conditional<AssetType, StableType, ConditionalCoinType>(
        escrow,
        outcome_index,
        spot_asset,
        ctx,
    )
}

/// Mint conditional stable coin for a specific outcome by depositing spot stable
public fun mint_conditional_stable_for_outcome<AssetType, StableType, ConditionalCoinType>(
    escrow: &mut TokenEscrow<AssetType, StableType>,
    outcome_index: u64,
    spot_stable: Coin<StableType>,
    ctx: &mut TxContext,
): Coin<ConditionalCoinType> {
    coin_escrow::deposit_stable_and_mint_conditional<AssetType, StableType, ConditionalCoinType>(
        escrow,
        outcome_index,
        spot_stable,
        ctx,
    )
}

/// Redeem conditional asset coin back to spot asset
/// Burns the conditional coin and returns spot asset
public fun redeem_conditional_asset<AssetType, StableType, ConditionalCoinType>(
    proposal: &Proposal<AssetType, StableType>,
    escrow: &mut TokenEscrow<AssetType, StableType>,
    conditional_coin: Coin<ConditionalCoinType>,
    outcome_index: u64,
    clock: &Clock,
    ctx: &mut TxContext,
): Coin<AssetType> {
    assert!(proposal.is_finalized(), EInvalidState);
    let winning_outcome = proposal.get_winning_outcome();
    assert!(outcome_index == winning_outcome, EWrongOutcome);

    let amount = conditional_coin.value();

    // Burn the conditional coin
    coin_escrow::burn_conditional_asset<AssetType, StableType, ConditionalCoinType>(
        escrow,
        outcome_index,
        conditional_coin,
    );

    // Withdraw spot asset (1:1)
    coin_escrow::withdraw_asset_balance(escrow, amount, ctx)
}

/// Redeem conditional stable coin back to spot stable
public fun redeem_conditional_stable<AssetType, StableType, ConditionalCoinType>(
    proposal: &Proposal<AssetType, StableType>,
    escrow: &mut TokenEscrow<AssetType, StableType>,
    conditional_coin: Coin<ConditionalCoinType>,
    outcome_index: u64,
    clock: &Clock,
    ctx: &mut TxContext,
): Coin<StableType> {
    assert!(proposal.is_finalized(), EInvalidState);
    let winning_outcome = proposal.get_winning_outcome();
    assert!(outcome_index == winning_outcome, EWrongOutcome);

    let amount = conditional_coin.value();

    // Burn the conditional coin
    coin_escrow::burn_conditional_stable<AssetType, StableType, ConditionalCoinType>(
        escrow,
        outcome_index,
        conditional_coin,
    );

    // Withdraw spot stable (1:1)
    coin_escrow::withdraw_stable_balance(escrow, amount, ctx)
}

// === AMM Liquidity Management ===

/// Add liquidity to an AMM pool for a specific outcome
/// Takes asset and stable conditional coins and mints LP tokens
/// Uses TreasuryCap-based conditional coins
public entry fun add_liquidity_entry<AssetType, StableType, AssetConditionalCoin, StableConditionalCoin, LPConditionalCoin>(
    proposal: &mut Proposal<AssetType, StableType>,
    escrow: &mut TokenEscrow<AssetType, StableType>,
    outcome_idx: u64,
    asset_in: Coin<AssetConditionalCoin>,
    stable_in: Coin<StableConditionalCoin>,
    min_lp_out: u64,
    clock: &Clock,
    ctx: &mut TxContext,
) {
    assert!(!proposal.is_finalized(), EInvalidState);

    let asset_amount = asset_in.value();
    let stable_amount = stable_in.value();

    // Burn the conditional coins using TreasuryCaps
    coin_escrow::burn_conditional_asset<AssetType, StableType, AssetConditionalCoin>(
        escrow,
        outcome_idx,
        asset_in,
    );

    coin_escrow::burn_conditional_stable<AssetType, StableType, StableConditionalCoin>(
        escrow,
        outcome_idx,
        stable_in,
    );

    // Get the pool for this outcome from market_state
    let market_state = escrow.get_market_state_mut();
    let pool = futarchy_markets::market_state::get_pool_mut_by_outcome(market_state, (outcome_idx as u8));

    // Add liquidity through the AMM (updates virtual reserves)
    let lp_amount = conditional_amm::add_liquidity_proportional(
        pool,
        asset_amount,
        stable_amount,
        min_lp_out,
        clock,
        ctx
    );

    // Mint LP tokens using TreasuryCap
    let lp_token = coin_escrow::mint_conditional_asset<AssetType, StableType, LPConditionalCoin>(
        escrow,
        outcome_idx,
        lp_amount,
        ctx
    );

    // Transfer LP token to the sender
    transfer::public_transfer(lp_token, ctx.sender());
}

/// Remove liquidity from an AMM pool proportionally
/// Burns LP tokens and returns asset and stable conditional coins
public entry fun remove_liquidity_entry<AssetType, StableType, AssetConditionalCoin, StableConditionalCoin, LPConditionalCoin>(
    proposal: &mut Proposal<AssetType, StableType>,
    escrow: &mut TokenEscrow<AssetType, StableType>,
    outcome_idx: u64,
    lp_token: Coin<LPConditionalCoin>,
    min_asset_out: u64,
    min_stable_out: u64,
    clock: &Clock,
    ctx: &mut TxContext,
) {
    assert!(!proposal.is_finalized(), EInvalidState);

    let lp_amount = lp_token.value();

    // Burn the LP token using TreasuryCap
    coin_escrow::burn_conditional_asset<AssetType, StableType, LPConditionalCoin>(
        escrow,
        outcome_idx,
        lp_token,
    );

    // Get the pool for this outcome from market_state
    let market_state = escrow.get_market_state_mut();
    let pool = futarchy_markets::market_state::get_pool_mut_by_outcome(market_state, (outcome_idx as u8));

    // Remove liquidity through the AMM (updates virtual reserves)
    let (asset_amount, stable_amount) = conditional_amm::remove_liquidity_proportional(
        pool,
        lp_amount,
        clock,
        ctx
    );

    // Verify slippage protection
    assert!(asset_amount >= min_asset_out, EMinAmountNotMet);
    assert!(stable_amount >= min_stable_out, EMinAmountNotMet);

    // Mint the asset and stable conditional tokens using TreasuryCaps
    let asset_token = coin_escrow::mint_conditional_asset<AssetType, StableType, AssetConditionalCoin>(
        escrow,
        outcome_idx,
        asset_amount,
        ctx
    );

    let stable_token = coin_escrow::mint_conditional_stable<AssetType, StableType, StableConditionalCoin>(
        escrow,
        outcome_idx,
        stable_amount,
        ctx
    );

    // Transfer tokens to the sender
    transfer::public_transfer(asset_token, ctx.sender());
    transfer::public_transfer(stable_token, ctx.sender());
}

// === Protocol Fee Collection ===

/// Collect protocol fees from the winning pool after finalization
/// Withdraws fees from escrow and deposits them to the fee manager
public fun collect_protocol_fees<AssetType, StableType>(
    proposal: &mut Proposal<AssetType, StableType>,
    escrow: &mut TokenEscrow<AssetType, StableType>,
    fee_manager: &mut FeeManager,
    clock: &Clock,
    ctx: &mut TxContext,
) {
    assert!(proposal.is_finalized(), EInvalidState);
    assert!(proposal.is_winning_outcome_set(), EInvalidState);

    let winning_outcome = proposal.get_winning_outcome();
    // Get winning pool from market_state
    let market_state = escrow.get_market_state_mut();
    let winning_pool = futarchy_markets::market_state::get_pool_mut_by_outcome(market_state, (winning_outcome as u8));
    let protocol_fee_amount = winning_pool.get_protocol_fees();

    if (protocol_fee_amount > 0) {
        // Reset fees in the pool
        winning_pool.reset_protocol_fees();

        // Extract the fees from escrow (fees are in stable coins)
        let (spot_asset, spot_stable) = coin_escrow::get_spot_balances(escrow);
        assert!(spot_stable >= protocol_fee_amount, EInsufficientAmount);

        let fee_balance_coin = coin_escrow::withdraw_stable_balance(escrow, protocol_fee_amount, ctx);
        let fee_balance = coin::into_balance(fee_balance_coin);

        // Deposit to fee manager
        fee_manager.deposit_stable_fees<StableType>(
            fee_balance,
            proposal.get_id(),
            clock,
        );

        // Emit event
        event::emit(ProtocolFeesCollected {
            proposal_id: proposal.get_id(),
            winning_outcome,
            fee_amount: protocol_fee_amount,
            timestamp_ms: clock.timestamp_ms(),
        });
    }
}

// === Test Helpers ===

#[test_only]
public fun get_liquidity_for_proposal<AssetType, StableType>(
    escrow: &futarchy_markets::coin_escrow::TokenEscrow<AssetType, StableType>,
): vector<u64> {
    let market_state = escrow.get_market_state();
    let pools = futarchy_markets::market_state::borrow_amm_pools(market_state);
    let mut liquidity = vector[];
    let mut i = 0;
    while (i < pools.length()) {
        let pool = &pools[i];
        let (asset, stable) = pool.get_reserves();
        liquidity.push_back(asset);
        liquidity.push_back(stable);
        i = i + 1;
    };
    liquidity
}
/// ============================================================================
/// OPTIMAL ROUTING - DETERMINISTIC SMART ORDER ROUTING
/// ============================================================================
///
/// Pure mathematical functions for calculating optimal swap routing across
/// multiple AMM pools with different prices and liquidity.
///
/// PROBLEM:
/// Given N pools (spot + conditionals) with different:
/// - Prices (determined by reserve ratios)
/// - Liquidity (total reserves)
/// - Fees
///
/// Find: How to split user's input across pools to MAXIMIZE output
///
/// SOLUTION:
/// Constant product AMMs (xy=k) have a deterministic optimal routing:
/// 1. Calculate marginal price for each pool
/// 2. Route to best-priced pool first
/// 3. Keep routing until marginal price equals next-best pool
/// 4. Split between pools where marginal prices are equal
/// 5. Continue until all input consumed
///
/// This is PURE MATH - fully deterministic, testable, no guessing.
///
/// ============================================================================

module futarchy_markets::optimal_routing;

use futarchy_one_shot_utils::math;

// === Structs for routing calculation ===

/// Represents a pool's state for routing calculations
public struct PoolState has copy, drop {
    pool_index: u64,      // Which pool (0 = spot, 1+ = conditionals)
    asset_reserve: u64,   // Current asset reserves
    stable_reserve: u64,  // Current stable reserves
    fee_bps: u64,         // Fee in basis points
}

/// Routing decision: how much to route to each pool
public struct RoutingPlan has copy, drop {
    amounts_per_pool: vector<u64>,  // Amount to route to each pool
    expected_output: u64,            // Total expected output
}

// === Public API ===

/// Calculate optimal routing for asset → stable swap
///
/// Returns: RoutingPlan showing how to split input across pools for maximum output
///
/// # Arguments
/// * `amount_in` - Total amount user wants to swap
/// * `pools` - Vector of all available pools (spot first, then conditionals)
///
/// # Pure Function
/// - No side effects
/// - Deterministic output for given inputs
/// - Fully testable
public fun calculate_optimal_asset_to_stable_routing(
    amount_in: u64,
    pools: &vector<PoolState>,
): RoutingPlan {
    let num_pools = vector::length(pools);
    if (num_pools == 0) {
        return RoutingPlan {
            amounts_per_pool: vector::empty(),
            expected_output: 0,
        }
    };

    // If only one pool, route everything there
    if (num_pools == 1) {
        let pool = vector::borrow(pools, 0);
        let output = calculate_output_with_fee(
            amount_in,
            pool.asset_reserve,
            pool.stable_reserve,
            pool.fee_bps,
        );

        let mut amounts = vector::empty();
        vector::push_back(&mut amounts, amount_in);

        return RoutingPlan {
            amounts_per_pool: amounts,
            expected_output: output,
        }
    };

    // Multiple pools - calculate optimal split
    calculate_optimal_split(amount_in, pools, true) // true = asset to stable
}

/// Calculate optimal routing for stable → asset swap
public fun calculate_optimal_stable_to_asset_routing(
    amount_in: u64,
    pools: &vector<PoolState>,
): RoutingPlan {
    let num_pools = vector::length(pools);
    if (num_pools == 0) {
        return RoutingPlan {
            amounts_per_pool: vector::empty(),
            expected_output: 0,
        }
    };

    if (num_pools == 1) {
        let pool = vector::borrow(pools, 0);
        let output = calculate_output_with_fee(
            amount_in,
            pool.stable_reserve,
            pool.asset_reserve,
            pool.fee_bps,
        );

        let mut amounts = vector::empty();
        vector::push_back(&mut amounts, amount_in);

        return RoutingPlan {
            amounts_per_pool: amounts,
            expected_output: output,
        }
    };

    calculate_optimal_split(amount_in, pools, false) // false = stable to asset
}

// === Core Routing Algorithm ===

/// Calculate optimal split using marginal price equalization
///
/// Algorithm:
/// 1. Start with all input unrouted
/// 2. Find pool with best marginal price
/// 3. Route small amount to that pool
/// 4. Recalculate marginal prices (they change as reserves change)
/// 5. Repeat until all input routed
///
/// This greedy algorithm is optimal for constant product AMMs
fun calculate_optimal_split(
    amount_in: u64,
    pools: &vector<PoolState>,
    is_asset_to_stable: bool,
): RoutingPlan {
    let num_pools = vector::length(pools);

    // Track how much to route to each pool
    let mut amounts_per_pool = vector::empty<u64>();
    let mut i = 0;
    while (i < num_pools) {
        vector::push_back(&mut amounts_per_pool, 0);
        i = i + 1;
    };

    // Track current reserves (will update as we route)
    let mut current_pools = vector::empty<PoolState>();
    i = 0;
    while (i < num_pools) {
        let pool = vector::borrow(pools, i);
        vector::push_back(&mut current_pools, *pool);
        i = i + 1;
    };

    // Route in small increments to approximate optimal continuous routing
    let num_iterations = 100; // More iterations = more accurate
    let increment = amount_in / num_iterations;
    let mut remaining = amount_in;

    let mut iteration = 0;
    while (iteration < num_iterations && remaining > 0) {
        let route_amount = if (remaining < increment) { remaining } else { increment };

        // Find pool with best marginal price
        let best_pool_idx = find_best_pool_for_routing(
            &current_pools,
            is_asset_to_stable,
        );

        // Route to that pool
        let current_amount = *vector::borrow(&amounts_per_pool, best_pool_idx);
        *vector::borrow_mut(&mut amounts_per_pool, best_pool_idx) = current_amount + route_amount;

        // Update pool reserves to reflect this routing
        update_pool_reserves(
            &mut current_pools,
            best_pool_idx,
            route_amount,
            is_asset_to_stable,
        );

        remaining = remaining - route_amount;
        iteration = iteration + 1;
    };

    // Calculate total expected output
    let mut total_output = 0u64;
    i = 0;
    while (i < num_pools) {
        let amount = *vector::borrow(&amounts_per_pool, i);
        if (amount > 0) {
            let pool = vector::borrow(pools, i);
            let output = if (is_asset_to_stable) {
                calculate_output_with_fee(amount, pool.asset_reserve, pool.stable_reserve, pool.fee_bps)
            } else {
                calculate_output_with_fee(amount, pool.stable_reserve, pool.asset_reserve, pool.fee_bps)
            };
            total_output = total_output + output;
        };
        i = i + 1;
    };

    RoutingPlan {
        amounts_per_pool,
        expected_output: total_output,
    }
}

/// Find pool with best marginal price (would give most output for next unit)
fun find_best_pool_for_routing(
    pools: &vector<PoolState>,
    is_asset_to_stable: bool,
): u64 {
    let num_pools = vector::length(pools);
    let mut best_pool_idx = 0;
    let mut best_marginal_output = 0u128;

    let mut i = 0;
    while (i < num_pools) {
        let pool = vector::borrow(pools, i);

        // Calculate marginal output for this pool (output for 1 unit)
        let marginal_output = if (is_asset_to_stable) {
            calculate_marginal_output(pool.asset_reserve, pool.stable_reserve, pool.fee_bps)
        } else {
            calculate_marginal_output(pool.stable_reserve, pool.asset_reserve, pool.fee_bps)
        };

        if (marginal_output > best_marginal_output) {
            best_marginal_output = marginal_output;
            best_pool_idx = i;
        };

        i = i + 1;
    };

    best_pool_idx
}

/// Update pool reserves after routing amount to it
fun update_pool_reserves(
    pools: &mut vector<PoolState>,
    pool_idx: u64,
    amount_in: u64,
    is_asset_to_stable: bool,
) {
    let pool = vector::borrow_mut(pools, pool_idx);

    // Calculate output for this amount
    let amount_out = if (is_asset_to_stable) {
        calculate_output_with_fee(amount_in, pool.asset_reserve, pool.stable_reserve, pool.fee_bps)
    } else {
        calculate_output_with_fee(amount_in, pool.stable_reserve, pool.asset_reserve, pool.fee_bps)
    };

    // Update reserves
    if (is_asset_to_stable) {
        pool.asset_reserve = pool.asset_reserve + amount_in;
        pool.stable_reserve = pool.stable_reserve - amount_out;
    } else {
        pool.stable_reserve = pool.stable_reserve + amount_in;
        pool.asset_reserve = pool.asset_reserve - amount_out;
    };
}

// === Helper Math Functions ===

/// Calculate output for constant product AMM with fees
fun calculate_output_with_fee(
    amount_in: u64,
    reserve_in: u64,
    reserve_out: u64,
    fee_bps: u64,
): u64 {
    if (amount_in == 0 || reserve_in == 0 || reserve_out == 0) return 0;

    // Apply fee: amount_in_after_fee = amount_in * (10000 - fee_bps) / 10000
    let amount_in_after_fee = amount_in - (amount_in * fee_bps / 10000);

    // Constant product: output = reserve_out * amount_in_after_fee / (reserve_in + amount_in_after_fee)
    math::mul_div_to_64(
        amount_in_after_fee,
        reserve_out,
        reserve_in + amount_in_after_fee
    )
}

/// Calculate marginal output (output for next infinitesimal unit)
/// This is the derivative: dy/dx at current reserves
/// For xy=k: marginal = y / (x + 1)^2 approximately y/x^2 for large pools
fun calculate_marginal_output(
    reserve_in: u64,
    reserve_out: u64,
    fee_bps: u64,
): u128 {
    if (reserve_in == 0 || reserve_out == 0) return 0;

    // Marginal output ≈ reserve_out / reserve_in for small trades
    // Scale up for precision
    let marginal = math::mul_div_to_128(
        reserve_out,
        10000 - fee_bps, // Account for fee
        reserve_in
    );

    marginal
}

// === Getters for RoutingPlan ===

public fun get_amount_for_pool(plan: &RoutingPlan, pool_index: u64): u64 {
    if (pool_index >= vector::length(&plan.amounts_per_pool)) return 0;
    *vector::borrow(&plan.amounts_per_pool, pool_index)
}

public fun get_expected_output(plan: &RoutingPlan): u64 {
    plan.expected_output
}

public fun get_num_pools(plan: &RoutingPlan): u64 {
    vector::length(&plan.amounts_per_pool)
}

// === Constructor for PoolState ===

public fun new_pool_state(
    pool_index: u64,
    asset_reserve: u64,
    stable_reserve: u64,
    fee_bps: u64,
): PoolState {
    PoolState {
        pool_index,
        asset_reserve,
        stable_reserve,
        fee_bps,
    }
}
/// ============================================================================
/// SWAP POSITION REGISTRY - DEX AGGREGATOR COMPATIBILITY
/// ============================================================================
///
/// Solves the problem of returning multiple conditional coin types from swaps
/// during active proposals. Standard DEX aggregators expect:
///   Input: 1 coin type (e.g., USDC)
///   Output: 1 coin type (e.g., SUI)
///
/// But optimal routing through conditional pools returns N different types:
///   Input: USDC
///   Output: Cond0_SUI + Cond1_SUI + ... (multiple conditional types)
///
/// SOLUTION:
/// 1. Store conditional coins in shared registry (no transfer = maintains PTB composability)
/// 2. Smart recombination: convert as much as possible to spot immediately
/// 3. Store only remainder that can't be recombined
/// 4. Permissionless crank after proposal resolves to settle positions
///
/// ARCHITECTURE:
/// - Shared SwapPositionRegistry (single global object per asset/stable pair)
/// - Positions indexed by (user_address, proposal_id)
/// - Conditional coins stored as dynamic fields on position UIDs
/// - Automatic merging when same user swaps multiple times
/// - Auto-cleanup after cranking (storage rebate)
///
/// FALLBACK MECHANISM:
/// - If registry gets too large (gas concerns), use `use_registry: false`
/// - Coins transfer directly to user (opt-out for advanced traders)
///
/// ============================================================================

module futarchy_markets::swap_position_registry;

use futarchy_markets::proposal::Proposal;
use futarchy_markets::coin_escrow::TokenEscrow;
use futarchy_one_shot_utils::math;
use sui::coin::{Self, Coin};
use sui::table::{Self, Table};
use sui::dynamic_field;
use sui::clock::Clock;
use sui::event;

// === Errors ===
const EPositionNotFound: u64 = 0;
const EProposalNotFinalized: u64 = 1;
const ENotOwner: u64 = 2;
const EPositionAlreadyExists: u64 = 3;
const EZeroAmount: u64 = 4;
const EInvalidOutcome: u64 = 5;
const ENoConditionalCoins: u64 = 6;
const ENoCrankerFeeForSelfRedeem: u64 = 7;

// === Structs ===

/// Shared registry storing all swap-generated conditional positions
/// One registry per asset/stable pair (created with markets)
public struct SwapPositionRegistry<phantom AssetType, phantom StableType> has key {
    id: UID,
    // Map: PositionKey → UID (the UID stores position data as dynamic fields)
    positions: Table<PositionKey, UID>,
    total_positions: u64,  // Metrics
    total_cranked: u64,
}

/// Composite key for indexing positions
public struct PositionKey has store, copy, drop {
    owner: address,
    proposal_id: ID,
}

/// Keys for storing conditional coins in dynamic fields on position UID
/// We store coins directly on the UID as dynamic fields:
/// - AssetOutcomeKey { outcome_index } → Coin<ConditionalAssetType>
/// - StableOutcomeKey { outcome_index } → Coin<ConditionalStableType>
public struct AssetOutcomeKey has store, copy, drop {
    outcome_index: u64,
}

public struct StableOutcomeKey has store, copy, drop {
    outcome_index: u64,
}

/// Metadata stored on position UID (as dynamic field with MetadataKey)
public struct MetadataKey has store, copy, drop {}

public struct PositionMetadata has store {
    created_at: u64,
    last_updated: u64,
    has_asset_outcome_0: bool,
    has_asset_outcome_1: bool,
    has_stable_outcome_0: bool,
    has_stable_outcome_1: bool,
}

// === Events ===

public struct SwapPositionCreated has copy, drop {
    owner: address,
    proposal_id: ID,
    timestamp: u64,
}

public struct SwapPositionUpdated has copy, drop {
    owner: address,
    proposal_id: ID,
    timestamp: u64,
}

public struct SwapPositionCranked has copy, drop {
    owner: address,
    proposal_id: ID,
    winning_outcome: u64,
    spot_asset_returned: u64,
    spot_stable_returned: u64,
    cranker: address,
    cranker_fee: u64,
    timestamp: u64,
}

public struct BatchCrankCompleted has copy, drop {
    proposal_id: ID,
    positions_processed: u64,
    positions_succeeded: u64,
    positions_failed: u64,
    total_fees_earned: u64,
    cranker: address,
    timestamp: u64,
}

public struct PositionCrankFailed has copy, drop {
    owner: address,
    proposal_id: ID,
    reason: u64,  // Error code
    timestamp: u64,
}

// === Public Functions ===

/// Create a new swap position registry (called when market is created)
public fun new<AssetType, StableType>(
    ctx: &mut TxContext,
): SwapPositionRegistry<AssetType, StableType> {
    SwapPositionRegistry {
        id: object::new(ctx),
        positions: table::new(ctx),
        total_positions: 0,
        total_cranked: 0,
    }
}

/// Store conditional asset coins in registry
/// If position exists, merge; otherwise create new
/// Returns true if new position created, false if merged
public fun store_conditional_asset<AssetType, StableType, ConditionalCoinType>(
    registry: &mut SwapPositionRegistry<AssetType, StableType>,
    owner: address,
    proposal_id: ID,
    outcome_index: u64,
    conditional_coin: Coin<ConditionalCoinType>,
    clock: &Clock,
    ctx: &mut TxContext,
): bool {
    let amount = conditional_coin.value();
    assert!(amount > 0, EZeroAmount);

    let key = PositionKey { owner, proposal_id };
    let timestamp = clock.timestamp_ms();

    if (table::contains(&registry.positions, key)) {
        // Merge with existing position
        let position_uid = table::borrow_mut(&mut registry.positions, key);
        merge_asset_coin(position_uid, outcome_index, conditional_coin);

        // Update metadata
        let metadata: &mut PositionMetadata = dynamic_field::borrow_mut(position_uid, MetadataKey {});
        metadata.last_updated = timestamp;
        if (outcome_index == 0) {
            metadata.has_asset_outcome_0 = true;
        } else {
            metadata.has_asset_outcome_1 = true;
        };

        event::emit(SwapPositionUpdated { owner, proposal_id, timestamp });
        false  // Merged, not created
    } else {
        // Create new position
        let mut position_uid = object::new(ctx);

        // Add coin as dynamic field
        let asset_key = AssetOutcomeKey { outcome_index };
        dynamic_field::add(&mut position_uid, asset_key, conditional_coin);

        // Add metadata
        let mut metadata = PositionMetadata {
            created_at: timestamp,
            last_updated: timestamp,
            has_asset_outcome_0: false,
            has_asset_outcome_1: false,
            has_stable_outcome_0: false,
            has_stable_outcome_1: false,
        };
        if (outcome_index == 0) {
            metadata.has_asset_outcome_0 = true;
        } else {
            metadata.has_asset_outcome_1 = true;
        };
        dynamic_field::add(&mut position_uid, MetadataKey {}, metadata);

        table::add(&mut registry.positions, key, position_uid);
        registry.total_positions = registry.total_positions + 1;

        event::emit(SwapPositionCreated { owner, proposal_id, timestamp });
        true  // Created new
    }
}

/// Store conditional stable coins in registry
public fun store_conditional_stable<AssetType, StableType, ConditionalCoinType>(
    registry: &mut SwapPositionRegistry<AssetType, StableType>,
    owner: address,
    proposal_id: ID,
    outcome_index: u64,
    conditional_coin: Coin<ConditionalCoinType>,
    clock: &Clock,
    ctx: &mut TxContext,
): bool {
    let amount = conditional_coin.value();
    assert!(amount > 0, EZeroAmount);

    let key = PositionKey { owner, proposal_id };
    let timestamp = clock.timestamp_ms();

    if (table::contains(&registry.positions, key)) {
        // Merge with existing position
        let position_uid = table::borrow_mut(&mut registry.positions, key);
        merge_stable_coin(position_uid, outcome_index, conditional_coin);

        // Update metadata
        let metadata: &mut PositionMetadata = dynamic_field::borrow_mut(position_uid, MetadataKey {});
        metadata.last_updated = timestamp;
        if (outcome_index == 0) {
            metadata.has_stable_outcome_0 = true;
        } else {
            metadata.has_stable_outcome_1 = true;
        };

        event::emit(SwapPositionUpdated { owner, proposal_id, timestamp });
        false  // Merged
    } else {
        // Create new position
        let mut position_uid = object::new(ctx);

        // Add coin as dynamic field
        let stable_key = StableOutcomeKey { outcome_index };
        dynamic_field::add(&mut position_uid, stable_key, conditional_coin);

        // Add metadata
        let mut metadata = PositionMetadata {
            created_at: timestamp,
            last_updated: timestamp,
            has_asset_outcome_0: false,
            has_asset_outcome_1: false,
            has_stable_outcome_0: false,
            has_stable_outcome_1: false,
        };
        if (outcome_index == 0) {
            metadata.has_stable_outcome_0 = true;
        } else {
            metadata.has_stable_outcome_1 = true;
        };
        dynamic_field::add(&mut position_uid, MetadataKey {}, metadata);

        table::add(&mut registry.positions, key, position_uid);
        registry.total_positions = registry.total_positions + 1;

        event::emit(SwapPositionCreated { owner, proposal_id, timestamp });
        true  // Created new
    }
}

/// Crank a position after proposal resolves (permissionless)
/// Burns losing conditional coins, recombines winner to spot, pays cranker fee
/// Generic version - caller must know outcome count and provide burn/extract closures
///
/// NOTE: Due to Move's type system limitations, we can't iterate over arbitrary conditional
/// coin types at runtime. The frontend/SDK knows the outcome count and conditional coin types,
/// so they should call type-specific crank functions (crank_position_2, crank_position_3, etc.)
public fun crank_position_generic<AssetType, StableType>(
    registry: &mut SwapPositionRegistry<AssetType, StableType>,
    owner: address,
    proposal: &Proposal<AssetType, StableType>,
    escrow: &mut TokenEscrow<AssetType, StableType>,
    // Closures to extract and burn coins for each outcome
    // Frontend provides these based on known conditional coin types
    extract_and_burn_losers: vector<u64>,  // Outcome indices to burn
    extract_winner: u64,  // Winning outcome index
    cranker_fee_bps: u64,
    clock: &Clock,
    ctx: &mut TxContext,
): (u64, u64) {  // Returns (asset_returned, stable_returned)
    let proposal_id = object::id(proposal);
    let key = PositionKey { owner, proposal_id };

    assert!(table::contains(&registry.positions, key), EPositionNotFound);
    assert!(futarchy_markets::proposal::is_finalized(proposal), EProposalNotFinalized);

    let winning_outcome = futarchy_markets::proposal::get_winning_outcome(proposal);
    let mut position_uid = table::remove(&mut registry.positions, key);
    let metadata: PositionMetadata = dynamic_field::remove(&mut position_uid, MetadataKey {});

    // NOTE: Actual burning of conditional coins must happen in type-specific wrappers
    // This is a limitation of Move's type system - we can't dynamically dispatch on coin types

    // For now, delete position and return (type-specific functions handle coin extraction)
    object::delete(position_uid);
    registry.total_positions = registry.total_positions - 1;
    registry.total_cranked = registry.total_cranked + 1;

    (0, 0)  // Placeholder - type-specific functions return actual amounts
}

/// Crank a 2-outcome position (most common case)
public entry fun crank_position_2<AssetType, StableType, Cond0Asset, Cond1Asset, Cond0Stable, Cond1Stable>(
    registry: &mut SwapPositionRegistry<AssetType, StableType>,
    owner: address,
    proposal: &Proposal<AssetType, StableType>,
    escrow: &mut TokenEscrow<AssetType, StableType>,
    cranker_fee_bps: u64,
    clock: &Clock,
    ctx: &mut TxContext,
) {
    let proposal_id = object::id(proposal);
    let key = PositionKey { owner, proposal_id };
    assert!(table::contains(&registry.positions, key), EPositionNotFound);
    assert!(futarchy_markets::proposal::is_finalized(proposal), EProposalNotFinalized);

    let winning_outcome = futarchy_markets::proposal::get_winning_outcome(proposal);
    let mut position_uid = table::remove(&mut registry.positions, key);
    let metadata: PositionMetadata = dynamic_field::remove(&mut position_uid, MetadataKey {});

    let asset_0 = extract_asset_coin<Cond0Asset>(&mut position_uid, 0, ctx);
    let asset_1 = extract_asset_coin<Cond1Asset>(&mut position_uid, 1, ctx);
    let stable_0 = extract_stable_coin<Cond0Stable>(&mut position_uid, 0, ctx);
    let stable_1 = extract_stable_coin<Cond1Stable>(&mut position_uid, 1, ctx);

    let (winning_asset, winning_stable) = if (winning_outcome == 0) {
        if (asset_1.value() > 0) {
            futarchy_markets::coin_escrow::burn_conditional_asset(escrow, 1, asset_1);
        } else { coin::destroy_zero(asset_1); };
        if (stable_1.value() > 0) {
            futarchy_markets::coin_escrow::burn_conditional_stable(escrow, 1, stable_1);
        } else { coin::destroy_zero(stable_1); };
        (asset_0, stable_0)
    } else {
        if (asset_0.value() > 0) {
            futarchy_markets::coin_escrow::burn_conditional_asset(escrow, 0, asset_0);
        } else { coin::destroy_zero(asset_0); };
        if (stable_0.value() > 0) {
            futarchy_markets::coin_escrow::burn_conditional_stable(escrow, 0, stable_0);
        } else { coin::destroy_zero(stable_0); };
        (asset_1, stable_1)
    };

    let asset_amount = winning_asset.value();
    let stable_amount = winning_stable.value();

    let mut spot_asset = if (asset_amount > 0) {
        futarchy_markets::coin_escrow::burn_conditional_asset(escrow, winning_outcome, winning_asset);
        futarchy_markets::coin_escrow::withdraw_asset_balance<AssetType, StableType>(escrow, asset_amount, ctx)
    } else {
        coin::destroy_zero(winning_asset);
        coin::zero<AssetType>(ctx)
    };

    let spot_stable = if (stable_amount > 0) {
        futarchy_markets::coin_escrow::burn_conditional_stable(escrow, winning_outcome, winning_stable);
        futarchy_markets::coin_escrow::withdraw_stable_balance<AssetType, StableType>(escrow, stable_amount, ctx)
    } else {
        coin::destroy_zero(winning_stable);
        coin::zero<StableType>(ctx)
    };

    let cranker_fee = if (cranker_fee_bps > 0 && asset_amount > 0) {
        let fee_amount = (asset_amount * cranker_fee_bps) / 10000;
        if (fee_amount > 0) {
            let fee_coin = spot_asset.split(fee_amount, ctx);
            transfer::public_transfer(fee_coin, ctx.sender());
            fee_amount
        } else { 0 }
    } else { 0 };

    if (spot_asset.value() > 0) {
        transfer::public_transfer(spot_asset, owner);
    } else { coin::destroy_zero(spot_asset); };

    if (spot_stable.value() > 0) {
        transfer::public_transfer(spot_stable, owner);
    } else { coin::destroy_zero(spot_stable); };

    object::delete(position_uid);
    registry.total_positions = registry.total_positions - 1;
    registry.total_cranked = registry.total_cranked + 1;

    event::emit(SwapPositionCranked {
        owner, proposal_id, winning_outcome,
        spot_asset_returned: asset_amount - cranker_fee,
        spot_stable_returned: stable_amount,
        cranker: ctx.sender(), cranker_fee,
        timestamp: clock.timestamp_ms(),
    });
}

/// Crank a 3-outcome position
public entry fun crank_position_3<AssetType, StableType,
    Cond0Asset, Cond1Asset, Cond2Asset,
    Cond0Stable, Cond1Stable, Cond2Stable>(
    registry: &mut SwapPositionRegistry<AssetType, StableType>,
    owner: address,
    proposal: &Proposal<AssetType, StableType>,
    escrow: &mut TokenEscrow<AssetType, StableType>,
    cranker_fee_bps: u64,
    clock: &Clock,
    ctx: &mut TxContext,
) {
    let proposal_id = object::id(proposal);
    let key = PositionKey { owner, proposal_id };
    assert!(table::contains(&registry.positions, key), EPositionNotFound);
    assert!(futarchy_markets::proposal::is_finalized(proposal), EProposalNotFinalized);

    let winning_outcome = futarchy_markets::proposal::get_winning_outcome(proposal);
    let mut position_uid = table::remove(&mut registry.positions, key);
    let metadata: PositionMetadata = dynamic_field::remove(&mut position_uid, MetadataKey {});

    // Extract all outcome coins
    let asset_0 = extract_asset_coin<Cond0Asset>(&mut position_uid, 0, ctx);
    let asset_1 = extract_asset_coin<Cond1Asset>(&mut position_uid, 1, ctx);
    let asset_2 = extract_asset_coin<Cond2Asset>(&mut position_uid, 2, ctx);
    let stable_0 = extract_stable_coin<Cond0Stable>(&mut position_uid, 0, ctx);
    let stable_1 = extract_stable_coin<Cond1Stable>(&mut position_uid, 1, ctx);
    let stable_2 = extract_stable_coin<Cond2Stable>(&mut position_uid, 2, ctx);

    // Burn losers, keep winner
    let (winning_asset, winning_stable) = if (winning_outcome == 0) {
        burn_if_nonzero(escrow, 1, asset_1, stable_1);
        burn_if_nonzero(escrow, 2, asset_2, stable_2);
        (asset_0, stable_0)
    } else if (winning_outcome == 1) {
        burn_if_nonzero(escrow, 0, asset_0, stable_0);
        burn_if_nonzero(escrow, 2, asset_2, stable_2);
        (asset_1, stable_1)
    } else {
        burn_if_nonzero(escrow, 0, asset_0, stable_0);
        burn_if_nonzero(escrow, 1, asset_1, stable_1);
        (asset_2, stable_2)
    };

    // Convert winner to spot and pay fee (same logic as crank_position_2)
    let (spot_asset, spot_stable, cranker_fee) = convert_to_spot_and_pay_fee(
        escrow, winning_outcome, winning_asset, winning_stable, cranker_fee_bps, owner, ctx
    );

    object::delete(position_uid);
    registry.total_positions = registry.total_positions - 1;
    registry.total_cranked = registry.total_cranked + 1;

    event::emit(SwapPositionCranked {
        owner, proposal_id, winning_outcome,
        spot_asset_returned: spot_asset,
        spot_stable_returned: spot_stable,
        cranker: ctx.sender(), cranker_fee,
        timestamp: clock.timestamp_ms(),
    });
}

/// Helper: Burn conditional coins if non-zero
fun burn_if_nonzero<AssetType, StableType, AssetCond, StableCond>(
    escrow: &mut TokenEscrow<AssetType, StableType>,
    outcome_idx: u64,
    asset: Coin<AssetCond>,
    stable: Coin<StableCond>,
) {
    if (asset.value() > 0) {
        futarchy_markets::coin_escrow::burn_conditional_asset(escrow, outcome_idx, asset);
    } else { coin::destroy_zero(asset); };
    if (stable.value() > 0) {
        futarchy_markets::coin_escrow::burn_conditional_stable(escrow, outcome_idx, stable);
    } else { coin::destroy_zero(stable); };
}

/// Helper: Convert winning conditional to spot, pay fee, transfer
fun convert_to_spot_and_pay_fee<AssetType, StableType, AssetCond, StableCond>(
    escrow: &mut TokenEscrow<AssetType, StableType>,
    winning_outcome: u64,
    winning_asset: Coin<AssetCond>,
    winning_stable: Coin<StableCond>,
    cranker_fee_bps: u64,
    owner: address,
    ctx: &mut TxContext,
): (u64, u64, u64) {  // (asset_returned, stable_returned, fee_paid)
    let asset_amount = winning_asset.value();
    let stable_amount = winning_stable.value();

    let mut spot_asset = if (asset_amount > 0) {
        futarchy_markets::coin_escrow::burn_conditional_asset(escrow, winning_outcome, winning_asset);
        futarchy_markets::coin_escrow::withdraw_asset_balance<AssetType, StableType>(escrow, asset_amount, ctx)
    } else {
        coin::destroy_zero(winning_asset);
        coin::zero<AssetType>(ctx)
    };

    let spot_stable = if (stable_amount > 0) {
        futarchy_markets::coin_escrow::burn_conditional_stable(escrow, winning_outcome, winning_stable);
        futarchy_markets::coin_escrow::withdraw_stable_balance<AssetType, StableType>(escrow, stable_amount, ctx)
    } else {
        coin::destroy_zero(winning_stable);
        coin::zero<StableType>(ctx)
    };

    let cranker_fee = if (cranker_fee_bps > 0 && asset_amount > 0) {
        let fee_amount = (asset_amount * cranker_fee_bps) / 10000;
        if (fee_amount > 0) {
            let fee_coin = spot_asset.split(fee_amount, ctx);
            transfer::public_transfer(fee_coin, ctx.sender());
            fee_amount
        } else { 0 }
    } else { 0 };

    let final_asset = spot_asset.value();
    let final_stable = spot_stable.value();

    if (final_asset > 0) {
        transfer::public_transfer(spot_asset, owner);
    } else { coin::destroy_zero(spot_asset); };

    if (final_stable > 0) {
        transfer::public_transfer(spot_stable, owner);
    } else { coin::destroy_zero(spot_stable); };

    (final_asset, final_stable, cranker_fee)
}

/// Self-redeem 2-outcome position (no fee)
public entry fun self_redeem_position_2<AssetType, StableType, Cond0Asset, Cond1Asset, Cond0Stable, Cond1Stable>(
    registry: &mut SwapPositionRegistry<AssetType, StableType>,
    proposal: &Proposal<AssetType, StableType>,
    escrow: &mut TokenEscrow<AssetType, StableType>,
    clock: &Clock,
    ctx: &mut TxContext,
) {
    let owner = ctx.sender();
    crank_position_2<AssetType, StableType, Cond0Asset, Cond1Asset, Cond0Stable, Cond1Stable>(
        registry, owner, proposal, escrow, 0, clock, ctx
    );
}

/// Self-redeem 3-outcome position (no fee)
public entry fun self_redeem_position_3<AssetType, StableType,
    Cond0Asset, Cond1Asset, Cond2Asset,
    Cond0Stable, Cond1Stable, Cond2Stable>(
    registry: &mut SwapPositionRegistry<AssetType, StableType>,
    proposal: &Proposal<AssetType, StableType>,
    escrow: &mut TokenEscrow<AssetType, StableType>,
    clock: &Clock,
    ctx: &mut TxContext,
) {
    let owner = ctx.sender();
    crank_position_3<AssetType, StableType, Cond0Asset, Cond1Asset, Cond2Asset, Cond0Stable, Cond1Stable, Cond2Stable>(
        registry, owner, proposal, escrow, 0, clock, ctx
    );
}

// === Batch Cranking Functions (Gas Optimization) ===

/// Batch crank multiple 2-outcome positions in a single transaction
/// This is MUCH more gas-efficient than cranking individually
///
/// Gas savings:
/// - Individual: ~500K gas per crank = 5M gas for 10 positions
/// - Batch: ~2M gas for 10 positions (60% savings)
///
/// Limits:
/// - Max ~100-200 positions per transaction (depending on gas limit)
/// - Sui limit: 1000 objects accessed per transaction
///
/// Error handling:
/// - Continues processing on individual failures
/// - Emits PositionCrankFailed event for each failure
/// - Returns total succeeded/failed counts
public entry fun batch_crank_positions_2<AssetType, StableType, Cond0Asset, Cond1Asset, Cond0Stable, Cond1Stable>(
    registry: &mut SwapPositionRegistry<AssetType, StableType>,
    owners: vector<address>,
    proposal: &Proposal<AssetType, StableType>,
    escrow: &mut TokenEscrow<AssetType, StableType>,
    cranker_fee_bps: u64,
    clock: &Clock,
    ctx: &mut TxContext,
) {
    let proposal_id = object::id(proposal);
    let timestamp = clock.timestamp_ms();
    let winning_outcome = futarchy_markets::proposal::get_winning_outcome(proposal);

    let mut total_fees = 0u64;
    let mut succeeded = 0u64;
    let mut failed = 0u64;
    let batch_size = vector::length(&owners);

    let mut i = 0;
    while (i < batch_size) {
        let owner = *vector::borrow(&owners, i);
        let key = PositionKey { owner, proposal_id };

        // Check if position exists
        if (!table::contains(&registry.positions, key)) {
            event::emit(PositionCrankFailed {
                owner,
                proposal_id,
                reason: EPositionNotFound,
                timestamp,
            });
            failed = failed + 1;
            i = i + 1;
            continue
        };

        // Extract position
        let mut position_uid = table::remove(&mut registry.positions, key);
        let metadata: PositionMetadata = dynamic_field::remove(&mut position_uid, MetadataKey {});

        // Extract conditional coins
        let asset_0 = extract_asset_coin<Cond0Asset>(&mut position_uid, 0, ctx);
        let asset_1 = extract_asset_coin<Cond1Asset>(&mut position_uid, 1, ctx);
        let stable_0 = extract_stable_coin<Cond0Stable>(&mut position_uid, 0, ctx);
        let stable_1 = extract_stable_coin<Cond1Stable>(&mut position_uid, 1, ctx);

        // Burn losers, keep winner
        let (winning_asset, winning_stable) = if (winning_outcome == 0) {
            burn_if_nonzero(escrow, 1, asset_1, stable_1);
            (asset_0, stable_0)
        } else {
            burn_if_nonzero(escrow, 0, asset_0, stable_0);
            (asset_1, stable_1)
        };

        let asset_amount = winning_asset.value();
        let stable_amount = winning_stable.value();

        // Convert to spot
        let mut spot_asset = if (asset_amount > 0) {
            futarchy_markets::coin_escrow::burn_conditional_asset(escrow, winning_outcome, winning_asset);
            futarchy_markets::coin_escrow::withdraw_asset_balance<AssetType, StableType>(escrow, asset_amount, ctx)
        } else {
            coin::destroy_zero(winning_asset);
            coin::zero<AssetType>(ctx)
        };

        let spot_stable = if (stable_amount > 0) {
            futarchy_markets::coin_escrow::burn_conditional_stable(escrow, winning_outcome, winning_stable);
            futarchy_markets::coin_escrow::withdraw_stable_balance<AssetType, StableType>(escrow, stable_amount, ctx)
        } else {
            coin::destroy_zero(winning_stable);
            coin::zero<StableType>(ctx)
        };

        // Calculate fee and accumulate
        let position_fee = if (cranker_fee_bps > 0 && asset_amount > 0) {
            let fee_amount = (asset_amount * cranker_fee_bps) / 10000;
            if (fee_amount > 0) {
                let fee_coin = spot_asset.split(fee_amount, ctx);
                // Don't transfer yet - accumulate in total_fees
                transfer::public_transfer(fee_coin, ctx.sender());
                fee_amount
            } else { 0 }
        } else { 0 };

        total_fees = total_fees + position_fee;

        // Transfer spot to owner
        if (spot_asset.value() > 0) {
            transfer::public_transfer(spot_asset, owner);
        } else { coin::destroy_zero(spot_asset); };

        if (spot_stable.value() > 0) {
            transfer::public_transfer(spot_stable, owner);
        } else { coin::destroy_zero(spot_stable); };

        // Cleanup
        object::delete(position_uid);
        registry.total_positions = registry.total_positions - 1;
        registry.total_cranked = registry.total_cranked + 1;

        // Emit individual event
        event::emit(SwapPositionCranked {
            owner,
            proposal_id,
            winning_outcome,
            spot_asset_returned: asset_amount - position_fee,
            spot_stable_returned: stable_amount,
            cranker: ctx.sender(),
            cranker_fee: position_fee,
            timestamp,
        });

        succeeded = succeeded + 1;
        i = i + 1;
    };

    // Emit batch summary event
    event::emit(BatchCrankCompleted {
        proposal_id,
        positions_processed: batch_size,
        positions_succeeded: succeeded,
        positions_failed: failed,
        total_fees_earned: total_fees,
        cranker: ctx.sender(),
        timestamp,
    });
}

/// Batch crank multiple 3-outcome positions
public entry fun batch_crank_positions_3<AssetType, StableType,
    Cond0Asset, Cond1Asset, Cond2Asset,
    Cond0Stable, Cond1Stable, Cond2Stable>(
    registry: &mut SwapPositionRegistry<AssetType, StableType>,
    owners: vector<address>,
    proposal: &Proposal<AssetType, StableType>,
    escrow: &mut TokenEscrow<AssetType, StableType>,
    cranker_fee_bps: u64,
    clock: &Clock,
    ctx: &mut TxContext,
) {
    let proposal_id = object::id(proposal);
    let timestamp = clock.timestamp_ms();
    let winning_outcome = futarchy_markets::proposal::get_winning_outcome(proposal);

    let mut total_fees = 0u64;
    let mut succeeded = 0u64;
    let mut failed = 0u64;
    let batch_size = vector::length(&owners);

    let mut i = 0;
    while (i < batch_size) {
        let owner = *vector::borrow(&owners, i);
        let key = PositionKey { owner, proposal_id };

        if (!table::contains(&registry.positions, key)) {
            event::emit(PositionCrankFailed {
                owner, proposal_id,
                reason: EPositionNotFound,
                timestamp,
            });
            failed = failed + 1;
            i = i + 1;
            continue
        };

        let mut position_uid = table::remove(&mut registry.positions, key);
        let metadata: PositionMetadata = dynamic_field::remove(&mut position_uid, MetadataKey {});

        // Extract all outcome coins
        let asset_0 = extract_asset_coin<Cond0Asset>(&mut position_uid, 0, ctx);
        let asset_1 = extract_asset_coin<Cond1Asset>(&mut position_uid, 1, ctx);
        let asset_2 = extract_asset_coin<Cond2Asset>(&mut position_uid, 2, ctx);
        let stable_0 = extract_stable_coin<Cond0Stable>(&mut position_uid, 0, ctx);
        let stable_1 = extract_stable_coin<Cond1Stable>(&mut position_uid, 1, ctx);
        let stable_2 = extract_stable_coin<Cond2Stable>(&mut position_uid, 2, ctx);

        // Burn losers, keep winner
        let (winning_asset, winning_stable) = if (winning_outcome == 0) {
            burn_if_nonzero(escrow, 1, asset_1, stable_1);
            burn_if_nonzero(escrow, 2, asset_2, stable_2);
            (asset_0, stable_0)
        } else if (winning_outcome == 1) {
            burn_if_nonzero(escrow, 0, asset_0, stable_0);
            burn_if_nonzero(escrow, 2, asset_2, stable_2);
            (asset_1, stable_1)
        } else {
            burn_if_nonzero(escrow, 0, asset_0, stable_0);
            burn_if_nonzero(escrow, 1, asset_1, stable_1);
            (asset_2, stable_2)
        };

        let asset_amount = winning_asset.value();
        let stable_amount = winning_stable.value();

        let mut spot_asset = if (asset_amount > 0) {
            futarchy_markets::coin_escrow::burn_conditional_asset(escrow, winning_outcome, winning_asset);
            futarchy_markets::coin_escrow::withdraw_asset_balance<AssetType, StableType>(escrow, asset_amount, ctx)
        } else {
            coin::destroy_zero(winning_asset);
            coin::zero<AssetType>(ctx)
        };

        let spot_stable = if (stable_amount > 0) {
            futarchy_markets::coin_escrow::burn_conditional_stable(escrow, winning_outcome, winning_stable);
            futarchy_markets::coin_escrow::withdraw_stable_balance<AssetType, StableType>(escrow, stable_amount, ctx)
        } else {
            coin::destroy_zero(winning_stable);
            coin::zero<StableType>(ctx)
        };

        let position_fee = if (cranker_fee_bps > 0 && asset_amount > 0) {
            let fee_amount = (asset_amount * cranker_fee_bps) / 10000;
            if (fee_amount > 0) {
                let fee_coin = spot_asset.split(fee_amount, ctx);
                transfer::public_transfer(fee_coin, ctx.sender());
                fee_amount
            } else { 0 }
        } else { 0 };

        total_fees = total_fees + position_fee;

        if (spot_asset.value() > 0) {
            transfer::public_transfer(spot_asset, owner);
        } else { coin::destroy_zero(spot_asset); };

        if (spot_stable.value() > 0) {
            transfer::public_transfer(spot_stable, owner);
        } else { coin::destroy_zero(spot_stable); };

        object::delete(position_uid);
        registry.total_positions = registry.total_positions - 1;
        registry.total_cranked = registry.total_cranked + 1;

        event::emit(SwapPositionCranked {
            owner, proposal_id, winning_outcome,
            spot_asset_returned: asset_amount - position_fee,
            spot_stable_returned: stable_amount,
            cranker: ctx.sender(),
            cranker_fee: position_fee,
            timestamp,
        });

        succeeded = succeeded + 1;
        i = i + 1;
    };

    event::emit(BatchCrankCompleted {
        proposal_id,
        positions_processed: batch_size,
        positions_succeeded: succeeded,
        positions_failed: failed,
        total_fees_earned: total_fees,
        cranker: ctx.sender(),
        timestamp,
    });
}

// === Internal Helpers ===

/// Merge asset coin into existing position
fun merge_asset_coin<ConditionalCoinType>(
    position_uid: &mut UID,
    outcome_index: u64,
    coin: Coin<ConditionalCoinType>,
) {
    let asset_key = AssetOutcomeKey { outcome_index };

    if (dynamic_field::exists_(position_uid, asset_key)) {
        // Merge with existing coin
        let existing_coin: &mut Coin<ConditionalCoinType> =
            dynamic_field::borrow_mut(position_uid, asset_key);
        existing_coin.join(coin);
    } else {
        // Add new coin
        dynamic_field::add(position_uid, asset_key, coin);
    };
}

/// Merge stable coin into existing position
fun merge_stable_coin<ConditionalCoinType>(
    position_uid: &mut UID,
    outcome_index: u64,
    coin: Coin<ConditionalCoinType>,
) {
    let stable_key = StableOutcomeKey { outcome_index };

    if (dynamic_field::exists_(position_uid, stable_key)) {
        // Merge with existing coin
        let existing_coin: &mut Coin<ConditionalCoinType> =
            dynamic_field::borrow_mut(position_uid, stable_key);
        existing_coin.join(coin);
    } else {
        // Add new coin
        dynamic_field::add(position_uid, stable_key, coin);
    };
}

/// Extract asset coin for a specific outcome (returns zero coin if doesn't exist)
fun extract_asset_coin<ConditionalCoinType>(
    position_uid: &mut UID,
    outcome_index: u64,
    ctx: &mut TxContext,
): Coin<ConditionalCoinType> {
    let asset_key = AssetOutcomeKey { outcome_index };

    if (dynamic_field::exists_(position_uid, asset_key)) {
        dynamic_field::remove(position_uid, asset_key)
    } else {
        // No coin for this outcome - return zero
        coin::zero<ConditionalCoinType>(ctx)
    }
}

/// Extract stable coin for a specific outcome
fun extract_stable_coin<ConditionalCoinType>(
    position_uid: &mut UID,
    outcome_index: u64,
    ctx: &mut TxContext,
): Coin<ConditionalCoinType> {
    let stable_key = StableOutcomeKey { outcome_index };

    if (dynamic_field::exists_(position_uid, stable_key)) {
        dynamic_field::remove(position_uid, stable_key)
    } else {
        coin::zero<ConditionalCoinType>(ctx)
    }
}

// === Cranking Economics & Priority Helpers ===

/// Estimate cranking profit for a batch of positions
/// Returns: (total_fees_estimate, recommended_batch_size)
///
/// This helps crankers decide if it's profitable to crank given gas costs
/// Gas cost on Sui: ~2M gas units for batch of 10 = ~0.002 SUI
/// Profitable if total_fees > gas_cost
public fun estimate_batch_cranking_profit(
    position_count: u64,
    avg_position_value_usd: u64,  // Estimated avg value in USD (6 decimals)
    cranker_fee_bps: u64,
    gas_price_sui: u64,  // Current gas price in nanoSUI
): (u64, u64) {  // (estimated_profit_usd, recommended_batch_size)
    // Estimate total fees
    let total_value = position_count * avg_position_value_usd;
    let total_fees = (total_value * cranker_fee_bps) / 10000;

    // Estimate gas cost (simplified)
    // ~200K gas per position + 500K base
    let gas_units = 500000 + (position_count * 200000);
    let gas_cost_nano_sui = gas_units * gas_price_sui;
    let gas_cost_sui = gas_cost_nano_sui / 1000000000;  // Convert to SUI

    // Assume 1 SUI = $1 for simplicity (should use oracle in production)
    let gas_cost_usd = gas_cost_sui;

    let profit = if (total_fees > gas_cost_usd) {
        total_fees - gas_cost_usd
    } else {
        0
    };

    // Recommend batch size that maximizes profit
    // Ideal: Process as many as possible while staying under 1K object limit
    let recommended_size = math::min(position_count, 100);  // Cap at 100 for safety

    (profit, recommended_size)
}

/// Calculate minimum position value worth cranking individually
/// Returns: minimum_value_usd (6 decimals)
///
/// Example: If gas costs $0.01 and fee is 0.1% (10 bps)
/// Minimum profitable position = $0.01 / 0.001 = $10
public fun minimum_profitable_position_value(
    gas_cost_usd: u64,
    cranker_fee_bps: u64,
): u64 {
    if (cranker_fee_bps == 0) return 0;

    // Break-even: position_value * (fee_bps / 10000) = gas_cost
    // position_value = gas_cost * 10000 / fee_bps
    (gas_cost_usd * 10000) / cranker_fee_bps
}

/// Check if individual position is profitable to crank
/// Useful for crankers to filter positions
public fun is_position_profitable_to_crank(
    estimated_position_value_usd: u64,
    cranker_fee_bps: u64,
    gas_cost_usd: u64,
): bool {
    let fee_earned = (estimated_position_value_usd * cranker_fee_bps) / 10000;
    fee_earned > gas_cost_usd
}

/// Get recommended cranker fee based on position size
/// Larger positions can afford lower fees (more competitive)
/// Smaller positions need higher fees to be profitable
public fun recommend_cranker_fee_bps(
    position_value_usd: u64,
    gas_cost_usd: u64,
): u64 {
    // Calculate minimum fee to break even
    let min_fee_bps = (gas_cost_usd * 10000) / position_value_usd;

    // Add 50% margin for profit
    let recommended = min_fee_bps + (min_fee_bps / 2);

    // Cap at reasonable max (e.g., 1% = 100 bps)
    if (recommended > 100) {
        100
    } else if (recommended < 5) {
        // Minimum 0.05% for competitive market
        5
    } else {
        recommended
    }
}

// === View Functions ===

/// Check if a position exists
public fun has_position<AssetType, StableType>(
    registry: &SwapPositionRegistry<AssetType, StableType>,
    owner: address,
    proposal_id: ID,
): bool {
    let key = PositionKey { owner, proposal_id };
    table::contains(&registry.positions, key)
}

/// Get total number of active positions in registry
public fun total_positions<AssetType, StableType>(
    registry: &SwapPositionRegistry<AssetType, StableType>,
): u64 {
    registry.total_positions
}

/// Get total number of positions that have been cranked
public fun total_cranked<AssetType, StableType>(
    registry: &SwapPositionRegistry<AssetType, StableType>,
): u64 {
    registry.total_cranked
}

/// Get cranking efficiency metrics (for cranker dashboards)
/// Returns: (total_active, total_cranked, success_rate_bps)
public fun get_cranking_metrics<AssetType, StableType>(
    registry: &SwapPositionRegistry<AssetType, StableType>,
): (u64, u64, u64) {
    let active = registry.total_positions;
    let cranked = registry.total_cranked;

    // Success rate in basis points (e.g., 9500 = 95%)
    let success_rate = if (cranked > 0) {
        10000  // Assume 100% success (failures not tracked separately yet)
    } else {
        0
    };

    (active, cranked, success_rate)
}

/// Share the registry (called after creation)
public fun share<AssetType, StableType>(
    registry: SwapPositionRegistry<AssetType, StableType>,
) {
    transfer::share_object(registry);
}
/// ============================================================================
/// SPOT AMM WITH BASE FAIR VALUE TWAP - CRITICAL ARCHITECTURE NOTES
/// ============================================================================
/// 
/// This is a specialized spot AMM designed for Hanson-style futarchy with quantum
/// liquidity splitting. The TWAP here serves as the "base fair value" price for
/// internal protocol functions like founder token minting based on price targets.
/// 
/// KEY ARCHITECTURAL DECISIONS:
/// 
/// 1. QUANTUM LIQUIDITY MODEL (Hanson Futarchy)
///    - When a proposal uses DAO liquidity, 1 spot dollar becomes 1 conditional 
///      dollar in EACH outcome (not split, but quantum - exists in all states)
///    - Spot pool becomes COMPLETELY EMPTY during these proposals
///    - Only the highest-priced conditional market determines the winner
/// 
/// 2. TWAP CONTINUITY ACROSS TRANSITIONS
///    The spot TWAP must maintain continuity even when liquidity moves to conditional AMMs:
///    
///    Timeline example:
///    [Spot Active: N seconds] → [Proposal Live: M seconds] → [Spot Active Again]
///    
///    - N could be >> M (spot active much longer than proposal)
///    - M could be >> N (long proposal, short spot history)
///    - We don't know relative durations in advance
/// 
/// 3. LOCKING MECHANISM
///    When proposal starts:
///    - Spot pool is LOCKED (last_proposal_usage timestamp set)
///    - No TWAP updates allowed while locked
///    - All liquidity moves to conditional AMMs
///    
///    During proposal (spot locked):
///    - get_twap() reads from WINNING conditional AMM (highest price)
///    - Adds conditional TWAP for the missing time period
///    - Maintains continuous price history
///    
///    When proposal ends:
///    - Winning conditional's TWAP fills the gap in spot history
///    - Pool unlocks and resumes normal operation
///    - Liquidity returns from winning conditional
/// 
/// 4. TWAP CALCULATION LOGIC
///    
///    Normal operation (no active proposal):
///    - Standard rolling 3-day window
///    - Accumulates price × time
///    - Updates on swaps and liquidity events
///    
///    During live proposal:
///    - Spot accumulator frozen at proposal start time
///    - get_twap() adds: winning_conditional_twap × time_since_proposal_start
///    - Returns combined TWAP over full window
///    
///    After proposal (hot path):
///    - fill_twap_gap_from_proposal() writes: winning_twap × proposal_duration
///    - Adds to window_cumulative_price permanently
///    - Resumes from winning conditional's final price
/// 
/// 5. NOT FOR EXTERNAL PROTOCOLS
///    This TWAP is NOT suitable for:
///    - Lending protocols (need continuous updates)
///    - External price oracles (too specialized)
///    - High-frequency trading (updates only on major events)
///    
///    It IS designed for:
///    - Founder token minting based on price milestones
///    - Long-term protocol health metrics
///    - Base fair value for protocol decisions
/// 
/// 6. SECURITY CONSIDERATIONS
///    - Manipulation requires attacking the WINNING conditional market
///    - Historical segments cannot be modified after writing
///    - Lock prevents TWAP updates during proposals (no double-counting)
///    - Window sliding uses last_window_twap (stable reference) not current price
/// 
/// ============================================================================

module futarchy_markets::spot_amm;

use std::option::{Self, Option};
use std::vector::{Self};
use sui::balance::{Self, Balance};
use sui::coin::{Self, Coin};
use sui::object::{Self, UID, ID};
use sui::transfer;
use sui::tx_context::{Self, TxContext};
use sui::clock::{Self, Clock};
use sui::event;
use futarchy_one_shot_utils::math;
use futarchy_markets::conditional_amm;
use futarchy_markets::simple_twap::{Self, SimpleTWAP};
use futarchy_one_shot_utils::constants;
use futarchy_markets::position_nft;

/// Data structure for passing conditional oracle information
/// (Move doesn't allow Option<&T>, so we pass values instead of references)
public struct ConditionalOracleData has copy, drop {
    window_cumulative: u256,
    window_start: u64,
    last_price: u128,
    last_timestamp: u64,
}

/// Helper to extract oracle data from SimpleTWAP
public fun extract_oracle_data(oracle: &SimpleTWAP): ConditionalOracleData {
    ConditionalOracleData {
        window_cumulative: simple_twap::window_cumulative_price(oracle),
        window_start: simple_twap::window_start_timestamp(oracle),
        last_price: simple_twap::last_price(oracle),
        last_timestamp: simple_twap::last_timestamp(oracle),
    }
}

// Basic errors
const EZeroAmount: u64 = 1;
const EInsufficientLiquidity: u64 = 2;
const ESlippageExceeded: u64 = 3;
const EInvalidFee: u64 = 4;
const EOverflow: u64 = 5;
const EImbalancedLiquidity: u64 = 6;
const ENotInitialized: u64 = 7;
const EAlreadyInitialized: u64 = 8;
const ETwapNotReady: u64 = 9;
const EPoolLockedForProposal: u64 = 10;
const EOracleTooStale: u64 = 11;

// MAX_FEE_BPS moved to constants module
const MINIMUM_LIQUIDITY: u64 = 1000;

// TWAP constants
const THREE_DAYS_MS: u64 = 259_200_000; // 3 days in milliseconds (3 * 24 * 60 * 60 * 1000)
const PRICE_SCALE: u128 = 1_000_000_000_000; // 10^12 for price precision

// Oracle staleness limit (1 hour)
const MAX_ORACLE_STALENESS_MS: u64 = 3_600_000;

// K-invariant error (guards constant-product invariant)
const EKInvariantViolation: u64 = 12;

/// Simple spot AMM for <AssetType, StableType> with SimpleTWAP oracle
public struct SpotAMM<phantom AssetType, phantom StableType> has key, store {
    id: UID,
    asset_reserve: Balance<AssetType>,
    stable_reserve: Balance<StableType>,
    lp_supply: u64,
    fee_bps: u64,
    // SimpleTWAP oracle for external consumers (lending protocols, etc.)
    simple_twap: Option<SimpleTWAP>,  // None until first liquidity added
    // Track when DAO liquidity was last used in a proposal
    last_proposal_usage: Option<u64>,
    // Protocol fees accumulated (in stable token)
    protocol_fees_stable: Balance<StableType>,
}

/// Event emitted when spot price updates
public struct SpotPriceUpdate has copy, drop {
    pool_id: ID,
    price: u128,
    timestamp: u64,
    asset_reserve: u64,
    stable_reserve: u64,
}

/// Event emitted when TWAP is updated
public struct SpotTwapUpdate has copy, drop {
    pool_id: ID,
    twap: u128,
    window_start: u64,
    window_end: u64,
}

/// Create a new pool (simple Uniswap V2 style)
public fun new<AssetType, StableType>(fee_bps: u64, ctx: &mut TxContext): SpotAMM<AssetType, StableType> {
    assert!(fee_bps <= constants::max_amm_fee_bps(), EInvalidFee);
    SpotAMM<AssetType, StableType> {
        id: object::new(ctx),
        asset_reserve: balance::zero<AssetType>(),
        stable_reserve: balance::zero<StableType>(),
        lp_supply: 0,
        fee_bps,
        simple_twap: option::none(),  // Initialize when first liquidity added
        last_proposal_usage: option::none(),
        protocol_fees_stable: balance::zero<StableType>(),
    }
}

/// Initialize SimpleTWAP oracle when first liquidity is added
fun initialize_twap<AssetType, StableType>(
    pool: &mut SpotAMM<AssetType, StableType>,
    clock: &Clock,
) {
    assert!(pool.simple_twap.is_none(), EAlreadyInitialized);

    // Calculate initial price from reserves
    let price = calculate_spot_price(
        pool.asset_reserve.value(),
        pool.stable_reserve.value()
    );

    // Create SimpleTWAP - Uniswap V2 style (no capping)
    let twap = simple_twap::new(price, clock);
    option::fill(&mut pool.simple_twap, twap);
}

/// Update SimpleTWAP oracle on price changes
fun update_twap<AssetType, StableType>(
    pool: &mut SpotAMM<AssetType, StableType>,
    clock: &Clock,
) {
    assert!(pool.simple_twap.is_some(), ENotInitialized);

    // Calculate current raw price from reserves
    let raw_price = calculate_spot_price(
        pool.asset_reserve.value(),
        pool.stable_reserve.value()
    );

    // Update SimpleTWAP (handles capping and accumulation internally)
    simple_twap::update(pool.simple_twap.borrow_mut(), raw_price, clock);

    // Emit price update event
    event::emit(SpotPriceUpdate {
        pool_id: object::id(pool),
        price: simple_twap::last_price(pool.simple_twap.borrow()),
        timestamp: clock.timestamp_ms(),
        asset_reserve: pool.asset_reserve.value(),
        stable_reserve: pool.stable_reserve.value(),
    });
}

/// Calculate spot price (stable per asset) with scaling
fun calculate_spot_price(asset_reserve: u64, stable_reserve: u64): u128 {
    if (asset_reserve == 0) return 0;
    
    // Price = stable_reserve / asset_reserve * PRICE_SCALE
    ((stable_reserve as u128) * PRICE_SCALE) / (asset_reserve as u128)
}

/// Add liquidity (entry)
public entry fun add_liquidity<AssetType, StableType>(
    pool: &mut SpotAMM<AssetType, StableType>,
    asset_in: Coin<AssetType>,
    stable_in: Coin<StableType>,
    min_lp_out: u64,
    clock: &Clock,
    ctx: &mut TxContext,
) {
    let a = asset_in.value();
    let s = stable_in.value();
    assert!(a > 0 && s > 0, EZeroAmount);

    let minted = if (pool.lp_supply == 0) {
        let prod = (a as u128) * (s as u128);
        let root_u128 = math::sqrt_u128(prod);
        assert!(root_u128 <= (std::u64::max_value!() as u128), EOverflow);
        let root = root_u128 as u64;
        assert!(root > MINIMUM_LIQUIDITY, EInsufficientLiquidity);
        // Lock MINIMUM_LIQUIDITY permanently to prevent rounding attacks
        pool.lp_supply = MINIMUM_LIQUIDITY;  // Set to minimum, will add minted below
        
        // Initialize TWAP oracle on first liquidity
        pool.asset_reserve.join(asset_in.into_balance());
        pool.stable_reserve.join(stable_in.into_balance());
        initialize_twap(pool, clock);
        
        root - MINIMUM_LIQUIDITY  // Return minted amount minus locked liquidity
    } else {
        // Update TWAP before liquidity change
        update_twap(pool, clock);
        
        // For subsequent deposits, calculate LP tokens based on proportional contribution
        let from_a = math::mul_div_to_64(a, pool.lp_supply, pool.asset_reserve.value());
        let from_s = math::mul_div_to_64(s, pool.lp_supply, pool.stable_reserve.value());
        
        // Enforce balanced deposits with 1% tolerance to prevent value extraction
        let max_delta = if (from_a > from_s) {
            from_a - from_s
        } else {
            from_s - from_a
        };
        let avg = (from_a + from_s) / 2;
        assert!(max_delta <= avg / 100, EImbalancedLiquidity); // Max 1% imbalance
        
        // Add liquidity to reserves
        pool.asset_reserve.join(asset_in.into_balance());
        pool.stable_reserve.join(stable_in.into_balance());
        
        // Use minimum to be conservative
        math::min(from_a, from_s)
    };
    assert!(minted >= min_lp_out, ESlippageExceeded);

    pool.lp_supply = pool.lp_supply + minted;

    // Mint NFT position receipt
    let position = position_nft::mint_spot_position<AssetType, StableType>(
        object::id(pool),
        minted,
        pool.fee_bps,
        clock,
        ctx
    );
    transfer::public_transfer(position, ctx.sender());
}

/// Remove liquidity (entry)
public entry fun remove_liquidity<AssetType, StableType>(
    pool: &mut SpotAMM<AssetType, StableType>,
    position: position_nft::SpotLPPosition<AssetType, StableType>,
    min_asset_out: u64,
    min_stable_out: u64,
    clock: &Clock,
    ctx: &mut TxContext,
) {
    // Update TWAP before liquidity change
    if (pool.simple_twap.is_some()) {
        update_twap(pool, clock);
    };

    // Get LP amount from NFT position and burn it
    let amount = position_nft::get_spot_lp_amount(&position);
    position_nft::burn_spot_position(position, clock, ctx);

    assert!(amount > 0, EZeroAmount);
    assert!(pool.lp_supply > MINIMUM_LIQUIDITY, EInsufficientLiquidity);

    let a = math::mul_div_to_64(amount, pool.asset_reserve.value(), pool.lp_supply);
    let s = math::mul_div_to_64(amount, pool.stable_reserve.value(), pool.lp_supply);
    assert!(a >= min_asset_out, ESlippageExceeded);
    assert!(s >= min_stable_out, ESlippageExceeded);

    pool.lp_supply = pool.lp_supply - amount;
    let a_out = coin::from_balance(pool.asset_reserve.split(a), ctx);
    let s_out = coin::from_balance(pool.stable_reserve.split(s), ctx);
    transfer::public_transfer(a_out, ctx.sender());
    transfer::public_transfer(s_out, ctx.sender());
}

/// Swap asset for stable (simple spot swap, no inline arbitrage)
/// Arbitrage happens externally via PTBs - see ARBITRAGE_ANALYSIS.md
///
/// Fee split model (matches conditional AMM):
/// - Calculate gross stable output based on constant product
/// - Take fee from this output
/// - Split fee: spot_lp_fee_share_bps to LPs (stays in pool), remainder to protocol
/// - User receives net stable output
public fun swap_asset_for_stable<AssetType, StableType>(
    pool: &mut SpotAMM<AssetType, StableType>,
    asset_in: Coin<AssetType>,
    min_stable_out: u64,
    clock: &Clock,
    ctx: &mut TxContext,
): Coin<StableType> {
    assert!(pool.simple_twap.is_some(), ENotInitialized);
    update_twap(pool, clock);

    let amount_in = asset_in.value();
    assert!(amount_in > 0, EZeroAmount);

    // K-GUARD: Capture reserves before swap to validate constant-product invariant
    // WHY: LP fees stay in pool so k must GROW, protocol fees don't. This catches rounding bugs.
    let asset_before = pool.asset_reserve.value();
    let stable_before = pool.stable_reserve.value();
    let k_before = (asset_before as u128) * (stable_before as u128);

    // Calculate gross output using constant product formula (x * y = k)
    let stable_out_before_fee = math::mul_div_to_64(
        amount_in,
        stable_before,
        asset_before + amount_in
    );

    // Calculate fee from stable output
    let total_fee = math::mul_div_to_64(stable_out_before_fee, pool.fee_bps, constants::max_fee_bps());
    let lp_share = math::mul_div_to_64(total_fee, constants::spot_lp_fee_share_bps(), constants::total_fee_bps());
    let protocol_share = total_fee - lp_share;

    // Net amount for user
    let stable_out = stable_out_before_fee - total_fee;
    assert!(stable_out >= min_stable_out, ESlippageExceeded);
    assert!(stable_out_before_fee < stable_before, EInsufficientLiquidity);

    // Update reserves
    pool.asset_reserve.join(asset_in.into_balance());

    // Protocol share goes to protocol_fees_stable, LP share stays in pool
    pool.protocol_fees_stable.join(pool.stable_reserve.split(protocol_share));
    let stable_coin = coin::from_balance(pool.stable_reserve.split(stable_out), ctx);

    // K-GUARD: Validate k increased (LP fees stay in pool, so k must grow)
    // Formula: (asset + amount_in) * (stable - stable_out - protocol_share) >= asset * stable
    let asset_after = pool.asset_reserve.value();
    let stable_after = pool.stable_reserve.value();
    let k_after = (asset_after as u128) * (stable_after as u128);
    assert!(k_after >= k_before, EKInvariantViolation);

    stable_coin
}

/// Entry wrapper - swaps and transfers output
public entry fun swap_asset_for_stable_entry<AssetType, StableType>(
    pool: &mut SpotAMM<AssetType, StableType>,
    asset_in: Coin<AssetType>,
    min_stable_out: u64,
    clock: &Clock,
    ctx: &mut TxContext,
) {
    let stable_out = swap_asset_for_stable(
        pool,
        asset_in,
        min_stable_out,
        clock,
        ctx,
    );
    transfer::public_transfer(stable_out, ctx.sender());
}


/// Swap stable for asset (simple spot swap, no inline arbitrage)
/// Arbitrage happens externally via PTBs - see ARBITRAGE_ANALYSIS.md
///
/// Fee split model (matches conditional AMM):
/// - Take fee from stable input
/// - Split fee: spot_lp_fee_share_bps to LPs (stays in pool), remainder to protocol
/// - Calculate asset output based on amount after LP fee
public fun swap_stable_for_asset<AssetType, StableType>(
    pool: &mut SpotAMM<AssetType, StableType>,
    stable_in: Coin<StableType>,
    min_asset_out: u64,
    clock: &Clock,
    ctx: &mut TxContext,
): Coin<AssetType> {
    assert!(pool.simple_twap.is_some(), ENotInitialized);
    update_twap(pool, clock);

    let amount_in = stable_in.value();
    assert!(amount_in > 0, EZeroAmount);

    // K-GUARD: Capture reserves before swap to validate constant-product invariant
    // WHY: LP fees stay in pool so k must GROW, protocol fees don't. This catches rounding bugs.
    let asset_before = pool.asset_reserve.value();
    let stable_before = pool.stable_reserve.value();
    let k_before = (asset_before as u128) * (stable_before as u128);

    // Calculate fee from stable input
    let total_fee = math::mul_div_to_64(amount_in, pool.fee_bps, constants::max_fee_bps());
    let lp_share = math::mul_div_to_64(total_fee, constants::spot_lp_fee_share_bps(), constants::total_fee_bps());
    let protocol_share = total_fee - lp_share;

    // Amount used for swap calculation (after removing total fee)
    let amount_in_after_fee = amount_in - total_fee;

    // Calculate output using constant product formula (x * y = k)
    let asset_out = math::mul_div_to_64(
        amount_in_after_fee,
        asset_before,
        stable_before + amount_in_after_fee
    );
    assert!(asset_out >= min_asset_out, ESlippageExceeded);
    assert!(asset_out < asset_before, EInsufficientLiquidity);

    // Update reserves
    // Protocol share goes to protocol_fees_stable, LP share + amount_in_after_fee stay in pool
    let stable_balance = stable_in.into_balance();
    pool.protocol_fees_stable.join(stable_balance.split(protocol_share));
    pool.stable_reserve.join(stable_balance); // This adds amount_in_after_fee + lp_share

    let asset_coin = coin::from_balance(pool.asset_reserve.split(asset_out), ctx);

    // K-GUARD: Validate k increased (LP fees stay in pool, so k must grow)
    // Formula: (asset - asset_out) * (stable + amount_in_after_fee + lp_share) >= asset * stable
    let asset_after = pool.asset_reserve.value();
    let stable_after = pool.stable_reserve.value();
    let k_after = (asset_after as u128) * (stable_after as u128);
    assert!(k_after >= k_before, EKInvariantViolation);

    asset_coin
}

/// Entry wrapper - swaps and transfers output
public entry fun swap_stable_for_asset_entry<AssetType, StableType>(
    pool: &mut SpotAMM<AssetType, StableType>,
    stable_in: Coin<StableType>,
    min_asset_out: u64,
    clock: &Clock,
    ctx: &mut TxContext,
) {
    let asset_out = swap_stable_for_asset(
        pool,
        stable_in,
        min_asset_out,
        clock,
        ctx,
    );
    transfer::public_transfer(asset_out, ctx.sender());
}


/// ---- Conversion hook used by coin_escrow during LP conversion (no balance movement here) ----
/// Returns the ID of the minted spot LP position NFT (the NFT is transferred to the sender).
public fun mint_lp_for_conversion<AssetType, StableType>(
    pool: &mut SpotAMM<AssetType, StableType>,
    _asset_amount: u64,
    _stable_amount: u64,
    lp_amount_to_mint: u64,
    _total_lp_supply_at_finalization: u64,
    _market_id: ID,
    clock: &Clock,
    ctx: &mut TxContext,
): ID {
    assert!(lp_amount_to_mint > 0, EZeroAmount);
    pool.lp_supply = pool.lp_supply + lp_amount_to_mint;

    // Mint NFT position receipt
    let position = position_nft::mint_spot_position<AssetType, StableType>(
        object::id(pool),
        lp_amount_to_mint,
        pool.fee_bps,
        clock,
        ctx
    );
    let position_id = object::id(&position);
    transfer::public_transfer(position, ctx.sender());
    position_id
}

// === Arbitrage Helper Functions ===

/// Feeless swap asset→stable (for internal arbitrage only)
/// No fees charged to maximize arbitrage efficiency
/// Profits distributed separately by arbitrage module
///
/// IMPORTANT: Caller must have already added amount_in to asset_reserve
/// This function updates reserves and returns output amount
public(package) fun feeless_swap_asset_to_stable<AssetType, StableType>(
    pool: &mut SpotAMM<AssetType, StableType>,
    amount_in: u64,
): u64 {
    assert!(amount_in > 0, EZeroAmount);

    // K-GUARD: Feeless swaps should preserve k EXACTLY (no fees = no k growth)
    // WHY: Validates b-parameterization math is correct
    let asset_reserve = pool.asset_reserve.value();
    let stable_reserve = pool.stable_reserve.value();
    let k_before = (asset_reserve as u128) * (stable_reserve as u128);

    // No fee for arbitrage swaps (fee-free constant product)
    let stable_out = math::mul_div_to_64(
        amount_in,
        stable_reserve,
        asset_reserve + amount_in
    );
    assert!(stable_out < stable_reserve, EInsufficientLiquidity);

    // K-GUARD: Validate k unchanged (feeless swap preserves k within rounding)
    // Formula: (asset + amount_in) * (stable - stable_out) ≈ asset * stable
    // Allow tiny rounding tolerance (1 part in 10^6)
    let k_after = (asset_reserve + amount_in as u128) * ((stable_reserve - stable_out) as u128);
    let k_delta = if (k_after > k_before) { k_after - k_before } else { k_before - k_after };
    let tolerance = k_before / 1000000; // 0.0001% tolerance
    assert!(k_delta <= tolerance, EKInvariantViolation);

    stable_out
}

/// Feeless swap stable→asset (for internal arbitrage only)
public(package) fun feeless_swap_stable_to_asset<AssetType, StableType>(
    pool: &mut SpotAMM<AssetType, StableType>,
    amount_in: u64,
): u64 {
    assert!(amount_in > 0, EZeroAmount);

    // K-GUARD: Feeless swaps should preserve k EXACTLY (no fees = no k growth)
    // WHY: Validates b-parameterization math is correct
    let asset_reserve = pool.asset_reserve.value();
    let stable_reserve = pool.stable_reserve.value();
    let k_before = (asset_reserve as u128) * (stable_reserve as u128);

    // No fee for arbitrage swaps
    let asset_out = math::mul_div_to_64(
        amount_in,
        asset_reserve,
        stable_reserve + amount_in
    );
    assert!(asset_out < asset_reserve, EInsufficientLiquidity);

    // K-GUARD: Validate k unchanged (feeless swap preserves k within rounding)
    // Formula: (asset - asset_out) * (stable + amount_in) ≈ asset * stable
    // Allow tiny rounding tolerance (1 part in 10^6)
    let k_after = ((asset_reserve - asset_out) as u128) * ((stable_reserve + amount_in) as u128);
    let k_delta = if (k_after > k_before) { k_after - k_before } else { k_before - k_after };
    let tolerance = k_before / 1000000; // 0.0001% tolerance
    assert!(k_delta <= tolerance, EKInvariantViolation);

    asset_out
}

/// Simulate asset→stable swap without executing
/// Pure function for arbitrage optimization
public fun simulate_swap_asset_to_stable<AssetType, StableType>(
    pool: &SpotAMM<AssetType, StableType>,
    amount_in: u64,
): u64 {
    if (amount_in == 0) return 0;

    let asset_reserve = pool.asset_reserve.value();
    let stable_reserve = pool.stable_reserve.value();

    if (asset_reserve == 0 || stable_reserve == 0) return 0;

    // Simulate with fee (user-facing simulation)
    let amount_after_fee = amount_in - math::mul_div_to_64(
        amount_in,
        pool.fee_bps,
        constants::max_fee_bps()
    );

    let stable_out = math::mul_div_to_64(
        amount_after_fee,
        stable_reserve,
        asset_reserve + amount_after_fee
    );

    if (stable_out >= stable_reserve) return 0;

    stable_out
}

/// Simulate stable→asset swap without executing
public fun simulate_swap_stable_to_asset<AssetType, StableType>(
    pool: &SpotAMM<AssetType, StableType>,
    amount_in: u64,
): u64 {
    if (amount_in == 0) return 0;

    let asset_reserve = pool.asset_reserve.value();
    let stable_reserve = pool.stable_reserve.value();

    if (asset_reserve == 0 || stable_reserve == 0) return 0;

    // Simulate with fee
    let amount_after_fee = amount_in - math::mul_div_to_64(
        amount_in,
        pool.fee_bps,
        constants::max_fee_bps()
    );

    let asset_out = math::mul_div_to_64(
        amount_after_fee,
        asset_reserve,
        stable_reserve + amount_after_fee
    );

    if (asset_out >= asset_reserve) return 0;

    asset_out
}

// === View Functions ===

/// Get current spot price
public fun get_spot_price<AssetType, StableType>(pool: &SpotAMM<AssetType, StableType>): u128 {
    calculate_spot_price(
        pool.asset_reserve.value(),
        pool.stable_reserve.value()
    )
}

/// Get current TWAP (3-day rolling window)
public fun get_twap_mut<AssetType, StableType>(
    pool: &mut SpotAMM<AssetType, StableType>,
    clock: &Clock,
): u128 {
    assert!(pool.simple_twap.is_some(), ENotInitialized);

    // Update oracle to current time before reading
    let raw_price = calculate_spot_price(pool.asset_reserve.value(), pool.stable_reserve.value());
    simple_twap::update(pool.simple_twap.borrow_mut(), raw_price, clock);

    // Get TWAP from SimpleTWAP
    simple_twap::get_twap(pool.simple_twap.borrow(), clock)
}

/// Get current TWAP with live conditional integration
/// During proposals: combines spot's frozen cumulative + conditional's live cumulative
/// Normal operation: returns SimpleTWAP
///
/// # Arguments
/// * `conditional_data` - Oracle data from winning conditional (if proposal active)
///
/// # Sophisticated Time-Weighted Combination
/// This properly combines spot frozen period + conditional live period by:
/// 1. Taking spot's cumulative up to proposal start (frozen)
/// 2. Adding conditional's cumulative for proposal period (live)
/// 3. Dividing by total window duration
///
/// This maintains proper time weighting (unlike naive averaging)
public fun get_twap<AssetType, StableType>(
    pool: &SpotAMM<AssetType, StableType>,
    conditional_data: Option<ConditionalOracleData>,
    clock: &Clock,
): u128 {
    assert!(pool.simple_twap.is_some(), ENotInitialized);
    let spot_oracle = pool.simple_twap.borrow();
    let now = clock.timestamp_ms();

    // Require at least 3 days of history
    assert!(simple_twap::is_ready(spot_oracle, clock), ETwapNotReady);

    // If no conditional active, just return spot TWAP
    if (conditional_data.is_none()) {
        return simple_twap::get_twap(spot_oracle, clock)
    };

    // Sophisticated cumulative combination for proposal period
    let cond = *option::borrow(&conditional_data);

    // SAFETY: Validate conditional oracle is not stale (within 1 hour)
    let time_since_update = now - cond.last_timestamp;
    assert!(time_since_update <= MAX_ORACLE_STALENESS_MS, EOracleTooStale);

    // Must have proposal_start timestamp
    assert!(pool.last_proposal_usage.is_some(), ENotInitialized);
    let proposal_start = *pool.last_proposal_usage.borrow();

    // Get spot's cumulative up to proposal start (frozen)
    let spot_cumulative = simple_twap::projected_cumulative_to(spot_oracle, proposal_start);
    let spot_window_start = simple_twap::window_start_timestamp(spot_oracle);

    // Calculate conditional's contribution for the proposal period
    // Note: Conditional oracle started at proposal_start, so its window might be different
    let conditional_duration = now - cond.window_start;
    let proposal_duration = now - proposal_start;

    // Conditional's cumulative scaled to just the proposal period
    let conditional_contribution = if (conditional_duration > 0) {
        // SAFETY: Use overflow-protected multiplication
        // Scale: (conditional_cumulative × proposal_duration) / conditional_duration
        simple_twap::safe_mul_u256(cond.window_cumulative, (proposal_duration as u256)) / (conditional_duration as u256)
    } else {
        0
    };

    // Combine: spot's frozen cumulative + conditional's live cumulative
    let total_cumulative = spot_cumulative + conditional_contribution;

    // Total duration is from spot's window start to now
    let total_duration = now - spot_window_start;

    // Apply 3-day rolling window (cap at THREE_DAYS_MS)
    let effective_duration = if (total_duration > THREE_DAYS_MS) {
        THREE_DAYS_MS
    } else {
        total_duration
    };

    // Calculate properly time-weighted average
    if (effective_duration > 0) {
        ((total_cumulative / (effective_duration as u256)) as u128)
    } else {
        cond.last_price
    }
}

/// Get TWAP for conditional AMM initialization
/// This is used when transitioning from spot trading to proposal trading
public fun get_twap_for_conditional_amm<AssetType, StableType>(
    pool: &SpotAMM<AssetType, StableType>,
    clock: &Clock,
): u128 {
    if (pool.simple_twap.is_some()) {
        let oracle = pool.simple_twap.borrow();
        if (simple_twap::is_ready(oracle, clock)) {
            return simple_twap::get_twap(oracle, clock)
        }
    };

    // Fall back to spot price if TWAP not ready
    // This allows proposals before 3-day TWAP is available
    get_spot_price(pool)
}

/// Check if TWAP oracle is ready (has been running for at least 3 days)
public fun is_twap_ready<AssetType, StableType>(
    pool: &SpotAMM<AssetType, StableType>,
    clock: &Clock,
): bool {
    if (pool.simple_twap.is_none()) return false;
    simple_twap::is_ready(pool.simple_twap.borrow(), clock)
}

/// Check if pool is locked for a proposal
public fun is_locked_for_proposal<AssetType, StableType>(
    pool: &SpotAMM<AssetType, StableType>
): bool {
    pool.last_proposal_usage.is_some()
}


/// Get pool reserves
public fun get_reserves<AssetType, StableType>(
    pool: &SpotAMM<AssetType, StableType>
): (u64, u64) {
    (pool.asset_reserve.value(), pool.stable_reserve.value())
}

/// Get pool fee in basis points
public fun get_fee_bps<AssetType, StableType>(
    pool: &SpotAMM<AssetType, StableType>
): u64 {
    pool.fee_bps
}

/// Get SimpleTWAP oracle reference (for spot_oracle_interface)
public fun get_simple_twap<AssetType, StableType>(
    pool: &SpotAMM<AssetType, StableType>
): &SimpleTWAP {
    assert!(pool.simple_twap.is_some(), ENotInitialized);
    pool.simple_twap.borrow()
}

/// Get pool state (basic info)
public fun get_pool_state<AssetType, StableType>(
    pool: &SpotAMM<AssetType, StableType>
): (u64, u64, u64) {
    (
        pool.asset_reserve.value(),
        pool.stable_reserve.value(),
        pool.lp_supply,
    )
}

/// Get accumulated protocol fees (in stable tokens)
public fun get_protocol_fees<AssetType, StableType>(
    pool: &SpotAMM<AssetType, StableType>
): u64 {
    pool.protocol_fees_stable.value()
}

/// Reset protocol fees to zero and return the balance
/// Should only be called by fee collection mechanisms
public(package) fun reset_protocol_fees<AssetType, StableType>(
    pool: &mut SpotAMM<AssetType, StableType>,
    ctx: &mut TxContext,
): Coin<StableType> {
    let fee_amount = pool.protocol_fees_stable.value();
    if (fee_amount > 0) {
        coin::from_balance(pool.protocol_fees_stable.split(fee_amount), ctx)
    } else {
        coin::zero<StableType>(ctx)
    }
}

// === Conditional TWAP Integration ===


/// Mark when DAO liquidity moves to a proposal
/// This records the timestamp for later TWAP backfilling
public fun mark_liquidity_to_proposal<AssetType, StableType>(
    pool: &mut SpotAMM<AssetType, StableType>,
    clock: &Clock,
) {
    // Update SimpleTWAP one last time before liquidity moves to proposal
    if (pool.simple_twap.is_some()) {
        update_twap(pool, clock);
    };
    // Record when liquidity moved to proposal (spot oracle freezes here)
    pool.last_proposal_usage = option::some(clock.timestamp_ms());
}

/// Backfill spot's SimpleTWAP with winning conditional's data after proposal ends
///
/// # Arguments
/// * `winning_conditional_oracle` - SimpleTWAP from winning conditional AMM
public fun backfill_from_winning_conditional<AssetType, StableType>(
    pool: &mut SpotAMM<AssetType, StableType>,
    winning_conditional_oracle: &SimpleTWAP,
    clock: &Clock,
) {
    assert!(pool.simple_twap.is_some(), ENotInitialized);
    assert!(pool.last_proposal_usage.is_some(), ENotInitialized); // Must be locked

    let proposal_start = *pool.last_proposal_usage.borrow();
    let proposal_end = clock.timestamp_ms();

    // Calculate conditional's cumulative for the proposal period
    let conditional_window_start = simple_twap::window_start_timestamp(winning_conditional_oracle);
    let conditional_cumulative = simple_twap::projected_cumulative_to(winning_conditional_oracle, proposal_end);
    let conditional_duration = proposal_end - conditional_window_start;
    let proposal_duration = proposal_end - proposal_start;

    // SAFETY: Scale to just the proposal period with overflow protection
    let period_cumulative = if (conditional_duration > 0) {
        simple_twap::safe_mul_u256(conditional_cumulative, (proposal_duration as u256)) / (conditional_duration as u256)
    } else {
        0
    };

    let period_final_price = simple_twap::last_price(winning_conditional_oracle);

    // Backfill spot's SimpleTWAP with conditional's data
    simple_twap::backfill_from_conditional(
        pool.simple_twap.borrow_mut(),
        proposal_start,
        proposal_end,
        period_cumulative,
        period_final_price,
    );

    // Unlock the pool
    pool.last_proposal_usage = option::none();
}

/// ============================================================================
/// SPOT ORACLE INTERFACE - UNIFIED ACCESS POINT FOR ALL PRICE QUERIES
/// ============================================================================
/// 
/// PURPOSE: Single interface that abstracts away futarchy complexity
/// 
/// USED BY:
/// - Lending protocols that need continuous prices
/// - Governance actions that need long-term TWAPs
/// - Any external protocol integrating with the DAO token
/// 
/// KEY FEATURES:
/// - Automatically switches between spot and conditional oracles
/// - Hides proposal state from external consumers
/// - Provides both short (lending) and long (governance) windows
/// - Never returns empty/null - always has a price
/// 
/// WHY IT EXISTS:
/// External protocols shouldn't need to understand futarchy mechanics.
/// This interface makes our complex oracle system look like a standard
/// Uniswap oracle to the outside world. Lending protocols can integrate
/// without knowing about proposals, conditional AMMs, or quantum liquidity.
/// 
/// HOW IT WORKS:
/// - Normal times: Reads from spot's 90-day TWAP oracle
/// - During proposals: Reads from winning conditional's futarchy oracle
/// - Seamless transition with no gaps in price feed
/// 
/// ============================================================================

module futarchy_markets::spot_oracle_interface;

use sui::clock::Clock;
use futarchy_markets::spot_amm::{Self, SpotAMM};
use futarchy_markets::conditional_amm::{Self, LiquidityPool};
use futarchy_markets::simple_twap::{Self, SimpleTWAP};
use std::vector;
use std::option;

// ============================================================================
// Constants
// ============================================================================

const LENDING_WINDOW_SECONDS: u64 = 1800; // 30 minutes standard
const GOVERNANCE_MAX_WINDOW: u64 = 7_776_000; // 90 days maximum

// Errors
const ENoOracles: u64 = 1;
const ESpotLocked: u64 = 2;

// ============================================================================
// Public Functions for Lending Protocols
// ============================================================================

/// Get TWAP for lending protocols (continuous, 30-minute window)
/// This ALWAYS returns a value, even during proposals
/// During proposals: reads from highest conditional (but doesn't store)
/// After finalization: reads from spot (which has merged winning data)
public fun get_lending_twap<AssetType, StableType>(
    spot_pool: &SpotAMM<AssetType, StableType>,
    conditional_pools: &vector<LiquidityPool>,
    clock: &Clock,
): u128 {
    // Check if spot is locked for proposal
    if (spot_pool.is_locked_for_proposal()) {
        // READ from highest priced conditional (no storage in spot)
        // This is temporary - winner can change until finalization
        get_highest_conditional_twap(conditional_pools, LENDING_WINDOW_SECONDS, clock)
    } else {
        // Get TWAP from spot's SimpleTWAP (90-day window)
        spot_pool.get_twap(option::none(), clock)
    }
}

/// Get custom window TWAP (for protocols that need different windows)
public fun get_twap_custom_window<AssetType, StableType>(
    spot_pool: &SpotAMM<AssetType, StableType>,
    conditional_pools: &vector<LiquidityPool>,
    _seconds: u64,  // Note: Currently ignored, spot uses 90-day window
    clock: &Clock,
): u128 {
    if (spot_pool.is_locked_for_proposal()) {
        get_highest_conditional_twap(conditional_pools, _seconds, clock)
    } else {
        // Use spot's SimpleTWAP (always 90-day window)
        spot_pool.get_twap(option::none(), clock)
    }
}

/// Get instantaneous price
public fun get_spot_price<AssetType, StableType>(
    spot_pool: &SpotAMM<AssetType, StableType>,
    conditional_pools: &vector<LiquidityPool>,
    _clock: &Clock,
): u128 {
    if (spot_pool.is_locked_for_proposal()) {
        get_highest_conditional_price(conditional_pools)
    } else {
        spot_pool.get_spot_price()
    }
}

// ============================================================================
// Public Functions for Governance/Minting
// ============================================================================

/// Get longest possible TWAP for governance decisions and token minting
/// Uses SimpleTWAP from spot AMM (90-day window)
/// During proposals: properly combines spot frozen + conditional live cumulatives
public fun get_governance_twap<AssetType, StableType>(
    spot_pool: &SpotAMM<AssetType, StableType>,
    conditional_pools: &vector<LiquidityPool>,
    clock: &Clock,
): u128 {
    // For governance, we want the 90-day TWAP with proper time weighting
    if (spot_pool.is_locked_for_proposal()) {
        // During proposal: extract conditional oracle data for proper cumulative combination
        let winning_conditional_oracle = get_highest_conditional_oracle(conditional_pools);
        let conditional_data = spot_amm::extract_oracle_data(winning_conditional_oracle);

        // Sophisticated cumulative combination (not naive averaging)
        spot_pool.get_twap(option::some(conditional_data), clock)
    } else {
        // Use spot's SimpleTWAP only
        spot_pool.get_twap(option::none(), clock)
    }
}

// ============================================================================
// Helper Functions
// ============================================================================

/// Get SimpleTWAP oracle from highest priced conditional pool
/// Used for sophisticated cumulative combination with spot oracle
fun get_highest_conditional_oracle(pools: &vector<LiquidityPool>): &SimpleTWAP {
    assert!(!pools.is_empty(), ENoOracles);

    let mut highest_idx = 0;
    let mut highest_price = 0u128;
    let mut i = 0;

    // Find pool with highest price
    while (i < pools.length()) {
        let pool = pools.borrow(i);
        let pool_simple_twap = conditional_amm::get_simple_twap(pool);
        let price = simple_twap::get_spot_price(pool_simple_twap);
        if (price > highest_price) {
            highest_price = price;
            highest_idx = i;
        };
        i = i + 1;
    };

    // Return oracle from highest priced pool
    let winning_pool = pools.borrow(highest_idx);
    conditional_amm::get_simple_twap(winning_pool)
}

/// Get highest TWAP from conditional pools using SimpleTWAP
/// Note: SimpleTWAP uses 90-day window, `seconds` parameter is ignored
fun get_highest_conditional_twap(
    pools: &vector<LiquidityPool>,
    _seconds: u64,  // Note: SimpleTWAP uses fixed 90-day window
    clock: &Clock,
): u128 {
    assert!(!pools.is_empty(), ENoOracles);

    let mut highest_twap = 0u128;
    let mut i = 0;

    while (i < pools.length()) {
        let pool = pools.borrow(i);
        let pool_simple_twap = conditional_amm::get_simple_twap(pool);
        let twap = simple_twap::get_twap(pool_simple_twap, clock);
        if (twap > highest_twap) {
            highest_twap = twap;
        };
        i = i + 1;
    };

    highest_twap
}

/// Get highest current price from conditional pools using SimpleTWAP
fun get_highest_conditional_price(pools: &vector<LiquidityPool>): u128 {
    assert!(!pools.is_empty(), ENoOracles);

    let mut highest_price = 0u128;
    let mut i = 0;

    while (i < pools.length()) {
        let pool = pools.borrow(i);
        let pool_simple_twap = conditional_amm::get_simple_twap(pool);
        let price = simple_twap::get_spot_price(pool_simple_twap);
        if (price > highest_price) {
            highest_price = price;
        };
        i = i + 1;
    };

    highest_price
}

/// Check if TWAP is available for a given window
public fun is_twap_available<AssetType, StableType>(
    spot_pool: &SpotAMM<AssetType, StableType>,
    _conditional_pools: &vector<LiquidityPool>,
    _seconds: u64,  // Note: Currently ignored, spot TWAP readiness is based on 90-day window
    clock: &Clock,
): bool {
    // Check if spot's base fair value TWAP is ready (requires 90 days of history)
    spot_pool.is_twap_ready(clock)
}/// Simplified spot liquidity pool for use with Account<FutarchyConfig>
/// This module provides a basic AMM pool that doesn't depend on the DAO structure
module futarchy_markets::account_spot_pool;

// === Imports ===
use std::option::{Self, Option};
use sui::{
    balance::{Self, Balance},
    coin::{Self, Coin},
    object::{Self, UID},
    transfer,
    event,
};
use futarchy_one_shot_utils::{
    math,
    constants,
};

// === Errors ===
const EInsufficientLiquidity: u64 = 1;
const EZeroAmount: u64 = 2;
const ESlippageExceeded: u64 = 3;
const EInvalidFee: u64 = 4;
const EPoolNotInitialized: u64 = 5;

// === Constants ===
const MINIMUM_LIQUIDITY: u64 = 1000;

// === Structs ===

/// A simple spot liquidity pool for trading between two assets
public struct AccountSpotPool<phantom AssetType, phantom StableType> has key, store {
    id: UID,
    /// Asset token reserves
    asset_reserve: Balance<AssetType>,
    /// Stable token reserves
    stable_reserve: Balance<StableType>,
    /// Total LP token supply
    lp_supply: u64,
    /// Trading fee in basis points
    fee_bps: u64,
    /// Minimum liquidity locked (for first LP)
    minimum_liquidity: u64,
}

/// LP token for the pool
public struct LPToken<phantom AssetType, phantom StableType> has key, store {
    id: UID,
    /// Amount of LP tokens
    amount: u64,
}

/// Result of a swap operation
public struct SwapResult<phantom T> has drop {
    /// Output amount
    amount_out: u64,
    /// Fee amount
    fee_amount: u64,
}

// === Events ===

public struct PoolCreated<phantom AssetType, phantom StableType> has copy, drop {
    pool_id: ID,
    fee_bps: u64,
}

public struct LiquidityAdded<phantom AssetType, phantom StableType> has copy, drop {
    pool_id: ID,
    asset_amount: u64,
    stable_amount: u64,
    lp_minted: u64,
}

public struct LiquidityRemoved<phantom AssetType, phantom StableType> has copy, drop {
    pool_id: ID,
    asset_amount: u64,
    stable_amount: u64,
    lp_burned: u64,
}

public struct Swap<phantom AssetType, phantom StableType> has copy, drop {
    pool_id: ID,
    is_asset_to_stable: bool,
    amount_in: u64,
    amount_out: u64,
    fee: u64,
}

// === Public Functions ===

/// Create a new spot pool
public fun new<AssetType, StableType>(
    fee_bps: u64,
    ctx: &mut TxContext,
): AccountSpotPool<AssetType, StableType> {
    assert!(fee_bps <= constants::max_amm_fee_bps(), EInvalidFee);
    
    let id = object::new(ctx);
    let pool_id = object::uid_to_inner(&id);
    
    event::emit(PoolCreated<AssetType, StableType> {
        pool_id,
        fee_bps,
    });
    
    AccountSpotPool {
        id,
        asset_reserve: balance::zero<AssetType>(),
        stable_reserve: balance::zero<StableType>(),
        lp_supply: 0,
        fee_bps,
        minimum_liquidity: MINIMUM_LIQUIDITY,
    }
}

/// Share the pool object
#[allow(lint(custom_state_change, share_owned))]
public fun share<AssetType, StableType>(pool: AccountSpotPool<AssetType, StableType>) {
    transfer::share_object(pool);
}

/// Add liquidity to the pool
public entry fun add_liquidity<AssetType, StableType>(
    pool: &mut AccountSpotPool<AssetType, StableType>,
    asset_coin: Coin<AssetType>,
    stable_coin: Coin<StableType>,
    min_lp_out: u64,
    ctx: &mut TxContext,
) {
    let asset_amount = asset_coin.value();
    let stable_amount = stable_coin.value();
    
    assert!(asset_amount > 0 && stable_amount > 0, EZeroAmount);
    
    let lp_minted = if (pool.lp_supply == 0) {
        // First liquidity provider
        // Calculate initial LP as sqrt(asset * stable)
        let product = (asset_amount as u128) * (stable_amount as u128);
        let initial_lp = math::sqrt_u128(product) as u64;
        assert!(initial_lp > pool.minimum_liquidity, EInsufficientLiquidity);
        
        // Lock minimum liquidity
        pool.lp_supply = pool.minimum_liquidity;
        initial_lp - pool.minimum_liquidity
    } else {
        // Calculate proportional LP tokens
        // Calculate LP tokens based on ratio of added liquidity to existing reserves
        let asset_ratio = math::mul_div_to_64(asset_amount, pool.lp_supply, pool.asset_reserve.value());
        let stable_ratio = math::mul_div_to_64(stable_amount, pool.lp_supply, pool.stable_reserve.value());
        
        // Use the minimum ratio to maintain pool ratio
        math::min(asset_ratio, stable_ratio)
    };
    
    assert!(lp_minted >= min_lp_out, ESlippageExceeded);
    
    // Update reserves
    pool.asset_reserve.join(asset_coin.into_balance());
    pool.stable_reserve.join(stable_coin.into_balance());
    pool.lp_supply = pool.lp_supply + lp_minted;
    
    // Mint LP tokens
    let lp_token = LPToken<AssetType, StableType> {
        id: object::new(ctx),
        amount: lp_minted,
    };
    
    transfer::public_transfer(lp_token, ctx.sender());
    
    event::emit(LiquidityAdded<AssetType, StableType> {
        pool_id: object::id(pool),
        asset_amount,
        stable_amount,
        lp_minted,
    });
}

/// Add liquidity and return LP token (for use in actions)
public fun add_liquidity_and_return<AssetType, StableType>(
    pool: &mut AccountSpotPool<AssetType, StableType>,
    asset_coin: Coin<AssetType>,
    stable_coin: Coin<StableType>,
    min_lp_out: u64,
    ctx: &mut TxContext,
): LPToken<AssetType, StableType> {
    let asset_amount = asset_coin.value();
    let stable_amount = stable_coin.value();
    
    assert!(asset_amount > 0 && stable_amount > 0, EZeroAmount);
    
    let lp_minted = if (pool.lp_supply == 0) {
        // First liquidity provider
        let product = (asset_amount as u128) * (stable_amount as u128);
        let initial_lp = math::sqrt_u128(product) as u64;
        assert!(initial_lp > pool.minimum_liquidity, EInsufficientLiquidity);
        
        // Lock minimum liquidity
        pool.lp_supply = pool.minimum_liquidity;
        initial_lp - pool.minimum_liquidity
    } else {
        // Calculate proportional LP tokens
        let asset_ratio = math::mul_div_to_64(asset_amount, pool.lp_supply, pool.asset_reserve.value());
        let stable_ratio = math::mul_div_to_64(stable_amount, pool.lp_supply, pool.stable_reserve.value());
        math::min(asset_ratio, stable_ratio)
    };
    
    assert!(lp_minted >= min_lp_out, ESlippageExceeded);
    
    // Update reserves
    pool.asset_reserve.join(asset_coin.into_balance());
    pool.stable_reserve.join(stable_coin.into_balance());
    pool.lp_supply = pool.lp_supply + lp_minted;
    
    // Create and return LP token
    let lp_token = LPToken<AssetType, StableType> {
        id: object::new(ctx),
        amount: lp_minted,
    };
    
    event::emit(LiquidityAdded<AssetType, StableType> {
        pool_id: object::id(pool),
        asset_amount,
        stable_amount,
        lp_minted,
    });
    
    lp_token
}

/// Remove liquidity and return coins (for use in actions)
public fun remove_liquidity_and_return<AssetType, StableType>(
    pool: &mut AccountSpotPool<AssetType, StableType>,
    lp_token: LPToken<AssetType, StableType>,
    min_asset_out: u64,
    min_stable_out: u64,
    ctx: &mut TxContext,
): (Coin<AssetType>, Coin<StableType>) {
    let LPToken { id, amount: lp_amount } = lp_token;
    id.delete();
    
    assert!(lp_amount > 0, EZeroAmount);
    assert!(pool.lp_supply > pool.minimum_liquidity, EInsufficientLiquidity);
    
    // Calculate proportional share
    let asset_amount = math::mul_div_to_64(lp_amount, pool.asset_reserve.value(), pool.lp_supply);
    let stable_amount = math::mul_div_to_64(lp_amount, pool.stable_reserve.value(), pool.lp_supply);
    
    assert!(asset_amount >= min_asset_out, ESlippageExceeded);
    assert!(stable_amount >= min_stable_out, ESlippageExceeded);
    
    // Update state
    pool.lp_supply = pool.lp_supply - lp_amount;
    
    // Create coins
    let asset_out = coin::from_balance(
        pool.asset_reserve.split(asset_amount),
        ctx
    );
    let stable_out = coin::from_balance(
        pool.stable_reserve.split(stable_amount),
        ctx
    );
    
    event::emit(LiquidityRemoved<AssetType, StableType> {
        pool_id: object::id(pool),
        asset_amount,
        stable_amount,
        lp_burned: lp_amount,
    });
    
    (asset_out, stable_out)
}

/// Remove liquidity from the pool
public entry fun remove_liquidity<AssetType, StableType>(
    pool: &mut AccountSpotPool<AssetType, StableType>,
    lp_token: LPToken<AssetType, StableType>,
    min_asset_out: u64,
    min_stable_out: u64,
    ctx: &mut TxContext,
) {
    let LPToken { id, amount: lp_amount } = lp_token;
    id.delete();
    
    assert!(lp_amount > 0, EZeroAmount);
    assert!(pool.lp_supply > pool.minimum_liquidity, EInsufficientLiquidity);
    
    // Calculate proportional share
    // Calculate proportional assets to return
    let asset_amount = math::mul_div_to_64(lp_amount, pool.asset_reserve.value(), pool.lp_supply);
    let stable_amount = math::mul_div_to_64(lp_amount, pool.stable_reserve.value(), pool.lp_supply);
    
    assert!(asset_amount >= min_asset_out, ESlippageExceeded);
    assert!(stable_amount >= min_stable_out, ESlippageExceeded);
    
    // Update state
    pool.lp_supply = pool.lp_supply - lp_amount;
    
    // Transfer tokens
    let asset_out = coin::from_balance(
        pool.asset_reserve.split(asset_amount),
        ctx
    );
    let stable_out = coin::from_balance(
        pool.stable_reserve.split(stable_amount),
        ctx
    );
    
    transfer::public_transfer(asset_out, ctx.sender());
    transfer::public_transfer(stable_out, ctx.sender());
    
    event::emit(LiquidityRemoved<AssetType, StableType> {
        pool_id: object::id(pool),
        asset_amount,
        stable_amount,
        lp_burned: lp_amount,
    });
}

/// Swap asset for stable
public entry fun swap_asset_to_stable<AssetType, StableType>(
    pool: &mut AccountSpotPool<AssetType, StableType>,
    asset_in: Coin<AssetType>,
    min_stable_out: u64,
    ctx: &mut TxContext,
) {
    let amount_in = asset_in.value();
    assert!(amount_in > 0, EZeroAmount);
    
    let (amount_out, fee) = calculate_output(
        amount_in,
        pool.asset_reserve.value(),
        pool.stable_reserve.value(),
        pool.fee_bps
    );
    
    assert!(amount_out >= min_stable_out, ESlippageExceeded);
    assert!(amount_out <= pool.stable_reserve.value(), EInsufficientLiquidity);
    
    // Update reserves
    pool.asset_reserve.join(asset_in.into_balance());
    
    // Send output
    let stable_out = coin::from_balance(
        pool.stable_reserve.split(amount_out),
        ctx
    );
    transfer::public_transfer(stable_out, ctx.sender());
    
    event::emit(Swap<AssetType, StableType> {
        pool_id: object::id(pool),
        is_asset_to_stable: true,
        amount_in,
        amount_out,
        fee,
    });
}

/// Swap stable for asset
public entry fun swap_stable_to_asset<AssetType, StableType>(
    pool: &mut AccountSpotPool<AssetType, StableType>,
    stable_in: Coin<StableType>,
    min_asset_out: u64,
    ctx: &mut TxContext,
) {
    let amount_in = stable_in.value();
    assert!(amount_in > 0, EZeroAmount);
    
    let (amount_out, fee) = calculate_output(
        amount_in,
        pool.stable_reserve.value(),
        pool.asset_reserve.value(),
        pool.fee_bps
    );
    
    assert!(amount_out >= min_asset_out, ESlippageExceeded);
    assert!(amount_out <= pool.asset_reserve.value(), EInsufficientLiquidity);
    
    // Update reserves
    pool.stable_reserve.join(stable_in.into_balance());
    
    // Send output
    let asset_out = coin::from_balance(
        pool.asset_reserve.split(amount_out),
        ctx
    );
    transfer::public_transfer(asset_out, ctx.sender());
    
    event::emit(Swap<AssetType, StableType> {
        pool_id: object::id(pool),
        is_asset_to_stable: false,
        amount_in,
        amount_out,
        fee,
    });
}

// === View Functions ===

/// Get pool reserves
public fun get_reserves<AssetType, StableType>(
    pool: &AccountSpotPool<AssetType, StableType>
): (u64, u64) {
    (pool.asset_reserve.value(), pool.stable_reserve.value())
}

/// Get spot price (asset per stable)
public fun get_spot_price<AssetType, StableType>(
    pool: &AccountSpotPool<AssetType, StableType>
): u128 {
    if (pool.asset_reserve.value() == 0) {
        0
    } else {
        // Price = stable_reserve / asset_reserve * price_multiplier_scale
        // This scale is used across the system for price calculations and multipliers
        ((pool.stable_reserve.value() as u128) * (constants::price_multiplier_scale() as u128)) / (pool.asset_reserve.value() as u128)
    }
}

/// Get pool ID
public fun pool_id<AssetType, StableType>(
    pool: &AccountSpotPool<AssetType, StableType>
): ID {
    object::id(pool)
}

/// Get LP supply
public fun lp_supply<AssetType, StableType>(
    pool: &AccountSpotPool<AssetType, StableType>
): u64 {
    pool.lp_supply
}

/// Get fee in basis points
public fun fee_bps<AssetType, StableType>(
    pool: &AccountSpotPool<AssetType, StableType>
): u64 {
    pool.fee_bps
}

// === Internal Functions ===

/// Calculate output amount for a swap
fun calculate_output(
    amount_in: u64,
    reserve_in: u64,
    reserve_out: u64,
    fee_bps: u64,
): (u64, u64) {
    // Calculate fee
    // Calculate fee amount
    let fee_amount = math::mul_div_to_64(amount_in, fee_bps, 10000);
    let amount_in_after_fee = amount_in - fee_amount;
    
    // Calculate output using constant product formula
    // amount_out = (amount_in_after_fee * reserve_out) / (reserve_in + amount_in_after_fee)
    // Use mul_div_to_64 to calculate output amount
    let amount_out = math::mul_div_to_64(amount_in_after_fee, reserve_out, reserve_in + amount_in_after_fee);
    
    (amount_out, fee_amount)
}

// === LP Token Functions ===

/// Get LP token amount
public fun lp_token_amount<AssetType, StableType>(
    token: &LPToken<AssetType, StableType>
): u64 {
    token.amount
}

/// Merge two LP tokens and return the result
public fun merge_lp_tokens<AssetType, StableType>(
    token1: LPToken<AssetType, StableType>,
    token2: LPToken<AssetType, StableType>,
    ctx: &mut TxContext,
): LPToken<AssetType, StableType> {
    let LPToken { id: id1, amount: amount1 } = token1;
    let LPToken { id: id2, amount: amount2 } = token2;
    
    id1.delete();
    id2.delete();
    
    LPToken<AssetType, StableType> {
        id: object::new(ctx),
        amount: amount1 + amount2,
    }
}

/// Merge two LP tokens (entry function)
public entry fun merge_lp_tokens_entry<AssetType, StableType>(
    token1: LPToken<AssetType, StableType>,
    token2: LPToken<AssetType, StableType>,
    ctx: &mut TxContext,
) {
    let merged = merge_lp_tokens(token1, token2, ctx);
    transfer::public_transfer(merged, ctx.sender());
}

/// Split an LP token and return both parts
public fun split_lp_token<AssetType, StableType>(
    token: LPToken<AssetType, StableType>,
    split_amount: u64,
    ctx: &mut TxContext,
): (LPToken<AssetType, StableType>, LPToken<AssetType, StableType>) {
    let LPToken { id, amount } = token;
    id.delete();
    
    assert!(split_amount > 0 && split_amount < amount, EZeroAmount);
    
    let token1 = LPToken<AssetType, StableType> {
        id: object::new(ctx),
        amount: split_amount,
    };
    
    let token2 = LPToken<AssetType, StableType> {
        id: object::new(ctx),
        amount: amount - split_amount,
    };
    
    (token1, token2)
}

/// Split an LP token (entry function)
public entry fun split_lp_token_entry<AssetType, StableType>(
    token: LPToken<AssetType, StableType>,
    split_amount: u64,
    ctx: &mut TxContext,
) {
    let (token1, token2) = split_lp_token(token, split_amount, ctx);
    transfer::public_transfer(token1, ctx.sender());
    transfer::public_transfer(token2, ctx.sender());
}

// === LP Token Recovery Functions ===
// These functions allow DAOs to recover LP tokens that were sent to the account address

/// Get information about an LP token
public fun lp_token_info<AssetType, StableType>(
    token: &LPToken<AssetType, StableType>
): (ID, u64) {
    (object::id(token), token.amount)
}

// === Test-Only Functions ===

#[test_only]
/// Create an LP token for testing purposes
public fun new_lp_token_for_testing<AssetType, StableType>(
    amount: u64,
    ctx: &mut TxContext,
): LPToken<AssetType, StableType> {
    LPToken {
        id: object::new(ctx),
        amount,
    }
}

// === Share Functions ===

/// Share the account spot pool - can only be called by this module
/// Used during DAO initialization after setup is complete
public fun share_pool<AssetType, StableType>(
    pool: AccountSpotPool<AssetType, StableType>
) {
    transfer::share_object(pool);
}