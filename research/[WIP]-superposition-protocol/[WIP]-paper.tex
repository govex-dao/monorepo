\documentclass{article}
\usepackage{graphicx} % Required for inserting images
\usepackage{authblk}
\usepackage{hyperref}
\usepackage{algorithm}
\usepackage{algpseudocode}
\usepackage{amsmath}
\usepackage{amssymb}


% Language setting
% Replace `english' with e.g. `spanish' to change the document language
\usepackage[english]{babel}

% Set page size and margins
% Replace `letterpaper' with `a4paper' for UK/EU standard size
\usepackage[letterpaper,top=2cm,bottom=2cm,left=3cm,right=3cm,marginparwidth=1.75cm]{geometry}

% Useful packages
\usepackage{amsmath}
\usepackage{graphicx}
\title{Superposition Futarchy: Conditional Execution via Market-Based State Collapse}
\author[1]{Greshams Code}
\affil[1]{Founder, \href{https://govex.ai}{Govex.ai}}
\date{June 2025}
\begin{document}
\maketitle

\begin{abstract}
    We present a novel form of futarchy where conditional outcomes exist in superposition until resolved by market consensus, with all concurrent 
    proposals sharing the same liquidity pool. Unlike traditional futarchy 
    where each proposal requires separate liquidity, our system enables 
    multiple proposals to trade simultaneously against a unified AMM, 
    dramatically improving capital efficiency and price discovery. Upon initiation of a futarchy proposal all proposed token actions are minted and performed immediately with conditional tokens. These tokens trade freely until being resolved by highest reading the Time-Weighted-Average-Price.
    The protocol operates on a state budget rather than limiting concurrent events, allowing flexible combinations (e.g., the Cartesian product of 4 binary events or one 16-outcome event within a 16-state budget).
    \end{abstract}
    
\section{Unified Liquidity Across Concurrent Proposals}

Traditional futarchy implementations suffer from liquidity fragmentation - 
each proposal requires its own separate market with dedicated liquidity. 
This creates several problems: capital inefficiency where 10 proposals need 10x the liquidity; weak price signals as thin markets lead to poor price discovery; and limited scalability since organizations can only run few proposals simultaneously.

Superposition futarchy solves this by having ALL proposals share the SAME liquidity pool. With a 16-state budget, you could run: 4 binary proposals concurrently ($2^4 = 16$ states); 2 binary + 1 four-option proposal ($2 \times 2 \times 4 = 16$ states); or 1 sixteen-option proposal.

All using the SAME liquidity, providing deep markets for accurate pricing.

\subsection{Independent Conditional AMM Pools per Elementary State}
Each elementary state $s \in \mathcal{S}$ maintains an \textbf{independent} constant-product AMM pool:
\begin{equation}
x_s \cdot y_s = k_s, \quad k_s = x_0 \cdot y_0
\end{equation}
where $x_s$ and $y_s$ denote the conditional-USDC and conditional-DAO-TOKEN balances for state $s$, initialized from original spot reserves $(x_0, y_0)$. Following Hanson's conditional token framework, each spot token entering the system creates one conditional token per state. This ensures each state pool has full depth while maintaining the key solvency property: exactly one state resolves as winning, so maximum payout equals original collateral.

\section{Immediate Conditional Token Creation}

Current implementations of futarchy allow users to create proposals for a company treasury to transfer spot tokens to an address if the proposal passes \cite{govex}. Assuming the proposal measuring period is X seconds, this creates X seconds latency between decision proposal and decision actions. This has an opportunity cost of:
\begin{equation}
    C = V \cdot X \cdot r
\end{equation}
where:
\begin{align*}
    C &= \text{Opportunity Cost} \\
    V &= \text{Value to Transfer} \\
    X &= \text{Latency (in seconds)} \\
    r &= \text{Market Interest Rate}
\end{align*}
Immediate transfers offer immediate capital utility.

In Superposition futarchy, if Alice creates a proposal for company B to pay her 1000 USDC to do work, she immediately gets sent 1000 Accept-USDC. This will only be redeemable for 1000 spot USDC if the proposal passes. So she both does and doesn't get paid. The decision markets collapse the superposition to one of the options.

This is a useful abstraction that allows a futarchy treasury to atomically buy back or dilute its own stock when it trades below or above net asset value, without being front run. MntCapital, an onchain fund, had significant friction with buy backs \cite{mntcapital}. This requires deep conditional liquidity, which a futarchy AMM provides \cite{metadao}. Conditional tokens trade freely until resolution. This helps the market to more fairly price token actions.

\section{Superposition State Budget}

Current leading implementations of futarchy allow for N outcomes markets that share the same liquidity \cite{govex2}. However, existing systems require separate liquidity pools per proposal. Our superposition approach ensures ALL active proposals trade against the same unified liquidity pool. This means adding a new proposal doesn't dilute liquidity - it simply expands the state space while maintaining full market depth. Assuming all liquidity is in a Uniswap-V2 style AMM, thicker liquidity will create greater incentives for traders to price the outcomes accurately.

Each proposal $i$ defines a \textbf{factor space} $\mathcal{F}_i$ with $k_i$ possible outcomes where $k_i \geq 2$. Proposals are \textbf{not} restricted to binary choices. For example: binary proposals have $\mathcal{F}_i = \{\text{Accept}_i, \text{Reject}_i\}$ where $k_i = 2$; multi-option proposals have $\mathcal{F}_i = \{\text{Option}_1, \text{Option}_2, \ldots, \text{Option}_{k_i}\}$; and ranked choice proposals might have $\mathcal{F}_i = \{\text{Candidate}_A, \text{Candidate}_B, \text{Candidate}_C, \text{Candidate}_D\}$ where $k_i = 4$.

Consider two binary proposals: Alice requesting 1000 USDC and Bob requesting 1000 USDC. The complete state space is:
    \begin{equation}
    \mathcal{S} = \mathcal{F}_A \times \mathcal{F}_B
    \end{equation}
    
    This yields four states:
    \begin{center}
    \begin{tabular}{|c|c|c|}
    \hline
    & $\text{Accept}_B$ & $\text{Reject}_B$ \\
    \hline
    $\text{Accept}_A$ & Alice: 1000 USDC, Bob: 1000 USDC & Alice: 1000 USDC, Bob: 0 USDC \\
    \hline
    $\text{Reject}_A$ & Alice: 0 USDC, Bob: 1000 USDC & Alice: 0 USDC, Bob: 0 USDC \\
    \hline
    \end{tabular}
    \end{center}

For $n$ proposals, the state space size is:
    \begin{equation}
    |\mathcal{S}| = \prod_{i=1}^{n} k_i
    \end{equation}
    subject to the state budget constraint:
    \begin{equation}
    |\mathcal{S}| \leq B
    \end{equation}
    where $B$ is the maximum state budget. This allows flexible combinations (e.g., 4 binary proposals yield $2^4 = 16$ states, equivalent to one 16-outcome proposal).

The state space forms a tensor $\mathcal{T} \in \mathbb{R}^{k_1 \times k_2 \times \ldots \times k_n}$ where each proposal corresponds to a mode. Each element $\mathcal{T}_{i_1, i_2, \ldots, i_n}$ represents the state where proposal 1 has outcome $i_1$, proposal 2 has outcome $i_2$, etc.

    When proposal $j$ resolves to outcome $o_j^*$, the state space collapses along factor $\mathcal{F}_j$:
    \begin{equation}
    \mathcal{S}_{\text{collapsed}} = \mathcal{F}_1 \times \ldots \times \{o_j^*\} \times \ldots \times \mathcal{F}_n
    \end{equation}
    
    This is equivalent to taking a tensor slice along mode $j$ at index $o_j^*$.

Proposals can contribute factors of varying sizes: binary votes have $|\mathcal{F}_i| = 2$, multi-option rankings have $|\mathcal{F}_i| = 5$ (for 5 options), and complex conditional proposals have $|\mathcal{F}_i| = k_i$ conditional paths.

New proposals enter freed slots. When proposal $j$ resolves, the state budget capacity freed is:
    \begin{equation}
    \Delta B = |\mathcal{S}| \cdot \left(1 - \frac{1}{k_j}\right)
    \end{equation}
    New proposal $m$ with $k_m$ outcomes can enter if:
    \begin{equation}
    |\mathcal{S}_{\text{collapsed}}| \cdot k_m \leq B
    \end{equation}

State expansion creates a continuous decision pipeline. When proposal $m$ enters at time $t$, the state space expands:
    \begin{equation}
    \mathcal{S}_{t+1} = \mathcal{S}_t \times \mathcal{F}_m \quad \text{where} \quad |\mathcal{S}_{t+1}| = |\mathcal{S}_t| \cdot k_m
    \end{equation}
    This creates a continuous pipeline where proposals can be added as capacity becomes available, maintaining:
    \begin{equation}
    \prod_{i \in \text{active}} k_i \leq B
    \end{equation}

For state collapse mechanics, when proposal $j$ resolves to $o_j^*$, the collapse operation:
    \begin{equation}
    \Pi_j(o_j^*): \mathcal{S} \rightarrow \mathcal{S}_{\text{collapsed}}
    \end{equation}
    reduces the state count by factor $k_j$:
    \begin{equation}
    |\mathcal{S}_{\text{collapsed}}| = \frac{|\mathcal{S}|}{k_j}
    \end{equation}

\subsection{Hanson-Style Conditional Token Creation}
When spot tokens enter the system, they follow Hanson's conditional token framework: 1 spot token creates 1 conditional token for \textit{each} mutually exclusive state. For example, 1000 spot USDC with 16 active states creates 1000 conditional-USDC tokens in \textit{each} state (16,000 total conditional tokens). Upon resolution, only tokens in winning states redeem 1:1 to spot; tokens in losing states become worthless. This ensures every state has full depth while maintaining solvency—the maximum payout equals the original collateral.


Total AMM liquidity $L$ is preserved during state transitions. When all proposals resolve, conditional liquidity converts to spot liquidity at a 1:1 ratio for winning outcomes.

\subsection{Lazy Token State Updates}
When users interact with their conditional tokens, the system must resolve their current valid states. Two approaches:


Two approaches exist for state resolution. \textbf{State History Traversal} maintains a log of state collapses. When user tokens are accessed, replay collapses from their last update timestamp. Complexity: O(k) where k is number of resolutions since last update. \textbf{Finalization Checkpoints} mark remaining states as "finalized" with direct spot redemption rates after sufficient proposals resolve. Tokens in finalized states skip traversal entirely (O(1) redemption).

Example: User holds tokens from state (Accept$_A$, Accept$_B$, Reject$_C$). If proposal A resolved to Reject, their tokens are worthless. If A and B both resolved to Accept, and only C remains active, their tokens map to states (Accept$_C$) and (Reject$_C$) with defined redemption values.

\subsection{Per-Proposal TWAP with State Transition Checkpointing}
Let $\mathcal{T} = \{\mathcal{S}_1, \mathcal{S}_2, \ldots, \mathcal{S}_m\}$ denote the sequence of state tensor configurations separated by expansions (proposal entry) or collapses (proposal resolution). For configuration $\mathcal{S}_j$, let $[t_j^{\text{start}}, t_j^{\text{end}}]$ be its validity interval.
        
        For proposal $i$ entering during configuration $\mathcal{S}_{\alpha}$ and resolving during $\mathcal{S}_{\beta}$, the TWAP for outcome $o \in \mathcal{F}_i$ is:
        \begin{equation}
        \text{TWAP}_{i,o} = \frac{\sum_{j=\alpha}^{\beta-1} \text{TWAP}_{i,o,j} \cdot (t_j^{\text{end}} - t_j^{\text{start}})}{\sum_{j=\alpha}^{\beta-1} (t_j^{\text{end}} - t_j^{\text{start}})}
        \end{equation}
        where for each configuration $j$:
        \begin{equation}
        \text{TWAP}_{i,o,j} = \frac{1}{t_j^{\text{end}} - t_j^{\text{start}}} \sum_{\tau=t_j^{\text{start}}}^{t_j^{\text{end}}} \max_{s \in \mathcal{S}_j : s_i = o} p_s(\tau)
        \end{equation}
        
        \textbf{Key insight}: State tensor transitions $\mathcal{S}_j \to \mathcal{S}_{j+1}$ (via expansion or collapse) trigger checkpointing of all active proposals' TWAPs, then fresh accumulation begins under the new tensor geometry.
        
        At resolution time for proposal $i$:
        \begin{equation}
        o_i^* = \arg\max_{o \in \mathcal{F}_i} \text{TWAP}_{i,o}
        \end{equation}
        
        \textbf{Example}: Consider 2×2 state space with proposals A, B: Configuration $\mathcal{S}_1$ [0,100] has only A active (2-dimensional state space); Configuration $\mathcal{S}_2$ [100,200] has B enter causing expansion (4-dimensional tensor); Configuration $\mathcal{S}_3$ [200,300] has A collapse to outcome (2-dimensional residual). For B's outcome $o$: $\text{TWAP}_{B,o} = \frac{\text{TWAP}_{B,o,2} \cdot 100 + \text{TWAP}_{B,o,3} \cdot 100}{200}$
        
        \textbf{Storage Complexity}: System maintains checkpoint tensor $\mathcal{C} \in \mathbb{R}^{|\mathcal{P}| \times |\mathcal{O}| \times |\mathcal{T}|}$ where $|\mathcal{P}|$ is max concurrent proposals, $|\mathcal{O}|$ is max outcomes per proposal, and $|\mathcal{T}|$ is number of state transitions. Each expansion/collapse triggers O($|\mathcal{P}| \cdot |\mathcal{O}|$) checkpoint writes.
        
        \textbf{Critical Property}: When proposal $i$ enters at time $t_{\text{entry}}$ causing state expansion, its TWAP accumulation begins at $t_{\text{entry}}$. It has no price history before $t_{\text{entry}}$, preventing manipulation via strategic late entry. Proposals cannot retroactively claim prices from before they existed in the state tensor.
        
        Example: Proposal A tracked over 3 windows: Window 1 has Accept$_A$ max state TWAP of \$0.70 and Reject$_A$ max state TWAP of \$0.35; Window 2 has Accept$_A$ at \$0.75 and Reject$_A$ at \$0.30; Window 3 has Accept$_A$ at \$0.68 and Reject$_A$ at \$0.32. Accept$_A$ wins with average of max TWAPs: \$0.71 vs Reject$_A$'s \$0.323.
        
\section{Computational Complexity}
The protocol's computational requirements scale with the state tensor size $|\mathcal{S}| = \prod_{i=1}^{n} k_i$. AMM operations require O(1) per affected pool, O($|\mathcal{S}|$) worst case. State transitions (expansion/collapse) require O($|\mathcal{S}|$) pool updates. TWAP checkpointing requires O($|\mathcal{P}| \cdot |\mathcal{O}|$) per state transition. Token redemption requires O($\log |\mathcal{T}|$) via binary search through transition history.
For a 16-state budget, these operations remain tractable on high-throughput chains (Solana, Sui). Larger budgets may require layer-2 solutions or specialized hardware.

\section{Manipulation Resistance}
The cloned liquidity architecture provides strong manipulation resistance. Manipulating outcome $o$ requires moving prices in ALL states where $s_i = o$. With liquidity $L$ per state, attack cost scales as O($L \cdot |\{s : s_i = o\}|$). Multi-block manipulation is required due to time-weighting in the TWAP defense. Cross-state arbitrageurs maintain price coherence through arbitrage protection.

\section{Conclusion}
Superposition futarchy represents a fundamental advance in decentralized governance, solving the liquidity fragmentation problem through a novel tensor-based state space that collapses via market consensus. By cloning rather than splitting liquidity, the protocol enables unlimited concurrent proposals while maintaining deep markets and accurate price discovery. The immediate conditional execution eliminates latency costs, while the state budget constraint provides flexible complexity management. This architecture could enable a new generation of highly responsive, market-driven DAOs.

\bibliographystyle{unsrt}
\bibliography{references}

\end{document}