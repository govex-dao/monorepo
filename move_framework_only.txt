// ============================================================================
// FORK NOTE: Table-based implementation for architectural correctness
// 
// CONTEXT:
// Extensions is a shared global registry - a public good that all protocols
// build upon. Success means growth: new standards, partners, and integrations.
// 
// DECISION:
// Using Tables for O(1) lookups is not optimization - it's the architecturally
// correct choice for a global registry. A vector would create a scalability
// bug that punishes ecosystem growth with degraded performance.
// 
// AUDIT BENEFIT:
// Table-based code is simpler to audit - verifying correct usage of standard
// Sui primitives vs. proving correctness of custom nested loops.
// ============================================================================

/// The Extensions shared object tracks a list of verified and whitelisted packages.
/// These are the only packages that can be added as dependencies to an account if it disallows unverified packages.

module account_extensions::extensions;

// === Imports ===

use std::string::String;
use sui::table::{Self, Table};

// === Errors ===

const EExtensionNotFound: u64 = 0;
const EExtensionAlreadyExists: u64 = 1;
const ECannotRemoveAccountProtocol: u64 = 2;

// === Structs ===

/// A list of verified and whitelisted packages
public struct Extensions has key {
    id: UID,
    /// Table for O(1) name-based lookups
    by_name: Table<String, Extension>,
    /// Table for O(1) address-based lookups  
    by_addr: Table<address, String>,
}

/// A package with a name and all authorized versions
public struct Extension has copy, drop, store {
    name: String,
    history: vector<History>,
}

/// The address and version of a package
public struct History has copy, drop, store {
    addr: address,
    version: u64,
}

/// A capability to add and remove extensions
public struct AdminCap has key, store {
    id: UID,
}

// === Public functions ===

fun init(ctx: &mut TxContext) {
    transfer::transfer(AdminCap { id: object::new(ctx) }, ctx.sender());
    transfer::share_object(Extensions { 
        id: object::new(ctx),
        by_name: table::new(ctx),
        by_addr: table::new(ctx),
    });
}

// === View functions ===

/// Returns the number of extensions in the list
public fun length(extensions: &Extensions): u64 {
    extensions.by_name.length()
}

/// Returns the extension by name
public fun get_by_name(extensions: &Extensions, name: String): &Extension {
    assert!(extensions.by_name.contains(name), EExtensionNotFound);
    extensions.by_name.borrow(name)
}


/// Returns the name of the extension
public fun name(extension: &Extension): String {
    extension.name
}

/// Returns the history of the extension
public fun history(extension: &Extension): vector<History> {
    extension.history
}

/// Returns the address of the history
public fun addr(history: &History): address {
    history.addr
}

/// Returns the version of the history
public fun version(history: &History): u64 {
    history.version
}

/// Returns the latest address and version for a given name
public fun get_latest_for_name(
    extensions: &Extensions, 
    name: String, 
): (address, u64) {
    assert!(extensions.by_name.contains(name), EExtensionNotFound);
    let extension = extensions.by_name.borrow(name);
    let history = extension.history;
    let last_idx = history.length() - 1;

    (history[last_idx].addr, history[last_idx].version)
}

/// Returns true if the package (name, addr, version) is in the list
public fun is_extension(
    extensions: &Extensions, 
    name: String,
    addr: address,
    version: u64,
): bool {
    // O(1) check if the extension exists
    if (!extensions.by_name.contains(name)) return false;
    
    let extension = extensions.by_name.borrow(name);
    
    // Linear search through history (O(versions) - typically 1-3)
    let mut found = false;
    let mut i = 0;
    while (i < extension.history.length()) {
        let h = &extension.history[i];
        if (h.addr == addr && h.version == version) {
            found = true;
            break
        };
        i = i + 1;
    };
    found
}

// === Admin functions ===

/// Adds a package to the list
public fun add(extensions: &mut Extensions, _: &AdminCap, name: String, addr: address, version: u64) {    
    // O(1) checks - simpler for auditors to verify
    assert!(!extensions.by_name.contains(name), EExtensionAlreadyExists);
    assert!(!extensions.by_addr.contains(addr), EExtensionAlreadyExists);
    
    let extension = Extension { name, history: vector[History { addr, version }] };
    
    // O(1) insertions
    extensions.by_name.add(name, extension);
    extensions.by_addr.add(addr, name);
}

/// Removes a package from the list with proper cleanup
public fun remove(extensions: &mut Extensions, _: &AdminCap, name: String) {
    assert!(extensions.by_name.contains(name), EExtensionNotFound);
    assert!(name != b"AccountProtocol".to_string(), ECannotRemoveAccountProtocol);
    
    // Remove the extension and get its history for cleanup
    let extension = extensions.by_name.remove(name);
    let Extension { name: _, history } = extension;
    
    // Clean up all associated addresses from reverse lookup (O(versions) - small)
    let mut i = 0;
    while (i < history.length()) {
        let h = &history[i];
        // Only remove if address still maps to this extension name
        if (extensions.by_addr.contains(h.addr)) {
            let mapped_name = extensions.by_addr.borrow(h.addr);
            if (*mapped_name == name) {
                extensions.by_addr.remove(h.addr);
            }
        };
        i = i + 1;
    };
    
    // History is a vector of History structs with copy+drop, it will be dropped automatically
}

/// Adds a new version to the history of a package
public fun update(extensions: &mut Extensions, _: &AdminCap, name: String, addr: address, version: u64) {
    // O(1) checks
    assert!(extensions.by_name.contains(name), EExtensionNotFound);
    assert!(!extensions.by_addr.contains(addr), EExtensionAlreadyExists);
    
    // Update in table
    let extension = extensions.by_name.borrow_mut(name);
    extension.history.push_back(History { addr, version });
    
    // Add address mapping
    extensions.by_addr.add(addr, name);
}

public entry fun new_admin(_: &AdminCap, recipient: address, ctx: &mut TxContext) {
    transfer::public_transfer(AdminCap { id: object::new(ctx) }, recipient);
}

// === Private functions ===


//**************************************************************************************************//
// Tests                                                                                            //
//**************************************************************************************************//

// === Test Helpers ===

#[test_only]
public fun init_for_testing(ctx: &mut TxContext) {
    init(ctx);
}

#[test_only]
public fun new_for_testing(ctx: &mut TxContext): Extensions {
    Extensions {
        id: object::new(ctx),
        by_name: table::new(ctx),
        by_addr: table::new(ctx),
    }
}

#[test_only]
public fun add_for_testing(extensions: &mut Extensions, name: String, addr: address, version: u64) {    
    assert!(!extensions.by_name.contains(name), EExtensionAlreadyExists);
    assert!(!extensions.by_addr.contains(addr), EExtensionAlreadyExists);
    let extension = Extension { name, history: vector[History { addr, version }] };
    extensions.by_name.add(name, extension);
    extensions.by_addr.add(addr, name);
}

#[test_only]
public fun remove_for_testing(extensions: &mut Extensions, name: String) {
    assert!(extensions.by_name.contains(name), EExtensionNotFound);
    assert!(name != b"AccountProtocol".to_string(), ECannotRemoveAccountProtocol);
    
    let extension = extensions.by_name.remove(name);
    let Extension { name: _, history } = extension;
    
    let mut i = 0;
    while (i < history.length()) {
        let h = &history[i];
        if (extensions.by_addr.contains(h.addr)) {
            let mapped_name = extensions.by_addr.borrow(h.addr);
            if (*mapped_name == name) {
                extensions.by_addr.remove(h.addr);
            }
        };
        i = i + 1;
    };
    
    // History is a vector of History structs with copy+drop, it will be dropped automatically
}

#[test_only]
public fun update_for_testing(extensions: &mut Extensions, name: String, addr: address, version: u64) {
    assert!(extensions.by_name.contains(name), EExtensionNotFound);
    assert!(!extensions.by_addr.contains(addr), EExtensionAlreadyExists);
    
    let extension = extensions.by_name.borrow_mut(name);
    extension.history.push_back(History { addr, version });
    extensions.by_addr.add(addr, name);
}

#[test_only]
public fun new_for_testing_with_addrs(addr1: address, addr2: address, addr3: address, ctx: &mut TxContext): Extensions {
    let mut extensions = Extensions {
        id: object::new(ctx),
        by_name: table::new(ctx),
        by_addr: table::new(ctx),
    };
    
    // Add AccountProtocol
    let ext1 = Extension { name: b"AccountProtocol".to_string(), history: vector[History { addr: addr1, version: 1 }] };
    extensions.by_name.add(b"AccountProtocol".to_string(), ext1);
    extensions.by_addr.add(addr1, b"AccountProtocol".to_string());
    
    // Add AccountConfig
    let ext2 = Extension { name: b"AccountConfig".to_string(), history: vector[History { addr: addr2, version: 1 }] };
    extensions.by_name.add(b"AccountConfig".to_string(), ext2);
    extensions.by_addr.add(addr2, b"AccountConfig".to_string());
    
    // Add AccountActions
    let ext3 = Extension { name: b"AccountActions".to_string(), history: vector[History { addr: addr3, version: 1 }] };
    extensions.by_name.add(b"AccountActions".to_string(), ext3);
    extensions.by_addr.add(addr3, b"AccountActions".to_string());
    
    extensions
}

#[test_only]
public struct Witness() has drop;

#[test_only]
public fun witness(): Witness {
    Witness()
}

// === Unit Tests ===

#[test_only]
use sui::test_utils::destroy;
#[test_only]
use sui::test_scenario as ts;

#[test]
fun test_init() {
    let mut scenario = ts::begin(@0xCAFE);
    init(scenario.ctx());
    scenario.next_tx(@0xCAFE);

    let cap = scenario.take_from_sender<AdminCap>();
    let extensions = scenario.take_shared<Extensions>();

    destroy(cap);
    destroy(extensions);
    scenario.end();
}

#[test]
fun test_getters() {
    let extensions = new_for_testing_with_addrs(@0x0, @0x1, @0x2, &mut tx_context::dummy());

    // assertions
    assert!(extensions.is_extension(b"AccountProtocol".to_string(), @0x0, 1));
    assert!(extensions.is_extension(b"AccountConfig".to_string(), @0x1, 1));

    assert!(extensions.length() == 3);
    assert!(extensions.get_by_name(b"AccountProtocol".to_string()).name() == b"AccountProtocol".to_string());
    assert!(extensions.get_by_name(b"AccountProtocol".to_string()).history()[0].addr() == @0x0);
    assert!(extensions.get_by_name(b"AccountProtocol".to_string()).history()[0].version() == 1);
    assert!(extensions.get_by_name(b"AccountConfig".to_string()).name() == b"AccountConfig".to_string());
    assert!(extensions.get_by_name(b"AccountConfig".to_string()).history()[0].addr() == @0x1);
    assert!(extensions.get_by_name(b"AccountConfig".to_string()).history()[0].version() == 1);
    assert!(extensions.get_by_name(b"AccountActions".to_string()).name() == b"AccountActions".to_string());
    assert!(extensions.get_by_name(b"AccountActions".to_string()).history()[0].addr() == @0x2);
    assert!(extensions.get_by_name(b"AccountActions".to_string()).history()[0].version() == 1);

    destroy(extensions);
}

#[test]
fun test_get_latest_for_name() {
    let mut extensions = new_for_testing_with_addrs(@0x0, @0x1, @0x2, &mut tx_context::dummy());
    let cap = AdminCap { id: object::new(&mut tx_context::dummy()) };

    let (addr, version) = extensions.get_latest_for_name(b"AccountProtocol".to_string());
    assert!(addr == @0x0);
    assert!(version == 1);
    let (addr, version) = extensions.get_latest_for_name(b"AccountConfig".to_string());
    assert!(addr == @0x1);
    assert!(version == 1);
    let (addr, version) = extensions.get_latest_for_name(b"AccountActions".to_string());
    assert!(addr == @0x2);
    assert!(version == 1);
    // update
    extensions.update(&cap, b"AccountConfig".to_string(), @0x11, 2);
    extensions.update(&cap, b"AccountActions".to_string(), @0x21, 2);
    extensions.update(&cap, b"AccountActions".to_string(), @0x22, 3);
    let (addr, version) = extensions.get_latest_for_name(b"AccountProtocol".to_string());
    assert!(addr == @0x0);
    assert!(version == 1);
    let (addr, version) = extensions.get_latest_for_name(b"AccountConfig".to_string());
    assert!(addr == @0x11);
    assert!(version == 2);
    let (addr, version) = extensions.get_latest_for_name(b"AccountActions".to_string());
    assert!(addr == @0x22);
    assert!(version == 3);

    destroy(extensions);
    destroy(cap);
}

#[test]
fun test_is_extension() {
    let extensions = new_for_testing_with_addrs(@0x0, @0x1, @0x2, &mut tx_context::dummy());
    let cap = AdminCap { id: object::new(&mut tx_context::dummy()) };

    let (addr, version) = extensions.get_latest_for_name(b"AccountProtocol".to_string());
    assert!(addr == @0x0);
    assert!(version == 1);
    let (addr, version) = extensions.get_latest_for_name(b"AccountConfig".to_string());
    assert!(addr == @0x1);
    assert!(version == 1);
    let (addr, version) = extensions.get_latest_for_name(b"AccountActions".to_string());
    assert!(addr == @0x2);
    assert!(version == 1);

    // correct extensions
    assert!(extensions.is_extension(b"AccountProtocol".to_string(), @0x0, 1));
    assert!(extensions.is_extension(b"AccountConfig".to_string(), @0x1, 1));
    assert!(extensions.is_extension(b"AccountActions".to_string(), @0x2, 1));
    // incorrect names
    assert!(!extensions.is_extension(b"AccountProtoco".to_string(), @0x0, 1));
    assert!(!extensions.is_extension(b"AccountConfi".to_string(), @0x1, 1));
    assert!(!extensions.is_extension(b"AccountAction".to_string(), @0x2, 1));
    // incorrect addresses
    assert!(!extensions.is_extension(b"AccountProtocol".to_string(), @0x1, 1));
    assert!(!extensions.is_extension(b"AccountConfig".to_string(), @0x0, 1));
    assert!(!extensions.is_extension(b"AccountActions".to_string(), @0x0, 1));
    // incorrect versions
    assert!(!extensions.is_extension(b"AccountProtocol".to_string(), @0x0, 2));
    assert!(!extensions.is_extension(b"AccountConfig".to_string(), @0x1, 2));
    assert!(!extensions.is_extension(b"AccountActions".to_string(), @0x2, 2));

    destroy(extensions);
    destroy(cap);
}

#[test]
fun test_add_deps() {
    let mut extensions = new_for_testing(&mut tx_context::dummy());
    let cap = AdminCap { id: object::new(&mut tx_context::dummy()) };

    // add extension
    extensions.add(&cap, b"A".to_string(), @0xA, 1);
    extensions.add(&cap, b"B".to_string(), @0xB, 1);
    extensions.add(&cap, b"C".to_string(), @0xC, 1);
    // assertions
    assert!(extensions.is_extension(b"A".to_string(), @0xA, 1));
    assert!(extensions.is_extension(b"B".to_string(), @0xB, 1));
    assert!(extensions.is_extension(b"C".to_string(), @0xC, 1));

    destroy(extensions);
    destroy(cap);
}

#[test]
fun test_update_deps() {
    let mut extensions = new_for_testing_with_addrs(@0x0, @0x1, @0x2, &mut tx_context::dummy());
    let cap = AdminCap { id: object::new(&mut tx_context::dummy()) };

    // add extension (checked above)
    extensions.add(&cap, b"A".to_string(), @0xA, 1);
    extensions.add(&cap, b"B".to_string(), @0xB, 1);
    extensions.add(&cap, b"C".to_string(), @0xC, 1);
    // update deps
    extensions.update(&cap, b"B".to_string(), @0x1B, 2);
    extensions.update(&cap, b"C".to_string(), @0x1C, 2);
    extensions.update(&cap, b"C".to_string(), @0x2C, 3);
    // assertions
    assert!(extensions.get_by_name(b"A".to_string()).name() == b"A".to_string());
    assert!(extensions.get_by_name(b"A".to_string()).history()[0].addr() == @0xA);
    assert!(extensions.get_by_name(b"A".to_string()).history()[0].version() == 1);
    assert!(extensions.get_by_name(b"B".to_string()).name() == b"B".to_string());
    assert!(extensions.get_by_name(b"B".to_string()).history()[1].addr() == @0x1B);
    assert!(extensions.get_by_name(b"B".to_string()).history()[1].version() == 2);
    assert!(extensions.get_by_name(b"C".to_string()).name() == b"C".to_string());
    assert!(extensions.get_by_name(b"C".to_string()).history()[2].addr() == @0x2C);
    assert!(extensions.get_by_name(b"C".to_string()).history()[2].version() == 3);
    // verify core deps didn't change    
    assert!(extensions.length() == 6);
    assert!(extensions.get_by_name(b"AccountProtocol".to_string()).name() == b"AccountProtocol".to_string());
    assert!(extensions.get_by_name(b"AccountProtocol".to_string()).history()[0].addr() == @0x0);
    assert!(extensions.get_by_name(b"AccountProtocol".to_string()).history()[0].version() == 1);
    assert!(extensions.get_by_name(b"AccountConfig".to_string()).name() == b"AccountConfig".to_string());
    assert!(extensions.get_by_name(b"AccountConfig".to_string()).history()[0].addr() == @0x1);
    assert!(extensions.get_by_name(b"AccountConfig".to_string()).history()[0].version() == 1);
    assert!(extensions.get_by_name(b"AccountActions".to_string()).name() == b"AccountActions".to_string());
    assert!(extensions.get_by_name(b"AccountActions".to_string()).history()[0].addr() == @0x2);
    assert!(extensions.get_by_name(b"AccountActions".to_string()).history()[0].version() == 1);

    destroy(extensions);
    destroy(cap);
}

#[test]
fun test_remove_deps() {
    let mut extensions = new_for_testing_with_addrs(@0x0, @0x1, @0x2, &mut tx_context::dummy());
    let cap = AdminCap { id: object::new(&mut tx_context::dummy()) };

    // add extension (checked above)
    extensions.add(&cap, b"A".to_string(), @0xA, 1);
    extensions.add(&cap, b"B".to_string(), @0xB, 1);
    extensions.add(&cap, b"C".to_string(), @0xC, 1);
    // update deps
    extensions.update(&cap, b"B".to_string(), @0x1B, 2);
    extensions.update(&cap, b"C".to_string(), @0x1C, 2);
    extensions.update(&cap, b"C".to_string(), @0x2C, 3);
    // remove deps
    extensions.remove(&cap, b"A".to_string());
    extensions.remove(&cap, b"B".to_string());
    extensions.remove(&cap, b"C".to_string());
    // assertions
    assert!(!extensions.is_extension(b"A".to_string(), @0xA, 1));
    assert!(!extensions.is_extension(b"B".to_string(), @0xB, 1));
    assert!(!extensions.is_extension(b"B".to_string(), @0x1B, 2));
    assert!(!extensions.is_extension(b"C".to_string(), @0xC, 1));
    assert!(!extensions.is_extension(b"C".to_string(), @0x1C, 2));
    assert!(!extensions.is_extension(b"C".to_string(), @0x2C, 3));

    destroy(extensions);
    destroy(cap);
}

#[test]
fun test_new_admin() {
    let mut scenario = ts::begin(@0xCAFE);
    let cap = AdminCap { id: object::new(scenario.ctx()) };
    new_admin(&cap, @0xB0B, scenario.ctx());
    scenario.next_tx(@0xB0B);
    // check it exists
    let new_cap = scenario.take_from_sender<AdminCap>();
    destroy(cap);
    destroy(new_cap);
    ts::end(scenario);
}

#[test, expected_failure(abort_code = ECannotRemoveAccountProtocol)]
fun test_error_remove_account_protocol() {
    let mut extensions = new_for_testing_with_addrs(@0x0, @0x1, @0x2, &mut tx_context::dummy());
    let cap = AdminCap { id: object::new(&mut tx_context::dummy()) };
    extensions.remove(&cap, b"AccountProtocol".to_string());
    destroy(extensions);
    destroy(cap);
}

#[test, expected_failure(abort_code = EExtensionAlreadyExists)]
fun test_error_add_extension_name_already_exists() {
    let mut extensions = new_for_testing_with_addrs(@0x0, @0x1, @0x2, &mut tx_context::dummy());
    let cap = AdminCap { id: object::new(&mut tx_context::dummy()) };
    extensions.add(&cap, b"AccountProtocol".to_string(), @0xA, 1);
    destroy(extensions);
    destroy(cap);
}

#[test, expected_failure(abort_code = EExtensionAlreadyExists)]
fun test_error_add_extension_address_already_exists() {
    let mut extensions = new_for_testing_with_addrs(@0x0, @0x1, @0x2, &mut tx_context::dummy());
    let cap = AdminCap { id: object::new(&mut tx_context::dummy()) };
    extensions.add(&cap, b"A".to_string(), @0x0, 1);
    destroy(extensions);
    destroy(cap);
}

#[test, expected_failure(abort_code = EExtensionNotFound)]
fun test_error_update_not_extension() {
    let mut extensions = new_for_testing_with_addrs(@0x0, @0x1, @0x2, &mut tx_context::dummy());
    let cap = AdminCap { id: object::new(&mut tx_context::dummy()) };
    extensions.update(&cap, b"A".to_string(), @0x0, 1);
    destroy(extensions);
    destroy(cap);
}

#[test, expected_failure(abort_code = EExtensionAlreadyExists)]
fun test_error_update_same_address() {
    let mut extensions = new_for_testing_with_addrs(@0x0, @0x1, @0x2, &mut tx_context::dummy());
    let cap = AdminCap { id: object::new(&mut tx_context::dummy()) };
    extensions.add(&cap, b"A".to_string(), @0xA, 1);
    extensions.update(&cap, b"A".to_string(), @0xA, 2);
    destroy(extensions);
    destroy(cap);
}

#[test, expected_failure(abort_code = EExtensionNotFound)]
fun test_error_remove_not_extension() {
    let mut extensions = new_for_testing_with_addrs(@0x0, @0x1, @0x2, &mut tx_context::dummy());
    let cap = AdminCap { id: object::new(&mut tx_context::dummy()) };
    extensions.remove(&cap, b"A".to_string());
    destroy(extensions);
    destroy(cap);
}

// === Additional tests for Table optimization edge cases ===

#[test]
/// Test that Tables handle many extensions efficiently
fun test_large_scale_extensions() {
    let mut extensions = new_for_testing_with_addrs(@0x0, @0x1, @0x2, &mut tx_context::dummy());
    let cap = AdminCap { id: object::new(&mut tx_context::dummy()) };
    
    // Add multiple extensions to test O(1) scalability
    // Using predefined addresses since Move doesn't support address arithmetic
    let test_addrs = vector[@0x1000, @0x1001, @0x1002, @0x1003, @0x1004, 
                            @0x1005, @0x1006, @0x1007, @0x1008, @0x1009,
                            @0x100A, @0x100B, @0x100C, @0x100D, @0x100E];
    
    let mut i = 0;
    while (i < test_addrs.length()) {
        let mut name = b"Extension_".to_string();
        let num_str = if (i < 10) {
            vector[48u8 + (i as u8)]  // ASCII '0' = 48
        } else {
            vector[49u8, 48u8 + ((i - 10) as u8)]  // "1x" for 10-14
        };
        name.append_utf8(num_str);
        extensions.add(&cap, name, test_addrs[i], 1);
        i = i + 1;
    };
    
    // Verify O(1) lookups work with many extensions
    assert!(extensions.is_extension(b"Extension_0".to_string(), @0x1000, 1));
    assert!(extensions.is_extension(b"Extension_5".to_string(), @0x1005, 1));
    assert!(extensions.is_extension(b"Extension_14".to_string(), @0x100E, 1));
    
    // Verify get_latest_for_name still works efficiently
    let (addr, version) = extensions.get_latest_for_name(b"Extension_7".to_string());
    assert!(addr == @0x1007);
    assert!(version == 1);
    
    destroy(extensions);
    destroy(cap);
}

#[test]
/// Test that version history is maintained correctly with Tables
fun test_version_history_with_tables() {
    let mut extensions = new_for_testing_with_addrs(@0x0, @0x1, @0x2, &mut tx_context::dummy());
    let cap = AdminCap { id: object::new(&mut tx_context::dummy()) };
    
    // Add an extension
    extensions.add(&cap, b"TestExt".to_string(), @0xA, 1);
    
    // Update it multiple times
    extensions.update(&cap, b"TestExt".to_string(), @0xB, 2);
    extensions.update(&cap, b"TestExt".to_string(), @0xC, 3);
    extensions.update(&cap, b"TestExt".to_string(), @0xD, 4);
    
    // Verify version history
    assert!(extensions.is_extension(b"TestExt".to_string(), @0xA, 1));
    assert!(extensions.is_extension(b"TestExt".to_string(), @0xB, 2));
    assert!(extensions.is_extension(b"TestExt".to_string(), @0xC, 3));
    assert!(extensions.is_extension(b"TestExt".to_string(), @0xD, 4));
    
    // Verify latest version
    let (addr, version) = extensions.get_latest_for_name(b"TestExt".to_string());
    assert!(addr == @0xD);
    assert!(version == 4);
    
    destroy(extensions);
    destroy(cap);
}

#[test]
/// Test concurrent operations on different extensions
fun test_concurrent_operations() {
    let mut extensions = new_for_testing_with_addrs(@0x0, @0x1, @0x2, &mut tx_context::dummy());
    let cap = AdminCap { id: object::new(&mut tx_context::dummy()) };
    
    // Add multiple extensions
    extensions.add(&cap, b"Ext1".to_string(), @0xA1, 1);
    extensions.add(&cap, b"Ext2".to_string(), @0xA2, 1);
    extensions.add(&cap, b"Ext3".to_string(), @0xA3, 1);
    
    // Update them in different order
    extensions.update(&cap, b"Ext3".to_string(), @0xB3, 2);
    extensions.update(&cap, b"Ext1".to_string(), @0xB1, 2);
    extensions.update(&cap, b"Ext2".to_string(), @0xB2, 2);
    
    // Verify all updates worked correctly
    assert!(extensions.is_extension(b"Ext1".to_string(), @0xB1, 2));
    assert!(extensions.is_extension(b"Ext2".to_string(), @0xB2, 2));
    assert!(extensions.is_extension(b"Ext3".to_string(), @0xB3, 2));
    
    // Remove one and verify others still work
    extensions.remove(&cap, b"Ext2".to_string());
    assert!(extensions.is_extension(b"Ext1".to_string(), @0xB1, 2));
    assert!(extensions.is_extension(b"Ext3".to_string(), @0xB3, 2));
    assert!(!extensions.by_name.contains(b"Ext2".to_string()));
    
    destroy(extensions);
    destroy(cap);
}

#[test, expected_failure(abort_code = EExtensionAlreadyExists)]
/// Test that duplicate address detection works with Tables
fun test_error_duplicate_address_across_extensions() {
    let mut extensions = new_for_testing_with_addrs(@0x0, @0x1, @0x2, &mut tx_context::dummy());
    let cap = AdminCap { id: object::new(&mut tx_context::dummy()) };
    
    extensions.add(&cap, b"Ext1".to_string(), @0xABC, 1);
    // Try to add different extension with same address
    extensions.add(&cap, b"Ext2".to_string(), @0xABC, 1);
    
    destroy(extensions);
    destroy(cap);
}

// === Comprehensive Table Implementation Tests ===

#[test]
/// Test O(1) operations with growing number of extensions
fun test_table_constant_time_operations() {
    let mut extensions = new_for_testing(&mut tx_context::dummy());
    let cap = AdminCap { id: object::new(&mut tx_context::dummy()) };
    
    // Add many extensions using predefined addresses
    let test_addrs = vector[
        @0x1000, @0x1001, @0x1002, @0x1003, @0x1004, @0x1005, @0x1006, @0x1007,
        @0x1008, @0x1009, @0x100A, @0x100B, @0x100C, @0x100D, @0x100E, @0x100F,
        @0x1010, @0x1011, @0x1012, @0x1013, @0x1014, @0x1015, @0x1016, @0x1017,
        @0x1018, @0x1019, @0x101A, @0x101B, @0x101C, @0x101D, @0x101E, @0x101F
    ];
    
    let mut i = 0;
    while (i < test_addrs.length()) {
        let mut name = b"Extension_".to_string();
        if (i < 10) {
            name.append_utf8(vector[48u8 + (i as u8)]);
        } else {
            name.append_utf8(vector[((i / 10) as u8) + 48u8, ((i % 10) as u8) + 48u8]);
        };
        extensions.add(&cap, name, test_addrs[i], 1);
        i = i + 1;
    };
    
    // Verify O(1) lookup works efficiently even with many extensions
    assert!(extensions.is_extension(b"Extension_0".to_string(), @0x1000, 1));
    assert!(extensions.is_extension(b"Extension_25".to_string(), @0x1019, 1));
    assert!(extensions.is_extension(b"Extension_31".to_string(), @0x101F, 1));
    
    // Verify get_latest_for_name is O(1)
    let (addr, version) = extensions.get_latest_for_name(b"Extension_30".to_string());
    assert!(addr == @0x101E);
    assert!(version == 1);
    
    destroy(extensions);
    destroy(cap);
}

#[test]
/// Test proper cleanup of reverse lookup table on remove
fun test_remove_cleanup_reverse_lookup() {
    let mut extensions = new_for_testing(&mut tx_context::dummy());
    let cap = AdminCap { id: object::new(&mut tx_context::dummy()) };
    
    // Add extension with multiple versions
    extensions.add(&cap, b"TestExt".to_string(), @0xA, 1);
    extensions.update(&cap, b"TestExt".to_string(), @0xB, 2);
    extensions.update(&cap, b"TestExt".to_string(), @0xC, 3);
    
    // Verify all addresses are in reverse lookup
    assert!(extensions.by_addr.contains(@0xA));
    assert!(extensions.by_addr.contains(@0xB));
    assert!(extensions.by_addr.contains(@0xC));
    
    // Remove the extension
    extensions.remove(&cap, b"TestExt".to_string());
    
    // Verify all addresses are cleaned up from reverse lookup
    assert!(!extensions.by_addr.contains(@0xA));
    assert!(!extensions.by_addr.contains(@0xB));
    assert!(!extensions.by_addr.contains(@0xC));
    
    // Verify we can now reuse those addresses for new extensions
    extensions.add(&cap, b"NewExt1".to_string(), @0xA, 1);
    extensions.add(&cap, b"NewExt2".to_string(), @0xB, 1);
    extensions.add(&cap, b"NewExt3".to_string(), @0xC, 1);
    
    destroy(extensions);
    destroy(cap);
}

#[test]
/// Test address reuse after removal
fun test_address_reuse_after_removal() {
    let mut extensions = new_for_testing(&mut tx_context::dummy());
    let cap = AdminCap { id: object::new(&mut tx_context::dummy()) };
    
    // Add and remove an extension
    extensions.add(&cap, b"TempExt".to_string(), @0xDEAD, 1);
    assert!(extensions.is_extension(b"TempExt".to_string(), @0xDEAD, 1));
    extensions.remove(&cap, b"TempExt".to_string());
    
    // Verify the address can be reused
    extensions.add(&cap, b"NewExt".to_string(), @0xDEAD, 2);
    assert!(extensions.is_extension(b"NewExt".to_string(), @0xDEAD, 2));
    assert!(!extensions.is_extension(b"TempExt".to_string(), @0xDEAD, 1));
    
    destroy(extensions);
    destroy(cap);
}

#[test]
/// Test multiple extensions with overlapping version numbers
fun test_multiple_extensions_different_versions() {
    let mut extensions = new_for_testing(&mut tx_context::dummy());
    let cap = AdminCap { id: object::new(&mut tx_context::dummy()) };
    
    // Add multiple extensions with different version patterns
    extensions.add(&cap, b"Ext1".to_string(), @0x100, 1);
    extensions.update(&cap, b"Ext1".to_string(), @0x101, 2);
    
    extensions.add(&cap, b"Ext2".to_string(), @0x200, 1);
    extensions.update(&cap, b"Ext2".to_string(), @0x201, 2);
    extensions.update(&cap, b"Ext2".to_string(), @0x202, 3);
    
    extensions.add(&cap, b"Ext3".to_string(), @0x300, 5); // Different starting version
    
    // Verify each extension's history is independent
    assert!(extensions.is_extension(b"Ext1".to_string(), @0x100, 1));
    assert!(extensions.is_extension(b"Ext1".to_string(), @0x101, 2));
    assert!(!extensions.is_extension(b"Ext1".to_string(), @0x101, 3)); // Wrong version
    
    assert!(extensions.is_extension(b"Ext2".to_string(), @0x202, 3));
    assert!(!extensions.is_extension(b"Ext2".to_string(), @0x202, 2)); // Wrong version
    
    assert!(extensions.is_extension(b"Ext3".to_string(), @0x300, 5));
    assert!(!extensions.is_extension(b"Ext3".to_string(), @0x300, 1)); // Wrong version
    
    destroy(extensions);
    destroy(cap);
}

#[test, expected_failure(abort_code = EExtensionNotFound)]
/// Test error when getting latest for non-existent extension
fun test_error_get_latest_non_existent() {
    let extensions = new_for_testing(&mut tx_context::dummy());
    let (_addr, _version) = extensions.get_latest_for_name(b"NonExistent".to_string());
    destroy(extensions);
}

#[test, expected_failure(abort_code = EExtensionNotFound)]
/// Test error when updating non-existent extension
fun test_error_update_non_existent() {
    let mut extensions = new_for_testing(&mut tx_context::dummy());
    let cap = AdminCap { id: object::new(&mut tx_context::dummy()) };
    extensions.update(&cap, b"NonExistent".to_string(), @0xBAD, 1);
    destroy(extensions);
    destroy(cap);
}

#[test, expected_failure(abort_code = EExtensionAlreadyExists)]
/// Test error when updating with already used address in same extension
fun test_error_update_duplicate_address_same_extension() {
    let mut extensions = new_for_testing(&mut tx_context::dummy());
    let cap = AdminCap { id: object::new(&mut tx_context::dummy()) };
    
    extensions.add(&cap, b"TestExt".to_string(), @0xA, 1);
    extensions.update(&cap, b"TestExt".to_string(), @0xB, 2);
    // Try to add same address again
    extensions.update(&cap, b"TestExt".to_string(), @0xB, 3);
    
    destroy(extensions);
    destroy(cap);
}

#[test, expected_failure(abort_code = EExtensionAlreadyExists)]
/// Test error when updating with address used by another extension
fun test_error_update_duplicate_address_different_extension() {
    let mut extensions = new_for_testing(&mut tx_context::dummy());
    let cap = AdminCap { id: object::new(&mut tx_context::dummy()) };
    
    extensions.add(&cap, b"Ext1".to_string(), @0xA, 1);
    extensions.add(&cap, b"Ext2".to_string(), @0xB, 1);
    // Try to update Ext2 with Ext1's address
    extensions.update(&cap, b"Ext2".to_string(), @0xA, 2);
    
    destroy(extensions);
    destroy(cap);
}

#[test]
/// Test edge case: empty Extensions object operations
fun test_empty_extensions_operations() {
    let extensions = new_for_testing(&mut tx_context::dummy());
    
    // Test operations on empty Extensions
    assert!(extensions.length() == 0);
    assert!(extensions.size() == 0);
    assert!(!extensions.is_extension(b"Any".to_string(), @0x1, 1));
    
    destroy(extensions);
}

#[test]
/// Test edge case: single extension with single version
fun test_single_extension_single_version() {
    let mut extensions = new_for_testing(&mut tx_context::dummy());
    let cap = AdminCap { id: object::new(&mut tx_context::dummy()) };
    
    extensions.add(&cap, b"OnlyOne".to_string(), @0x51173E, 42);
    
    assert!(extensions.length() == 1);
    assert!(extensions.is_extension(b"OnlyOne".to_string(), @0x51173E, 42));
    assert!(!extensions.is_extension(b"OnlyOne".to_string(), @0x51173E, 41));
    
    let (addr, version) = extensions.get_latest_for_name(b"OnlyOne".to_string());
    assert!(addr == @0x51173E);
    assert!(version == 42);
    
    destroy(extensions);
    destroy(cap);
}/// === FORK MODIFICATIONS ===
/// This file defines type markers for ALL Move Framework actions.
/// 
/// PURPOSE:
/// - Provides compile-time type safety for action routing
/// - Replaces string-based action identification
/// - Avoids circular dependencies by defining types in extensions layer
/// - Each action in protocol/actions packages has a corresponding type here
///
/// DESIGN:
/// - Empty structs with `drop` ability serve as type tags
/// - Constructor functions enable cross-module instantiation
/// - No logic, just pure type definitions
/// - Used by intents system for type-based action routing
///
/// Pure type definitions for Move Framework action types
/// This module has NO dependencies and defines ONLY types (no logic)
/// Can be imported by both protocol layer and application layer
module account_extensions::framework_action_types {
    // NO IMPORTS - This is critical to avoid circular dependencies
    
    // Note: In Sui Move, empty structs cannot be instantiated from other modules
    // without constructor functions, even if the struct is public.
    // We provide minimal constructors only for cross-module instantiation.
    
    // ======== Vault Actions ========
    
    /// Deposit coins into vault  
    public struct VaultDeposit has drop {}
    
    /// Spend coins from vault
    public struct VaultSpend has drop {}
    
    // ======== Transfer Actions ========
    
    /// Transfer object ownership
    public struct TransferObject has drop {}
    
    // ======== Currency Actions ========
    
    /// Lock treasury cap (for future intent-based usage)
    public struct CurrencyLockCap has drop {}
    
    /// Disable currency operations
    public struct CurrencyDisable has drop {}
    
    /// Mint new currency
    public struct CurrencyMint has drop {}
    
    /// Burn currency
    public struct CurrencyBurn has drop {}
    
    /// Update currency metadata
    public struct CurrencyUpdate has drop {}
    
    // ======== Access Control Actions ========
    
    /// Store/lock capability (for future intent-based usage)
    public struct AccessControlStore has drop {}
    
    /// Borrow capability
    public struct AccessControlBorrow has drop {}
    
    /// Return borrowed capability
    public struct AccessControlReturn has drop {}
    
    // ======== Package Upgrade Actions ========
    
    /// Upgrade package
    public struct PackageUpgrade has drop {}
    
    /// Commit upgrade
    public struct PackageCommit has drop {}
    
    /// Restrict upgrade policy
    public struct PackageRestrict has drop {}
    
    // ======== Kiosk Actions ========
    
    /// Take item from kiosk
    public struct KioskTake has drop {}
    
    /// List item in kiosk
    public struct KioskList has drop {}
    
    // ======== Vesting Actions ========
    
    /// Create vesting schedule
    public struct VestingCreate has drop {}
    
    /// Cancel vesting schedule
    public struct VestingCancel has drop {}
    
    // ======== Configuration Actions ========
    
    /// Update account dependencies
    public struct ConfigUpdateDeps has drop {}
    
    /// Toggle unverified packages allowed
    public struct ConfigToggleUnverified has drop {}
    
    /// Update account metadata
    public struct ConfigUpdateMetadata has drop {}
    
    /// Configure object deposit settings
    public struct ConfigUpdateDeposits has drop {}
    
    /// Manage type whitelist for deposits
    public struct ConfigManageWhitelist has drop {}
    
    // ======== Owned Actions ========
    
    /// Withdraw owned object
    public struct OwnedWithdraw has drop {}
    
    // ======== Minimal Constructors for Cross-Module Usage ========
    // These are required because Sui Move doesn't allow instantiating
    // empty structs from other modules without constructors.
    
    public fun vault_deposit(): VaultDeposit { VaultDeposit {} }
    public fun vault_spend(): VaultSpend { VaultSpend {} }
    public fun transfer_object(): TransferObject { TransferObject {} }
    public fun currency_lock_cap(): CurrencyLockCap { CurrencyLockCap {} }
    public fun currency_disable(): CurrencyDisable { CurrencyDisable {} }
    public fun currency_mint(): CurrencyMint { CurrencyMint {} }
    public fun currency_burn(): CurrencyBurn { CurrencyBurn {} }
    public fun currency_update(): CurrencyUpdate { CurrencyUpdate {} }
    public fun access_control_store(): AccessControlStore { AccessControlStore {} }
    public fun access_control_borrow(): AccessControlBorrow { AccessControlBorrow {} }
    public fun access_control_return(): AccessControlReturn { AccessControlReturn {} }
    public fun package_upgrade(): PackageUpgrade { PackageUpgrade {} }
    public fun package_commit(): PackageCommit { PackageCommit {} }
    public fun package_restrict(): PackageRestrict { PackageRestrict {} }
    public fun kiosk_take(): KioskTake { KioskTake {} }
    public fun kiosk_list(): KioskList { KioskList {} }
    public fun vesting_create(): VestingCreate { VestingCreate {} }
    public fun vesting_cancel(): VestingCancel { VestingCancel {} }
    public fun config_update_deps(): ConfigUpdateDeps { ConfigUpdateDeps {} }
    public fun config_toggle_unverified(): ConfigToggleUnverified { ConfigToggleUnverified {} }
    public fun config_update_metadata(): ConfigUpdateMetadata { ConfigUpdateMetadata {} }
    public fun config_update_deposits(): ConfigUpdateDeposits { ConfigUpdateDeposits {} }
    public fun config_manage_whitelist(): ConfigManageWhitelist { ConfigManageWhitelist {} }
    public fun owned_withdraw(): OwnedWithdraw { OwnedWithdraw {} }
}/// === FORK MODIFICATIONS ===
/// REORDER OPTIMIZATION:
/// - Optimized reorder_accounts function from O(N*M) to O(N + M*log N)
/// - Uses VecSet for validation instead of repeated index_of + swap_remove
/// 
/// REASON:
/// The original implementation performed nested loops: for each address in the
/// new order, it would linearly search the existing accounts vector and swap_remove.
/// For 20 accounts, this meant ~400 operations. The new implementation creates
/// a VecSet for O(log N) validation, then directly replaces the vector.
/// This reduces gas costs for a simple UI reordering operation from quadratic
/// to near-linear complexity.
///
/// TYPE-BASED ACTION SYSTEM:
/// - No direct changes, but user module works with type-based intents

/// Users have a non-transferable User account object used to track Accounts in which they are a member.
/// Each account type can define a way to send on-chain invites to Users.
/// Invited users can accept or refuse the invite, to add the Account id to their User account or not.
/// Alternatively, Account interfaces can define rules allowing users to join an Account without invite.
/// This avoid the need for an indexer as all data can be easily found on-chain.

module account_protocol::user;

// === Imports ===

use std::{
    string::String,
    type_name,
};
use sui::{
    vec_map::{Self, VecMap},
    vec_set::{Self, VecSet},
    table::{Self, Table},
};
use account_protocol::account::{Self, Account};

// === Errors ===

const ENotEmpty: u64 = 0;
const EAlreadyHasUser: u64 = 1;
const EAccountNotFound: u64 = 2;
const EAccountTypeDoesntExist: u64 = 3;
const EWrongUserId: u64 = 4;
const EAccountAlreadyRegistered: u64 = 5;
const EWrongNumberOfAccounts: u64 = 6;
const ENoAccountsToReorder: u64 = 7;

// === Struct ===

/// Shared object enforcing one account maximum per user
public struct Registry has key {
    id: UID,
    // address to User ID mapping
    users: Table<address, ID>,
}

/// Non-transferable user account for tracking Accounts
public struct User has key {
    id: UID,
    // account type to list of accounts that the user has joined
    accounts: VecMap<String, vector<address>>,
}

/// Invite object issued by an Account to a user
public struct Invite has key { 
    id: UID, 
    // Account that issued the invite
    account_addr: address,
    // Account type
    account_type: String,
}

// === Public functions ===

fun init(ctx: &mut TxContext) {
    transfer::share_object(Registry {
        id: object::new(ctx),
        users: table::new(ctx),
    });
}

/// Creates a soulbound User account (1 per address)
public fun new(ctx: &mut TxContext): User {
    User {
        id: object::new(ctx),
        accounts: vec_map::empty(),
    }
}

/// Can transfer the User object only if the other address has no User object yet
public fun transfer(registry: &mut Registry, user: User, recipient: address, ctx: &mut TxContext) {
    assert!(!registry.users.contains(recipient), EAlreadyHasUser);
    // if the sender is not in the registry, then the User has been just created
    if (registry.users.contains(ctx.sender())) {
        let id = registry.users.remove(ctx.sender());
        assert!(id == object::id(&user), EWrongUserId); // should never throw
    };

    registry.users.add(recipient, object::id(&user));
    transfer::transfer(user, recipient);
}

/// Must remove all Accounts before, for consistency
public fun destroy(registry: &mut Registry, user: User, ctx: &mut TxContext) {
    let User { id, accounts, .. } = user;
    assert!(accounts.is_empty(), ENotEmpty);

    id.delete();
    registry.users.remove(ctx.sender());
}

/// Invited user can register the Account in his User account
public fun accept_invite(user: &mut User, invite: Invite) {
    let Invite { id, account_addr, account_type } = invite;
    id.delete();
    
    if (user.accounts.contains(&account_type)) {
        assert!(!user.accounts[&account_type].contains(&account_addr), EAccountAlreadyRegistered);
        user.accounts.get_mut(&account_type).push_back(account_addr);
    } else {
        user.accounts.insert(account_type, vector<address>[account_addr]);
    }
}

/// Deletes the invite object
public fun refuse_invite(invite: Invite) {
    let Invite { id, .. } = invite;
    id.delete();
}

public fun reorder_accounts<Config>(user: &mut User, addrs: vector<address>) {
    let account_type = type_name::with_defining_ids<Config>().into_string().to_string();
    assert!(user.accounts.contains(&account_type), ENoAccountsToReorder);

    // Get the current accounts
    let current_accounts = user.accounts[&account_type];
    assert!(current_accounts.length() == addrs.length(), EWrongNumberOfAccounts);

    // O(N) - Create a VecSet from original accounts for O(log N) validation
    let mut account_set = vec_set::empty();
    current_accounts.do!(|addr| {
        account_set.insert(addr);
    });

    // O(M * log N) - Validate all addresses are in the original set
    addrs.do_ref!(|addr| {
        assert!(account_set.contains(addr), EAccountNotFound);
    });
    
    // Check for duplicates in the new order
    let mut check_duplicates = vec_set::empty();
    addrs.do_ref!(|addr| {
        assert!(!check_duplicates.contains(addr), EAccountNotFound);
        check_duplicates.insert(*addr);
    });

    // O(1) - Remove old and insert new order
    user.accounts.remove(&account_type);
    user.accounts.insert(account_type, addrs);
}
// === Config-only functions ===

public fun add_account<Config, CW: drop>(
    user: &mut User, 
    account: &Account<Config>, 
    config_witness: CW,
) {
    account::assert_is_config_module(account, config_witness);
    let account_type = type_name::with_defining_ids<Config>().into_string().to_string();

    if (user.accounts.contains(&account_type)) {
        assert!(!user.accounts[&account_type].contains(&account.addr()), EAccountAlreadyRegistered);
        user.accounts.get_mut(&account_type).push_back(account.addr());
    } else {
        user.accounts.insert(account_type, vector<address>[account.addr()]);
    }
}

public fun remove_account<Config, CW: drop>(
    user: &mut User, 
    account: &Account<Config>, 
    config_witness: CW,
) {
    account::assert_is_config_module(account, config_witness);
    let account_type = type_name::with_defining_ids<Config>().into_string().to_string();

    assert!(user.accounts.contains(&account_type), EAccountTypeDoesntExist);
    let (exists, idx) = user.accounts[&account_type].index_of(&account.addr());
    
    assert!(exists, EAccountNotFound);
    user.accounts.get_mut(&account_type).swap_remove(idx);

    if (user.accounts[&account_type].is_empty())
        (_, _) = user.accounts.remove(&account_type);
}

/// Invites can be sent by an Account member (upon Account creation for instance)
public fun send_invite<Config, CW: drop>(
    account: &Account<Config>, 
    recipient: address, 
    config_witness: CW,
    ctx: &mut TxContext,
) {
    account::assert_is_config_module(account, config_witness);
    let account_type = type_name::with_defining_ids<Config>().into_string().to_string();

    transfer::transfer(Invite { 
        id: object::new(ctx), 
        account_addr: account.addr(),
        account_type,
    }, recipient);
}

// === View functions ===    

public fun users(registry: &Registry): &Table<address, ID> {
    &registry.users
}

public fun ids_for_type<Config>(user: &User): vector<address> {
    let account_type = type_name::with_defining_ids<Config>().into_string().to_string();
    user.accounts[&account_type]
}

public fun all_ids(user: &User): vector<address> {
    let mut map = user.accounts;
    let mut ids = vector<address>[];

    while (!map.is_empty()) {
        let (_, vec) = map.pop();
        ids.append(vec);
    };

    ids
}

//**************************************************************************************************//
// Tests                                                                                            //
//**************************************************************************************************//

// === Test Helpers ===

#[test_only]
public fun init_for_testing(ctx: &mut TxContext) {
    init(ctx);
}

#[test_only]
public fun registry_for_testing(ctx: &mut TxContext): Registry {
    Registry {
        id: object::new(ctx),
        users: table::new(ctx),
    }
}

#[test_only]
public fun add_account_for_testing<Config>(
    user: &mut User,
    account_addr: address,
) {
    let account_type = type_name::with_defining_ids<Config>().into_string().to_string();
    if (user.accounts.contains(&account_type)) {
        assert!(!user.accounts[&account_type].contains(&account_addr), EAccountAlreadyRegistered);
        user.accounts.get_mut(&account_type).push_back(account_addr);
    } else {
        user.accounts.insert(account_type, vector[account_addr]);
    };
}

// === Unit Tests ===

#[test_only]
use sui::test_scenario as ts;
#[test_only]
use sui::test_utils as tu;

#[test_only]
public struct DummyConfig has copy, drop, store {}
#[test_only]
public struct DummyConfig2 has copy, drop, store {}

#[test]
fun test_init() {
    let mut scenario = ts::begin(@0xCAFE);
    init(scenario.ctx());
    scenario.next_tx(@0xCAFE);

    let registry = scenario.take_shared<Registry>();
    assert!(registry.users.is_empty());
    ts::return_shared(registry);

    scenario.end();
}

#[test]
fun test_transfer_user_recipient() {
    let mut scenario = ts::begin(@0xCAFE);
    let mut registry = registry_for_testing(scenario.ctx());
    let user = new(scenario.ctx());

    transfer(&mut registry, user, @0xA11CE, scenario.ctx());
    scenario.next_tx(@0xA11CE);

    let user = scenario.take_from_sender<User>();
    let user_id = object::id(&user);

    assert!(registry.users.contains(@0xA11CE));
    assert!(registry.users.borrow(@0xA11CE) == user_id);

    tu::destroy(user);
    tu::destroy(registry);
    scenario.end();
}

#[test]
fun test_destroy_user() {
    let mut scenario = ts::begin(@0xCAFE);
    let mut registry = registry_for_testing(scenario.ctx());
    let user = new(scenario.ctx());

    transfer(&mut registry, user, @0xA11CE, scenario.ctx());
    scenario.next_tx(@0xA11CE);

    let user = scenario.take_from_sender<User>();
    destroy(&mut registry, user, scenario.ctx());

    assert!(!registry.users.contains(@0xA11CE));
    tu::destroy(registry);
    scenario.end();
}

#[test]
fun test_accept_invite() {
    let mut scenario = ts::begin(@0xCAFE);
    let mut user = new(scenario.ctx());

    let invite = Invite {
        id: object::new(scenario.ctx()),
        account_addr: @0xACC,
        account_type: b"0x0::config::Config".to_string(),
    };

    accept_invite(&mut user, invite);
    assert!(user.accounts.contains(&b"0x0::config::Config".to_string()));
    assert!(user.accounts[&b"0x0::config::Config".to_string()].contains(&@0xACC));

    tu::destroy(user);
    scenario.end();
}

#[test, expected_failure(abort_code = EAccountAlreadyRegistered)]
fun test_accept_invite_already_registered() {
    let mut scenario = ts::begin(@0xCAFE);
    let mut user = new(scenario.ctx());

    let invite = Invite {
        id: object::new(scenario.ctx()),
        account_addr: @0xACC,
        account_type: type_name::with_defining_ids<DummyConfig>().into_string().to_string(),
    };

    user.add_account_for_testing<DummyConfig>(@0xACC);
    assert!(user.accounts.contains(&type_name::with_defining_ids<DummyConfig>().into_string().to_string()));
    assert!(user.accounts[&type_name::with_defining_ids<DummyConfig>().into_string().to_string()].contains(&@0xACC));
    
    accept_invite(&mut user, invite);

    tu::destroy(user);
    scenario.end();
}

#[test]
fun test_refuse_invite() {
    let mut scenario = ts::begin(@0xCAFE);
    let user = new(scenario.ctx());

    let invite = Invite {
        id: object::new(scenario.ctx()),
        account_addr: @0xACC,
        account_type: b"0x0::config::Config".to_string(),
    };

    refuse_invite(invite);
    assert!(!user.accounts.contains(&b"0x0::config::Config".to_string()));

    tu::destroy(user);
    scenario.end();
}

#[test]
fun test_reorder_accounts() {
    let mut scenario = ts::begin(@0xCAFE);
    let mut user = new(scenario.ctx());
    
    user.add_account_for_testing<DummyConfig>(@0x1);
    user.add_account_for_testing<DummyConfig>(@0x2);
    user.add_account_for_testing<DummyConfig>(@0x3);
    let key = type_name::with_defining_ids<DummyConfig>().into_string().to_string();
    assert!(user.accounts.get(&key) == vector[@0x1, @0x2, @0x3]);

    user.reorder_accounts<DummyConfig>(vector[@0x2, @0x3, @0x1]);
    assert!(user.accounts.get(&key) == vector[@0x2, @0x3, @0x1]);

    tu::destroy(user);
    scenario.end();
}

#[test, expected_failure(abort_code = EAlreadyHasUser)]
fun test_error_transfer_to_existing_user() {
    let mut scenario = ts::begin(@0xCAFE);
    let mut registry = registry_for_testing(scenario.ctx());

    registry.transfer(new(scenario.ctx()), @0xCAFE, scenario.ctx());
    registry.transfer(new(scenario.ctx()), @0xCAFE, scenario.ctx());

    tu::destroy(registry);
    scenario.end();
}

#[test, expected_failure(abort_code = EWrongUserId)]
fun test_error_transfer_wrong_user_object() {
    let mut scenario = ts::begin(@0xCAFE);
    let mut registry = registry_for_testing(scenario.ctx());

    registry.transfer(new(scenario.ctx()), @0xCAFE, scenario.ctx());
    // OWNER transfers wrong user object to ALICE
    registry.transfer(new(scenario.ctx()), @0xA11CE, scenario.ctx());

    tu::destroy(registry);
    scenario.end();
}

#[test, expected_failure(abort_code = ENotEmpty)]
fun test_error_destroy_non_empty_user() {
    let mut scenario = ts::begin(@0xCAFE);
    let mut registry = registry_for_testing(scenario.ctx());
    let mut user = new(scenario.ctx());

    user.add_account_for_testing<DummyConfig>(@0xACC);
    destroy(&mut registry, user, scenario.ctx());

    tu::destroy(registry);
    scenario.end();
}

#[test, expected_failure(abort_code = EAccountAlreadyRegistered)]
fun test_error_add_already_existing_account() {
    let mut scenario = ts::begin(@0xCAFE);
    let mut user = new(scenario.ctx());

    user.add_account_for_testing<DummyConfig>(@0xACC);
    user.add_account_for_testing<DummyConfig>(@0xACC);
    
    tu::destroy(user);
    scenario.end();
}

#[test, expected_failure(abort_code = ENoAccountsToReorder)]
fun test_reorder_accounts_empty() {
    let mut scenario = ts::begin(@0xCAFE);
    let mut user = new(scenario.ctx());

    user.reorder_accounts<DummyConfig>(vector[]);

    tu::destroy(user);
    scenario.end();
}

#[test, expected_failure(abort_code = EWrongNumberOfAccounts)]
fun test_reorder_accounts_different_length() {
    let mut scenario = ts::begin(@0xCAFE);
    
    let mut user = new(scenario.ctx());
    user.add_account_for_testing<DummyConfig>(@0xACC);
    user.add_account_for_testing<DummyConfig>(@0xACC2);

    user.reorder_accounts<DummyConfig>(vector[@0xACC]);

    tu::destroy(user);
    scenario.end();
}

#[test, expected_failure(abort_code = EAccountNotFound)]
fun test_reorder_accounts_wrong_account() {
    let mut scenario = ts::begin(@0xCAFE);
    let mut user = new(scenario.ctx());
    
    user.add_account_for_testing<DummyConfig>(@0x1);
    user.add_account_for_testing<DummyConfig>(@0x2);

    user.reorder_accounts<DummyConfig>(vector[@0x1, @0x3]);

    tu::destroy(user);
    scenario.end();
}// ============================================================================
// FORK MODIFICATION NOTICE - BCS Validation Security Module
// ============================================================================
// NEW FILE added to the fork for BCS deserialization security.
//
// CHANGES IN THIS FORK (2025-01-14):
// - Added validate_all_bytes_consumed() function
// - Prevents trailing data attacks in action deserialization
// - Required by all decoder modules for security
//
// PURPOSE:
// - Ensures all BCS bytes are consumed when deserializing actions
// - Prevents attacks where extra data is appended to action payloads
// - Critical for security of the typed Intent system
//
// SECURITY CONSIDERATIONS:
// Without this validation, attackers could append extra bytes to actions that
// would be ignored during deserialization but could potentially affect
// execution if the bytes were passed to other functions.
//
// USAGE:
// Called after deserializing any action from BCS to ensure no trailing data.
// Example: After bcs::peel_vec_u8(&mut reader), call validate_all_bytes_consumed(reader)
// ============================================================================
/// BCS validation helpers to ensure complete consumption of serialized data
module account_protocol::bcs_validation;

// === Imports ===

use sui::bcs::BCS;

// === Errors ===

const ETrailingActionData: u64 = 0;

// === Public Functions ===

/// Validates that all bytes in the BCS reader have been consumed
/// This prevents attacks where extra data is appended to actions
public fun validate_all_bytes_consumed(reader: BCS) {
    // Check if there are any remaining bytes
    let remaining = reader.into_remainder_bytes();
    assert!(remaining.is_empty(), ETrailingActionData);
}// ============================================================================
// Action Type Validation Helper Module
// ============================================================================
// This module provides a centralized type validation helper for action handlers.
// It ensures type safety by verifying that action specs match expected types
// before deserialization, preventing type confusion vulnerabilities.
//
// SECURITY: This is a critical security module that prevents wrong actions
// from being executed by wrong handlers.
// ============================================================================

module account_protocol::action_validation;

// === Imports ===

use std::type_name::{Self, TypeName};
use account_protocol::intents::{Self, ActionSpec};

// === Errors ===

const EWrongActionType: u64 = 0;

// === Public Functions ===

/// Assert that an ActionSpec has the expected action type.
/// This MUST be called before deserializing action data in any do_* function.
///
/// # Type Parameters
/// * `T` - The expected action type (must have `drop`)
///
/// # Arguments
/// * `spec` - The ActionSpec to validate
///
/// # Aborts
/// * `EWrongActionType` - If the action type doesn't match the expected type
///
/// # Example
/// ```move
/// public fun do_spend<...>(...) {
///     let spec = specs.borrow(executable.action_idx());
///     action_validation::assert_action_type<VaultSpend>(spec);
///     // Now safe to deserialize
///     let action_data = intents::action_spec_data(spec);
/// }
/// ```
public fun assert_action_type<T: drop>(spec: &ActionSpec) {
    let expected_type = type_name::with_defining_ids<T>();
    assert!(
        intents::action_spec_type(spec) == expected_type,
        EWrongActionType
    );
}

/// Assert that an ActionSpec has the expected action type with custom error.
/// Useful when modules want to use their own error codes.
///
/// # Type Parameters
/// * `T` - The expected action type (must have `drop`)
///
/// # Arguments
/// * `spec` - The ActionSpec to validate
/// * `error_code` - Custom error code to use if validation fails
///
/// # Aborts
/// * Custom error code if the action type doesn't match
public fun assert_action_type_with_error<T: drop>(
    spec: &ActionSpec,
    error_code: u64
) {
    let expected_type = type_name::with_defining_ids<T>();
    assert!(
        intents::action_spec_type(spec) == expected_type,
        error_code
    );
}

/// Check if an ActionSpec matches the expected type without aborting.
/// Returns true if types match, false otherwise.
///
/// # Type Parameters
/// * `T` - The expected action type (must have `drop`)
///
/// # Arguments
/// * `spec` - The ActionSpec to check
///
/// # Returns
/// * `bool` - true if action type matches, false otherwise
public fun is_action_type<T: drop>(spec: &ActionSpec): bool {
    let expected_type = type_name::with_defining_ids<T>();
    intents::action_spec_type(spec) == expected_type
}

/// Get the TypeName for a given action type.
/// Useful for modules that need to work with TypeNames directly.
///
/// # Type Parameters
/// * `T` - The action type (must have `drop`)
///
/// # Returns
/// * `TypeName` - The TypeName of the action type
public fun get_action_type_name<T: drop>(): TypeName {
    type_name::with_defining_ids<T>()
}

// === Test Functions ===

#[test_only]
use account_protocol::intents::test_helpers;

#[test_only]
public struct TestAction has drop {}

#[test_only]
public struct WrongAction has drop {}

#[test]
fun test_assert_action_type_success() {
    let spec = test_helpers::create_test_action_spec<TestAction>();
    assert_action_type<TestAction>(&spec);
    // Should not abort
}

#[test]
#[expected_failure(abort_code = EWrongActionType)]
fun test_assert_action_type_failure() {
    let spec = test_helpers::create_test_action_spec<TestAction>();
    assert_action_type<WrongAction>(&spec);
    // Should abort with EWrongActionType
}

#[test]
fun test_is_action_type() {
    let spec = test_helpers::create_test_action_spec<TestAction>();
    assert!(is_action_type<TestAction>(&spec));
    assert!(!is_action_type<WrongAction>(&spec));
}

#[test]
#[expected_failure(abort_code = 999)]
fun test_assert_action_type_with_custom_error() {
    let spec = test_helpers::create_test_action_spec<TestAction>();
    assert_action_type_with_error<WrongAction>(&spec, 999);
    // Should abort with custom error 999
}// ============================================================================
// FORK MODIFICATION NOTICE - Account with Hot Potato Execution
// ============================================================================
// Core module managing Account<Config> with intent-based action execution.
//
// CHANGES IN THIS FORK:
// - REMOVED: lock_object() function - no longer needed
// - REMOVED: unlock_object() function - no longer needed
// - ADDED: cancel_intent() function - allows config-authorized intent cancellation
// - Modified create_executable() - no longer passes ctx (no ExecutionContext needed)
// - Integration with hot potato results instead of ExecutionContext
// - Type safety through compile-time checks
// - Removed ~100 lines of object locking code
//
// RATIONALE:
// In DAO governance, multiple proposals competing for the same resources is
// natural and desirable. The blockchain's ownership model already provides
// necessary conflict resolution. Removal prevents the critical footgun where
// objects could become permanently locked if cleanup wasn't performed correctly.
// ============================================================================

/// This is the core module managing the account Account<Config>.
/// It provides the apis to create, approve and execute intents with actions.
/// 
/// The flow is as follows:
///   1. An intent is created by stacking actions into it. 
///      Actions are pushed from first to last, they must be executed then destroyed in the same order.
///   2. When the intent is resolved (threshold reached, quorum reached, etc), it can be executed. 
///      This returns an Executable hot potato constructed from certain fields of the validated Intent. 
///      It is directly passed into action functions to enforce account approval for an action to be executed.
///   3. The module that created the intent must destroy all of the actions and the Executable after execution 
///      by passing the same witness that was used for instantiation. 
///      This prevents the actions or the intent to be stored instead of executed.
/// 
/// Dependencies can create and manage dynamic fields for an account.
/// They should use custom types as keys to enable access only via the accessors defined.
/// 
/// Functions related to authentication, intent resolution, state of intents and config for an account type 
/// must be called from the module that defines the config of the account.
/// They necessitate a config_witness to ensure the caller is a dependency of the account.
/// 
/// The rest of the functions manipulating the common state of accounts are only called within this package.

module account_protocol::account;

// === Imports ===

use std::{
    string::String,
    type_name::{Self, TypeName},
    option::Option,
};
use sui::{
    transfer::Receiving,
    clock::Clock,
    dynamic_field as df,
    dynamic_object_field as dof,
    package,
    vec_set::{Self, VecSet},
    event,
};
use account_protocol::{
    metadata::{Self, Metadata},
    deps::{Self, Deps},
    version_witness::{Self, VersionWitness},
    intents::{Self, Intents, Intent, Expired, Params},
    executable::{Self, Executable},
    version,
};

// === Errors ===

const ECantBeRemovedYet: u64 = 1;
const EHasntExpired: u64 = 2;
const ECantBeExecutedYet: u64 = 3;
const EWrongAccount: u64 = 4;
const ENotCalledFromConfigModule: u64 = 5;
const EActionsRemaining: u64 = 6;
const EManagedDataAlreadyExists: u64 = 7;
const EManagedDataDoesntExist: u64 = 8;
const EManagedAssetAlreadyExists: u64 = 9;
const EManagedAssetDoesntExist: u64 = 10;
const EDepositsDisabled: u64 = 11;
const EObjectCountUnderflow: u64 = 12;
const EWhitelistTooLarge: u64 = 13;
const EObjectLimitReached: u64 = 14;
const EMaxObjectsReached: u64 = 14;

// === Structs ===

public struct ACCOUNT has drop {}

/// Shared multisig Account object.
public struct Account<Config> has key, store {
    id: UID,
    // arbitrary data that can be proposed and added by members
    // first field is a human readable name to differentiate the multisig accounts
    metadata: Metadata,
    // ids and versions of the packages this account is using
    // idx 0: account_protocol, idx 1: account_actions optionally
    deps: Deps,
    // open intents, key should be a unique descriptive name
    intents: Intents,
    // config can be anything (e.g. Multisig, coin-based DAO, etc.)
    config: Config,
}

/// Object tracking state stored as dynamic field
/// Separate struct to allow extensions to interact without circular deps
public struct ObjectTracker has copy, drop, store {}

public struct ObjectTrackerState has copy, store {
    // Current object count (excluding coins)
    object_count: u128,
    // Whether permissionless deposits are enabled
    deposits_open: bool,
    // Maximum objects before auto-disabling deposits
    max_objects: u128,
    // Whitelisted types that bypass restrictions (O(1) lookups with VecSet)
    // Store canonical string representation for serializability
    whitelisted_types: VecSet<String>,
}

// === Events ===




/// Protected type ensuring provenance, authenticate an address to an account.
public struct Auth {
    // address of the account that created the auth
    account_addr: address,
}

// === Upgradeable Configuration Functions ===
// These are functions (not constants) so they can be changed in package upgrades

/// Maximum whitelist size - can be changed in future upgrades
public fun max_whitelist_size(): u64 {
    50  // Reasonable limit - can increase in upgrades if needed
}

/// Default max objects - can be changed in future upgrades
public fun default_max_objects(): u128 {
    10000  // Adjust this in future upgrades if needed
}

//**************************************************************************************************//
// Public functions                                                                                //
//**************************************************************************************************//

fun init(otw: ACCOUNT, ctx: &mut TxContext) {
    package::claim_and_keep(otw, ctx); // to create Display objects in the future
}

/// Initialize object tracking for an account (called during account creation)
public(package) fun init_object_tracker<Config>(
    account: &mut Account<Config>,
    max_objects: u128,
) {
    if (!df::exists_(&account.id, ObjectTracker {})) {
        df::add(&mut account.id, ObjectTracker {}, ObjectTrackerState {
            object_count: 0,
            deposits_open: true,
            max_objects: if (max_objects > 0) max_objects else default_max_objects(),
            whitelisted_types: vec_set::empty(),
        });
    }
}

/// Get or create object tracker state
public(package) fun ensure_object_tracker<Config>(account: &mut Account<Config>): &mut ObjectTrackerState {
    if (!df::exists_(&account.id, ObjectTracker {})) {
        init_object_tracker(account, default_max_objects());
    };
    df::borrow_mut(&mut account.id, ObjectTracker {})
}

/// Apply deposit configuration changes
public(package) fun apply_deposit_config<Config>(
    account: &mut Account<Config>,
    enable: bool,
    new_max: Option<u128>,
    reset_counter: bool
) {
    let tracker = ensure_object_tracker(account);
    tracker.deposits_open = enable;
    
    if (new_max.is_some()) {
        tracker.max_objects = *new_max.borrow();
    };
    
    if (reset_counter) {
        tracker.object_count = 0;
    };
}

/// Apply whitelist changes
public(package) fun apply_whitelist_changes<Config>(
    account: &mut Account<Config>,
    add_types: &vector<String>,
    remove_types: &vector<String>
) {
    let tracker = ensure_object_tracker(account);

    // Remove types first
    let mut i = 0;
    while (i < remove_types.length()) {
        let type_str = &remove_types[i];
        vec_set::remove(&mut tracker.whitelisted_types, type_str);
        i = i + 1;
    };

    // Add new types with size check
    i = 0;
    while (i < add_types.length()) {
        let type_str = add_types[i];
        if (!vec_set::contains(&tracker.whitelisted_types, &type_str)) {
            assert!(
                vec_set::size(&tracker.whitelisted_types) < max_whitelist_size(),
                EWhitelistTooLarge
            );
            vec_set::insert(&mut tracker.whitelisted_types, type_str);
        };
        i = i + 1;
    };
    
    // Whitelist updated
}

/// Verifies all actions have been processed and destroys the executable.
/// Called to complete the intent execution.
public fun confirm_execution<Config, Outcome: drop + store>(
    account: &mut Account<Config>, 
    executable: Executable<Outcome>,
) {
    let actions_length = executable.intent().action_specs().length();
    assert!(executable.action_idx() == actions_length, EActionsRemaining);
    
    let intent = executable.destroy();
    intent.assert_is_account(account.addr());
    
    account.intents.add_intent(intent);
}

/// Destroys an intent if it has no remaining execution.
/// Expired needs to be emptied by deleting each action in the bag within their own module.
public fun destroy_empty_intent<Config, Outcome: store + drop>(
    account: &mut Account<Config>, 
    key: String, 
): Expired {
    assert!(account.intents.get<Outcome>(key).execution_times().is_empty(), ECantBeRemovedYet);
    account.intents.destroy_intent<Outcome>(key)
}

/// Destroys an intent if it has expired.
/// Expired needs to be emptied by deleting each action in the bag within their own module.
public fun delete_expired_intent<Config, Outcome: store + drop>(
    account: &mut Account<Config>, 
    key: String, 
    clock: &Clock,
): Expired {
    assert!(clock.timestamp_ms() >= account.intents.get<Outcome>(key).expiration_time(), EHasntExpired);
    account.intents.destroy_intent<Outcome>(key)
}

/// Asserts that the function is called from the module defining the config of the account.
public(package) fun assert_is_config_module<Config, CW: drop>(
    _account: &Account<Config>, 
    _config_witness: CW
) {
    let account_type = type_name::with_defining_ids<Config>();
    let witness_type = type_name::with_defining_ids<CW>();
    assert!(
        account_type.address_string() == witness_type.address_string() &&
        account_type.module_string() == witness_type.module_string(),
        ENotCalledFromConfigModule
    );
}

/// Cancel an active intent and return its Expired bag for GC draining.
///
/// Security:
/// - `config_witness` gates **authority**: only the Config module may cancel.
/// - `deps_witness` gates **compatibility**: caller must be compiled against the
///   same `account_protocol` package identity/version the Account expects.
///   This prevents mismatched callers from older/newer packages.
public fun cancel_intent<Config, Outcome: store + drop, CW: drop>(
    account: &mut Account<Config>,
    key: String,
    deps_witness: VersionWitness,
    config_witness: CW,
): Expired {
    // Ensure the protocol dependency matches what this account expects
    account.deps().check(deps_witness);
    // Only the config module may cancel
    assert_is_config_module(account, config_witness);
    // Convert to Expired - deleters will handle unlocking during drain
    account.intents.destroy_intent<Outcome>(key)
}

/// Helper function to transfer an object to the account with tracking.
/// Excludes Coin types and whitelisted types from restrictions.
public fun keep<Config, T: key + store>(account: &mut Account<Config>, obj: T, ctx: &TxContext) {
    let type_name = type_name::with_defining_ids<T>();
    let is_coin = is_coin_type(type_name);
    
    // Check if type is whitelisted
    let is_whitelisted = {
        let tracker = ensure_object_tracker(account);
        let ascii_str = type_name::into_string(type_name);
        let type_str = ascii_str.to_string();
        vec_set::contains(&tracker.whitelisted_types, &type_str)
    };
    
    // Only apply restrictions to non-coin, non-whitelisted types
    if (!is_coin && !is_whitelisted) {
        // Get tracker state for checking
        let (deposits_open, sender_is_self) = {
            let tracker = ensure_object_tracker(account);
            (tracker.deposits_open, ctx.sender() == account.addr())
        };
        
        // Check if deposits are allowed
        if (!deposits_open) {
            // Allow self-deposits even when closed
            assert!(sender_is_self, EDepositsDisabled);
        };
        
        // Now update tracker state
        let tracker = ensure_object_tracker(account);
        
        // Increment counter only for restricted types
        tracker.object_count = tracker.object_count + 1;
        
        // Auto-disable if hitting threshold
        if (tracker.object_count >= tracker.max_objects) {
            tracker.deposits_open = false;
            // Auto-disabled deposits at threshold
        };
    };
    
    transfer::public_transfer(obj, account.addr());
}

/// Unpacks and verifies the Auth matches the account.
public fun verify<Config>(
    account: &Account<Config>,
    auth: Auth,
) {
    let Auth { account_addr } = auth;

    assert!(account.addr() == account_addr, EWrongAccount);
}

//**************************************************************************************************//
// Deps-only functions                                                                              //
//**************************************************************************************************//

/// The following functions are used to compose intents in external modules and packages.
/// 
/// The proper instantiation and execution of an intent is ensured by an intent witness.
/// This is a drop only type defined in the intent module preventing other modules to misuse the intent.
/// 
/// Additionally, these functions require a version witness which is a protected type for the protocol. 
/// It is checked against the dependencies of the account to ensure the package being called is authorized.
/// VersionWitness is a wrapper around a type defined in the version of the package being called.
/// It behaves like a witness but it is usable in the entire package instead of in a single module.

/// Creates a new intent. Can only be called from a dependency of the account.
public fun create_intent<Config, Outcome: store, IW: drop>(
    account: &Account<Config>,
    params: Params,
    outcome: Outcome, // resolution settings
    managed_name: String, // managed struct/object name for the role
    version_witness: VersionWitness, // proof of the package address that creates the intent
    intent_witness: IW, // intent witness
    ctx: &mut TxContext
): Intent<Outcome> {
    // ensures the package address is a dependency for this account
    account.deps().check(version_witness); 

    params.new_intent(
        outcome,
        managed_name,
        account.addr(),
        intent_witness,
        ctx
    )
}

/// Adds an intent to the account. Can only be called from a dependency of the account.
public fun insert_intent<Config, Outcome: store, IW: drop>(
    account: &mut Account<Config>, 
    intent: Intent<Outcome>, 
    version_witness: VersionWitness,
    intent_witness: IW,
) {
    // ensures the package address is a dependency for this account
    account.deps().check(version_witness);
    // ensures the right account is passed
    intent.assert_is_account(account.addr());
    // ensures the intent is created by the same package that creates the action
    intent.assert_is_witness(intent_witness);

    account.intents.add_intent(intent);
}

/// Managed data and assets:
/// Data structs and Assets objects attached as dynamic fields to the account object.
/// They are separated to improve objects discoverability on frontends and indexers.
/// Keys must be custom types defined in the same module where the function is implemented.

/// Adds a managed data struct to the account.
public fun add_managed_data<Config, Key: copy + drop + store, Data: store>(
    account: &mut Account<Config>, 
    key: Key, 
    data: Data,
    version_witness: VersionWitness,
) {
    assert!(!has_managed_data(account, key), EManagedDataAlreadyExists);
    account.deps().check(version_witness);
    df::add(&mut account.id, key, data);
}

/// Checks if a managed data struct exists in the account.
public fun has_managed_data<Config, Key: copy + drop + store>(
    account: &Account<Config>, 
    key: Key, 
): bool {
    df::exists_(&account.id, key)
}

/// Borrows a managed data struct from the account.
public fun borrow_managed_data<Config, Key: copy + drop + store, Data: store>(
    account: &Account<Config>,
    key: Key, 
    version_witness: VersionWitness,
): &Data {
    assert!(has_managed_data(account, key), EManagedDataDoesntExist);
    account.deps().check(version_witness);
    df::borrow(&account.id, key)
}

/// Borrows a managed data struct mutably from the account.
public fun borrow_managed_data_mut<Config, Key: copy + drop + store, Data: store>(
    account: &mut Account<Config>, 
    key: Key, 
    version_witness: VersionWitness,
): &mut Data {
    assert!(has_managed_data(account, key), EManagedDataDoesntExist);
    account.deps().check(version_witness);
    df::borrow_mut(&mut account.id, key)
}

/// Removes a managed data struct from the account.
public fun remove_managed_data<Config, Key: copy + drop + store, A: store>(
    account: &mut Account<Config>, 
    key: Key, 
    version_witness: VersionWitness,
): A {
    assert!(has_managed_data(account, key), EManagedDataDoesntExist);
    account.deps().check(version_witness);
    df::remove(&mut account.id, key)
}

/// Adds a managed object to the account.
public fun add_managed_asset<Config, Key: copy + drop + store, Asset: key + store>(
    account: &mut Account<Config>, 
    key: Key, 
    asset: Asset,
    version_witness: VersionWitness,
) {
    assert!(!has_managed_asset(account, key), EManagedAssetAlreadyExists);
    account.deps().check(version_witness);
    dof::add(&mut account.id, key, asset);
}

/// Checks if a managed object exists in the account.
public fun has_managed_asset<Config, Key: copy + drop + store>(
    account: &Account<Config>, 
    key: Key, 
): bool {
    dof::exists_(&account.id, key)
}

/// Borrows a managed object from the account.
public fun borrow_managed_asset<Config, Key: copy + drop + store, Asset: key + store>(
    account: &Account<Config>,
    key: Key, 
    version_witness: VersionWitness,
): &Asset {
    assert!(has_managed_asset(account, key), EManagedAssetDoesntExist);
    account.deps().check(version_witness);
    dof::borrow(&account.id, key)
}

/// Borrows a managed object mutably from the account.
public fun borrow_managed_asset_mut<Config, Key: copy + drop + store, Asset: key + store>(
    account: &mut Account<Config>, 
    key: Key, 
    version_witness: VersionWitness,
): &mut Asset {
    assert!(has_managed_asset(account, key), EManagedAssetDoesntExist);
    account.deps().check(version_witness);
    dof::borrow_mut(&mut account.id, key)
}

/// Removes a managed object from the account.
public fun remove_managed_asset<Config, Key: copy + drop + store, Asset: key + store>(
    account: &mut Account<Config>, 
    key: Key, 
    version_witness: VersionWitness,
): Asset {
    assert!(has_managed_asset(account, key), EManagedAssetDoesntExist);
    account.deps().check(version_witness);
    dof::remove(&mut account.id, key)
}

//**************************************************************************************************//
// Config-only functions                                                                            //
//**************************************************************************************************//

/// The following functions are used to define account and intent behavior for a specific account type/config.
/// 
/// They must be implemented in the module that defines the config of the account, which must be a dependency of the account.
/// We provide higher level macros to facilitate the implementation of these functions.

/// Creates a new account with default dependencies. Can only be called from the config module.
public fun new<Config, CW: drop>(
    config: Config,
    deps: Deps,
    version_witness: VersionWitness,
    config_witness: CW,
    ctx: &mut TxContext
): Account<Config> {
    let account = Account<Config> {
        id: object::new(ctx),
        metadata: metadata::empty(),
        deps,
        intents: intents::empty(ctx),
        config,
    };

    account.deps().check(version_witness);
    assert_is_config_module(&account, config_witness);

    account
}

/// Returns an Auth object that can be used to call gated functions. Can only be called from the config module.
public fun new_auth<Config, CW: drop>(
    account: &Account<Config>,
    version_witness: VersionWitness,
    config_witness: CW,
): Auth {
    account.deps().check(version_witness);
    assert_is_config_module(account, config_witness);

    Auth { account_addr: account.addr() }
}

/// Returns a tuple of the outcome that must be validated and the executable. Can only be called from the config module.
public fun create_executable<Config, Outcome: store + copy, CW: drop>(
    account: &mut Account<Config>,
    key: String,
    clock: &Clock,
    version_witness: VersionWitness,
    config_witness: CW,
    ctx: &mut TxContext, // Now essential for creating ExecutionContext
): (Outcome, Executable<Outcome>) {
    account.deps().check(version_witness);
    assert_is_config_module(account, config_witness);

    let mut intent = account.intents.remove_intent<Outcome>(key);
    let time = intent.pop_front_execution_time();
    assert!(clock.timestamp_ms() >= time, ECantBeExecutedYet);

    (
        *intent.outcome(),
        executable::new(intent) // No ctx needed - using hot potato results
    )
}

/// Returns a mutable reference to the intents of the account. Can only be called from the config module.
public fun intents_mut<Config, CW: drop>(
    account: &mut Account<Config>, 
    version_witness: VersionWitness,
    config_witness: CW,
): &mut Intents {
    account.deps().check(version_witness);
    assert_is_config_module(account, config_witness);

    &mut account.intents
}

/// Returns a mutable reference to the config of the account. Can only be called from the config module.
public fun config_mut<Config, CW: drop>(
    account: &mut Account<Config>, 
    version_witness: VersionWitness,
    config_witness: CW,
): &mut Config {
    account.deps().check(version_witness);
    assert_is_config_module(account, config_witness);

    &mut account.config
}

//**************************************************************************************************//
// View functions                                                                                   //
//**************************************************************************************************//

/// Returns the address of the account.
public fun addr<Config>(account: &Account<Config>): address {
    account.id.uid_to_inner().id_to_address()
}

/// Returns the metadata of the account.
public fun metadata<Config>(account: &Account<Config>): &Metadata {
    &account.metadata
}

/// Returns the dependencies of the account.
public fun deps<Config>(account: &Account<Config>): &Deps {
    &account.deps
}

/// Returns the intents of the account.
public fun intents<Config>(account: &Account<Config>): &Intents {
    &account.intents
}

/// Returns the config of the account.
public fun config<Config>(account: &Account<Config>): &Config {
    &account.config
}

/// Returns object tracking stats (count, deposits_open, max)
public fun object_stats<Config>(account: &Account<Config>): (u128, bool, u128) {
    if (df::exists_(&account.id, ObjectTracker {})) {
        let tracker: &ObjectTrackerState = df::borrow(&account.id, ObjectTracker {});
        (tracker.object_count, tracker.deposits_open, tracker.max_objects)
    } else {
        (0, true, default_max_objects())
    }
}

/// Check if account is accepting object deposits
public fun is_accepting_objects<Config>(account: &Account<Config>): bool {
    if (df::exists_(&account.id, ObjectTracker {})) {
        let tracker: &ObjectTrackerState = df::borrow(&account.id, ObjectTracker {});
        tracker.deposits_open && tracker.object_count < tracker.max_objects
    } else {
        true  // Default open if not initialized
    }
}

/// Configure object deposit settings (requires Auth)
public fun configure_object_deposits<Config>(
    auth: Auth,
    account: &mut Account<Config>,
    enable: bool,
    new_max: Option<u128>,
    reset_counter: bool,
) {
    account.verify(auth);
    
    let tracker = ensure_object_tracker(account);
    tracker.deposits_open = enable;
    
    if (new_max.is_some()) {
        tracker.max_objects = *new_max.borrow();
    };
    
    if (reset_counter) {
        tracker.object_count = 0;
    };
}

/// Manage whitelist for object types (requires Auth)
public fun manage_type_whitelist<Config>(
    auth: Auth,
    account: &mut Account<Config>,
    add_types: vector<String>,
    remove_types: vector<String>,
) {
    account.verify(auth);

    let tracker = ensure_object_tracker(account);

    // Remove types first (in case of duplicates in add/remove)
    let mut i = 0;
    while (i < remove_types.length()) {
        let type_str = &remove_types[i];
        vec_set::remove(&mut tracker.whitelisted_types, type_str);
        i = i + 1;
    };

    // Add new types (check size limit)
    i = 0;
    while (i < add_types.length()) {
        let type_str = add_types[i];
        if (!vec_set::contains(&tracker.whitelisted_types, &type_str)) {
            // Check size limit before adding
            assert!(
                vec_set::size(&tracker.whitelisted_types) < max_whitelist_size(),
                EWhitelistTooLarge
            );
            vec_set::insert(&mut tracker.whitelisted_types, type_str);
        };
        i = i + 1;
    };
    // Whitelist updated
}

/// Get whitelisted types for inspection/debugging
public fun get_whitelisted_types<Config>(account: &Account<Config>): vector<String> {
    if (df::exists_(&account.id, ObjectTracker {})) {
        let tracker: &ObjectTrackerState = df::borrow(&account.id, ObjectTracker {});
        vec_set::into_keys(tracker.whitelisted_types)  // Convert VecSet to vector
    } else {
        vector::empty()
    }
}

/// Check if a specific type is whitelisted
public fun is_type_whitelisted<Config, T>(account: &Account<Config>): bool {
    if (df::exists_(&account.id, ObjectTracker {})) {
        let tracker: &ObjectTrackerState = df::borrow(&account.id, ObjectTracker {});
        // Convert TypeName to String for the lookup
        let type_name = type_name::with_defining_ids<T>();
        let ascii_str = type_name::into_string(type_name);
        let type_str = ascii_str.to_string();
        vec_set::contains(&tracker.whitelisted_types, &type_str)
    } else {
        false
    }
}

/// Helper to check if a TypeName represents a Coin type
fun is_coin_type(type_name: TypeName): bool {
    // Check if the type is a Coin type by checking if it starts with
    // the Coin module prefix from the Sui framework
    let type_addr = type_name::address_string(&type_name);
    
    // Check if this is from the Sui framework and the module is "coin"
    if (type_addr == b"0000000000000000000000000000000000000000000000000000000000000002".to_ascii_string()) {
        let module_name = type_name::module_string(&type_name);
        module_name == b"coin".to_ascii_string()
    } else {
        false
    }
}

//**************************************************************************************************//
// Package functions                                                                                //
//**************************************************************************************************//

/// Returns a mutable reference to the metadata of the account.
public(package) fun metadata_mut<Config>(
    account: &mut Account<Config>, 
    version_witness: VersionWitness,
): &mut Metadata {
    // ensures the package address is a dependency for this account
    account.deps().check(version_witness);
    &mut account.metadata
}

/// Returns a mutable reference to the dependencies of the account.
public(package) fun deps_mut<Config>(
    account: &mut Account<Config>, 
    version_witness: VersionWitness,
): &mut Deps {
    // ensures the package address is a dependency for this account
    account.deps().check(version_witness);
    &mut account.deps
}

/// Receives an object from an account with tracking, only used in owned action lib module.
public(package) fun receive<Config, T: key + store>(
    account: &mut Account<Config>, 
    receiving: Receiving<T>,
): T {
    let type_name = type_name::with_defining_ids<T>();
    let is_coin = is_coin_type(type_name);
    
    let tracker = ensure_object_tracker(account);
    let ascii_str = type_name::into_string(type_name);
    let type_str = ascii_str.to_string();
    let is_whitelisted = vec_set::contains(&tracker.whitelisted_types, &type_str);
    
    // Only count non-coin, non-whitelisted types
    if (!is_coin && !is_whitelisted) {
        tracker.object_count = tracker.object_count + 1;
        
        // Auto-disable if hitting threshold
        if (tracker.object_count >= tracker.max_objects) {
            tracker.deposits_open = false;
        };
    };
    
    transfer::public_receive(&mut account.id, receiving)
}

/// Track when an object leaves the account (withdrawal/burn/transfer)
public(package) fun track_object_removal<Config>(
    account: &mut Account<Config>,
    _object_id: ID,
) {
    let tracker = ensure_object_tracker(account);
    assert!(tracker.object_count > 0, EObjectCountUnderflow);
    tracker.object_count = tracker.object_count - 1;
    
    // Re-enable deposits if we're back under 50% of threshold
    if (tracker.object_count < tracker.max_objects / 2) {
        tracker.deposits_open = true;
    };
}

// REMOVED: lock_object and unlock_object - no locking in new design
// Conflicts between intents are natural in DAO governance


//**************************************************************************************************//
// Tests                                                                                            //
//**************************************************************************************************//

// === Test Helpers ===

#[test_only]
public fun init_for_testing(ctx: &mut TxContext) {
    init(ACCOUNT {}, ctx);
}

#[test_only]
public struct Witness has drop {}

#[test_only]
public fun not_config_witness(): Witness {
    Witness {}
}

// === Unit Tests ===

#[test_only]
use sui::test_utils::{assert_eq, destroy};
use account_extensions::extensions;

#[test_only]
public struct TestConfig has copy, drop, store {}
#[test_only]
public struct TestWitness() has drop;
#[test_only]
public struct WrongWitness() has drop;
#[test_only]
public struct TestKey has copy, drop, store {}
#[test_only]
public struct TestData has copy, drop, store {
    value: u64
}
#[test_only]
public struct TestAsset has key, store {
    id: UID
}

#[test]
fun test_addr() {
    let ctx = &mut tx_context::dummy();
    let deps = deps::new_for_testing();
    
    let account = new(TestConfig {}, deps, version::current(), TestWitness(), ctx);
    let account_addr = addr(&account);
    
    assert_eq(account_addr, object::id(&account).to_address());
    destroy(account);
}

#[test]
fun test_verify_auth() {
    let ctx = &mut tx_context::dummy();
    let deps = deps::new_for_testing();
    
    let account = new(TestConfig {}, deps, version::current(), TestWitness(), ctx);
    let auth = Auth { account_addr: account.addr() };
    
    // Should not abort
    verify(&account, auth);
    destroy(account);
}

#[test, expected_failure(abort_code = EWrongAccount)]
fun test_verify_auth_wrong_account() {
    let ctx = &mut tx_context::dummy();
    let deps = deps::new_for_testing();
    
    let account = new(TestConfig {}, deps, version::current(), TestWitness(), ctx);
    let auth = Auth { account_addr: @0xBAD };
    
    verify(&account, auth);
    destroy(account);
}

#[test]
fun test_managed_data_flow() {
    let ctx = &mut tx_context::dummy();
    let deps = deps::new_for_testing();
    
    let mut account = new(TestConfig {}, deps, version::current(), TestWitness(), ctx);
    let key = TestKey {};
    let data = TestData { value: 42 };
    
    // Test add
    add_managed_data(&mut account, key, data, version::current());
    assert!(has_managed_data(&account, key));
    
    // Test borrow
    let borrowed_data = borrow_managed_data(&account, key, version::current());
    assert_eq(*borrowed_data, data);
    
    // Test borrow_mut
    let borrowed_mut_data = borrow_managed_data_mut(&mut account, key, version::current());
    assert_eq(*borrowed_mut_data, data);
    
    // Test remove
    let removed_data = remove_managed_data(&mut account, key, version::current());
    assert_eq(removed_data, data);
    assert!(!has_managed_data(&account, key));
    destroy(account);
}

#[test, expected_failure(abort_code = EManagedDataAlreadyExists)]
fun test_add_managed_data_already_exists() {
    let ctx = &mut tx_context::dummy();
    let deps = deps::new_for_testing();
    
    let mut account = new(TestConfig {}, deps, version::current(), TestWitness(), ctx);
    let key = TestKey {};
    let data1 = TestData { value: 42 };
    let data2 = TestData { value: 100 };
    
    add_managed_data(&mut account, key, data1, version::current());
    add_managed_data(&mut account, key, data2, version::current());
    destroy(account);
}

#[test, expected_failure(abort_code = EManagedDataDoesntExist)]
fun test_borrow_managed_data_doesnt_exist() {
    let ctx = &mut tx_context::dummy();
    let deps = deps::new_for_testing();
    
    let account = new(TestConfig {}, deps, version::current(), TestWitness(), ctx);
    let key = TestKey {};
    
    borrow_managed_data<_, TestKey, TestData>(&account, key, version::current());
    destroy(account);
}

#[test, expected_failure(abort_code = EManagedDataDoesntExist)]
fun test_borrow_managed_data_mut_doesnt_exist() {
    let ctx = &mut tx_context::dummy();
    let deps = deps::new_for_testing();
    
    let mut account = new(TestConfig {}, deps, version::current(), TestWitness(), ctx);
    let key = TestKey {};
    
    borrow_managed_data_mut<_, TestKey, TestData>(&mut account, key, version::current());
    destroy(account);
}

#[test, expected_failure(abort_code = EManagedDataDoesntExist)]
fun test_remove_managed_data_doesnt_exist() {
    let ctx = &mut tx_context::dummy();
    let deps = deps::new_for_testing();
    
    let mut account = new(TestConfig {}, deps, version::current(), TestWitness(), ctx);
    let key = TestKey {};
    
    remove_managed_data<_, TestKey, TestData>(&mut account, key, version::current());
    destroy(account);
}

#[test]
fun test_managed_asset_flow() {
    let ctx = &mut tx_context::dummy();
    let deps = deps::new_for_testing();
    
    let mut account = new(TestConfig {}, deps, version::current(), TestWitness(), ctx);
    let key = TestKey {};
    let asset = TestAsset { id: object::new(ctx) };
    let asset_id = object::id(&asset);
    
    // Test add
    add_managed_asset(&mut account, key, asset, version::current());
    assert!(has_managed_asset(&account, key), 0);
    
    // Test borrow
    let borrowed_asset = borrow_managed_asset<_, TestKey, TestAsset>(&account, key, version::current());
    assert_eq(object::id(borrowed_asset), asset_id);
    
    // Test remove
    let removed_asset = remove_managed_asset<_, TestKey, TestAsset>(&mut account, key, version::current());
    assert_eq(object::id(&removed_asset), asset_id);
    assert!(!has_managed_asset(&account, key));
    destroy(account);
    destroy(removed_asset);
}

#[test]
fun test_has_managed_data_false() {
    let ctx = &mut tx_context::dummy();
    let deps = deps::new_for_testing();
    
    let account = new(TestConfig {}, deps, version::current(), TestWitness(), ctx);
    let key = TestKey {};
    
    assert!(!has_managed_data(&account, key));
    destroy(account);
}

#[test]
fun test_has_managed_asset_false() {
    let ctx = &mut tx_context::dummy();
    let deps = deps::new_for_testing();
    
    let account = new(TestConfig {}, deps, version::current(), TestWitness(), ctx);
    let key = TestKey {};
    
    assert!(!has_managed_asset(&account, key));
    destroy(account);
}

#[test, expected_failure(abort_code = EManagedAssetAlreadyExists)]
fun test_add_managed_asset_already_exists() {
    let ctx = &mut tx_context::dummy();
    let deps = deps::new_for_testing();
    
    let mut account = new(TestConfig {}, deps, version::current(), TestWitness(), ctx);
    let key = TestKey {};
    let asset1 = TestAsset { id: object::new(ctx) };
    let asset2 = TestAsset { id: object::new(ctx) };
    
    add_managed_asset(&mut account, key, asset1, version::current());
    add_managed_asset(&mut account, key, asset2, version::current());
    destroy(account);
}

#[test, expected_failure(abort_code = EManagedAssetDoesntExist)]
fun test_borrow_managed_asset_doesnt_exist() {
    let ctx = &mut tx_context::dummy();
    let deps = deps::new_for_testing();
    
    let account = new(TestConfig {}, deps, version::current(), TestWitness(), ctx);
    let key = TestKey {};
    
    borrow_managed_asset<_, TestKey, TestAsset>(&account, key, version::current());
    destroy(account);
}

#[test, expected_failure(abort_code = EManagedAssetDoesntExist)]
fun test_borrow_managed_asset_mut_doesnt_exist() {
    let ctx = &mut tx_context::dummy();
    let deps = deps::new_for_testing();
    
    let mut account = new(TestConfig {}, deps, version::current(), TestWitness(), ctx);
    let key = TestKey {};
    
    borrow_managed_asset_mut<_, TestKey, TestAsset>(&mut account, key, version::current());
    destroy(account);
}

#[test, expected_failure(abort_code = EManagedAssetDoesntExist)]
fun test_remove_managed_asset_doesnt_exist() {
    let ctx = &mut tx_context::dummy();
    let deps = deps::new_for_testing();
    
    let mut account = new(TestConfig {}, deps, version::current(), TestWitness(), ctx);
    let key = TestKey {};
    
    let removed_asset = remove_managed_asset<_, TestKey, TestAsset>(&mut account, key, version::current());
    destroy(removed_asset);
    destroy(account);
}

#[test]
fun test_new_auth() {
    let ctx = &mut tx_context::dummy();
    let deps = deps::new_for_testing();
    
    let account = new(TestConfig {}, deps, version::current(), TestWitness(), ctx);
    let auth = new_auth(&account, version::current(), TestWitness());
    
    assert_eq(auth.account_addr, account.addr());
    destroy(account);
    destroy(auth);
}

#[test]
fun test_metadata_access() {
    let ctx = &mut tx_context::dummy();
    let deps = deps::new_for_testing();
    
    let account = new(TestConfig {}, deps, version::current(), TestWitness(), ctx);
    
    // Should not abort - just testing access
    assert_eq(metadata(&account).size(), 0);
    destroy(account);
}

#[test]
fun test_config_access() {
    let ctx = &mut tx_context::dummy();
    let deps = deps::new_for_testing();
    
    let account = new(TestConfig {}, deps, version::current(), TestWitness(), ctx);
    
    // Should not abort - just testing access
    config(&account);
    destroy(account);
}

#[test]
fun test_assert_is_config_module_correct_witness() {
    let ctx = &mut tx_context::dummy();
    let deps = deps::new_for_testing();
    
    let account = new(TestConfig {}, deps, version::current(), TestWitness(), ctx);
    
    // Should not abort
    assert_is_config_module(&account, TestWitness());
    destroy(account);
}

#[test, expected_failure(abort_code = ENotCalledFromConfigModule)]
fun test_assert_config_module_wrong_witness_package_address() {
    let ctx = &mut tx_context::dummy();
    let deps = deps::new_for_testing();
    
    let account = new(TestConfig {}, deps, version::current(), TestWitness(), ctx);
    assert_is_config_module(&account, extensions::witness());
    destroy(account);
}

#[test, expected_failure(abort_code = ENotCalledFromConfigModule)]
fun test_assert_config_module_wrong_witness_module() {
    let ctx = &mut tx_context::dummy();
    let deps = deps::new_for_testing();
    
    let account = new(TestConfig {}, deps, version::current(), TestWitness(), ctx);
    assert_is_config_module(&account, version::witness());
    destroy(account);
}

// === Test Helper Functions ===

#[test_only]
public fun new_for_testing(ctx: &mut TxContext): Account<TestConfig> {
    let deps = deps::new_for_testing();
    new(TestConfig {}, deps, version::current(), TestWitness(), ctx)
}

#[test_only]
public fun destroy_for_testing<Config>(account: Account<Config>) {
    destroy(account);
}

#[test_only]
public fun get_object_tracker<Config>(account: &Account<Config>): Option<ObjectTrackerState> {
    if (df::exists_(&account.id, ObjectTracker {})) {
        let tracker: &ObjectTrackerState = df::borrow(&account.id, ObjectTracker {});
        option::some(*tracker)
    } else {
        option::none()
    }
}

#[test_only]
public fun track_object_addition<Config>(account: &mut Account<Config>, id: ID) {
    let tracker = ensure_object_tracker(account);
    tracker.object_count = tracker.object_count + 1;
    if (tracker.object_count >= tracker.max_objects) {
        tracker.deposits_open = false;
    };
}

#[test_only]
public fun set_max_objects_for_testing<Config>(account: &mut Account<Config>, max: u128) {
    let tracker = ensure_object_tracker(account);
    tracker.max_objects = max;
}

#[test_only]
public fun enable_deposits_for_testing<Config>(account: &mut Account<Config>) {
    let tracker = ensure_object_tracker(account);
    tracker.deposits_open = true;
}

#[test_only]
public fun close_deposits_for_testing<Config>(account: &mut Account<Config>) {
    let tracker = ensure_object_tracker(account);
    tracker.deposits_open = false;
}

#[test_only]
public fun check_can_receive_object<Config, T>(account: &Account<Config>) {
    let tracker: &ObjectTrackerState = df::borrow(&account.id, ObjectTracker {});
    let type_name = type_name::with_defining_ids<T>();
    let ascii_str = type_name::into_string(type_name);
    let type_str = ascii_str.to_string();

    assert!(tracker.deposits_open || tracker.whitelisted_types.contains(&type_str), EDepositsDisabled);

    // For test purposes, we'll treat all objects the same
    // In production, coins don't count against limits but for tests this is fine
    if (!tracker.whitelisted_types.contains(&type_str)) {
        assert!(tracker.object_count < tracker.max_objects, EObjectLimitReached);
    };
}/// === FORK MODIFICATIONS ===
/// VECSET OPTIMIZATION FOR DUPLICATE DETECTION:
/// - Optimized to handle future growth to 10-20+ dependencies
/// - Dependencies may include: Cetus CLMM, Scallop, custom DAO packages, etc.
///
/// Changes in this fork:
/// - new(), new_latest_extensions(), new_inner(): Use VecSet for O(N log N) 
///   duplicate detection during construction instead of O(N) nested loops
/// - Storage remains vector-based to maintain `copy` + `drop` abilities
/// - Lookups remain O(N) which is acceptable for N20
///
/// TYPE-BASED ACTION SYSTEM:
/// - No direct changes, but deps are used with type-based action routing
///
/// Why not VecMap: VecMap's get() method has borrow checker issues - the key
/// must remain borrowed while the reference is in use, incompatible with our API
// Why not Table: Tables don't support `copy` or `drop` abilities which Deps requires
//
// Performance impact:
// - Before: N=20 required 190 comparisons during construction
// - After: N=20 requires ~86 operations (N log N with VecSet)
//
// All fork modifications are licensed under BSL 1.1
// ============================================================================

/// Dependencies are the packages that an Account object can call.
/// They are stored in a vector and can be modified through an intent.
/// AccountProtocol is the only mandatory dependency, found at index 0.
/// 
/// For improved security, we provide a whitelist of allowed packages in Extensions.
/// If unverified_allowed is false, then only these packages can be added.

module account_protocol::deps;

// === Imports ===

use std::string::String;
use sui::vec_set::{Self, VecSet};
use account_extensions::extensions::Extensions;
use account_protocol::version_witness::{Self, VersionWitness};

// === Errors ===

const EDepNotFound: u64 = 0;
const EDepAlreadyExists: u64 = 1;
const ENotDep: u64 = 2;
const ENotExtension: u64 = 3;
const EAccountProtocolMissing: u64 = 4;
const EDepsNotSameLength: u64 = 5;
const EAccountConfigMissing: u64 = 6;

// === Structs ===

/// Parent struct protecting the deps
public struct Deps has copy, drop, store {
    // vector of dependencies
    inner: vector<Dep>,
    // can community extensions be added
    unverified_allowed: bool,
}

/// Child struct storing the name, package and version of a dependency
public struct Dep has copy, drop, store {
    // name of the package
    name: String,
    // id of the package
    addr: address,
    // version of the package
    version: u64,
}

// === Public functions ===

/// Creates a new Deps struct, AccountProtocol must be the first dependency.
public fun new(
    extensions: &Extensions,
    unverified_allowed: bool,
    names: vector<String>,
    addresses: vector<address>,
    mut versions: vector<u64>,
): Deps {
    assert!(names.length() == addresses.length() && addresses.length() == versions.length(), EDepsNotSameLength);
    assert!(
        names[0] == b"AccountProtocol".to_string() &&
        extensions.is_extension(names[0], addresses[0], versions[0]), 
        EAccountProtocolMissing
    );
    // second dependency must be AccountConfig (we don't know the name)
    assert!(names[1] != b"AccountActions".to_string(), EAccountConfigMissing);

    let mut inner = vector<Dep>[];
    // Use VecSet for O(log N) duplicate detection during construction
    let mut name_set = vec_set::empty<String>();
    let mut addr_set = vec_set::empty<address>();

    names.zip_do!(addresses, |name, addr| {
        let version = versions.remove(0);
        
        // O(log N) duplicate checking instead of O(N)
        assert!(!name_set.contains(&name), EDepAlreadyExists);
        assert!(!addr_set.contains(&addr), EDepAlreadyExists);
        name_set.insert(name);
        addr_set.insert(addr);
        
        // verify extensions
        if (!unverified_allowed) 
            assert!(extensions.is_extension(name, addr, version), ENotExtension);
        
        // add dep
        inner.push_back(Dep { name, addr, version });
    });

    Deps { inner, unverified_allowed }
}

/// Creates a new Deps struct from latest packages for names.
/// Unverified packages are not allowed after this operation.
public fun new_latest_extensions(
    extensions: &Extensions,
    names: vector<String>,
): Deps {
    assert!(names[0] == b"AccountProtocol".to_string(), EAccountProtocolMissing);

    let mut inner = vector<Dep>[];
    // Use VecSet for O(log N) duplicate detection
    let mut name_set = vec_set::empty<String>();
    let mut addr_set = vec_set::empty<address>();
    
    names.do!(|name| {
        // O(log N) duplicate checking
        assert!(!name_set.contains(&name), EDepAlreadyExists);
        
        let (addr, version) = extensions.get_latest_for_name(name);
        
        assert!(!addr_set.contains(&addr), EDepAlreadyExists);
        name_set.insert(name);
        addr_set.insert(addr);
        
        // add dep
        inner.push_back(Dep { name, addr, version });
    });

    Deps { inner, unverified_allowed: false }
}

public fun new_inner(
    extensions: &Extensions,
    deps: &Deps,
    names: vector<String>,
    addresses: vector<address>,
    mut versions: vector<u64>,
): Deps {
    assert!(names.length() == addresses.length() && addresses.length() == versions.length(), EDepsNotSameLength);
    // AccountProtocol is mandatory and cannot be removed
    assert!(names[0] == b"AccountProtocol".to_string(), EAccountProtocolMissing);
    // second dependency must be AccountConfig (we don't know the name)
    assert!(names.length() >= 2, EAccountConfigMissing);
    assert!(names[1] != b"AccountActions".to_string(), EAccountConfigMissing);

    let mut inner = vector<Dep>[];
    // Use VecSet for O(log N) duplicate detection
    let mut name_set = vec_set::empty<String>();
    let mut addr_set = vec_set::empty<address>();

    names.zip_do!(addresses, |name, addr| {
        let version = versions.remove(0);
        
        // O(log N) duplicate checking
        assert!(!name_set.contains(&name), EDepAlreadyExists);
        assert!(!addr_set.contains(&addr), EDepAlreadyExists);
        name_set.insert(name);
        addr_set.insert(addr);
        
        // verify extensions
        if (!deps.unverified_allowed) 
            assert!(extensions.is_extension(name, addr, version), ENotExtension);
        
        // add dep
        inner.push_back(Dep { name, addr, version });
    });

    Deps { inner, unverified_allowed: deps.unverified_allowed }
}

/// Safe because deps_mut is only accessible in this package.
public fun inner_mut(deps: &mut Deps): &mut vector<Dep> {
    &mut deps.inner
}

// === View functions ===

/// Checks if a package is a dependency.
public fun check(deps: &Deps, version_witness: VersionWitness) {
    assert!(deps.contains_addr(version_witness.package_addr()), ENotDep);
}

public fun unverified_allowed(deps: &Deps): bool {
    deps.unverified_allowed
}

/// Toggles the unverified_allowed flag.
public(package) fun toggle_unverified_allowed(deps: &mut Deps) {
    deps.unverified_allowed = !deps.unverified_allowed;
}

/// Returns a dependency by name.
public fun get_by_name(deps: &Deps, name: String): &Dep {
    let mut i = 0;
    while (i < deps.inner.length()) {
        if (deps.inner[i].name == name) {
            return &deps.inner[i]
        };
        i = i + 1;
    };
    abort EDepNotFound
}

/// Returns a dependency by address.
public fun get_by_addr(deps: &Deps, addr: address): &Dep {
    let mut i = 0;
    while (i < deps.inner.length()) {
        if (deps.inner[i].addr == addr) {
            return &deps.inner[i]
        };
        i = i + 1;
    };
    abort EDepNotFound
}

/// Returns a dependency by index.
public fun get_by_idx(deps: &Deps, idx: u64): &Dep {
    &deps.inner[idx]
}

/// Returns the number of dependencies.
public fun length(deps: &Deps): u64 {
    deps.inner.length()
}

/// Returns the name of a dependency.
public fun name(dep: &Dep): String {
    dep.name
}

/// Returns the address of a dependency.
public fun addr(dep: &Dep): address {
    dep.addr
}

/// Returns the version of a dependency.
public fun version(dep: &Dep): u64 {
    dep.version
}

/// Returns true if the dependency exists by name.
public fun contains_name(deps: &Deps, name: String): bool {
    let mut i = 0;
    while (i < deps.inner.length()) {
        if (deps.inner[i].name == name) return true;
        i = i + 1;
    };
    false
}

/// Returns true if the dependency exists by address.
public fun contains_addr(deps: &Deps, addr: address): bool {
    let mut i = 0;
    while (i < deps.inner.length()) {
        if (deps.inner[i].addr == addr) return true;
        i = i + 1;
    };
    false
}

// === Test only ===

#[test_only]
public fun new_for_testing(): Deps {
    Deps {
        inner: vector[
            Dep { name: b"AccountProtocol".to_string(), addr: @account_protocol, version: 1 },
            Dep { name: b"AccountConfig".to_string(), addr: @0x1, version: 1 },
            Dep { name: b"AccountActions".to_string(), addr: @0x2, version: 1 },
        ],
        unverified_allowed: false,
    }
}

#[test_only]
public fun toggle_unverified_allowed_for_testing(deps: &mut Deps) {
    deps.unverified_allowed = !deps.unverified_allowed;
}

// === Tests ===

#[test]
fun test_new_and_getters() {
    let extensions = account_extensions::extensions::new_for_testing_with_addrs(@account_protocol, @0x1, @0x2, &mut tx_context::dummy());

    let _deps = new(&extensions, false, vector[b"AccountProtocol".to_string(), b"AccountConfig".to_string()], vector[@account_protocol, @0x1], vector[1, 1]);
    // assertions
    let deps = new_for_testing();
    let witness = version_witness::new_for_testing(@account_protocol);
    deps.check(witness);
    // deps getters
    assert!(deps.length() == 3);
    assert!(deps.contains_name(b"AccountProtocol".to_string()));
    assert!(deps.contains_addr(@account_protocol));
    // dep getters
    let dep = deps.get_by_name(b"AccountProtocol".to_string());
    assert!(dep.name() == b"AccountProtocol".to_string());
    assert!(dep.addr() == @account_protocol);
    assert!(dep.version() == 1);
    let dep = deps.get_by_addr(@account_protocol);
    assert!(dep.name() == b"AccountProtocol".to_string());
    assert!(dep.addr() == @account_protocol);
    assert!(dep.version() == 1);
    
    sui::test_utils::destroy(extensions);
}

#[test, expected_failure(abort_code = ENotDep)]
fun test_error_assert_is_dep() {
    let deps = new_for_testing();
    let witness = version_witness::new_for_testing(@0xDEAD);
    deps.check(witness);
}

#[test, expected_failure(abort_code = EDepNotFound)]
fun test_error_name_not_found() {
    let deps = new_for_testing();
    deps.get_by_name(b"Other".to_string());
}

#[test, expected_failure(abort_code = EDepNotFound)]
fun test_error_addr_not_found() {
    let deps = new_for_testing();
    deps.get_by_addr(@0xA);
}

#[test]
fun test_contains_name() {
    let deps = new_for_testing();
    assert!(deps.contains_name(b"AccountProtocol".to_string()));
    assert!(!deps.contains_name(b"Other".to_string()));
}

#[test]
fun test_contains_addr() {
    let deps = new_for_testing();
    assert!(deps.contains_addr(@account_protocol));
    assert!(!deps.contains_addr(@0xA));
}

#[test]
fun test_getters_by_idx() {
    let deps = new_for_testing();
    let dep = deps.get_by_idx(0);
    assert!(dep.name() == b"AccountProtocol".to_string());
    assert!(dep.addr() == @account_protocol);
    assert!(dep.version() == 1);
}

#[test]
fun test_toggle_unverified_allowed() {
    let mut deps = new_for_testing();
    assert!(deps.unverified_allowed() == false);
    deps.toggle_unverified_allowed_for_testing();
    assert!(deps.unverified_allowed() == true);
}

#[test]
fun test_contains_name_empty_deps() {
    let deps = Deps { 
        inner: vector[],
        unverified_allowed: false 
    };
    assert!(!deps.contains_name(b"AccountProtocol".to_string()));
}

#[test]
fun test_contains_addr_empty_deps() {
    let deps = Deps { 
        inner: vector[],
        unverified_allowed: false,
    };
    assert!(!deps.contains_addr(@account_protocol));
}/// This module defines the VersionWitness type used to track the version of the protocol.
/// This type is used as a regular witness, but for an entire package instead of a single module.

module account_protocol::version_witness;

// === Imports ===

use std::type_name;
use sui::{
    address, 
    hex,
};

// === Structs ===

/// Witness to check the version of a package.
public struct VersionWitness has copy, drop {
    // package id where the witness has been created
    package_addr: address,
}

/// Creates a new VersionWitness for the package where the Witness is instianted.
public fun new<PW: drop>(_package_witness: PW): VersionWitness {
    let package_type = type_name::with_defining_ids<PW>();
    let package_addr = address::from_bytes(hex::decode(package_type.address_string().into_bytes()));

    VersionWitness { package_addr }
}

// === Public Functions ===

/// Returns the address of the package where the witness has been created.
public fun package_addr(witness: &VersionWitness): address {
    witness.package_addr
}

//**************************************************************************************************//
// Tests                                                                                            //
//**************************************************************************************************//

// === Test Helpers ===

#[test_only]
public fun new_for_testing(package_addr: address): VersionWitness {
    VersionWitness { package_addr }
}

// === Unit Tests ===

#[test_only]
public struct TestPackageWitness() has drop;

#[test]
fun test_new_version_witness() {
    let witness = new(TestPackageWitness());
    // Should not abort - just testing creation and access
    assert!(package_addr(&witness) == @account_protocol, 0);
}// ============================================================================
// FORK MODIFICATION NOTICE - Hot Potato Action Results
// ============================================================================
// Zero-cost result passing between actions using hot potato pattern.
//
// PURPOSE:
// - Replace ExecutionContext with compile-time safe result chaining
// - Eliminate Table storage costs (~200 gas per operation)
// - Enforce explicit data dependencies between actions
//
// NEW IN THIS DIFF:
// - Added consumption functions for all result types
// - consume_mint_result, consume_spend_result, etc.
// - Enables proper cleanup of hot potato results in intent modules
// ============================================================================

module account_protocol::action_results;

use sui::object::ID;
use std::string::String;

// Generic result wrapper for any action that creates objects
public struct ActionResult<phantom T> {
    object_id: ID,
    // Additional fields can be added per action type
}

// Specific result types for common patterns
public struct TransferResult {
    transferred_id: ID,
    recipient: address,
}

public struct MintResult {
    coin_id: ID,
    amount: u64,
}

public struct CreateStreamResult {
    stream_id: ID,
    beneficiary: address,
}

public struct CreateProposalResult {
    proposal_id: ID,
    proposal_number: u64,
}

public struct SpendResult {
    coin_id: ID,
    amount: u64,
    vault_name: String,
}

public struct VestingResult {
    vesting_id: ID,
    recipient: address,
    amount: u64,
}

public struct KioskResult {
    item_id: ID,
    kiosk_id: ID,
}

public struct UpgradeResult {
    package_id: ID,
    version: u64,
}

// Result chain for complex multi-step operations
public struct ResultChain {
    // Can hold multiple results in sequence
    results: vector<ID>,
}

// Constructor functions
public fun new_action_result<T>(object_id: ID): ActionResult<T> {
    ActionResult { object_id }
}

public fun new_transfer_result(id: ID, recipient: address): TransferResult {
    TransferResult { transferred_id: id, recipient }
}

public fun new_mint_result(coin_id: ID, amount: u64): MintResult {
    MintResult { coin_id, amount }
}

public fun new_spend_result(coin_id: ID, amount: u64, vault_name: String): SpendResult {
    SpendResult { coin_id, amount, vault_name }
}

public fun new_vesting_result(vesting_id: ID, recipient: address, amount: u64): VestingResult {
    VestingResult { vesting_id, recipient, amount }
}

public fun new_kiosk_result(item_id: ID, kiosk_id: ID): KioskResult {
    KioskResult { item_id, kiosk_id }
}

public fun new_upgrade_result(package_id: ID, version: u64): UpgradeResult {
    UpgradeResult { package_id, version }
}

// Consumption functions to destroy hot potatoes
public fun consume_mint_result(result: MintResult) {
    let MintResult { coin_id: _, amount: _ } = result;
}

public fun consume_spend_result(result: SpendResult) {
    let SpendResult { coin_id: _, amount: _, vault_name: _ } = result;
}

public fun consume_transfer_result(result: TransferResult) {
    let TransferResult { transferred_id: _, recipient: _ } = result;
}

public fun consume_vesting_result(result: VestingResult) {
    let VestingResult { vesting_id: _, recipient: _, amount: _ } = result;
}

public fun consume_kiosk_result(result: KioskResult) {
    let KioskResult { item_id: _, kiosk_id: _ } = result;
}

public fun consume_upgrade_result(result: UpgradeResult) {
    let UpgradeResult { package_id: _, version: _ } = result;
}

public fun consume_create_stream_result(result: CreateStreamResult) {
    let CreateStreamResult { stream_id: _, beneficiary: _ } = result;
}

public fun consume_create_proposal_result(result: CreateProposalResult) {
    let CreateProposalResult { proposal_id: _, proposal_number: _ } = result;
}

public fun consume_action_result<T>(result: ActionResult<T>) {
    let ActionResult { object_id: _ } = result;
}

public fun new_result_chain(): ResultChain {
    ResultChain { results: vector::empty() }
}

public fun add_to_chain(chain: &mut ResultChain, id: ID) {
    vector::push_back(&mut chain.results, id);
}

// Destructor functions to extract data
public fun destroy_action_result<T>(result: ActionResult<T>): ID {
    let ActionResult { object_id } = result;
    object_id
}

public fun destroy_transfer_result(result: TransferResult): (ID, address) {
    let TransferResult { transferred_id, recipient } = result;
    (transferred_id, recipient)
}

public fun destroy_mint_result(result: MintResult): (ID, u64) {
    let MintResult { coin_id, amount } = result;
    (coin_id, amount)
}

public fun destroy_spend_result(result: SpendResult): (ID, u64, String) {
    let SpendResult { coin_id, amount, vault_name } = result;
    (coin_id, amount, vault_name)
}

public fun destroy_vesting_result(result: VestingResult): (ID, address, u64) {
    let VestingResult { vesting_id, recipient, amount } = result;
    (vesting_id, recipient, amount)
}

public fun destroy_kiosk_result(result: KioskResult): (ID, ID) {
    let KioskResult { item_id, kiosk_id } = result;
    (item_id, kiosk_id)
}

public fun destroy_upgrade_result(result: UpgradeResult): (ID, u64) {
    let UpgradeResult { package_id, version } = result;
    (package_id, version)
}

public fun destroy_result_chain(chain: ResultChain): vector<ID> {
    let ResultChain { results } = chain;
    results
}

// Accessors for reading without consuming
public fun result_object_id<T>(result: &ActionResult<T>): ID {
    result.object_id
}

public fun transfer_result_id(result: &TransferResult): ID {
    result.transferred_id
}

public fun transfer_result_recipient(result: &TransferResult): address {
    result.recipient
}

public fun mint_result_id(result: &MintResult): ID {
    result.coin_id
}

public fun mint_result_amount(result: &MintResult): u64 {
    result.amount
}

public fun spend_result_id(result: &SpendResult): ID {
    result.coin_id
}

public fun spend_result_amount(result: &SpendResult): u64 {
    result.amount
}

public fun spend_result_vault_name(result: &SpendResult): &String {
    &result.vault_name
}

public fun chain_results(chain: &ResultChain): &vector<ID> {
    &chain.results
}// ============================================================================
// FORK MODIFICATION NOTICE - Intents with Serialize-Then-Destroy Pattern
// ============================================================================
// Core module managing Intents with type-safe action execution.
//
// MAJOR CHANGES IN THIS FORK:
//
// 1. REMOVED OBJECT LOCKING:
//    - No locking - multiple intents can reference same objects
//    - Conflicts resolved naturally by blockchain (first to execute wins)
//
// 2. SERIALIZE-THEN-DESTROY PATTERN:
//    - add_typed_action() now accepts pre-serialized bytes instead of action structs
//    - Enables explicit destruction of action structs after serialization
//    - Maintains BCS compatibility while improving resource safety
//
// 3. TYPE-BASED ACTION SYSTEM:
//    Original: Used action_descriptors with string categories (b"treasury")
//    New: Uses action_types: vector<TypeName> for compile-time safety
//    - Removed dependency on action_descriptor module
//    - Added add_typed_action<Outcome, Action, T, IW>() with compile-time types
//    - Type names captured using type_name::with_defining_ids<T>() for zero-overhead routing
//
// BENEFITS:
// - Eliminates risk of permanently locked objects from incomplete cleanup
// - Compile-time type safety for all actions
// - Better gas efficiency (no string comparisons)
// - Simplifies codebase by ~100 lines
// - Better suits DAO governance where competing proposals are natural
// ============================================================================
/// This is the core module managing Intents.
/// It provides the interface to create and execute intents which is used in the `account` module.
/// In the new design, there is no locking - multiple intents can reference the same objects.
/// Conflicts are resolved naturally: if coinA is withdrawn by intent1, intent2 will fail when it tries.

module account_protocol::intents;

// === Imports ===

use std::{
    string::String,
    type_name::{Self, TypeName},
    bcs,
    vector,
};
use sui::{
    bag::{Self, Bag},
    dynamic_field,
    clock::Clock,
    object::{Self, ID},
};

// === Aliases ===

use fun dynamic_field::add as UID.df_add;
use fun dynamic_field::borrow as UID.df_borrow;
use fun dynamic_field::remove as UID.df_remove;
// Type-based action system - no string descriptors

// === Errors ===

const EIntentNotFound: u64 = 0;
// REMOVED: EObjectAlreadyLocked and EObjectNotLocked - no locking in new design
const ENoExecutionTime: u64 = 3;
const EExecutionTimesNotAscending: u64 = 4;
const EActionsNotEmpty: u64 = 5;
const EKeyAlreadyExists: u64 = 6;
const EWrongAccount: u64 = 7;
const EWrongWitness: u64 = 8;
const ESingleExecution: u64 = 9;
const EMaxPlaceholdersExceeded: u64 = 10;
const EUnsupportedActionVersion: u64 = 11;
const EActionDataTooLarge: u64 = 12;

// Version constants
const CURRENT_ACTION_VERSION: u8 = 1;

// === Limits ===

/// Maximum number of placeholders allowed in a single intent.
/// Exposed as a function to allow future upgrades to change this value.
public fun max_placeholders(): u64 { 50 }

/// Maximum size for action data in bytes (4KB).
/// Exposed as a function to allow future upgrades to change this value.
/// Prevents excessively large action data that could cause DoS.
public fun max_action_data_size(): u64 { 4096 }

// === Structs ===

/// A blueprint for a single action within an intent.
public struct ActionSpec has store, copy, drop {
    version: u8,                // Version byte for forward compatibility
    action_type: TypeName,      // The type of the action struct
    action_data: vector<u8>,    // The BCS-serialized action struct
}

/// Parent struct protecting the intents
public struct Intents has store {
    // map of intents: key -> Intent<Outcome>
    inner: Bag,
}

/// Child struct, intent owning a sequence of actions requested to be executed
/// Outcome is a custom struct depending on the config
public struct Intent<Outcome> has store {
    // type of the intent, checked against the witness to ensure correct execution
    type_: TypeName,
    // name of the intent, serves as a key, should be unique
    key: String,
    // what this intent aims to do, for informational purpose
    description: String,
    // address of the account that created the intent
    account: address,
    // address of the user that created the intent
    creator: address,
    // timestamp of the intent creation
    creation_time: u64,
    // proposer can add a timestamp_ms before which the intent can't be executed
    // can be used to schedule actions via a backend
    // recurring intents can be executed at these times
    execution_times: vector<u64>,
    // the intent can be deleted from this timestamp
    expiration_time: u64,
    // role for the intent
    role: String,
    // Structured action specifications for type-safe routing (single source of truth)
    action_specs: vector<ActionSpec>,
    // Counter for unique placeholder IDs
    next_placeholder_id: u64,
    // Generic struct storing vote related data, depends on the config
    outcome: Outcome,
}

/// Hot potato wrapping actions from an intent that expired or has been executed
public struct Expired {
    // address of the account that created the intent
    account: address,
    // action specs that expired or were executed
    action_specs: vector<ActionSpec>,
    // NEW: Track which actions were executed for proper destruction
    executed_actions: vector<bool>,
    // intent ID for tracking
    intent_id: ID,
}

/// Params of an intent to reduce boilerplate.
public struct Params has key, store {
    id: UID,
}
/// Fields are a df so it intents can be improved in the future
public struct ParamsFieldsV1 has copy, drop, store {
    key: String,
    description: String,
    creation_time: u64,
    execution_times: vector<u64>,
    expiration_time: u64,
}

// === Public functions ===

/// Reserve a placeholder ID for use during intent creation
public(package) fun reserve_placeholder_id<Outcome>(
    intent: &mut Intent<Outcome>
): u64 {
    let id = intent.next_placeholder_id;
    assert!(id < max_placeholders(), EMaxPlaceholdersExceeded);
    intent.next_placeholder_id = id + 1;
    id
}

/// Add an action specification with pre-serialized bytes (serialize-then-destroy pattern)
public fun add_action_spec<Outcome, T: drop, IW: drop>(
    intent: &mut Intent<Outcome>,
    action_type_witness: T,
    action_data_bytes: vector<u8>,
    intent_witness: IW,
) {
    intent.assert_is_witness(intent_witness);

    // Validate action data size to prevent excessively large actions
    assert!(
        action_data_bytes.length() <= max_action_data_size(),
        EActionDataTooLarge
    );

    // Create and store the action spec with BCS-serialized action
    let spec = ActionSpec {
        version: CURRENT_ACTION_VERSION,
        action_type: type_name::with_defining_ids<T>(),
        action_data: action_data_bytes,
    };
    intent.action_specs.push_back(spec);
}

public fun new_params(
    key: String,
    description: String,
    execution_times: vector<u64>,
    expiration_time: u64,
    clock: &Clock,
    ctx: &mut TxContext,
): Params {
    assert!(!execution_times.is_empty(), ENoExecutionTime);
    let mut i = 0;
    while (i < vector::length(&execution_times) - 1) {
        assert!(execution_times[i] <= execution_times[i + 1], EExecutionTimesNotAscending);
        i = i + 1;
    };
    
    let fields = ParamsFieldsV1 { 
        key, 
        description, 
        creation_time: clock.timestamp_ms(), 
        execution_times, 
        expiration_time 
    };
    let mut id = object::new(ctx);
    id.df_add(true, fields);

    Params { id }
}

public fun new_params_with_rand_key(
    description: String,
    execution_times: vector<u64>,
    expiration_time: u64,
    clock: &Clock,
    ctx: &mut TxContext,
): (Params, String) {
    let key = ctx.fresh_object_address().to_string();
    let params = new_params(key, description, execution_times, expiration_time, clock, ctx);

    (params, key)
}

// REMOVED: Old add_action function without types - use add_typed_action instead

/// Add a typed action with pre-serialized bytes (serialize-then-destroy pattern)
/// Callers must serialize the action and then explicitly destroy it
public fun add_typed_action<Outcome, T: drop, IW: drop>(
    intent: &mut Intent<Outcome>,
    action_type: T,
    action_data: vector<u8>,
    intent_witness: IW,
) {
    add_action_spec(intent, action_type, action_data, intent_witness);
}

public fun remove_action_spec(
    expired: &mut Expired,
): ActionSpec {
    // Also mark as not executed when removing
    expired.executed_actions.remove(0);
    expired.action_specs.remove(0)
}

/// Mark an action as executed in the Expired struct
public fun mark_action_executed(
    expired: &mut Expired,
    index: u64,
) {
    let executed = vector::borrow_mut(&mut expired.executed_actions, index);
    *executed = true;
}

/// Check if an action was executed
public fun is_action_executed(
    expired: &Expired,
    index: u64,
): bool {
    *vector::borrow(&expired.executed_actions, index)
}

/// Get the number of actions in the Expired struct
public fun expired_action_count(expired: &Expired): u64 {
    expired.action_specs.length()
}

public use fun destroy_empty_expired as Expired.destroy_empty;
public fun destroy_empty_expired(expired: Expired) {
    let Expired { action_specs, executed_actions, .. } = expired;
    assert!(action_specs.is_empty(), EActionsNotEmpty);
    assert!(executed_actions.is_empty(), EActionsNotEmpty);
    // vectors don't need explicit destroy
}

// === View functions ===

public use fun params_key as Params.key;
public fun params_key(params: &Params): String {
    params.id.df_borrow<_, ParamsFieldsV1>(true).key
}

public use fun params_description as Params.description;
public fun params_description(params: &Params): String {
    params.id.df_borrow<_, ParamsFieldsV1>(true).description
}

public use fun params_creation_time as Params.creation_time;
public fun params_creation_time(params: &Params): u64 {
    params.id.df_borrow<_, ParamsFieldsV1>(true).creation_time
}

public use fun params_execution_times as Params.execution_times;
public fun params_execution_times(params: &Params): vector<u64> {
    params.id.df_borrow<_, ParamsFieldsV1>(true).execution_times
}

public use fun params_expiration_time as Params.expiration_time;
public fun params_expiration_time(params: &Params): u64 {
    params.id.df_borrow<_, ParamsFieldsV1>(true).expiration_time
}

public fun length(intents: &Intents): u64 {
    intents.inner.length()
}

// REMOVED: locked() getter - no longer tracking locked objects

public fun contains(intents: &Intents, key: String): bool {
    intents.inner.contains(key)
}

public fun get<Outcome: store>(intents: &Intents, key: String): &Intent<Outcome> {
    assert!(intents.inner.contains(key), EIntentNotFound);
    intents.inner.borrow(key)
}

public fun get_mut<Outcome: store>(intents: &mut Intents, key: String): &mut Intent<Outcome> {
    assert!(intents.inner.contains(key), EIntentNotFound);
    intents.inner.borrow_mut(key)
}

public fun type_<Outcome>(intent: &Intent<Outcome>): TypeName {
    intent.type_
}

public fun key<Outcome>(intent: &Intent<Outcome>): String {
    intent.key
}

public fun description<Outcome>(intent: &Intent<Outcome>): String {
    intent.description
}

public fun account<Outcome>(intent: &Intent<Outcome>): address {
    intent.account
}

public fun creator<Outcome>(intent: &Intent<Outcome>): address {
    intent.creator
}

public fun creation_time<Outcome>(intent: &Intent<Outcome>): u64 {
    intent.creation_time
}

public fun execution_times<Outcome>(intent: &Intent<Outcome>): vector<u64> {
    intent.execution_times
}

public fun expiration_time<Outcome>(intent: &Intent<Outcome>): u64 {
    intent.expiration_time
}

public fun role<Outcome>(intent: &Intent<Outcome>): String {
    intent.role
}

// Actions are now accessed through action_specs
public fun action_count<Outcome>(intent: &Intent<Outcome>): u64 {
    intent.action_specs.length()
}

public fun outcome<Outcome>(intent: &Intent<Outcome>): &Outcome {
    &intent.outcome
}

public fun outcome_mut<Outcome>(intent: &mut Intent<Outcome>): &mut Outcome {
    &mut intent.outcome
}

public fun action_specs<Outcome>(intent: &Intent<Outcome>): &vector<ActionSpec> {
    &intent.action_specs
}

public fun action_spec_version(spec: &ActionSpec): u8 {
    spec.version
}

public fun action_spec_type(spec: &ActionSpec): TypeName {
    spec.action_type
}

public fun action_spec_data(spec: &ActionSpec): &vector<u8> {
    &spec.action_data
}

public fun action_spec_action_data(spec: ActionSpec): vector<u8> {
    let ActionSpec { version: _, action_data, .. } = spec;
    action_data
}

public use fun expired_account as Expired.account;
public fun expired_account(expired: &Expired): address {
    expired.account
}

// start_index no longer exists in ActionSpec-based design

public use fun expired_action_specs as Expired.action_specs;
public fun expired_action_specs(expired: &Expired): &vector<ActionSpec> {
    &expired.action_specs
}

public fun assert_is_account<Outcome>(
    intent: &Intent<Outcome>,
    account_addr: address,
) {
    assert!(intent.account == account_addr, EWrongAccount);
}

public fun assert_is_witness<Outcome, IW: drop>(
    intent: &Intent<Outcome>,
    _: IW,
) {
    assert!(intent.type_ == type_name::with_defining_ids<IW>(), EWrongWitness);
}

public use fun assert_expired_is_account as Expired.assert_is_account;
public fun assert_expired_is_account(expired: &Expired, account_addr: address) {
    assert!(expired.account == account_addr, EWrongAccount);
}

public fun assert_single_execution(params: &Params) {
    assert!(
        params.id.df_borrow<_, ParamsFieldsV1>(true).execution_times.length() == 1, 
        ESingleExecution
    );
}

// === Package functions ===

/// The following functions are only used in the `account` module

public(package) fun empty(ctx: &mut TxContext): Intents {
    Intents { inner: bag::new(ctx) }
}

public(package) fun new_intent<Outcome, IW: drop>(
    params: Params,
    outcome: Outcome,
    managed_name: String,
    account_addr: address,
    _intent_witness: IW,
    ctx: &mut TxContext
): Intent<Outcome> {
    let Params { mut id } = params;
    
    let ParamsFieldsV1 { 
        key, 
        description, 
        creation_time, 
        execution_times, 
        expiration_time 
    } = id.df_remove(true);
    id.delete();

    Intent<Outcome> {
        type_: type_name::with_defining_ids<IW>(),
        key,
        description,
        account: account_addr,
        creator: ctx.sender(),
        creation_time,
        execution_times,
        expiration_time,
        role: new_role<IW>(managed_name),
        action_specs: vector::empty(),
        next_placeholder_id: 0,
        outcome,
    }
}

public(package) fun add_intent<Outcome: store>(
    intents: &mut Intents,
    intent: Intent<Outcome>,
) {
    assert!(!intents.contains(intent.key), EKeyAlreadyExists);
    intents.inner.add(intent.key, intent);
}

public(package) fun remove_intent<Outcome: store>(
    intents: &mut Intents,
    key: String,
): Intent<Outcome> {
    assert!(intents.contains(key), EIntentNotFound);
    intents.inner.remove(key)
}

public(package) fun pop_front_execution_time<Outcome>(
    intent: &mut Intent<Outcome>,
): u64 {
    intent.execution_times.remove(0)
}

// REMOVED: lock and unlock functions - no locking needed in the new design
// Conflicts between intents are natural in DAO governance where multiple proposals
// can compete for the same resources

/// Removes an intent being executed if the execution_time is reached
/// Outcome must be validated in AccountMultisig to be destroyed
public(package) fun destroy_intent<Outcome: store + drop>(
    intents: &mut Intents,
    key: String,
): Expired {
    let Intent<Outcome> { account, action_specs, key, .. } = intents.inner.remove(key);
    let num_actions = action_specs.length();
    let mut executed_actions = vector::empty<bool>();
    let mut i = 0;
    while (i < num_actions) {
        vector::push_back(&mut executed_actions, false);
        i = i + 1;
    };

    // Create a dummy ID for now - in production you might want to use a hash of the key
    let intent_id = object::id_from_address(@0x0);

    Expired { account, action_specs, executed_actions, intent_id }
}

// === Private functions ===

fun new_role<IW: drop>(managed_name: String): String {
    let intent_type = type_name::with_defining_ids<IW>();
    let mut role = intent_type.address_string().to_string();
    role.append_utf8(b"::");
    role.append(intent_type.module_string().to_string());

    if (!managed_name.is_empty()) {
        role.append_utf8(b"::");
        role.append(managed_name);
    };

    role
}

//**************************************************************************************************//
// Tests                                                                                            //
//**************************************************************************************************//

#[test_only]
use sui::test_utils::{assert_eq, destroy};
#[test_only]
use sui::clock;

#[test_only]
public struct TestOutcome has copy, drop, store {}
#[test_only]
public struct TestAction has store {}
#[test_only]
public struct TestActionType has drop {}
#[test_only]
public struct TestIntentWitness() has drop;
#[test_only]
public struct WrongWitness() has drop;

#[test]
fun test_new_params() {
    let ctx = &mut tx_context::dummy();
    let clock = clock::create_for_testing(ctx);
    
    let params = new_params(
        b"test_key".to_string(),
        b"test_description".to_string(),
        vector[1000],
        2000,
        &clock,
        ctx
    );
    
    assert_eq(params.key(), b"test_key".to_string());
    assert_eq(params.description(), b"test_description".to_string());
    assert_eq(params.execution_times(), vector[1000]);
    assert_eq(params.expiration_time(), 2000);
    assert_eq(params.creation_time(), 0);
    
    destroy(params);
    destroy(clock);
}

#[test]
fun test_new_params_with_rand_key() {
    let ctx = &mut tx_context::dummy();
    let clock = clock::create_for_testing(ctx);
    
    let (params, key) = new_params_with_rand_key(
        b"test_description".to_string(),
        vector[1000],
        2000,
        &clock,
        ctx
    );
    
    assert_eq(params.key(), key);
    assert_eq(params.description(), b"test_description".to_string());
    assert_eq(params.execution_times(), vector[1000]);
    assert_eq(params.expiration_time(), 2000);
    
    destroy(params);
    destroy(clock);
}

#[test, expected_failure(abort_code = ENoExecutionTime)]
fun test_new_params_empty_execution_times() {
    let ctx = &mut tx_context::dummy();
    let clock = clock::create_for_testing(ctx);
    
    let params = new_params(
        b"test_key".to_string(),
        b"test_description".to_string(),
        vector[],
        2000,
        &clock,
        ctx
    );
    destroy(params);
    destroy(clock);
}

#[test, expected_failure(abort_code = EExecutionTimesNotAscending)]
fun test_new_params_not_ascending_execution_times() {
    let ctx = &mut tx_context::dummy();
    let clock = clock::create_for_testing(ctx);
    
    let params = new_params(
        b"test_key".to_string(),
        b"test_description".to_string(),
        vector[2000, 1000],
        3000,
        &clock,
        ctx
    );
    destroy(params);
    destroy(clock);
}

#[test]
fun test_new_intent() {
    let ctx = &mut tx_context::dummy();
    let clock = clock::create_for_testing(ctx);
    
    let params = new_params(
        b"test_key".to_string(),
        b"test_description".to_string(),
        vector[1000],
        2000,
        &clock,
        ctx
    );
    
    let intent = new_intent(
        params,
        TestOutcome {},
        b"test_role".to_string(),
        @0xCAFE,
        TestIntentWitness(),
        ctx
    );
    
    assert_eq(intent.key(), b"test_key".to_string());
    assert_eq(intent.description(), b"test_description".to_string());
    assert_eq(intent.account(), @0xCAFE);
    assert_eq(intent.creation_time(), clock.timestamp_ms());
    assert_eq(intent.execution_times(), vector[1000]);
    assert_eq(intent.expiration_time(), 2000);
    assert_eq(intent.actions().length(), 0);
    
    destroy(intent);
    destroy(clock);
}

#[test]
fun test_add_action() {
    let ctx = &mut tx_context::dummy();
    let clock = clock::create_for_testing(ctx);
    
    let params = new_params(
        b"test_key".to_string(),
        b"test_description".to_string(),
        vector[1000],
        2000,
        &clock,
        ctx
    );
    
    let mut intent = new_intent(
        params,
        TestOutcome {},
        b"test_role".to_string(),
        @0xCAFE,
        TestIntentWitness(),
        ctx
    );
    
    intent.add_typed_action(TestAction {}, TestActionType {}, TestIntentWitness());
    assert_eq(intent.actions().length(), 1);
    
    intent.add_typed_action(TestAction {}, TestActionType {}, TestIntentWitness());
    assert_eq(intent.actions().length(), 2);
    
    destroy(intent);
    destroy(clock);
}

#[test]
fun test_remove_action() {
    let ctx = &mut tx_context::dummy();
    let clock = clock::create_for_testing(ctx);
    let mut intents = empty(ctx);
    
    let params = new_params(
        b"test_key".to_string(),
        b"test_description".to_string(),
        vector[1000],
        2000,
        &clock,
        ctx
    );
    
    let mut intent = new_intent(
        params,
        TestOutcome {},
        b"test_role".to_string(),
        @0xCAFE,
        TestIntentWitness(),
        ctx
    );
    
    intent.add_typed_action(TestAction {}, TestActionType {}, TestIntentWitness());
    intent.add_typed_action(TestAction {}, TestActionType {}, TestIntentWitness());
    add_intent(&mut intents, intent);
    
    let mut expired = intents.destroy_intent<TestOutcome>(b"test_key".to_string());
    
    let action1: TestAction = remove_action(&mut expired);
    let action2: TestAction = remove_action(&mut expired);
    
    assert_eq(expired.start_index, 2);
    assert_eq(expired.actions().length(), 0);
    
    expired.destroy_empty();
    destroy(intents);
    destroy(clock);
    destroy(action1);
    destroy(action2);
}

#[test]
fun test_empty_intents() {
    let ctx = &mut tx_context::dummy();
    let intents = empty(ctx);
    
    assert_eq(length(&intents), 0);
    // No longer checking locked() - removed in new design
    assert!(!contains(&intents, b"test_key".to_string()));
    
    destroy(intents);
}

#[test]
fun test_add_and_remove_intent() {
    let ctx = &mut tx_context::dummy();
    let clock = clock::create_for_testing(ctx);
    let mut intents = empty(ctx);
    
    let params = new_params(
        b"test_key".to_string(),
        b"test_description".to_string(),
        vector[1000],
        2000,
        &clock,
        ctx
    );
    
    let intent = new_intent(
        params,
        TestOutcome {},
        b"test_role".to_string(),
        @0xCAFE,
        TestIntentWitness(),
        ctx
    );
    
    add_intent(&mut intents, intent);
    assert_eq(length(&intents), 1);
    assert!(contains(&intents, b"test_key".to_string()));
    
    let removed_intent = remove_intent<TestOutcome>(&mut intents, b"test_key".to_string());
    assert_eq(length(&intents), 0);
    assert!(!contains(&intents, b"test_key".to_string()));
    
    destroy(removed_intent);
    destroy(intents);
    destroy(clock);
}

#[test, expected_failure(abort_code = EKeyAlreadyExists)]
fun test_add_duplicate_intent() {
    let ctx = &mut tx_context::dummy();
    let clock = clock::create_for_testing(ctx);
    let mut intents = empty(ctx);
    
    let params1 = new_params(
        b"test_key".to_string(),
        b"test_description".to_string(),
        vector[1000],
        2000,
        &clock,
        ctx
    );
    
    let params2 = new_params(
        b"test_key".to_string(),
        b"test_description2".to_string(),
        vector[1000],
        2000,
        &clock,
        ctx
    );
    
    let intent1 = new_intent(
        params1,
        TestOutcome {},
        b"test_role".to_string(),
        @0xCAFE,
        TestIntentWitness(),
        ctx
    );
    
    let intent2 = new_intent(
        params2,
        TestOutcome {},
        b"test_role".to_string(),
        @0xCAFE,
        TestIntentWitness(),
        ctx
    );
    
    add_intent(&mut intents, intent1);
    add_intent(&mut intents, intent2);
    
    destroy(intents);
    destroy(clock);
}

#[test, expected_failure(abort_code = EIntentNotFound)]
fun test_remove_nonexistent_intent() {
    let ctx = &mut tx_context::dummy();
    let mut intents = empty(ctx);
    
    let removed_intent = remove_intent<TestOutcome>(&mut intents, b"nonexistent_key".to_string());
    
    destroy(removed_intent);
    destroy(intents);
}

// REMOVED: test_lock_and_unlock_object - no locking in new design
// REMOVED: test_lock_already_locked_object - no locking in new design  
// REMOVED: test_unlock_not_locked_object - no locking in new design

#[test]
fun test_pop_front_execution_time() {
    let ctx = &mut tx_context::dummy();
    let clock = clock::create_for_testing(ctx);
    
    let params = new_params(
        b"test_key".to_string(),
        b"test_description".to_string(),
        vector[1000, 2000, 3000],
        4000,
        &clock,
        ctx
    );
    
    let mut intent = new_intent(
        params,
        TestOutcome {},
        b"test_role".to_string(),
        @0xCAFE,
        TestIntentWitness(),
        ctx
    );
    
    assert_eq(intent.execution_times(), vector[1000, 2000, 3000]);
    
    let time1 = pop_front_execution_time(&mut intent);
    assert_eq(time1, 1000);
    assert_eq(intent.execution_times(), vector[2000, 3000]);
    
    let time2 = pop_front_execution_time(&mut intent);
    assert_eq(time2, 2000);
    assert_eq(intent.execution_times(), vector[3000]);
    
    destroy(intent);
    destroy(clock);
}

#[test]
fun test_assert_is_account() {
    let ctx = &mut tx_context::dummy();
    let clock = clock::create_for_testing(ctx);
    
    let params = new_params(
        b"test_key".to_string(),
        b"test_description".to_string(),
        vector[1000],
        2000,
        &clock,
        ctx
    );
    
    let intent = new_intent(
        params,
        TestOutcome {},
        b"test_role".to_string(),
        @0xCAFE,
        TestIntentWitness(),
        ctx
    );
    
    // Should not abort
    assert_is_account(&intent, @0xCAFE);
    
    destroy(intent);
    destroy(clock);
}

#[test, expected_failure(abort_code = EWrongAccount)]
fun test_assert_is_account_wrong() {
    let ctx = &mut tx_context::dummy();
    let clock = clock::create_for_testing(ctx);
    
    let params = new_params(
        b"test_key".to_string(),
        b"test_description".to_string(),
        vector[1000],
        2000,
        &clock,
        ctx
    );
    
    let intent = new_intent(
        params,
        TestOutcome {},
        b"test_role".to_string(),
        @0xCAFE,
        TestIntentWitness(),
        ctx
    );
    
    assert_is_account(&intent, @0xBAD);
    
    destroy(intent);
    destroy(clock);
}

#[test]
fun test_assert_is_witness() {
    let ctx = &mut tx_context::dummy();
    let clock = clock::create_for_testing(ctx);
    
    let params = new_params(
        b"test_key".to_string(),
        b"test_description".to_string(),
        vector[1000],
        2000,
        &clock,
        ctx
    );
    
    let intent = new_intent(
        params,
        TestOutcome {},
        b"test_role".to_string(),
        @0xCAFE,
        TestIntentWitness(),
        ctx
    );
    
    // Should not abort
    assert_is_witness(&intent, TestIntentWitness());
    
    destroy(intent);
    destroy(clock);
}

#[test, expected_failure(abort_code = EWrongWitness)]
fun test_assert_is_witness_wrong() {
    let ctx = &mut tx_context::dummy();
    let clock = clock::create_for_testing(ctx);
    
    let params = new_params(
        b"test_key".to_string(),
        b"test_description".to_string(),
        vector[1000],
        2000,
        &clock,
        ctx
    );
    
    let intent = new_intent(
        params,
        TestOutcome {},
        b"test_role".to_string(),
        @0xCAFE,
        TestIntentWitness(),
        ctx
    );
    
    assert_is_witness(&intent, WrongWitness());
    
    destroy(intent);
    destroy(clock);
}

#[test]
fun test_assert_single_execution() {
    let ctx = &mut tx_context::dummy();
    let clock = clock::create_for_testing(ctx);
    
    let params = new_params(
        b"test_key".to_string(),
        b"test_description".to_string(),
        vector[1000],
        2000,
        &clock,
        ctx
    );
    
    // Should not abort
    assert_single_execution(&params);
    
    destroy(params);
    destroy(clock);
}

#[test, expected_failure(abort_code = ESingleExecution)]
fun test_assert_single_execution_multiple() {
    let ctx = &mut tx_context::dummy();
    let clock = clock::create_for_testing(ctx);
    
    let params = new_params(
        b"test_key".to_string(),
        b"test_description".to_string(),
        vector[1000, 2000],
        3000,
        &clock,
        ctx
    );
    
    assert_single_execution(&params);
    
    destroy(params);
    destroy(clock);
}// ============================================================================
// FORK MODIFICATION NOTICE - Hot Potato Executable without ExecutionContext
// ============================================================================
// Hot potato ensuring actions are executed as intended (can't be stored).
//
// CHANGES IN THIS FORK:
// - REMOVED ExecutionContext entirely - no more Table storage costs
// - Added type_name imports for type-based action routing
// - Added current_action_type() to get the TypeName of current action
// - Added is_current_action<T>() to check if current action matches type T
// - Added peek_next_action_type() to look ahead at next action's type
// - Added find_action_by_type<T>() to search for specific action types
//
// RATIONALE:
// Enables compile-time type safety with zero-cost hot potato result chaining,
// eliminating Table storage costs (~200 gas per operation).
// ============================================================================
/// The Executable struct is hot potato constructed from an Intent that has been resolved.
/// It ensures that the actions are executed as intended as it can't be stored.
/// Action index is tracked to ensure each action is executed exactly once.

module account_protocol::executable;

// === Imports ===

use std::type_name::{Self, TypeName};
use account_protocol::intents::{Self, Intent};


// === Structs ===

/// Hot potato ensuring the actions in the intent are executed as intended.
/// Data passing between actions now uses hot potato result types.
public struct Executable<Outcome: store> {
    // intent to return or destroy (if execution_times empty) after execution
    intent: Intent<Outcome>,
    // current action index for sequential processing
    action_idx: u64,
    // No context - data passes through hot potato results
}

// === View functions ===

/// Returns the issuer of the corresponding intent
public fun intent<Outcome: store>(executable: &Executable<Outcome>): &Intent<Outcome> {
    &executable.intent
}

/// Returns the current action index
public fun action_idx<Outcome: store>(executable: &Executable<Outcome>): u64 {
    executable.action_idx
}

// Actions are now stored as BCS bytes in ActionSpec
// The dispatcher must deserialize them when needed

/// Get the type of the current action
public fun current_action_type<Outcome: store>(
    executable: &Executable<Outcome>
): TypeName {
    let specs = executable.intent().action_specs();
    intents::action_spec_type(specs.borrow(executable.action_idx))
}

/// Check if current action matches a specific type
public fun is_current_action<Outcome: store, T: store + drop + copy>(
    executable: &Executable<Outcome>
): bool {
    let current_type = current_action_type(executable);
    current_type == type_name::with_defining_ids<T>()
}

/// Get type of action at specific index
public fun action_type_at<Outcome: store>(
    executable: &Executable<Outcome>,
    idx: u64
): TypeName {
    let specs = executable.intent().action_specs();
    intents::action_spec_type(specs.borrow(idx))
}

/// Increment the action index to mark progress
public fun increment_action_idx<Outcome: store>(
    executable: &mut Executable<Outcome>
) {
    executable.action_idx = executable.action_idx + 1;
}


// === Package functions ===

public(package) fun new<Outcome: store>(
    intent: Intent<Outcome>,
): Executable<Outcome> {
    Executable { intent, action_idx: 0 }
}

public(package) fun destroy<Outcome: store>(executable: Executable<Outcome>): Intent<Outcome> {
    let Executable { intent, .. } = executable;
    intent
}

//**************************************************************************************************//
// Tests                                                                                            //
//**************************************************************************************************//

#[test_only]
use sui::test_utils::{assert_eq, destroy as test_destroy};
#[test_only]
use sui::clock;
#[test_only]
use account_protocol::intents;

#[test_only]
public struct TestOutcome has copy, drop, store {}
#[test_only]
public struct TestAction has store {}
#[test_only]
public struct TestActionType has drop {}
#[test_only]
public struct TestIntentWitness() has drop;

#[test]
fun test_new_executable() {
    let ctx = &mut tx_context::dummy();
    let clock = clock::create_for_testing(ctx);
    
    let params = intents::new_params(
        b"test_key".to_string(),
        b"test_description".to_string(),
        vector[1000],
        2000,
        &clock,
        ctx
    );
    
    let intent = intents::new_intent(
        params,
        TestOutcome {},
        b"test_role".to_string(),
        @0xCAFE,
        TestIntentWitness(),
        ctx
    );
    
    let executable = new(intent);

    assert_eq(action_idx(&executable), 0);
    assert_eq(intent(&executable).key(), b"test_key".to_string());
    
    test_destroy(executable);
    test_destroy(clock);
}

#[test]
fun test_next_action() {
    let ctx = &mut tx_context::dummy();
    let clock = clock::create_for_testing(ctx);
    
    let params = intents::new_params(
        b"test_key".to_string(),
        b"test_description".to_string(),
        vector[1000],
        2000,
        &clock,
        ctx
    );
    
    let mut intent = intents::new_intent(
        params,
        TestOutcome {},
        b"test_role".to_string(),
        @0xCAFE,
        TestIntentWitness(),
        ctx
    );
    
    intents::add_typed_action(&mut intent, TestAction {}, TestActionType {}, TestIntentWitness());
    intents::add_typed_action(&mut intent, TestAction {}, TestActionType {}, TestIntentWitness());
    
    let mut executable = new(intent);
    
    assert_eq(action_idx(&executable), 0);
    
    let _action1: &TestAction = next_action(&mut executable, TestIntentWitness());
    assert_eq(action_idx(&executable), 1);
    
    let _action2: &TestAction = next_action(&mut executable, TestIntentWitness());
    assert_eq(action_idx(&executable), 2);
    
    test_destroy(executable);
    test_destroy(clock);
}

#[test]
fun test_contains_action() {
    let ctx = &mut tx_context::dummy();
    let clock = clock::create_for_testing(ctx);
    
    let params = intents::new_params(
        b"test_key".to_string(),
        b"test_description".to_string(),
        vector[1000],
        2000,
        &clock,
        ctx
    );
    
    let mut intent = intents::new_intent(
        params,
        TestOutcome {},
        b"test_role".to_string(),
        @0xCAFE,
        TestIntentWitness(),
        ctx
    );
    
    intents::add_typed_action(&mut intent, TestAction {}, TestActionType {}, TestIntentWitness());
    
    let mut executable = new(intent);
    
    assert!(contains_action<_, TestAction>(&mut executable));
    
    test_destroy(executable);
    test_destroy(clock);
}

#[test]
fun test_contains_action_empty() {
    let ctx = &mut tx_context::dummy();
    let clock = clock::create_for_testing(ctx);
    
    let params = intents::new_params(
        b"test_key".to_string(),
        b"test_description".to_string(),
        vector[1000],
        2000,
        &clock,
        ctx
    );
    
    let intent = intents::new_intent(
        params,
        TestOutcome {},
        b"test_role".to_string(),
        @0xCAFE,
        TestIntentWitness(),
        ctx
    );
    
    let mut executable = new(intent);
    
    assert!(!contains_action<_, TestAction>(&mut executable));
    
    test_destroy(executable);
    test_destroy(clock);
}

#[test]
fun test_destroy_executable() {
    let ctx = &mut tx_context::dummy();
    let clock = clock::create_for_testing(ctx);
    
    let params = intents::new_params(
        b"test_key".to_string(),
        b"test_description".to_string(),
        vector[1000],
        2000,
        &clock,
        ctx
    );
    
    let intent = intents::new_intent(
        params,
        TestOutcome {},
        b"test_role".to_string(),
        @0xCAFE,
        TestIntentWitness(),
        ctx
    );
    
    let executable = new(intent);
    let recovered_intent = destroy(executable);
    
    assert_eq(recovered_intent.key(), b"test_key".to_string());
    assert_eq(recovered_intent.description(), b"test_description".to_string());
    
    test_destroy(recovered_intent);
    test_destroy(clock);
}

#[test]
fun test_executable_with_multiple_actions() {
    let ctx = &mut tx_context::dummy();
    let clock = clock::create_for_testing(ctx);
    
    let params = intents::new_params(
        b"test_key".to_string(),
        b"test_description".to_string(),
        vector[1000],
        2000,
        &clock,
        ctx
    );
    
    let mut intent = intents::new_intent(
        params,
        TestOutcome {},
        b"test_role".to_string(),
        @0xCAFE,
        TestIntentWitness(),
        ctx
    );
    
    // Add multiple actions
    intents::add_typed_action(&mut intent, TestAction {}, TestActionType {}, TestIntentWitness());
    intents::add_typed_action(&mut intent, TestAction {}, TestActionType {}, TestIntentWitness());
    intents::add_typed_action(&mut intent, TestAction {}, TestActionType {}, TestIntentWitness());
    
    let mut executable = new(intent);
    
    assert_eq(action_idx(&executable), 0);
    assert_eq(intent(&executable).actions().length(), 3);
    
    // Execute all actions
    let _action1: &TestAction = next_action(&mut executable, TestIntentWitness());
    let _action2: &TestAction = next_action(&mut executable, TestIntentWitness());
    let _action3: &TestAction = next_action(&mut executable, TestIntentWitness());
    
    assert_eq(action_idx(&executable), 3);
    
    test_destroy(executable);
    test_destroy(clock);
}

#[test]
fun test_intent_access() {
    let ctx = &mut tx_context::dummy();
    let clock = clock::create_for_testing(ctx);
    
    let params = intents::new_params(
        b"test_key".to_string(),
        b"test_description".to_string(),
        vector[1000],
        2000,
        &clock,
        ctx
    );
    
    let intent = intents::new_intent(
        params,
        TestOutcome {},
        b"test_role".to_string(),
        @0xCAFE,
        TestIntentWitness(),
        ctx
    );
    
    let executable = new(intent);
    let intent_ref = intent(&executable);
    
    assert_eq(intent_ref.key(), b"test_key".to_string());
    assert_eq(intent_ref.description(), b"test_description".to_string());
    assert_eq(intent_ref.account(), @0xCAFE);
    let mut role = @account_protocol.to_string();
    role.append_utf8(b"::executable");
    role.append_utf8(b"::test_role");
    assert_eq(intent_ref.role(), role);
    
    test_destroy(executable);
    test_destroy(clock);
}

/// This module manages the metadata field of Account.
/// It provides the interface to create and get the fields of a Metadata struct.

module account_protocol::metadata;

// === Imports ===

use std::string::String;
use sui::vec_map::{Self, VecMap};

// === Errors ===

const EMetadataNotSameLength: u64 = 0;

// === Structs ===

/// Parent struct protecting the metadata
public struct Metadata has copy, drop, store {
    inner: VecMap<String, String>
}

// === Public functions ===

/// Creates an empty Metadata struct
public fun empty(): Metadata {
    Metadata { inner: vec_map::empty() }
}

/// Creates a new Metadata struct from keys and values.
public fun from_keys_values(keys: vector<String>, values: vector<String>): Metadata {
    assert!(keys.length() == values.length(), EMetadataNotSameLength);
    Metadata {
        inner: vec_map::from_keys_values(keys, values)
    }
}

/// Gets the value for the key.
public fun get(metadata: &Metadata, key: String): String {
    *metadata.inner.get(&key)
}

/// Gets the entry at the index.
public fun get_entry_by_idx(metadata: &Metadata, idx: u64): (String, String) {
    let (key, value) = metadata.inner.get_entry_by_idx(idx);
    (*key, *value)
}

/// Returns the number of entries.
public fun size(metadata: &Metadata): u64 {
    metadata.inner.length()
}

//**************************************************************************************************//
// Tests                                                                                            //
//**************************************************************************************************//

// === Test Helpers ===

#[test_only]
use sui::test_utils::{assert_eq, destroy};

// === Unit Tests ===

#[test]
fun test_empty() {
    let metadata = empty();
    assert_eq(size(&metadata), 0);
    destroy(metadata);
}

#[test]
fun test_from_keys_values() {
    let keys = vector[b"key1".to_string(), b"key2".to_string()];
    let values = vector[b"value1".to_string(), b"value2".to_string()];
    
    let metadata = from_keys_values(keys, values);
    assert_eq(size(&metadata), 2);
    assert_eq(get(&metadata, b"key1".to_string()), b"value1".to_string());
    assert_eq(get(&metadata, b"key2".to_string()), b"value2".to_string());
    
    destroy(metadata);
}

#[test, expected_failure(abort_code = EMetadataNotSameLength)]
fun test_from_keys_values_different_lengths() {
    let keys = vector[b"key1".to_string(), b"key2".to_string()];
    let values = vector[b"value1".to_string()];
    
    let metadata = from_keys_values(keys, values);
    destroy(metadata);
}

#[test]
fun test_get() {
    let keys = vector[b"test_key".to_string()];
    let values = vector[b"test_value".to_string()];
    
    let metadata = from_keys_values(keys, values);
    let value = get(&metadata, b"test_key".to_string());
    assert_eq(value, b"test_value".to_string());
    
    destroy(metadata);
}

#[test]
fun test_get_entry_by_idx() {
    let keys = vector[b"key1".to_string(), b"key2".to_string()];
    let values = vector[b"value1".to_string(), b"value2".to_string()];
    
    let metadata = from_keys_values(keys, values);
    
    let (key1, value1) = get_entry_by_idx(&metadata, 0);
    let (key2, value2) = get_entry_by_idx(&metadata, 1);
    
    assert_eq(key1, b"key1".to_string());
    assert_eq(value1, b"value1".to_string());
    assert_eq(key2, b"key2".to_string());
    assert_eq(value2, b"value2".to_string());
    
    destroy(metadata);
}

#[test]
fun test_size() {
    let metadata = empty();
    assert_eq(size(&metadata), 0);
    
    let keys = vector[b"key1".to_string()];
    let values = vector[b"value1".to_string()];
    let metadata2 = from_keys_values(keys, values);
    assert_eq(size(&metadata2), 1);
    
    destroy(metadata);
    destroy(metadata2);
}

#[test]
fun test_multiple_entries() {
    let keys = vector[b"name".to_string(), b"description".to_string(), b"version".to_string()];
    let values = vector[b"Test Account".to_string(), b"A test account".to_string(), b"1.0".to_string()];
    
    let metadata = from_keys_values(keys, values);
    assert_eq(size(&metadata), 3);
    assert_eq(get(&metadata, b"name".to_string()), b"Test Account".to_string());
    assert_eq(get(&metadata, b"description".to_string()), b"A test account".to_string());
    assert_eq(get(&metadata, b"version".to_string()), b"1.0".to_string());
    
    destroy(metadata);
}// ============================================================================
// FORK MODIFICATION NOTICE - On-Chain Schema System
// ============================================================================
// NEW FILE added to the fork for self-describing actions.
//
// CHANGES IN THIS FORK (2025-01-14):
// - Created ActionDecoderRegistry as global shared object
// - Added HumanReadableField for standardized decoded output
// - Added assert_decoder_exists for mandatory validation
// - Decoders attached as dynamic object fields keyed by TypeName
//
// PURPOSE:
// Provides the foundation for on-chain action decoding, ensuring all actions
// can be transparently decoded and displayed to users before execution.
//
// ARCHITECTURE:
// - ActionDecoderRegistry: Global shared object holding all decoders
// - HumanReadableField: Standard format for decoded field display
// - Decoder objects attached as dynamic fields keyed by TypeName
//
// KEY DESIGN PRINCIPLES:
// - Protocol layer provides structure, application layer provides decoders
// - Mandatory validation at application boundary (entry functions)
// - Clean separation - protocol remains unaware of specific decoders
// - Universal transparency through self-describing actions
// ============================================================================

/// Simple, elegant schema system with active decoder objects
/// Each action module provides its own decoder that knows how to decode its actions
module account_protocol::schema;

// === Imports ===

use std::{string::String, type_name::TypeName};
use sui::{object::{Self, UID}, dynamic_object_field};

// === Structs ===

/// A standard, human-readable representation of a single decoded field
public struct HumanReadableField has drop, store, copy {
    name: String,   // Field name, e.g., "recipient"
    value: String,  // String representation of value, e.g., "0xabc..."
    type_name: String,   // Type description, e.g., "address"
}

/// The registry that holds all decoder objects
/// Decoders are attached as dynamic object fields keyed by TypeName
public struct ActionDecoderRegistry has key, store {
    id: UID,
}

// === Public Functions ===

/// Initialize an empty decoder registry
public fun init_registry(ctx: &mut TxContext): ActionDecoderRegistry {
    ActionDecoderRegistry {
        id: object::new(ctx),
    }
}

/// Create a human-readable field
public fun new_field(
    name: String,
    value: String,
    type_name: String,
): HumanReadableField {
    HumanReadableField { name, value, type_name }
}

// === View Functions ===

/// Get the registry's ID (immutable reference)
public fun registry_id(registry: &ActionDecoderRegistry): &UID {
    &registry.id
}

/// Get the registry's ID (mutable reference for adding decoders)
public fun registry_id_mut(registry: &mut ActionDecoderRegistry): &mut UID {
    &mut registry.id
}

/// Get field name
public fun field_name(field: &HumanReadableField): &String {
    &field.name
}

/// Get field value
public fun field_value(field: &HumanReadableField): &String {
    &field.value
}

/// Get field type
public fun field_type(field: &HumanReadableField): &String {
    &field.type_name
}

/// Check if a decoder exists for the given action type in the registry
public fun has_decoder(
    registry: &ActionDecoderRegistry,
    action_type: TypeName,
): bool {
    dynamic_object_field::exists_(registry_id(registry), action_type)
}

/// Assert that a decoder exists for the given action type
/// Aborts with EDecoderNotFound if the decoder is not registered
public fun assert_decoder_exists(
    registry: &ActionDecoderRegistry,
    action_type: TypeName,
) {
    assert!(has_decoder(registry, action_type), EDecoderNotFound);
}

// === Errors ===
const EDecoderNotFound: u64 = 1;/// Decoder validation helper module
/// Provides functions to check if decoders exist for action types
module account_protocol::decoder_validation;

// === Imports ===

use std::type_name::TypeName;
use account_protocol::schema;

// === Public Functions ===

/// Check if a decoder exists for the given action type in the registry
/// This is a wrapper around schema::has_decoder for convenience
public fun has_decoder(
    registry: &schema::ActionDecoderRegistry,
    action_type: TypeName,
): bool {
    schema::has_decoder(registry, action_type)
}

/// Validate that a decoder exists, aborting if not found
/// Use this when you want to enforce decoder existence
public fun assert_decoder_exists(
    registry: &schema::ActionDecoderRegistry,
    action_type: TypeName,
) {
    assert!(
        has_decoder(registry, action_type),
        EDecoderNotFound
    );
}

// === Errors ===

const EDecoderNotFound: u64 = 0;/// This module tracks the version of the package by implementing the version_witness type.
/// A new version type should be defined for each new version of the package.

module account_protocol::version;

// === Imports ===

use account_protocol::version_witness::{Self, VersionWitness};

// === Constants ===

const VERSION: u64 = 1; // bump this when the package is upgraded

// === Structs ===

// define a new version struct for each new version of the package
public struct V1() has drop;

public(package) fun current(): VersionWitness {
    version_witness::new(V1()) // modify with the new version struct
}

// === Public functions ===

public fun get(): u64 {
    VERSION
}

// === Test functions ===

#[test_only]
public struct Witness() has drop;

#[test_only]
public fun witness(): Witness {
    Witness()
}

#[test]
public fun test_get() {
    assert!(get() == 1, 1);
}// ============================================================================
// FORK MODIFICATION NOTICE - Owned Objects with Serialize-Then-Destroy Pattern
// ============================================================================
// This module manages withdrawal and transfer of owned objects from Account.
//
// CHANGES IN THIS FORK:
// - REMOVED: ALL pessimistic locking logic from original implementation
// - Multiple proposals can now reference the same objects
// - First-to-execute wins, others fail naturally via blockchain ownership
// - Implemented serialize-then-destroy pattern for WithdrawAction
// - Added destroy_withdraw_action function for explicit destruction
// - Actions serialize to bytes before adding to intent via add_typed_action()
// - OwnedWithdraw action uses type marker from framework_action_types
// - Compile-time type safety replaces string-based descriptors
//
// RATIONALE:
// Eliminates ~100 lines of locking code and removes the critical footgun
// where objects could become permanently locked from incomplete cleanup.
// ============================================================================
// where objects could be permanently locked if cleanup wasn't performed 
// correctly. The system is now simpler, safer, and more suitable for DAOs.
// ============================================================================

/// This module allows objects owned by the account to be accessed through intents in a secure way.
/// The objects can be taken only via an WithdrawAction action which uses Transfer to Object (TTO).
/// This action can't be proposed directly since it wouldn't make sense to withdraw an object without using it.

module account_protocol::owned;

// === Imports ===


use sui::{
    coin::{Self, Coin},
    transfer::Receiving,
    bcs::{Self, BCS}
};

use account_protocol::{
    action_validation,
    account::{Self, Account, Auth},
    intents::{Self, Expired, Intent},
    executable::Executable,
};
use account_extensions::framework_action_types;

use fun account_protocol::intents::add_typed_action as Intent.add_typed_action;

// === Errors ===

const EWrongObject: u64 = 0;
// REMOVED: EObjectLocked - no locking in new design

// === Structs ===

/// Action guarding access to account owned objects which can only be received via this action
public struct WithdrawAction has drop, store {
    // the owned object we want to access
    object_id: ID,
}

// === Destruction Functions ===

/// Destroy a WithdrawAction after serialization
public fun destroy_withdraw_action(action: WithdrawAction) {
    let WithdrawAction { object_id: _ } = action;
}

// === Public functions ===

/// Creates a new WithdrawAction and add it to an intent
public fun new_withdraw<Config, Outcome, IW: drop>(
    intent: &mut Intent<Outcome>, 
    account: &Account<Config>,
    object_id: ID,
    intent_witness: IW,
) {
    intent.assert_is_account(account.addr());
    // No validation needed - conflicts are natural in DAO governance

    // Create the action struct
    let action = WithdrawAction { object_id };

    // Serialize it
    let action_data = bcs::to_bytes(&action);

    // Add to intent with pre-serialized bytes
    intent.add_typed_action(
        framework_action_types::owned_withdraw(),
        action_data,
        intent_witness
    );

    // Explicitly destroy the action struct
    destroy_withdraw_action(action);
}

/// Executes a WithdrawAction and returns the object
public fun do_withdraw<Config, Outcome: store, T: key + store, IW: drop>(
    executable: &mut Executable<Outcome>,
    account: &mut Account<Config>,
    receiving: Receiving<T>,
    intent_witness: IW,
): T {
    executable.intent().assert_is_account(account.addr());

    // Get BCS bytes from ActionSpec
    let specs = executable.intent().action_specs();
    let spec = specs.borrow(executable.action_idx());

    // CRITICAL: Assert that the action type is what we expect
    action_validation::assert_action_type<framework_action_types::OwnedWithdraw>(spec);


    let action_data = intents::action_spec_data(spec);

    // Create BCS reader and deserialize
    let mut reader = bcs::new(*action_data);
    let object_id = object::id_from_bytes(bcs::peel_vec_u8(&mut reader));

    assert!(receiving.receiving_object_id() == object_id, EWrongObject);

    // Receive the object and increment action index
    let obj = account::receive(account, receiving);
    account_protocol::executable::increment_action_idx(executable);

    obj
}

/// Deletes a WithdrawAction from an expired intent
/// Note: No unlocking needed since we now only lock during execution
public fun delete_withdraw<Config>(expired: &mut Expired, account: &Account<Config>) {
    expired.assert_is_account(account.addr());

    let spec = intents::remove_action_spec(expired);
    let action_data = intents::action_spec_data(&spec);
    let mut reader = bcs::new(*action_data);

    // We don't need the value, but we must peel it to consume the bytes
    let WithdrawAction { object_id: _ } = WithdrawAction {
        object_id: object::id_from_bytes(bcs::peel_vec_u8(&mut reader))
    };
    // No unlock needed - objects are only locked during execution, not during intent creation
}

// Coin operations

/// Authorized addresses can merge and split coins.
/// Returns the IDs to use in a following intent, conserves the order.
public fun merge_and_split<Config, CoinType>(
    auth: Auth, 
    account: &mut Account<Config>, 
    to_merge: vector<Receiving<Coin<CoinType>>>, // there can be only one coin if we just want to split
    to_split: vector<u64>, // there can be no amount if we just want to merge
    ctx: &mut TxContext
): vector<ID> { 
    account.verify(auth);
    // receive all coins
    let mut coins = vector::empty();
    to_merge.do!(|item| {
        let coin = account::receive(account, item);
        coins.push_back(coin);
    });

    let coin = merge(account, coins, ctx);
    let ids = split(account, coin, to_split, ctx);

    ids
}

fun merge<Config, CoinType>(
    account: &Account<Config>,
    coins: vector<Coin<CoinType>>,
    ctx: &mut TxContext
): Coin<CoinType> {
    let mut merged = coin::zero<CoinType>(ctx);
    coins.do!(|coin| {
        // No lock check needed - conflicts are natural
        merged.join(coin);
    });

    merged
}

fun split<Config, CoinType>(
    account: &mut Account<Config>, 
    mut coin: Coin<CoinType>,
    amounts: vector<u64>, 
    ctx: &mut TxContext
): vector<ID> {
    // No lock check needed - conflicts are natural
    let ids = amounts.map!(|amount| {
        let split = coin.split(amount, ctx);
        let id = object::id(&split);
        account.keep(split, ctx);
        id
    });
    account.keep(coin, ctx);

    ids
}
// ============================================================================
// FORK MODIFICATION NOTICE - Config with Serialize-Then-Destroy Pattern
// ============================================================================
// This module manages Account settings and configuration updates.
//
// CHANGES IN THIS FORK:
// - Config actions use type markers: ConfigUpdateDeps, ConfigToggleUnverified,
//   ConfigUpdateDeposits, ConfigManageWhitelist
// - Implemented serialize-then-destroy pattern for all 4 action types
// - Added destruction functions for explicit resource management
// - Actions serialize to bytes before adding to intent via add_typed_action()
// - Better separation between config, deps, and metadata updates
// - Type-safe action validation through compile-time TypeName comparison
//
// RATIONALE:
// Ensures DAOs can safely update configuration without risking inconsistent
// states during multi-step governance processes.
// ============================================================================

/// This module allows to manage Account settings.
/// The actions are related to the modifications of all the fields of the Account (except Intents and Config).
/// All these fields are encapsulated in the `Account` struct and each managed in their own module.
/// They are only accessible mutably via package functions defined in account.move which are used here only.
/// 
/// Dependencies are all the packages and their versions that the account can call (including this one).
/// The allowed dependencies are defined in the `Extensions` struct and are maintained by account.tech team.
/// Optionally, any package can be added to the account if unverified_allowed is true.
/// 
/// Accounts can choose to use any version of any package and must explicitly migrate to the new version.
/// This is closer to a trustless model preventing anyone with the UpgradeCap from updating the dependencies maliciously.

module account_protocol::config;

// === Imports ===

use std::{string::{Self, String}, option::Option, type_name::{Self, TypeName}};
use sui::bcs::{Self, BCS};
use sui::{vec_set::{Self, VecSet}, event};
use account_protocol::{
    account::{Self, Account, Auth},
    intents::{Intent, Expired, Params},
    executable::Executable,
    deps::{Self, Dep},
    metadata,
    version,
    intent_interface,
};
use account_extensions::extensions::Extensions;
use account_extensions::framework_action_types::{Self, ConfigUpdateDeps, ConfigUpdateMetadata};

use fun account_protocol::intents::add_typed_action as Intent.add_typed_action;

// === Aliases ===

use fun intent_interface::build_intent as Account.build_intent;
use fun intent_interface::process_intent as Account.process_intent;

// === Structs ===

/// Intent Witness
public struct ConfigDepsIntent() has drop;
/// Intent Witness
public struct ToggleUnverifiedAllowedIntent() has drop;
/// Intent Witness for deposit configuration
public struct ConfigureDepositsIntent() has drop;
/// Intent Witness for whitelist management
public struct ManageWhitelistIntent() has drop;

/// Action struct wrapping the deps account field into an action
public struct ConfigDepsAction has drop, store {
    deps: vector<Dep>,
}
/// Action struct wrapping the unverified_allowed account field into an action
public struct ToggleUnverifiedAllowedAction has drop, store {}
/// Action to configure object deposit settings
public struct ConfigureDepositsAction has drop, store {
    enable: bool,
    new_max: Option<u128>,
    reset_counter: bool,
}
/// Action to manage type whitelist for deposits
public struct ManageWhitelistAction has drop, store {
    add_types: vector<String>,
    remove_types: vector<String>,
}

// === Helper Functions for BCS Deserialization ===

/// Helper to deserialize deps data as three vectors
fun peel_deps_as_vectors(reader: &mut BCS): (vector<String>, vector<address>, vector<u64>) {
    let len = bcs::peel_vec_length(reader);
    let mut names = vector::empty();
    let mut addrs = vector::empty();
    let mut versions = vector::empty();
    let mut i = 0;
    while (i < len) {
        // Each Dep has: name (String), addr (address), version (u64)
        names.push_back(string::utf8(bcs::peel_vec_u8(reader)));
        addrs.push_back(bcs::peel_address(reader));
        versions.push_back(bcs::peel_u64(reader));
        i = i + 1;
    };
    (names, addrs, versions)
}

// === Destruction Functions ===

/// Destroy a ConfigDepsAction after serialization
public fun destroy_config_deps_action(action: ConfigDepsAction) {
    let ConfigDepsAction { deps: _ } = action;
}

/// Destroy a ToggleUnverifiedAllowedAction after serialization
public fun destroy_toggle_unverified_action(action: ToggleUnverifiedAllowedAction) {
    let ToggleUnverifiedAllowedAction {} = action;
}

/// Destroy a ConfigureDepositsAction after serialization
public fun destroy_configure_deposits_action(action: ConfigureDepositsAction) {
    let ConfigureDepositsAction { enable: _, new_max: _, reset_counter: _ } = action;
}

/// Destroy a ManageWhitelistAction after serialization
public fun destroy_manage_whitelist_action(action: ManageWhitelistAction) {
    let ManageWhitelistAction { add_types: _, remove_types: _ } = action;
}

/// Helper to deserialize vector<String>
fun peel_vector_string(reader: &mut BCS): vector<String> {
    let len = bcs::peel_vec_length(reader);
    let mut i = 0;
    let mut vec = vector::empty();
    while (i < len) {
        vec.push_back(string::utf8(bcs::peel_vec_u8(reader)));
        i = i + 1;
    };
    vec
}

// === Public functions ===

/// Authorized addresses can configure object deposit settings directly
public fun configure_deposits<Config>(
    auth: Auth,
    account: &mut Account<Config>,
    enable: bool,
    new_max: Option<u128>,
    reset_counter: bool,
) {
    account.verify(auth);
    // Apply the configuration using the helper function
    account.apply_deposit_config(enable, new_max, reset_counter);
}

/// Authorized addresses can edit the metadata of the account
public fun edit_metadata<Config>(
    auth: Auth,
    account: &mut Account<Config>,
    keys: vector<String>,
    values: vector<String>,
) {
    account.verify(auth);
    *account::metadata_mut(account, version::current()) = metadata::from_keys_values(keys, values);
}

/// Authorized addresses can update the existing dependencies of the account to the latest versions
public fun update_extensions_to_latest<Config>(
    auth: Auth,
    account: &mut Account<Config>,
    extensions: &Extensions,
) {
    account.verify(auth);

    let mut i = 0;
    let mut new_names = vector<String>[];
    let mut new_addrs = vector<address>[];
    let mut new_versions = vector<u64>[];

    while (i < account.deps().length()) {
        let dep = account.deps().get_by_idx(i);
        if (extensions.is_extension(dep.name(), dep.addr(), dep.version())) {
            let (addr, version) = extensions.get_latest_for_name(dep.name());
            new_names.push_back(dep.name());
            new_addrs.push_back(addr);
            new_versions.push_back(version);
        } else {
            // else cannot automatically update to latest version so add as is
            new_names.push_back(dep.name());
            new_addrs.push_back(dep.addr());
            new_versions.push_back(dep.version());
        };
        i = i + 1;
    };

    *account::deps_mut(account, version::current()) = 
        deps::new_inner(extensions, account.deps(), new_names, new_addrs, new_versions);
}

/// Creates an intent to update the dependencies of the account
public fun request_config_deps<Config, Outcome: store>(
    auth: Auth,
    account: &mut Account<Config>, 
    params: Params,
    outcome: Outcome,
    extensions: &Extensions,
    names: vector<String>,
    addresses: vector<address>,
    versions: vector<u64>,
    ctx: &mut TxContext
) {
    account.verify(auth);
    params.assert_single_execution();
    
    let mut deps = deps::new_inner(extensions, account.deps(), names, addresses, versions);
    let deps_inner = *deps.inner_mut();

    account.build_intent!(
        params,
        outcome, 
        b"".to_string(),
        version::current(),
        ConfigDepsIntent(),   
        ctx,
        |intent, iw| {
            // Create the action struct
            let action = ConfigDepsAction { deps: deps_inner };

            // Serialize it
            let action_data = bcs::to_bytes(&action);

            // Add to intent with pre-serialized bytes
            intent.add_typed_action(
                framework_action_types::config_update_deps(),
                action_data,
                iw
            );

            // Explicitly destroy the action struct
            destroy_config_deps_action(action);
        },
    );
}

/// Executes an intent updating the dependencies of the account
public fun execute_config_deps<Config, Outcome: store>(
    executable: &mut Executable<Outcome>,
    account: &mut Account<Config>,  
) {
    account.process_intent!(
        executable, 
        version::current(),   
        ConfigDepsIntent(), 
        |executable, _iw| {
            // Get BCS bytes from ActionSpec
            let specs = executable.intent().action_specs();
            let spec = specs.borrow(executable.action_idx());
            let action_data = account_protocol::intents::action_spec_data(spec);

            // Create BCS reader and deserialize
            let mut reader = bcs::new(*action_data);
            let (_names, _addrs, _versions) = peel_deps_as_vectors(&mut reader);

            // Apply the action - reconstruct deps using the public constructor
            // Note: We need the Extensions object which should be available
            // For now, comment out as we need to pass Extensions
            // *account::deps_mut(account, version::current()) =
            //     deps::new_inner(extensions, account.deps(), names, addrs, versions);
            account_protocol::executable::increment_action_idx(executable);
        }
    ); 
} 

/// Deletes the ConfigDepsAction from an expired intent
public fun delete_config_deps(expired: &mut Expired) {
    let spec = expired.remove_action_spec();
    let action_data = account_protocol::intents::action_spec_data(&spec);
    let mut reader = bcs::new(*action_data);

    // We don't need the values, but we must peel them to consume the bytes
    let (names, addrs, versions) = peel_deps_as_vectors(&mut reader);
    // Just consume the data without creating the struct
    let _ = names;
    let _ = addrs;
    let _ = versions;
}

/// Creates an intent to toggle the unverified_allowed flag of the account
public fun request_toggle_unverified_allowed<Config, Outcome: store>(
    auth: Auth,
    account: &mut Account<Config>, 
    params: Params,
    outcome: Outcome,
    ctx: &mut TxContext
) {
    account.verify(auth);
    params.assert_single_execution();
    
    account.build_intent!(
        params,
        outcome,
        b"".to_string(),
        version::current(),
        ToggleUnverifiedAllowedIntent(),
        ctx,
        |intent, iw| {
            // Create the action struct
            let action = ToggleUnverifiedAllowedAction {};

            // Serialize it
            let action_data = bcs::to_bytes(&action);

            // Add to intent with pre-serialized bytes
            intent.add_typed_action(
                framework_action_types::config_toggle_unverified(),
                action_data,
                iw
            );

            // Explicitly destroy the action struct
            destroy_toggle_unverified_action(action);
        },
    );
}

/// Executes an intent toggling the unverified_allowed flag of the account
public fun execute_toggle_unverified_allowed<Config, Outcome: store>(
    executable: &mut Executable<Outcome>,
    account: &mut Account<Config>, 
) {
    account.process_intent!(
        executable, 
        version::current(),
        ToggleUnverifiedAllowedIntent(),
        |executable, _iw| {
            // ToggleUnverifiedAllowedAction is an empty struct, no deserialization needed
            // Just increment the action index
            account::deps_mut(account, version::current()).toggle_unverified_allowed();
            account_protocol::executable::increment_action_idx(executable);
        },
    );    
}

/// Deletes the ToggleUnverifiedAllowedAction from an expired intent
public fun delete_toggle_unverified_allowed(expired: &mut Expired) {
    let spec = expired.remove_action_spec();
    // ToggleUnverifiedAllowedAction is an empty struct, no deserialization needed
    let ToggleUnverifiedAllowedAction {} = ToggleUnverifiedAllowedAction {};
}

/// Creates an intent to configure object deposit settings
public fun request_configure_deposits<Config, Outcome: store>(
    auth: Auth,
    account: &mut Account<Config>,
    outcome: Outcome,
    params: Params,
    enable: bool,
    new_max: Option<u128>,
    reset_counter: bool,
    ctx: &mut TxContext,
) {
    account.verify(auth);
    account.build_intent!(
        params,
        outcome,
        b"ConfigureDepositsIntent".to_string(),
        version::current(),
        ConfigureDepositsIntent(),
        ctx,
        |intent, iw| {
            // Create the action struct
            let action = ConfigureDepositsAction { enable, new_max, reset_counter };

            // Serialize it
            let action_data = bcs::to_bytes(&action);

            // Add to intent with pre-serialized bytes
            intent.add_typed_action(
                framework_action_types::config_update_deposits(),
                action_data,
                iw
            );

            // Explicitly destroy the action struct
            destroy_configure_deposits_action(action);
        },
    );
}

/// Executes an intent to configure object deposit settings
public fun execute_configure_deposits<Config, Outcome: store>(
    executable: &mut Executable<Outcome>,
    account: &mut Account<Config>,
) {
    account.process_intent!(
        executable,
        version::current(),
        ConfigureDepositsIntent(),
        |executable, _iw| {
            // Get BCS bytes from ActionSpec
            let specs = executable.intent().action_specs();
            let spec = specs.borrow(executable.action_idx());
            let action_data = account_protocol::intents::action_spec_data(spec);

            // Create BCS reader and deserialize
            let mut reader = bcs::new(*action_data);
            let enable = bcs::peel_bool(&mut reader);
            let new_max = bcs::peel_option_u128(&mut reader);
            let reset_counter = bcs::peel_bool(&mut reader);

            // Apply the action
            account.apply_deposit_config(enable, new_max, reset_counter);
            account_protocol::executable::increment_action_idx(executable);
        },
    );
}

/// Deletes the ConfigureDepositsAction from an expired intent
public fun delete_configure_deposits(expired: &mut Expired) {
    let spec = expired.remove_action_spec();
    let action_data = account_protocol::intents::action_spec_data(&spec);
    let mut reader = bcs::new(*action_data);

    // We don't need the values, but we must peel them to consume the bytes
    let ConfigureDepositsAction { enable: _, new_max: _, reset_counter: _ } = ConfigureDepositsAction {
        enable: bcs::peel_bool(&mut reader),
        new_max: bcs::peel_option_u128(&mut reader),
        reset_counter: bcs::peel_bool(&mut reader)
    };
}

/// Creates an intent to manage type whitelist
public fun request_manage_whitelist<Config, Outcome: store>(
    auth: Auth,
    account: &mut Account<Config>,
    outcome: Outcome,
    params: Params,
    add_types: vector<String>,
    remove_types: vector<String>,
    ctx: &mut TxContext,
) {
    account.verify(auth);
    account.build_intent!(
        params,
        outcome,
        b"ManageWhitelistIntent".to_string(),
        version::current(),
        ManageWhitelistIntent(),
        ctx,
        |intent, iw| {
            // Create the action struct
            let action = ManageWhitelistAction { add_types, remove_types };

            // Serialize it
            let action_data = bcs::to_bytes(&action);

            // Add to intent with pre-serialized bytes
            intent.add_typed_action(
                framework_action_types::config_manage_whitelist(),
                action_data,
                iw
            );

            // Explicitly destroy the action struct
            destroy_manage_whitelist_action(action);
        },
    );
}

/// Executes an intent to manage type whitelist
public fun execute_manage_whitelist<Config, Outcome: store>(
    executable: &mut Executable<Outcome>,
    account: &mut Account<Config>,
) {
    account.process_intent!(
        executable,
        version::current(),
        ManageWhitelistIntent(),
        |executable, _iw| {
            // Get BCS bytes from ActionSpec
            let specs = executable.intent().action_specs();
            let spec = specs.borrow(executable.action_idx());
            let action_data = account_protocol::intents::action_spec_data(spec);

            // Create BCS reader and deserialize
            let mut reader = bcs::new(*action_data);
            let add_types = peel_vector_string(&mut reader);
            let remove_types = peel_vector_string(&mut reader);

            // Apply the action
            account.apply_whitelist_changes(&add_types, &remove_types);
            account_protocol::executable::increment_action_idx(executable);
        },
    );
}

/// Deletes the ManageWhitelistAction from an expired intent
public fun delete_manage_whitelist(expired: &mut Expired) {
    let spec = expired.remove_action_spec();
    let action_data = account_protocol::intents::action_spec_data(&spec);
    let mut reader = bcs::new(*action_data);

    // We don't need the values, but we must peel them to consume the bytes
    let ManageWhitelistAction { add_types: _, remove_types: _ } = ManageWhitelistAction {
        add_types: peel_vector_string(&mut reader),
        remove_types: peel_vector_string(&mut reader)
    };
}

/// [Intent Interface] - Functions to create intents and add actions to them.
///
/// 1. Build an intent by stacking actions into it.
/// 2. Process an intent by executing the actions sequentially.

module account_protocol::intent_interface;

// === Imports ===

use std::string::String;
use account_protocol::{
    account::{Self, Account},
    intents::{Intent, Params},
    version_witness::VersionWitness,
    executable::Executable,
};

// === Public functions ===

/// Example implementation:
/// 
/// ```move
/// 
/// public fun request_intent_name<Config, Outcome: store>(
///     auth: Auth,
///     account: &mut Account<Config>, 
///     params: Params,
///     outcome: Outcome,
///     action1: Action1,
///     action2: Action2,
///     ctx: &mut TxContext
/// ) {
///     account.verify(auth);
///     params.assert_single_execution(); // if not a recurring intent
/// 
///     account.build_intent!(
///         params,
///         outcome, 
///         b"".to_string(),
///         version::current(),
///         IntentWitness(),   
///         ctx,
///         |intent, iw| {
///             intent.add_action(action1, iw);
///             intent.add_action(action2, iw);
///         }
///     );
/// }
/// 
/// ```

/// Creates an intent with actions and adds it to the account.
public macro fun build_intent<$Config, $Outcome, $IW: drop>(
    $account: &mut Account<$Config>,
    $params: Params,
    $outcome: $Outcome,
    $managed_name: String,
    $version_witness: VersionWitness,
    $intent_witness: $IW,
    $ctx: &mut TxContext,
    $new_actions: |&mut Intent<$Outcome>, $IW|,
) {
    let mut intent = account::create_intent(
        $account,
        $params,
        $outcome,
        $managed_name,
        $version_witness, 
        $intent_witness,
        $ctx 
    );

    $new_actions(&mut intent, $intent_witness);

    account::insert_intent($account, intent, $version_witness, $intent_witness);
}

/// Example implementation:
/// 
/// ```move
/// 
/// public fun execute_intent_name<Config, Outcome: store>(
///     executable: &mut Executable<Outcome>,
///     account: &mut Account<Config>,  
/// ) {
///     account.process_intent!(
///         executable, 
///         version::current(),   
///         ConfigDepsIntent(), 
///         |executable, iw| {
///             do_action(executable, iw, <ADDITIONAL_ARG>)
///             do_other_action(executable, iw)
///         }
///     ); 
/// } 
/// 
/// ```

/// Executes the actions from the executable intent.
public macro fun process_intent<$Config, $Outcome: store, $IW: drop>(
    $account: &Account<$Config>, 
    $executable: &mut Executable<$Outcome>,
    $version_witness: VersionWitness,
    $intent_witness: $IW,
    $do_actions: |&mut Executable<$Outcome>, $IW| -> _
): _ {
    let account = $account;
    let executable = $executable;
    // let version_witness = $version_witness;
    // let intent_witness = $intent_witness;
    // ensures the package address is a dependency for this account
    account.deps().check($version_witness);
    // ensures the right account is passed
    executable.intent().assert_is_account(account.addr());
    // ensures the intent is created by the same package that creates the action
    executable.intent().assert_is_witness($intent_witness);

    $do_actions(executable, $intent_witness)
}// ============================================================================
// FORK MODIFICATION NOTICE - Enhanced Account Interface
// ============================================================================
// High-level functions to create Account "methods" with specific configs.
//
// CHANGES IN THIS FORK:
// - Enhanced interface to support typed Intent system
// - Integration with new BCS-based action validation
// - Support for hot potato pattern with Executable
// - Improved type safety through compile-time checks
// ============================================================================
/// [Account Interface] - High level functions to create required "methods" for the account.
///
/// 1. Define a new Account type with a specific config and default dependencies.
/// 2. Define a mechanism to authenticate an address to grant permission to call certain functions.
/// 3. Define a way to modify the outcome of an intent.
/// 4. Define an `Outcome.validate()` that will be called upon intent execution.

module account_protocol::account_interface;

// === Imports ===

use std::string::String;
use sui::clock::Clock;
use account_protocol::{
    account::{Self, Account, Auth},
    deps::Deps,
    version_witness::VersionWitness,
    executable::Executable,
};

// === Public functions ===

/// Example implementation:
/// 
/// ```move
/// 
/// public struct Witness() has drop;
///
/// public fun new_account(
///     extensions: &Extensions,
///     ctx: &mut TxContext,
/// ): Account<Config> {
///     fees.process(coin);
/// 
///     let config = Config {
///        .. <FIELDS>
///     };
/// 
///     create_account!(
///        config, 
///        version::current(), 
///        Witness(), 
///        ctx, 
///        || deps::new_latest_extensions(extensions, vector[b"AccountProtocol".to_string(), b"MyConfig".to_string()])
///     )
/// }
/// 
/// ```

/// Returns a new Account object with a specific config and initialize dependencies.
public macro fun create_account<$Config, $CW: drop>(
    $config: $Config,
    $version_witness: VersionWitness,
    $config_witness: $CW,
    $ctx: &mut TxContext,
    $init_deps: || -> Deps,
): Account<$Config> {
    let deps = $init_deps();
    account::new<$Config, $CW>($config, deps, $version_witness, $config_witness, $ctx)
}

/// Example implementation:
/// 
/// ```move
/// 
/// public fun authenticate(
///     account: &Account<Multisig, Approvals>,
///     ctx: &TxContext
/// ): Auth {
///     authenticate!(
///        account, 
///        version::current(), 
///        Witness(), 
///        || account.config().assert_is_member(ctx)
///     )
/// }
/// 
/// ```

/// Returns an Auth if the conditions passed are met (used to create intents and more).
public macro fun create_auth<$Config, $CW: drop>(
    $account: &Account<$Config>,
    $version_witness: VersionWitness,
    $config_witness: $CW,
    $grant_permission: ||, // condition to grant permission, must throw if not met
): Auth {
    let account = $account;

    $grant_permission();
    
    account.new_auth($version_witness, $config_witness)
}

/// Example implementation:
/// 
/// ```move
/// 
/// public fun approve_intent<Config>(
///     account: &mut Account<Config>, 
///     key: String,
///     ctx: &TxContext
/// ) {
///     <PREPARE_DATA>
///     
///     resolve_intent!(
///         account, 
///         key, 
///         version::current(), 
///         Witness(), 
///         |outcome_mut| {
///             <DO_SOMETHING>
///         }
///     );
/// }
/// 
/// ```

/// Modifies the outcome of an intent.
public macro fun resolve_intent<$Config, $Outcome, $CW: drop>(
    $account: &mut Account<$Config>,
    $key: String,
    $version_witness: VersionWitness,
    $config_witness: $CW,
    $modify_outcome: |&mut $Outcome|,
) {
    let account = $account;

    let outcome_mut = account
        .intents_mut($version_witness, $config_witness)
        .get_mut($key)
        .outcome_mut<$Outcome>();

    $modify_outcome(outcome_mut);
}

/// Example implementation:
/// 
/// IMPORTANT: You must provide an Outcome.validate() function that will be called automatically.
/// It must take the outcome by value, a reference to the Config and the role of the intent even if not used.
/// 
/// ```move
/// 
/// public fun execute_intent(
///     account: &mut Account<Config>, 
///     key: String, 
///     clock: &Clock,
/// ): Executable<Outcome> {
///     execute_intent!<_, Outcome, _>(account, key, clock, version::current(), Witness())
/// }
/// 
/// fun validate_outcome(
///     outcome: Outcome, 
///     config: &Config,
///     role: String,
/// ) {
///     let Outcome { fields, .. } = outcome;
/// 
///     assert!(<CHECK_CONDITIONS>);
/// }
/// 
/// ``` 

/// Validates the outcome of an intent and returns an executable.
public macro fun execute_intent<$Config, $Outcome, $CW: drop>(
    $account: &mut Account<$Config>,
    $key: String,
    $clock: &Clock,
    $version_witness: VersionWitness,
    $config_witness: $CW,
    $ctx: &mut TxContext,
    $validate_outcome: |$Outcome|,
): Executable<$Outcome> {
    let (outcome, executable) = account::create_executable<_, $Outcome, _>(
        $account, $key, $clock, $version_witness, $config_witness, $ctx
    );

    $validate_outcome(outcome);

    executable
}/// This module tracks the version of the package by implementing the version_witness type.
/// A new version type should be defined for each new version of the package.

module account_actions::version;

// === Imports ===

use account_protocol::version_witness::{Self, VersionWitness};

// === Constants ===

const VERSION: u64 = 1; // bump this when the package is upgraded

// === Structs ===

// define a new version struct for each new version of the package
public struct V1() has drop;

public fun current(): VersionWitness {
    version_witness::new(V1()) // modify with the new version struct
}

// === Public functions ===

public fun get(): u64 {
    VERSION
}
// ============================================================================
// FORK ADDITION - Currency Action Decoder
// ============================================================================
// NEW FILE added to the fork for on-chain action decoding.
//
// PURPOSE:
// Provides human-readable decoding of currency actions (minting, burning,
// metadata updates) for transparency. Part of the mandatory decoder system
// that ensures all actions can be decoded and displayed to users.
//
// IMPLEMENTATION:
// - Handles MintAction, BurnAction, UpdateAction, DisableAction
// - Complex Option<T> handling for metadata fields
// - Uses BCS deserialization with peel_* functions and macros
// - Security validation via validate_all_bytes_consumed()
// ============================================================================

/// Decoder for currency actions - tightly coupled with currency action definitions
module account_actions::currency_decoder;

// === Imports ===

use std::{string::String, type_name, ascii};
use sui::{object::{Self, UID}, dynamic_object_field, bcs};
use account_protocol::bcs_validation;
use account_protocol::schema::{Self, ActionDecoderRegistry, HumanReadableField};
use account_actions::currency::{MintAction, BurnAction, DisableAction, UpdateAction};

// === Decoder Objects ===

/// Decoder for MintAction<CoinType>
public struct MintActionDecoder has key, store {
    id: UID,
}

/// Decoder for BurnAction<CoinType>
public struct BurnActionDecoder has key, store {
    id: UID,
}

/// Decoder for DisableAction<CoinType>
public struct DisableActionDecoder has key, store {
    id: UID,
}

/// Decoder for UpdateAction<CoinType>
public struct UpdateActionDecoder has key, store {
    id: UID,
}

/// Placeholder for generic registration
public struct CoinPlaceholder has drop, store {}

// === Decoder Functions ===

/// Decode a MintAction
public fun decode_mint_action<CoinType>(
    _decoder: &MintActionDecoder,
    action_data: vector<u8>,
): vector<HumanReadableField> {
    let mut bcs_data = bcs::new(action_data);
    let amount = bcs::peel_u64(&mut bcs_data);

    // Security: ensure all bytes are consumed to prevent trailing data attacks
    bcs_validation::validate_all_bytes_consumed(bcs_data);

    vector[
        schema::new_field(
            b"amount".to_string(),
            amount.to_string(),
            b"u64".to_string(),
        )
    ]
}

/// Decode a BurnAction
public fun decode_burn_action<CoinType>(
    _decoder: &BurnActionDecoder,
    action_data: vector<u8>,
): vector<HumanReadableField> {
    let mut bcs_data = bcs::new(action_data);
    let amount = bcs::peel_u64(&mut bcs_data);

    // Security: ensure all bytes are consumed to prevent trailing data attacks
    bcs_validation::validate_all_bytes_consumed(bcs_data);

    vector[
        schema::new_field(
            b"amount".to_string(),
            amount.to_string(),
            b"u64".to_string(),
        )
    ]
}

/// Decode a DisableAction
public fun decode_disable_action<CoinType>(
    _decoder: &DisableActionDecoder,
    action_data: vector<u8>,
): vector<HumanReadableField> {
    let mut bcs_data = bcs::new(action_data);
    let mint = bcs::peel_bool(&mut bcs_data);
    let burn = bcs::peel_bool(&mut bcs_data);
    let update_symbol = bcs::peel_bool(&mut bcs_data);
    let update_name = bcs::peel_bool(&mut bcs_data);
    let update_description = bcs::peel_bool(&mut bcs_data);
    let update_icon = bcs::peel_bool(&mut bcs_data);

    // Security: ensure all bytes are consumed to prevent trailing data attacks
    bcs_validation::validate_all_bytes_consumed(bcs_data);

    let mut fields = vector::empty();

    fields.push_back(schema::new_field(
        b"mint".to_string(),
        if (mint) { b"true" } else { b"false" }.to_string(),
        b"bool".to_string(),
    ));

    fields.push_back(schema::new_field(
        b"burn".to_string(),
        if (burn) { b"true" } else { b"false" }.to_string(),
        b"bool".to_string(),
    ));

    fields.push_back(schema::new_field(
        b"update_symbol".to_string(),
        if (update_symbol) { b"true" } else { b"false" }.to_string(),
        b"bool".to_string(),
    ));

    fields.push_back(schema::new_field(
        b"update_name".to_string(),
        if (update_name) { b"true" } else { b"false" }.to_string(),
        b"bool".to_string(),
    ));

    fields.push_back(schema::new_field(
        b"update_description".to_string(),
        if (update_description) { b"true" } else { b"false" }.to_string(),
        b"bool".to_string(),
    ));

    fields
}

/// Decode an UpdateAction
public fun decode_update_action<CoinType>(
    _decoder: &UpdateActionDecoder,
    action_data: vector<u8>,
): vector<HumanReadableField> {
    let mut bcs_data = bcs::new(action_data);
    let mut symbol = bcs_data.peel_option!(|bcs| bcs.peel_vec_u8());
    let mut name = bcs_data.peel_option!(|bcs| bcs.peel_vec_u8());
    let mut description = bcs_data.peel_option!(|bcs| bcs.peel_vec_u8());
    let mut icon_url = bcs_data.peel_option!(|bcs| bcs.peel_vec_u8());

    // Security: ensure all bytes are consumed to prevent trailing data attacks
    bcs_validation::validate_all_bytes_consumed(bcs_data);

    let mut fields = vector::empty();

    // Symbol (optional)
    fields.push_back(schema::new_field(
        b"symbol".to_string(),
        if (symbol.is_some()) {
            symbol.destroy_some().to_string()
        } else {
            symbol.destroy_none();
            b"None".to_string()
        },
        b"Option<String>".to_string(),
    ));

    // Name (optional)
    fields.push_back(schema::new_field(
        b"name".to_string(),
        if (name.is_some()) {
            name.destroy_some().to_string()
        } else {
            name.destroy_none();
            b"None".to_string()
        },
        b"Option<String>".to_string(),
    ));

    // Description (optional)
    fields.push_back(schema::new_field(
        b"description".to_string(),
        if (description.is_some()) {
            description.destroy_some().to_string()
        } else {
            description.destroy_none();
            b"None".to_string()
        },
        b"Option<String>".to_string(),
    ));

    // Icon URL (optional)
    fields.push_back(schema::new_field(
        b"icon_url".to_string(),
        if (icon_url.is_some()) {
            icon_url.destroy_some().to_string()
        } else {
            icon_url.destroy_none();
            b"None".to_string()
        },
        b"Option<String>".to_string(),
    ));

    fields
}

// === Registration Functions ===

/// Register all currency decoders
public fun register_decoders(
    registry: &mut ActionDecoderRegistry,
    ctx: &mut TxContext,
) {
    register_mint_decoder(registry, ctx);
    register_burn_decoder(registry, ctx);
    register_disable_decoder(registry, ctx);
    register_update_decoder(registry, ctx);
}

fun register_mint_decoder(
    registry: &mut ActionDecoderRegistry,
    ctx: &mut TxContext,
) {
    let decoder = MintActionDecoder { id: object::new(ctx) };
    let type_key = type_name::with_defining_ids<MintAction<CoinPlaceholder>>();
    dynamic_object_field::add(schema::registry_id_mut(registry), type_key, decoder);
}

fun register_burn_decoder(
    registry: &mut ActionDecoderRegistry,
    ctx: &mut TxContext,
) {
    let decoder = BurnActionDecoder { id: object::new(ctx) };
    let type_key = type_name::with_defining_ids<BurnAction<CoinPlaceholder>>();
    dynamic_object_field::add(schema::registry_id_mut(registry), type_key, decoder);
}

fun register_disable_decoder(
    registry: &mut ActionDecoderRegistry,
    ctx: &mut TxContext,
) {
    let decoder = DisableActionDecoder { id: object::new(ctx) };
    let type_key = type_name::with_defining_ids<DisableAction<CoinPlaceholder>>();
    dynamic_object_field::add(schema::registry_id_mut(registry), type_key, decoder);
}

fun register_update_decoder(
    registry: &mut ActionDecoderRegistry,
    ctx: &mut TxContext,
) {
    let decoder = UpdateActionDecoder { id: object::new(ctx) };
    let type_key = type_name::with_defining_ids<UpdateAction<CoinPlaceholder>>();
    dynamic_object_field::add(schema::registry_id_mut(registry), type_key, decoder);
}// ============================================================================
// FORK ADDITION - Vault Action Decoder
// ============================================================================
// NEW FILE added to the fork for on-chain action decoding.
//
// PURPOSE:
// Provides human-readable decoding of vault actions (treasury operations)
// for transparency. Part of the mandatory decoder system that ensures all
// actions can be decoded and displayed to users before execution.
//
// IMPLEMENTATION:
// - Handles SpendAction and DepositAction for treasury management
// - Uses BCS deserialization with peel_* functions
// - Security validation via validate_all_bytes_consumed()
// - Returns vector<HumanReadableField> for universal display
// ============================================================================

/// Decoder for vault actions - tightly coupled with vault action definitions
/// This module knows exactly how to decode SpendAction and DepositAction
module account_actions::vault_decoder;

// === Imports ===

use std::{string::String, type_name};
use sui::{object::{Self, UID}, dynamic_object_field, bcs};
use account_protocol::bcs_validation;
use account_protocol::schema::{Self, ActionDecoderRegistry, HumanReadableField};
use account_actions::vault::{SpendAction, DepositAction};

// === Decoder Objects ===

/// Decoder that knows how to decode SpendAction<CoinType>
public struct SpendActionDecoder has key, store {
    id: UID,
}

/// Decoder that knows how to decode DepositAction<CoinType>
public struct DepositActionDecoder has key, store {
    id: UID,
}

// === Placeholder for Generic Registration ===

/// Placeholder type for registering generic decoders
public struct CoinPlaceholder has drop, store {}

// === Decoder Functions ===

/// Decode a SpendAction from BCS bytes to human-readable fields
public fun decode_spend_action<CoinType>(
    _decoder: &SpendActionDecoder,
    action_data: vector<u8>,
): vector<HumanReadableField> {
    // Deserialize the fields directly - DO NOT reconstruct the Action struct
    let mut bcs_data = bcs::new(action_data);
    let name = bcs::peel_vec_u8(&mut bcs_data).to_string();
    let amount = bcs::peel_u64(&mut bcs_data);

    // Security: ensure all bytes are consumed to prevent trailing data attacks
    bcs_validation::validate_all_bytes_consumed(bcs_data);

    let mut fields = vector::empty();

    // Extract and convert each field
    fields.push_back(schema::new_field(
        b"name".to_string(),
        name,
        b"String".to_string(),
    ));

    fields.push_back(schema::new_field(
        b"amount".to_string(),
        amount.to_string(),
        b"u64".to_string(),
    ));

    fields
}

/// Decode a DepositAction from BCS bytes to human-readable fields
public fun decode_deposit_action<CoinType>(
    _decoder: &DepositActionDecoder,
    action_data: vector<u8>,
): vector<HumanReadableField> {
    // Deserialize the fields directly - DO NOT reconstruct the Action struct
    let mut bcs_data = bcs::new(action_data);
    let name = bcs::peel_vec_u8(&mut bcs_data).to_string();
    let amount = bcs::peel_u64(&mut bcs_data);

    // Security: ensure all bytes are consumed to prevent trailing data attacks
    bcs_validation::validate_all_bytes_consumed(bcs_data);

    let mut fields = vector::empty();

    fields.push_back(schema::new_field(
        b"name".to_string(),
        name,
        b"String".to_string(),
    ));

    fields.push_back(schema::new_field(
        b"amount".to_string(),
        amount.to_string(),
        b"u64".to_string(),
    ));

    fields
}

// === Registration Functions ===

/// Register all vault decoders in the registry
/// Called once during protocol initialization
public fun register_decoders(
    registry: &mut ActionDecoderRegistry,
    ctx: &mut TxContext,
) {
    register_spend_decoder(registry, ctx);
    register_deposit_decoder(registry, ctx);
}

/// Register the SpendAction decoder
fun register_spend_decoder(
    registry: &mut ActionDecoderRegistry,
    ctx: &mut TxContext,
) {
    let decoder = SpendActionDecoder {
        id: object::new(ctx),
    };

    // Use placeholder for generic registration
    let type_key = type_name::with_defining_ids<SpendAction<CoinPlaceholder>>();

    // Attach decoder as dynamic object field
    dynamic_object_field::add(
        schema::registry_id_mut(registry),
        type_key,
        decoder,
    );
}

/// Register the DepositAction decoder
fun register_deposit_decoder(
    registry: &mut ActionDecoderRegistry,
    ctx: &mut TxContext,
) {
    let decoder = DepositActionDecoder {
        id: object::new(ctx),
    };

    let type_key = type_name::with_defining_ids<DepositAction<CoinPlaceholder>>();

    dynamic_object_field::add(
        schema::registry_id_mut(registry),
        type_key,
        decoder,
    );
}

// === Verification Functions ===

/// Check if a SpendAction decoder is registered
public fun has_spend_decoder(registry: &ActionDecoderRegistry): bool {
    let type_key = type_name::with_defining_ids<SpendAction<CoinPlaceholder>>();
    dynamic_object_field::exists_(schema::registry_id(registry), type_key)
}

/// Check if a DepositAction decoder is registered
public fun has_deposit_decoder(registry: &ActionDecoderRegistry): bool {
    let type_key = type_name::with_defining_ids<DepositAction<CoinPlaceholder>>();
    dynamic_object_field::exists_(schema::registry_id(registry), type_key)
}// ============================================================================
// FORK ADDITION - Kiosk Action Decoder
// ============================================================================
// NEW FILE added to the fork for on-chain action decoding.
//
// PURPOSE:
// Provides human-readable decoding of kiosk (NFT) actions for transparency.
// Part of the mandatory decoder system that ensures all actions can be
// decoded and displayed to users before execution.
//
// IMPLEMENTATION:
// - Handles TakeAction and ListAction for NFT operations
// - Uses object::id_from_bytes() for ID deserialization
// - Converts IDs to addresses for string representation
// - Returns vector<HumanReadableField> for universal display
// ============================================================================

/// Decoder for kiosk actions - tightly coupled with kiosk action definitions
module account_actions::kiosk_decoder;

// === Imports ===

use std::{string::String, type_name};
use sui::{object::{Self, UID, ID}, dynamic_object_field, bcs};
use account_protocol::{schema::{Self, ActionDecoderRegistry, HumanReadableField}, bcs_validation};
use account_actions::kiosk::{TakeAction, ListAction};

// === Decoder Objects ===

/// Decoder for TakeAction
public struct TakeActionDecoder has key, store {
    id: UID,
}

/// Decoder for ListAction
public struct ListActionDecoder has key, store {
    id: UID,
}

// === Decoder Functions ===

/// Decode a TakeAction
public fun decode_take_action(
    _decoder: &TakeActionDecoder,
    action_data: vector<u8>,
): vector<HumanReadableField> {
    // Deserialize the fields directly - DO NOT reconstruct the Action struct
    let mut bcs_data = bcs::new(action_data);
    let name = bcs::peel_vec_u8(&mut bcs_data).to_string();
    let nft_id = object::id_from_bytes(bcs::peel_vec_u8(&mut bcs_data));
    let recipient = bcs::peel_address(&mut bcs_data);

    // Security: ensure all bytes are consumed to prevent trailing data attacks
    bcs_validation::validate_all_bytes_consumed(bcs_data);

    let mut fields = vector::empty();

    fields.push_back(schema::new_field(
        b"name".to_string(),
        name,
        b"String".to_string(),
    ));

    fields.push_back(schema::new_field(
        b"nft_id".to_string(),
        nft_id.id_to_address().to_string(),
        b"ID".to_string(),
    ));

    fields.push_back(schema::new_field(
        b"recipient".to_string(),
        recipient.to_string(),
        b"address".to_string(),
    ));

    fields
}

/// Decode a ListAction
public fun decode_list_action(
    _decoder: &ListActionDecoder,
    action_data: vector<u8>,
): vector<HumanReadableField> {
    // Deserialize the fields directly - DO NOT reconstruct the Action struct
    let mut bcs_data = bcs::new(action_data);
    let name = bcs::peel_vec_u8(&mut bcs_data).to_string();
    let nft_id = object::id_from_bytes(bcs::peel_vec_u8(&mut bcs_data));
    let price = bcs::peel_u64(&mut bcs_data);

    // Security: ensure all bytes are consumed to prevent trailing data attacks
    bcs_validation::validate_all_bytes_consumed(bcs_data);

    let mut fields = vector::empty();

    fields.push_back(schema::new_field(
        b"name".to_string(),
        name,
        b"String".to_string(),
    ));

    fields.push_back(schema::new_field(
        b"nft_id".to_string(),
        nft_id.id_to_address().to_string(),
        b"ID".to_string(),
    ));

    fields.push_back(schema::new_field(
        b"price".to_string(),
        price.to_string(),
        b"u64".to_string(),
    ));

    fields
}

// === Registration Functions ===

/// Register all kiosk decoders
public fun register_decoders(
    registry: &mut ActionDecoderRegistry,
    ctx: &mut TxContext,
) {
    register_take_decoder(registry, ctx);
    register_list_decoder(registry, ctx);
}

fun register_take_decoder(
    registry: &mut ActionDecoderRegistry,
    ctx: &mut TxContext,
) {
    let decoder = TakeActionDecoder { id: object::new(ctx) };
    let type_key = type_name::with_defining_ids<TakeAction>();
    dynamic_object_field::add(schema::registry_id_mut(registry), type_key, decoder);
}

fun register_list_decoder(
    registry: &mut ActionDecoderRegistry,
    ctx: &mut TxContext,
) {
    let decoder = ListActionDecoder { id: object::new(ctx) };
    let type_key = type_name::with_defining_ids<ListAction>();
    dynamic_object_field::add(schema::registry_id_mut(registry), type_key, decoder);
}// ============================================================================
// FORK MODIFICATION NOTICE - Decoder Registry Initialization
// ============================================================================
// NEW FILE added to the fork for decoder system initialization.
//
// CHANGES IN THIS FORK (2025-01-14):
// - Added RegistryInfo shared object to store registry ID dynamically
// - Added RegistryCreated event emission for off-chain indexing
// - Added DECODER_REGISTRY_INIT one-time witness pattern
// - Removed hardcoded REGISTRY_ID constant - now discoverable at runtime
// - Single transaction deployment - no manual ID updates needed
//
// PURPOSE:
// Central initialization point for all action decoders. Creates and shares
// the global ActionDecoderRegistry during protocol deployment.
//
// BENEFITS:
// - Deploy once, fully configured
// - No constants to update post-deployment
// - Registry ID discoverable through multiple methods
// - Clean, professional deployment process
// ============================================================================

/// Main decoder registry initialization module
/// Registers all decoders during protocol deployment
module account_actions::decoder_registry_init;

// === Imports ===

use sui::{transfer, object::{Self, ID, UID}, event};
use account_protocol::schema::{Self, ActionDecoderRegistry};
use account_actions::{
    vault_decoder,
    currency_decoder,
    package_upgrade_decoder,
    vesting_decoder,
    transfer_decoder,
    kiosk_decoder,
    access_control_decoder,
};

// === Events ===

/// Emitted when the registry is created, containing its ID
public struct RegistryCreated has copy, drop {
    registry_id: ID,
}

// === Structs ===

/// One-time witness for initialization
public struct DECODER_REGISTRY_INIT has drop {}

/// Registry info object that stores the registry ID
/// This is a shared object that anyone can read to get the registry ID
public struct RegistryInfo has key, store {
    id: UID,
    registry_id: ID,
}

/// Admin capability for decoder management
public struct DecoderAdminCap has key, store {
    id: UID,
}

// === Init Function ===

/// Initialize the decoder registry with all action decoders
/// This is called once during protocol deployment
fun init(witness: DECODER_REGISTRY_INIT, ctx: &mut TxContext) {
    // Create the decoder registry
    let mut registry = schema::init_registry(ctx);

    // Get the registry ID before sharing
    let registry_id = object::id(&registry);

    // Register all decoders
    register_all_decoders(&mut registry, ctx);

    // Share the registry for public access
    transfer::public_share_object(registry);

    // Create and share a RegistryInfo object that stores the registry ID
    let info = RegistryInfo {
        id: object::new(ctx),
        registry_id,
    };
    transfer::public_share_object(info);

    // Create admin capability
    let admin_cap = DecoderAdminCap {
        id: object::new(ctx),
    };
    transfer::transfer(admin_cap, ctx.sender());

    // Emit event with the registry ID for off-chain indexing
    event::emit(RegistryCreated { registry_id });
}

// === Public Functions ===

/// Get the registry ID from the shared RegistryInfo object
public fun get_registry_id(info: &RegistryInfo): ID {
    info.registry_id
}

/// Register all decoders from all action modules
public fun register_all_decoders(
    registry: &mut ActionDecoderRegistry,
    ctx: &mut TxContext,
) {
    // Register vault action decoders
    vault_decoder::register_decoders(registry, ctx);

    // Register currency action decoders
    currency_decoder::register_decoders(registry, ctx);

    // Register package upgrade decoders
    package_upgrade_decoder::register_decoders(registry, ctx);

    // Register vesting action decoders
    vesting_decoder::register_decoders(registry, ctx);

    // Register transfer action decoders
    transfer_decoder::register_decoders(registry, ctx);

    // Register kiosk action decoders
    kiosk_decoder::register_decoders(registry, ctx);

    // Register access control action decoders
    access_control_decoder::register_decoders(registry, ctx);
}

/// Update decoders (requires admin capability)
public fun update_decoders(
    registry: &mut ActionDecoderRegistry,
    _admin_cap: &DecoderAdminCap,
    ctx: &mut TxContext,
) {
    // This allows re-registration of decoders after updates
    register_all_decoders(registry, ctx);
}// ============================================================================
// FORK ADDITION - Package Upgrade Action Decoder
// ============================================================================
// NEW FILE added to the fork for on-chain action decoding.
//
// PURPOSE:
// Provides human-readable decoding of package upgrade actions for transparency.
// Critical for DAO governance to understand contract upgrade proposals.
//
// IMPLEMENTATION:
// - Handles UpgradeAction and RestrictAction for package management
// - Decodes digest (32 bytes) and policy fields
// - Uses BCS deserialization with security validation
// - Returns vector<HumanReadableField> for universal display
// ============================================================================

/// Decoder for package upgrade actions
module account_actions::package_upgrade_decoder;

// === Imports ===

use std::{string::String, type_name, vector};
use sui::{object::{Self, UID}, dynamic_object_field, bcs};
use account_protocol::bcs_validation;
use account_protocol::schema::{Self, ActionDecoderRegistry, HumanReadableField};
use account_actions::package_upgrade::{UpgradeAction, CommitAction, RestrictAction};

// === Decoder Objects ===

/// Decoder for UpgradeAction
public struct UpgradeActionDecoder has key, store {
    id: UID,
}

/// Decoder for CommitAction
public struct CommitActionDecoder has key, store {
    id: UID,
}

/// Decoder for RestrictAction
public struct RestrictActionDecoder has key, store {
    id: UID,
}

// === Decoder Functions ===

/// Decode an UpgradeAction
public fun decode_upgrade_action(
    _decoder: &UpgradeActionDecoder,
    action_data: vector<u8>,
): vector<HumanReadableField> {
    let mut bcs_data = bcs::new(action_data);
    let name = bcs::peel_vec_u8(&mut bcs_data).to_string();
    let digest = bcs::peel_vec_u8(&mut bcs_data);

    // Security: ensure all bytes are consumed to prevent trailing data attacks
    bcs_validation::validate_all_bytes_consumed(bcs_data);

    let mut fields = vector::empty();

    fields.push_back(schema::new_field(
        b"name".to_string(),
        name,
        b"String".to_string(),
    ));

    // Convert digest bytes to hex string for readability
    fields.push_back(schema::new_field(
        b"digest".to_string(),
        bytes_to_hex_string(digest),
        b"vector<u8>".to_string(),
    ));

    fields
}

/// Decode a CommitAction
public fun decode_commit_action(
    _decoder: &CommitActionDecoder,
    action_data: vector<u8>,
): vector<HumanReadableField> {
    let mut bcs_data = bcs::new(action_data);
    let name = bcs::peel_vec_u8(&mut bcs_data).to_string();

    // Security: ensure all bytes are consumed to prevent trailing data attacks
    bcs_validation::validate_all_bytes_consumed(bcs_data);

    vector[
        schema::new_field(
            b"name".to_string(),
            name,
            b"String".to_string(),
        )
    ]
}

/// Decode a RestrictAction
public fun decode_restrict_action(
    _decoder: &RestrictActionDecoder,
    action_data: vector<u8>,
): vector<HumanReadableField> {
    let mut bcs_data = bcs::new(action_data);
    let name = bcs::peel_vec_u8(&mut bcs_data).to_string();
    let policy = bcs::peel_u8(&mut bcs_data);

    // Security: ensure all bytes are consumed to prevent trailing data attacks
    bcs_validation::validate_all_bytes_consumed(bcs_data);

    let mut fields = vector::empty();

    fields.push_back(schema::new_field(
        b"name".to_string(),
        name,
        b"String".to_string(),
    ));

    // Convert policy u8 to human-readable string
    let policy_str = if (policy == 0) {
        b"compatible"
    } else if (policy == 128) {
        b"additive"
    } else if (policy == 192) {
        b"dependency-only"
    } else if (policy == 255) {
        b"immutable"
    } else {
        b"unknown"
    };

    fields.push_back(schema::new_field(
        b"policy".to_string(),
        policy_str.to_string(),
        b"u8".to_string(),
    ));

    fields
}

// === Helper Functions ===

/// Convert bytes to hex string for display
fun bytes_to_hex_string(bytes: vector<u8>): String {
    let hex_chars = b"0123456789abcdef";
    let mut result = vector::empty<u8>();

    let mut i = 0;
    let len = bytes.length();
    while (i < len && i < 8) { // Show first 8 bytes for brevity
        let byte = bytes[i];
        result.push_back(hex_chars[(byte >> 4) as u64]);
        result.push_back(hex_chars[(byte & 0x0f) as u64]);
        i = i + 1;
    };

    if (len > 8) {
        result.append(b"...");
    };

    result.to_string()
}

// === Registration Functions ===

/// Register all package upgrade decoders
public fun register_decoders(
    registry: &mut ActionDecoderRegistry,
    ctx: &mut TxContext,
) {
    register_upgrade_decoder(registry, ctx);
    register_commit_decoder(registry, ctx);
    register_restrict_decoder(registry, ctx);
}

fun register_upgrade_decoder(
    registry: &mut ActionDecoderRegistry,
    ctx: &mut TxContext,
) {
    let decoder = UpgradeActionDecoder { id: object::new(ctx) };
    let type_key = type_name::with_defining_ids<UpgradeAction>();
    dynamic_object_field::add(schema::registry_id_mut(registry), type_key, decoder);
}

fun register_commit_decoder(
    registry: &mut ActionDecoderRegistry,
    ctx: &mut TxContext,
) {
    let decoder = CommitActionDecoder { id: object::new(ctx) };
    let type_key = type_name::with_defining_ids<CommitAction>();
    dynamic_object_field::add(schema::registry_id_mut(registry), type_key, decoder);
}

fun register_restrict_decoder(
    registry: &mut ActionDecoderRegistry,
    ctx: &mut TxContext,
) {
    let decoder = RestrictActionDecoder { id: object::new(ctx) };
    let type_key = type_name::with_defining_ids<RestrictAction>();
    dynamic_object_field::add(schema::registry_id_mut(registry), type_key, decoder);
}// ============================================================================
// FORK ADDITION - Vesting Action Decoder
// ============================================================================
// NEW FILE added to the fork for on-chain action decoding.
//
// PURPOSE:
// Provides human-readable decoding of vesting actions for transparency.
// Part of the mandatory decoder system that ensures all actions can be
// decoded and displayed to users before execution.
//
// IMPLEMENTATION:
// - Uses BCS deserialization with peel_* functions
// - Security validation via validate_all_bytes_consumed()
// - Returns vector<HumanReadableField> for universal display
// - Handles CreateVestingAction and CancelVestingAction
// ============================================================================

/// Decoder for vesting actions - tightly coupled with vesting action definitions
module account_actions::vesting_decoder;

// === Imports ===

use std::{string::String, type_name};
use sui::{object::{Self, UID, ID}, dynamic_object_field, bcs};
use account_protocol::{schema::{Self, ActionDecoderRegistry, HumanReadableField}, bcs_validation};
use account_actions::vesting::{CreateVestingAction, CancelVestingAction};

// === Decoder Objects ===

/// Decoder for CreateVestingAction<CoinType>
public struct CreateVestingActionDecoder has key, store {
    id: UID,
}

/// Decoder for CancelVestingAction
public struct CancelVestingActionDecoder has key, store {
    id: UID,
}

// === Placeholder for Generic Registration ===

/// Placeholder type for registering generic decoders
public struct CoinPlaceholder has drop, store {}

// === Decoder Functions ===

/// Decode a CreateVestingAction
public fun decode_create_vesting_action<CoinType>(
    _decoder: &CreateVestingActionDecoder,
    action_data: vector<u8>,
): vector<HumanReadableField> {
    // Deserialize the fields directly - DO NOT reconstruct the Action struct
    let mut bcs_data = bcs::new(action_data);
    let amount = bcs::peel_u64(&mut bcs_data);
    let start_timestamp = bcs::peel_u64(&mut bcs_data);
    let end_timestamp = bcs::peel_u64(&mut bcs_data);
    let mut cliff_time = bcs_data.peel_option!(|bcs| bcs.peel_u64());
    let recipient = bcs::peel_address(&mut bcs_data);
    let max_beneficiaries = bcs::peel_u64(&mut bcs_data);
    let max_per_withdrawal = bcs::peel_u64(&mut bcs_data);
    let min_interval_ms = bcs::peel_u64(&mut bcs_data);
    let is_transferable = bcs::peel_bool(&mut bcs_data);
    let is_cancelable = bcs::peel_bool(&mut bcs_data);
    let mut metadata = bcs_data.peel_option!(|bcs| bcs.peel_vec_u8());

    // Security: ensure all bytes are consumed to prevent trailing data attacks
    bcs_validation::validate_all_bytes_consumed(bcs_data);

    let mut fields = vector::empty();

    fields.push_back(schema::new_field(
        b"amount".to_string(),
        amount.to_string(),
        b"u64".to_string(),
    ));

    fields.push_back(schema::new_field(
        b"start_timestamp".to_string(),
        start_timestamp.to_string(),
        b"u64".to_string(),
    ));

    fields.push_back(schema::new_field(
        b"end_timestamp".to_string(),
        end_timestamp.to_string(),
        b"u64".to_string(),
    ));

    fields.push_back(schema::new_field(
        b"cliff_time".to_string(),
        if (cliff_time.is_some()) {
            cliff_time.destroy_some().to_string()
        } else {
            cliff_time.destroy_none();
            b"None".to_string()
        },
        b"Option<u64>".to_string(),
    ));

    fields.push_back(schema::new_field(
        b"recipient".to_string(),
        recipient.to_string(),
        b"address".to_string(),
    ));

    fields.push_back(schema::new_field(
        b"max_beneficiaries".to_string(),
        max_beneficiaries.to_string(),
        b"u64".to_string(),
    ));

    fields.push_back(schema::new_field(
        b"max_per_withdrawal".to_string(),
        max_per_withdrawal.to_string(),
        b"u64".to_string(),
    ));

    fields.push_back(schema::new_field(
        b"min_interval_ms".to_string(),
        min_interval_ms.to_string(),
        b"u64".to_string(),
    ));

    fields.push_back(schema::new_field(
        b"is_transferable".to_string(),
        if (is_transferable) { b"true" } else { b"false" }.to_string(),
        b"bool".to_string(),
    ));

    fields.push_back(schema::new_field(
        b"is_cancelable".to_string(),
        if (is_cancelable) { b"true" } else { b"false" }.to_string(),
        b"bool".to_string(),
    ));

    fields.push_back(schema::new_field(
        b"metadata".to_string(),
        if (metadata.is_some()) {
            metadata.destroy_some().to_string()
        } else {
            metadata.destroy_none();
            b"None".to_string()
        },
        b"Option<String>".to_string(),
    ));

    fields
}

/// Decode a CancelVestingAction
public fun decode_cancel_vesting_action(
    _decoder: &CancelVestingActionDecoder,
    action_data: vector<u8>,
): vector<HumanReadableField> {
    // Deserialize the fields directly - DO NOT reconstruct the Action struct
    let mut bcs_data = bcs::new(action_data);
    let vesting_id = object::id_from_bytes(bcs::peel_vec_u8(&mut bcs_data));

    // Security: ensure all bytes are consumed to prevent trailing data attacks
    bcs_validation::validate_all_bytes_consumed(bcs_data);

    vector[
        schema::new_field(
            b"vesting_id".to_string(),
            vesting_id.id_to_address().to_string(),
            b"ID".to_string(),
        )
    ]
}

// === Registration Functions ===

/// Register all vesting decoders
public fun register_decoders(
    registry: &mut ActionDecoderRegistry,
    ctx: &mut TxContext,
) {
    register_create_vesting_decoder(registry, ctx);
    register_cancel_vesting_decoder(registry, ctx);
}

fun register_create_vesting_decoder(
    registry: &mut ActionDecoderRegistry,
    ctx: &mut TxContext,
) {
    let decoder = CreateVestingActionDecoder { id: object::new(ctx) };
    let type_key = type_name::with_defining_ids<CreateVestingAction<CoinPlaceholder>>();
    dynamic_object_field::add(schema::registry_id_mut(registry), type_key, decoder);
}

fun register_cancel_vesting_decoder(
    registry: &mut ActionDecoderRegistry,
    ctx: &mut TxContext,
) {
    let decoder = CancelVestingActionDecoder { id: object::new(ctx) };
    let type_key = type_name::with_defining_ids<CancelVestingAction>();
    dynamic_object_field::add(schema::registry_id_mut(registry), type_key, decoder);
}// ============================================================================
// FORK ADDITION - Transfer Action Decoder
// ============================================================================
// NEW FILE added to the fork for on-chain action decoding.
//
// PURPOSE:
// Provides human-readable decoding of transfer actions for transparency.
// Part of the mandatory decoder system that ensures all actions can be
// decoded and displayed to users before execution.
//
// IMPLEMENTATION:
// - Simple single-field decoder for TransferAction
// - Uses BCS deserialization with security validation
// - Returns vector<HumanReadableField> for universal display
// ============================================================================

/// Decoder for transfer actions - tightly coupled with transfer action definitions
module account_actions::transfer_decoder;

// === Imports ===

use std::{string::String, type_name};
use sui::{object::{Self, UID}, dynamic_object_field, bcs};
use account_protocol::{schema::{Self, ActionDecoderRegistry, HumanReadableField}, bcs_validation};
use account_actions::transfer::TransferAction;

// === Decoder Objects ===

/// Decoder for TransferAction
public struct TransferActionDecoder has key, store {
    id: UID,
}

// === Decoder Functions ===

/// Decode a TransferAction
public fun decode_transfer_action(
    _decoder: &TransferActionDecoder,
    action_data: vector<u8>,
): vector<HumanReadableField> {
    // Deserialize the fields directly - DO NOT reconstruct the Action struct
    let mut bcs_data = bcs::new(action_data);
    let recipient = bcs::peel_address(&mut bcs_data);

    // Security: ensure all bytes are consumed to prevent trailing data attacks
    bcs_validation::validate_all_bytes_consumed(bcs_data);

    vector[
        schema::new_field(
            b"recipient".to_string(),
            recipient.to_string(),
            b"address".to_string(),
        )
    ]
}

// === Registration Functions ===

/// Register all transfer decoders
public fun register_decoders(
    registry: &mut ActionDecoderRegistry,
    ctx: &mut TxContext,
) {
    register_transfer_decoder(registry, ctx);
}

fun register_transfer_decoder(
    registry: &mut ActionDecoderRegistry,
    ctx: &mut TxContext,
) {
    let decoder = TransferActionDecoder { id: object::new(ctx) };
    let type_key = type_name::with_defining_ids<TransferAction>();
    dynamic_object_field::add(schema::registry_id_mut(registry), type_key, decoder);
}// ============================================================================
// FORK ADDITION - Access Control Action Decoder
// ============================================================================
// NEW FILE added to the fork for on-chain action decoding.
//
// PURPOSE:
// Provides human-readable decoding of access control actions for transparency.
// Part of the mandatory decoder system that ensures all actions can be
// decoded and displayed to users before execution.
//
// IMPLEMENTATION:
// - Handles BorrowAction and ReturnAction (empty structs)
// - Minimal decoder as these actions have no fields
// - Still validates BCS consumption for security
// - Returns action type information for display
// ============================================================================

/// Decoder for access control actions - tightly coupled with access control action definitions
module account_actions::access_control_decoder;

// === Imports ===

use std::{string::String, type_name};
use sui::{object::{Self, UID}, dynamic_object_field};
use account_protocol::{schema::{Self, ActionDecoderRegistry, HumanReadableField}, bcs_validation};
use account_actions::access_control::{BorrowAction, ReturnAction};

// === Decoder Objects ===

/// Decoder for BorrowAction<Cap>
public struct BorrowActionDecoder has key, store {
    id: UID,
}

/// Decoder for ReturnAction<Cap>
public struct ReturnActionDecoder has key, store {
    id: UID,
}

// === Placeholder for Generic Registration ===

/// Placeholder type for registering generic decoders
public struct CapPlaceholder has drop, store {}

// === Decoder Functions ===

/// Decode a BorrowAction
public fun decode_borrow_action<Cap>(
    _decoder: &BorrowActionDecoder,
    action_data: vector<u8>,
): vector<HumanReadableField> {
    // BorrowAction has no fields - it's an empty struct
    // Still validate that all bytes are consumed (should be empty)
    let bcs_data = sui::bcs::new(action_data);

    // Security: ensure all bytes are consumed to prevent trailing data attacks
    bcs_validation::validate_all_bytes_consumed(bcs_data);

    // Return empty vector since there are no fields to decode
    vector[
        schema::new_field(
            b"action_type".to_string(),
            b"BorrowAction".to_string(),
            b"String".to_string(),
        )
    ]
}

/// Decode a ReturnAction
public fun decode_return_action<Cap>(
    _decoder: &ReturnActionDecoder,
    action_data: vector<u8>,
): vector<HumanReadableField> {
    // ReturnAction has no fields - it's an empty struct
    // Still validate that all bytes are consumed (should be empty)
    let bcs_data = sui::bcs::new(action_data);

    // Security: ensure all bytes are consumed to prevent trailing data attacks
    bcs_validation::validate_all_bytes_consumed(bcs_data);

    // Return empty vector since there are no fields to decode
    vector[
        schema::new_field(
            b"action_type".to_string(),
            b"ReturnAction".to_string(),
            b"String".to_string(),
        )
    ]
}

// === Registration Functions ===

/// Register all access control decoders
public fun register_decoders(
    registry: &mut ActionDecoderRegistry,
    ctx: &mut TxContext,
) {
    register_borrow_decoder(registry, ctx);
    register_return_decoder(registry, ctx);
}

fun register_borrow_decoder(
    registry: &mut ActionDecoderRegistry,
    ctx: &mut TxContext,
) {
    let decoder = BorrowActionDecoder { id: object::new(ctx) };
    let type_key = type_name::with_defining_ids<BorrowAction<CapPlaceholder>>();
    dynamic_object_field::add(schema::registry_id_mut(registry), type_key, decoder);
}

fun register_return_decoder(
    registry: &mut ActionDecoderRegistry,
    ctx: &mut TxContext,
) {
    let decoder = ReturnActionDecoder { id: object::new(ctx) };
    let type_key = type_name::with_defining_ids<ReturnAction<CapPlaceholder>>();
    dynamic_object_field::add(schema::registry_id_mut(registry), type_key, decoder);
}// ============================================================================
// FORK MODIFICATION NOTICE - Kiosk Management with Serialize-Then-Destroy Pattern
// ============================================================================
// This module manages NFT operations in Kiosks for Account.
//
// CHANGES IN THIS FORK:
// - Actions use type markers: KioskTake, KioskList
// - Implemented serialize-then-destroy pattern for both action types
// - Added destruction functions: destroy_take_action, destroy_list_action
// - Actions serialize to bytes before adding to intent via add_typed_action()
// - Returns TransferRequest hot potato for completing NFT transfers
// - Type-safe action validation through compile-time TypeName comparison
// ============================================================================
/// Authenticated users can place nfts from their kiosk into the account's without passing through the intent process.
/// Nfts can be transferred into any other Kiosk. Upon resolution, the recipient must execute the transfer.
/// The functions take the caller's kiosk and the account's kiosk to execute.
/// Nfts can be listed for sale in the kiosk, and then purchased by anyone.
/// Authorized addresses can withdraw the profits from the kiosk to the Account.

module account_actions::kiosk;

// === Imports ===

use std::string::String;
use sui::{
    coin,
    sui::SUI,
    kiosk::{Self, Kiosk, KioskOwnerCap},
    transfer_policy::{TransferPolicy, TransferRequest},
    bcs::{Self, BCS},
};
use kiosk::{kiosk_lock_rule, royalty_rule, personal_kiosk_rule};
use account_protocol::{
    action_validation,
    account::{Account, Auth},
    intents::{Self, Expired, Intent},
    executable::{Self, Executable},
    version_witness::VersionWitness,
};
use account_actions::version;
use account_extensions::framework_action_types::{Self, KioskTake, KioskList};

// === Use Fun Aliases ===
// Removed - add_typed_action is now called directly

// === Errors ===

const EWrongReceiver: u64 = 0;

// === Structs ===    

/// Dynamic Object Field key for the KioskOwnerCap
public struct KioskOwnerKey(String) has copy, drop, store;

/// Action transferring nfts from the account's kiosk to another one
public struct TakeAction has drop, store {
    // name of the Kiosk
    name: String,
    // id of the nfts to transfer
    nft_id: ID,
    // owner of the receiver kiosk
    recipient: address,
}
/// Action listing nfts for purchase
public struct ListAction has drop, store {
    // name of the Kiosk
    name: String,
    // id of the nft to list
    nft_id: ID,
    // listing price of the nft
    price: u64
}

// === Public functions ===

/// Creates a new Kiosk and locks the KioskOwnerCap in the Account
#[allow(lint(share_owned))]
public fun open<Config>(
    auth: Auth,
    account: &mut Account<Config>, 
    name: String, 
    ctx: &mut TxContext
) {
    account.verify(auth);

    let (mut kiosk, kiosk_owner_cap) = kiosk::new(ctx);
    kiosk.set_owner_custom(&kiosk_owner_cap, account.addr());

    account.add_managed_asset(KioskOwnerKey(name), kiosk_owner_cap, version::current());
    transfer::public_share_object(kiosk);
}

/// Checks if a Kiosk exists for a given name.
public fun has_lock<Config>(
    account: &Account<Config>,
    name: String
): bool {
    account.has_managed_asset(KioskOwnerKey(name))
}

/// Deposits from another Kiosk, no need for intent.
/// Optional royalty, lock and personal kiosk rules are automatically resolved for the type.
/// Additional rules may be confirmed after in the PTB.
public fun place<Config, Nft: key + store>(
    auth: Auth,
    account: &mut Account<Config>, 
    account_kiosk: &mut Kiosk, 
    sender_kiosk: &mut Kiosk, 
    sender_cap: &KioskOwnerCap, 
    policy: &mut TransferPolicy<Nft>,
    name: String,
    nft_id: ID,
    ctx: &mut TxContext
): TransferRequest<Nft> {
    account.verify(auth);

    let cap: &KioskOwnerCap = account.borrow_managed_asset(KioskOwnerKey(name), version::current());

    sender_kiosk.list<Nft>(sender_cap, nft_id, 0);
    let (nft, mut request) = sender_kiosk.purchase<Nft>(nft_id, coin::zero<SUI>(ctx));

    if (policy.has_rule<Nft, kiosk_lock_rule::Rule>()) {
        account_kiosk.lock(cap, policy, nft);
        kiosk_lock_rule::prove(&mut request, account_kiosk);
    } else {
        account_kiosk.place(cap, nft);
    };

    if (policy.has_rule<Nft, royalty_rule::Rule>()) {
        // can't read royalty rule on-chain because transfer_policy::get_rule not implemented
        // so we can't throw an error if there is a minimum floor price set
        royalty_rule::pay(policy, &mut request, coin::zero<SUI>(ctx));
    }; 

    if (policy.has_rule<Nft, personal_kiosk_rule::Rule>()) {
        personal_kiosk_rule::prove(account_kiosk, &mut request);
    };
    // the request can be filled with arbitrary rules and must be confirmed afterwards
    request
}

/// Authenticated users can delist nfts
public fun delist<Config, Nft: key + store>(
    auth: Auth,
    account: &mut Account<Config>, 
    kiosk: &mut Kiosk, 
    name: String,
    nft_id: ID,
) {
    account.verify(auth);

    let cap: &KioskOwnerCap = account.borrow_managed_asset(KioskOwnerKey(name), version::current());
    kiosk.delist<Nft>(cap, nft_id);
}

/// Authenticated users can withdraw the profits to the account
public fun withdraw_profits<Config>(
    auth: Auth,
    account: &mut Account<Config>,
    kiosk: &mut Kiosk,
    name: String,
    ctx: &mut TxContext
) {
    account.verify(auth);

    let cap: &KioskOwnerCap = account.borrow_managed_asset(KioskOwnerKey(name), version::current());

    let profits_mut = kiosk.profits_mut(cap);
    let profits_value = profits_mut.value();
    let profits = profits_mut.split(profits_value);

    account.keep(coin::from_balance<SUI>(profits, ctx), ctx);
}

/// Closes the kiosk if empty
public fun close<Config>(
    auth: Auth,
    account: &mut Account<Config>,
    name: String,
    kiosk: Kiosk,
    ctx: &mut TxContext
) {
    account.verify(auth);

    let cap: KioskOwnerCap = account.remove_managed_asset(KioskOwnerKey(name), version::current());
    let profits = kiosk.close_and_withdraw(cap, ctx);
    
    account.keep(profits, ctx);
}

// === Destruction Functions ===

/// Destroy a TakeAction after serialization
public fun destroy_take_action(action: TakeAction) {
    let TakeAction { name: _, nft_id: _, recipient: _ } = action;
}

/// Destroy a ListAction after serialization
public fun destroy_list_action(action: ListAction) {
    let ListAction { name: _, nft_id: _, price: _ } = action;
}

// Intent functions

/// Creates a new TakeAction and adds it to an intent.
public fun new_take<Outcome, IW: drop>(
    intent: &mut Intent<Outcome>,
    name: String,
    nft_id: ID,
    recipient: address,
    intent_witness: IW,
) {
    // Create the action struct
    let action = TakeAction { name, nft_id, recipient };

    // Serialize it
    let action_data = bcs::to_bytes(&action);

    // Add to intent with pre-serialized bytes
    intent.add_typed_action(
        framework_action_types::kiosk_take(),
        action_data,
        intent_witness
    );

    // Explicitly destroy the action struct
    destroy_take_action(action);
}

/// Processes a TakeAction, resolves the rules and places the nft into the recipient's kiosk.
public fun do_take<Config, Outcome: store, Nft: key + store, IW: drop>(
    executable: &mut Executable<Outcome>,
    account: &mut Account<Config>,
    account_kiosk: &mut Kiosk,
    recipient_kiosk: &mut Kiosk,
    recipient_cap: &KioskOwnerCap,
    policy: &mut TransferPolicy<Nft>,
    version_witness: VersionWitness,
    _intent_witness: IW,
    ctx: &mut TxContext
): TransferRequest<Nft> {
    executable.intent().assert_is_account(account.addr());

    // Get BCS bytes from ActionSpec
    let specs = executable.intent().action_specs();
    let spec = specs.borrow(executable.action_idx());

    // CRITICAL: Assert that the action type is what we expect
    action_validation::assert_action_type<KioskTake>(spec);

    let action_data = intents::action_spec_data(spec);

    // Create BCS reader and deserialize
    let mut reader = bcs::new(*action_data);
    let name = bcs::peel_vec_u8(&mut reader).to_string();
    let nft_id = bcs::peel_address(&mut reader).to_id();
    let recipient = bcs::peel_address(&mut reader);

    assert!(recipient == ctx.sender(), EWrongReceiver);

    let cap: &KioskOwnerCap = account.borrow_managed_asset(KioskOwnerKey(name), version_witness);

    account_kiosk.list<Nft>(cap, nft_id, 0);
    let (nft, mut request) = account_kiosk.purchase<Nft>(nft_id, coin::zero<SUI>(ctx));

    if (policy.has_rule<Nft, kiosk_lock_rule::Rule>()) {
        recipient_kiosk.lock(recipient_cap, policy, nft);
        kiosk_lock_rule::prove(&mut request, recipient_kiosk);
    } else {
        recipient_kiosk.place(recipient_cap, nft);
    };

    if (policy.has_rule<Nft, royalty_rule::Rule>()) {
        royalty_rule::pay(policy, &mut request, coin::zero<SUI>(ctx));
    };

    if (policy.has_rule<Nft, personal_kiosk_rule::Rule>()) {
        personal_kiosk_rule::prove(account_kiosk, &mut request);
    };

    // Increment action index
    executable::increment_action_idx(executable);

    // the request can be filled with arbitrary rules and must be confirmed afterwards
    request
}

/// Deletes a TakeAction from an expired intent.
public fun delete_take(expired: &mut Expired) {
    let _spec = intents::remove_action_spec(expired);
    // ActionSpec has drop, automatically cleaned up
}

/// Creates a new ListAction and adds it to an intent.
public fun new_list<Outcome, IW: drop>(
    intent: &mut Intent<Outcome>,
    name: String,
    nft_id: ID,
    price: u64,
    intent_witness: IW,
) {
    // Create the action struct
    let action = ListAction { name, nft_id, price };

    // Serialize it
    let action_data = bcs::to_bytes(&action);

    // Add to intent with pre-serialized bytes
    intent.add_typed_action(
        framework_action_types::kiosk_list(),
        action_data,
        intent_witness
    );

    // Explicitly destroy the action struct
    destroy_list_action(action);
}

/// Processes a ListAction and lists the nft for purchase.
public fun do_list<Config, Outcome: store, Nft: key + store, IW: drop>(
    executable: &mut Executable<Outcome>,
    account: &mut Account<Config>,
    kiosk: &mut Kiosk,
    version_witness: VersionWitness,
    _intent_witness: IW,
) {
    executable.intent().assert_is_account(account.addr());

    // Get BCS bytes from ActionSpec
    let specs = executable.intent().action_specs();
    let spec = specs.borrow(executable.action_idx());

    // CRITICAL: Assert that the action type is what we expect
    action_validation::assert_action_type<KioskList>(spec);

    let action_data = intents::action_spec_data(spec);

    // Create BCS reader and deserialize
    let mut reader = bcs::new(*action_data);
    let name = bcs::peel_vec_u8(&mut reader).to_string();
    let nft_id = bcs::peel_address(&mut reader).to_id();
    let price = bcs::peel_u64(&mut reader);

    let cap: &KioskOwnerCap = account.borrow_managed_asset(KioskOwnerKey(name), version_witness);

    kiosk.list<Nft>(cap, nft_id, price);

    // Increment action index
    executable::increment_action_idx(executable);
}

/// Deletes a ListAction from an expired intent.
public fun delete_list(expired: &mut Expired) {
    let _spec = intents::remove_action_spec(expired);
    // ActionSpec has drop, automatically cleaned up
}

// ============================================================================
// FORK MODIFICATION NOTICE - Package Upgrade with Serialize-Then-Destroy Pattern
// ============================================================================
// This module manages UpgradeCap operations with timelock for Account.
//
// CHANGES IN THIS FORK:
// - Actions use type markers: PackageUpgrade, PackageCommit, PackageRestrict
// - Implemented serialize-then-destroy pattern for all 3 action types
// - Added destruction functions: destroy_upgrade_action, destroy_commit_action, destroy_restrict_action
// - Actions serialize to bytes before adding to intent via add_typed_action()
// - Enhanced BCS validation: version checks + validate_all_bytes_consumed
// - Type-safe action validation through compile-time TypeName comparison
// ============================================================================
/// Package managers can lock UpgradeCaps in the account. Caps can't be unlocked, this is to enforce the policies.
/// Any rule can be defined for the upgrade lock. The module provide a timelock rule by default, based on execution time.
/// Upon locking, the user can define an optional timelock corresponding to the minimum delay between an upgrade proposal and its execution.
/// The account can decide to make the policy more restrictive or destroy the Cap, to make the package immutable.

module account_actions::package_upgrade;

// === Imports ===

use std::string::String;
use sui::{
    package::{Self, UpgradeCap, UpgradeTicket, UpgradeReceipt},
    clock::Clock,
    vec_map::{Self, VecMap},
    bcs::{Self, BCS},
};
use account_protocol::{
    action_validation,
    account::{Account, Auth},
    intents::{Self, Expired, Intent},
    executable::{Self, Executable},
    version_witness::VersionWitness,
    bcs_validation,
};
use account_actions::{
    version,
};
use account_extensions::framework_action_types::{Self, PackageUpgrade, PackageCommit, PackageRestrict};

// === Use Fun Aliases ===
// Removed - add_typed_action is now called directly

// === Error ===

const ELockAlreadyExists: u64 = 0;
const EUpgradeTooEarly: u64 = 1;
const EPackageDoesntExist: u64 = 2;
const EUnsupportedActionVersion: u64 = 3;

// === Structs ===

/// Dynamic Object Field key for the UpgradeCap.
public struct UpgradeCapKey(String) has copy, drop, store;
/// Dynamic field key for the UpgradeRules.
public struct UpgradeRulesKey(String) has copy, drop, store;
/// Dynamic field key for the UpgradeIndex.
public struct UpgradeIndexKey() has copy, drop, store;

/// Dynamic field wrapper defining an optional timelock.
public struct UpgradeRules has store {
    // minimum delay between proposal and execution
    delay_ms: u64,
} 

/// Map tracking the latest upgraded package address for a package name.
public struct UpgradeIndex has store {
    // map of package name to address
    packages_info: VecMap<String, address>,
}

/// Action to upgrade a package using a locked UpgradeCap.
public struct UpgradeAction has drop, store {
    // name of the package
    name: String,
    // digest of the package build we want to publish
    digest: vector<u8>,
}
/// Action to commit an upgrade.
public struct CommitAction has drop, store {
    // name of the package
    name: String,
}
/// Action to restrict the policy of a locked UpgradeCap.
public struct RestrictAction has drop, store {
    // name of the package
    name: String,
    // downgrades to this policy
    policy: u8,
}

// === Public Functions ===

/// Attaches the UpgradeCap as a Dynamic Object Field to the account.
public fun lock_cap<Config>(
    auth: Auth,
    account: &mut Account<Config>,
    cap: UpgradeCap,
    name: String, // name of the package
    delay_ms: u64, // minimum delay between proposal and execution
) {
    account.verify(auth);
    assert!(!has_cap(account, name), ELockAlreadyExists);

    if (!account.has_managed_data(UpgradeIndexKey()))
        account.add_managed_data(UpgradeIndexKey(), UpgradeIndex { packages_info: vec_map::empty() }, version::current());

    let upgrade_index_mut: &mut UpgradeIndex = account.borrow_managed_data_mut(UpgradeIndexKey(), version::current());
    upgrade_index_mut.packages_info.insert(name, cap.package().to_address());
    
    account.add_managed_asset(UpgradeCapKey(name), cap, version::current());
    account.add_managed_data(UpgradeRulesKey(name), UpgradeRules { delay_ms }, version::current());
}

/// Returns true if the account has an UpgradeCap for a given package name.
public fun has_cap<Config>(
    account: &Account<Config>, 
    name: String
): bool {
    account.has_managed_asset(UpgradeCapKey(name))
}

/// Returns the address of the package for a given package name.
public fun get_cap_package<Config>(
    account: &Account<Config>, 
    name: String
): address {
    account.borrow_managed_asset<_, _, UpgradeCap>(UpgradeCapKey(name), version::current()).package().to_address()
} 

/// Returns the version of the UpgradeCap for a given package name.
public fun get_cap_version<Config>(
    account: &Account<Config>, 
    name: String
): u64 {
    account.borrow_managed_asset<_, _, UpgradeCap>(UpgradeCapKey(name), version::current()).version()
} 

/// Returns the policy of the UpgradeCap for a given package name.
public fun get_cap_policy<Config>(
    account: &Account<Config>, 
    name: String
): u8 {
    account.borrow_managed_asset<_, _, UpgradeCap>(UpgradeCapKey(name), version::current()).policy()
} 

/// Returns the timelock of the UpgradeRules for a given package name.
public fun get_time_delay<Config>(
    account: &Account<Config>, 
    name: String
): u64 {
    account.borrow_managed_data<_, _, UpgradeRules>(UpgradeRulesKey(name), version::current()).delay_ms
}

/// Returns the map of package names to package addresses.
public fun get_packages_info<Config>(
    account: &Account<Config>
): &VecMap<String, address> {
    &account.borrow_managed_data<_, _, UpgradeIndex>(UpgradeIndexKey(), version::current()).packages_info
}

/// Returns true if the package is managed by the account.
public fun is_package_managed<Config>(
    account: &Account<Config>,
    package_addr: address
): bool {
    if (!account.has_managed_data(UpgradeIndexKey())) return false;
    let index: &UpgradeIndex = account.borrow_managed_data(UpgradeIndexKey(), version::current());
    
    let mut i = 0;
    while (i < index.packages_info.length()) {
        let (_, value) = index.packages_info.get_entry_by_idx(i);
        if (value == package_addr) return true;
        i = i + 1;
    };

    false
}

/// Returns the address of the package for a given package name.
public fun get_package_addr<Config>(
    account: &Account<Config>,
    package_name: String
): address {
    let index: &UpgradeIndex = account.borrow_managed_data(UpgradeIndexKey(), version::current());
    *index.packages_info.get(&package_name)
}

/// Returns the package name for a given package address.
#[allow(unused_assignment)] // false positive
public fun get_package_name<Config>(
    account: &Account<Config>,
    package_addr: address
): String {
    let index: &UpgradeIndex = account.borrow_managed_data(UpgradeIndexKey(), version::current());
    let (mut i, mut package_name) = (0, b"".to_string());
    loop {
        let (name, addr) = index.packages_info.get_entry_by_idx(i);
        package_name = *name;
        if (addr == package_addr) break package_name;
        
        i = i + 1;
        if (i == index.packages_info.length()) abort EPackageDoesntExist;
    };
    
    package_name
}

// === Destruction Functions ===

/// Destroy an UpgradeAction after serialization
public fun destroy_upgrade_action(action: UpgradeAction) {
    let UpgradeAction { name: _, digest: _ } = action;
}

/// Destroy a CommitAction after serialization
public fun destroy_commit_action(action: CommitAction) {
    let CommitAction { name: _ } = action;
}

/// Destroy a RestrictAction after serialization
public fun destroy_restrict_action(action: RestrictAction) {
    let RestrictAction { name: _, policy: _ } = action;
}

// Intent functions

/// Creates a new UpgradeAction and adds it to an intent.
public fun new_upgrade<Outcome, IW: drop>(
    intent: &mut Intent<Outcome>,
    name: String,
    digest: vector<u8>,
    intent_witness: IW,
) {
    // Create the action struct
    let action = UpgradeAction { name, digest };

    // Serialize it
    let action_data = bcs::to_bytes(&action);

    // Add to intent with pre-serialized bytes
    intent.add_typed_action(
        framework_action_types::package_upgrade(),
        action_data,
        intent_witness
    );

    // Explicitly destroy the action struct
    destroy_upgrade_action(action);
}    

/// Processes an UpgradeAction and returns a UpgradeTicket.
public fun do_upgrade<Config, Outcome: store, IW: drop>(
    executable: &mut Executable<Outcome>,
    account: &mut Account<Config>,
    clock: &Clock,
    version_witness: VersionWitness,
    _intent_witness: IW,
): UpgradeTicket {
    executable.intent().assert_is_account(account.addr());

    // Get BCS bytes from ActionSpec
    let specs = executable.intent().action_specs();
    let spec = specs.borrow(executable.action_idx());

    // CRITICAL: Assert that the action type is what we expect
    action_validation::assert_action_type<PackageUpgrade>(spec);

    let action_data = intents::action_spec_data(spec);

    // Check version before deserialization
    let spec_version = intents::action_spec_version(spec);
    assert!(spec_version == 1, EUnsupportedActionVersion);

    // Create BCS reader and deserialize
    let mut reader = bcs::new(*action_data);
    let name = bcs::peel_vec_u8(&mut reader).to_string();
    let digest = bcs::peel_vec_u8(&mut reader);

    // Validate all bytes consumed
    bcs_validation::validate_all_bytes_consumed(reader);

    assert!(
        clock.timestamp_ms() >= executable.intent().creation_time() + get_time_delay(account, name),
        EUpgradeTooEarly
    );

    let cap: &mut UpgradeCap = account.borrow_managed_asset_mut(UpgradeCapKey(name), version_witness);
    let policy = cap.policy();

    // Increment action index
    executable::increment_action_idx(executable);

    cap.authorize_upgrade(policy, digest) // return ticket
}    

/// Deletes an UpgradeAction from an expired intent.
public fun delete_upgrade(expired: &mut Expired) {
    let _spec = intents::remove_action_spec(expired);
    // ActionSpec has drop, automatically cleaned up
}

/// Creates a new CommitAction and adds it to an intent.
public fun new_commit<Outcome, IW: drop>(
    intent: &mut Intent<Outcome>,
    name: String,
    intent_witness: IW,
) {
    // Create the action struct
    let action = CommitAction { name };

    // Serialize it
    let action_data = bcs::to_bytes(&action);

    // Add to intent with pre-serialized bytes
    intent.add_typed_action(
        framework_action_types::package_commit(),
        action_data,
        intent_witness
    );

    // Explicitly destroy the action struct
    destroy_commit_action(action);
}    

// must be called after UpgradeAction is processed, there cannot be any other action processed before
/// Commits an upgrade and updates the index with the new package address.
public fun do_commit<Config, Outcome: store, IW: drop>(
    executable: &mut Executable<Outcome>,
    account: &mut Account<Config>,
    receipt: UpgradeReceipt,
    version_witness: VersionWitness,
    _intent_witness: IW,
) {
    executable.intent().assert_is_account(account.addr());

    // Get BCS bytes from ActionSpec
    let specs = executable.intent().action_specs();
    let spec = specs.borrow(executable.action_idx());

    // CRITICAL: Assert that the action type is what we expect
    action_validation::assert_action_type<PackageCommit>(spec);

    let action_data = intents::action_spec_data(spec);

    // Check version before deserialization
    let spec_version = intents::action_spec_version(spec);
    assert!(spec_version == 1, EUnsupportedActionVersion);

    // Create BCS reader and deserialize
    let mut reader = bcs::new(*action_data);
    let name = bcs::peel_vec_u8(&mut reader).to_string();

    // Validate all bytes consumed
    bcs_validation::validate_all_bytes_consumed(reader);

    let cap_mut: &mut UpgradeCap = account.borrow_managed_asset_mut(UpgradeCapKey(name), version_witness);
    cap_mut.commit_upgrade(receipt);
    let new_package_addr = cap_mut.package().to_address();

    // update the index with the new package address
    let index_mut: &mut UpgradeIndex = account.borrow_managed_data_mut(UpgradeIndexKey(), version_witness);
    *index_mut.packages_info.get_mut(&name) = new_package_addr;

    // Increment action index
    executable::increment_action_idx(executable);
}

public fun delete_commit(expired: &mut Expired) {
    let _spec = intents::remove_action_spec(expired);
    // ActionSpec has drop, automatically cleaned up
}

/// Creates a new RestrictAction and adds it to an intent.
public fun new_restrict<Outcome, IW: drop>(
    intent: &mut Intent<Outcome>,
    name: String,
    policy: u8,
    intent_witness: IW,
) {
    // Create the action struct
    let action = RestrictAction { name, policy };

    // Serialize it
    let action_data = bcs::to_bytes(&action);

    // Add to intent with pre-serialized bytes
    intent.add_typed_action(
        framework_action_types::package_restrict(),
        action_data,
        intent_witness
    );

    // Explicitly destroy the action struct
    destroy_restrict_action(action);
}    

/// Processes a RestrictAction and updates the UpgradeCap policy.
public fun do_restrict<Config, Outcome: store, IW: drop>(
    executable: &mut Executable<Outcome>,
    account: &mut Account<Config>,
    version_witness: VersionWitness,
    _intent_witness: IW,
) {
    executable.intent().assert_is_account(account.addr());

    // Get BCS bytes from ActionSpec
    let specs = executable.intent().action_specs();
    let spec = specs.borrow(executable.action_idx());

    // CRITICAL: Assert that the action type is what we expect
    action_validation::assert_action_type<PackageRestrict>(spec);

    let action_data = intents::action_spec_data(spec);

    // Check version before deserialization
    let spec_version = intents::action_spec_version(spec);
    assert!(spec_version == 1, EUnsupportedActionVersion);

    // Create BCS reader and deserialize
    let mut reader = bcs::new(*action_data);
    let name = bcs::peel_vec_u8(&mut reader).to_string();
    let policy = bcs::peel_u8(&mut reader);

    // Validate all bytes consumed
    bcs_validation::validate_all_bytes_consumed(reader);

    if (policy == package::additive_policy()) {
        let cap_mut: &mut UpgradeCap = account.borrow_managed_asset_mut(UpgradeCapKey(name), version_witness);
        cap_mut.only_additive_upgrades();
    } else if (policy == package::dep_only_policy()) {
        let cap_mut: &mut UpgradeCap = account.borrow_managed_asset_mut(UpgradeCapKey(name), version_witness);
        cap_mut.only_dep_upgrades();
    } else {
        let cap: UpgradeCap = account.remove_managed_asset(UpgradeCapKey(name), version_witness);
        package::make_immutable(cap);
    };

    // Increment action index
    executable::increment_action_idx(executable);
}

/// Deletes a RestrictAction from an expired intent.
public fun delete_restrict(expired: &mut Expired) {
    let _spec = intents::remove_action_spec(expired);
    // ActionSpec has drop, automatically cleaned up
}

// === Package Funtions ===

/// Borrows the UpgradeCap for a given package address.
public(package) fun borrow_cap<Config>(
    account: &Account<Config>, 
    package_addr: address
): &UpgradeCap {
    let name = get_package_name(account, package_addr);
    account.borrow_managed_asset(UpgradeCapKey(name), version::current())
}
/// Common utilities for time-based streaming/vesting functionality.
/// Shared between vault streams and vesting modules to avoid duplication.
///
/// === Fork Addition (BSL 1.1 Licensed) ===
/// Created to consolidate common logic for streaming/vesting calculations.
/// This module was added to the original Move framework to:
/// 1. Eliminate code duplication between vault.move and vesting.move
/// 2. Provide consistent vesting math across all time-based payment features
/// 3. Enable future modules to leverage tested streaming calculations
/// 4. Support advanced features like cliff periods, pausing, and rate limiting
///
/// Key shared functionality:
/// - Linear vesting calculations with overflow protection
/// - Cliff period support for delayed vesting starts
/// - Pause duration tracking for accurate vesting adjustments
/// - Rate limiting checks for withdrawal protection
/// - Effective time calculations accounting for pauses
/// - Vested/unvested split calculations for cancellations
///
/// This enables both vault streams and standalone vestings to have:
/// - Consistent mathematical accuracy
/// - Shared security validations
/// - Unified approach to time-based fund releases

module account_actions::stream_utils;

// === Imports ===

use std::u128;

// === Constants ===

public fun max_beneficiaries(): u64 { 100 }

// === Vesting Calculation Functions ===

/// Calculates linearly vested amount based on time elapsed
public fun calculate_linear_vested(
    total_amount: u64,
    start_time: u64,
    end_time: u64,
    current_time: u64,
): u64 {
    if (current_time < start_time) return 0;
    if (current_time >= end_time) return total_amount;
    
    let duration = end_time - start_time;
    let elapsed = current_time - start_time;
    
    // Use u128 to prevent overflow in multiplication
    let vested = (total_amount as u128) * (elapsed as u128) / (duration as u128);
    (vested as u64)
}

/// Calculates vested amount with cliff period
public fun calculate_vested_with_cliff(
    total_amount: u64,
    start_time: u64,
    end_time: u64,
    cliff_time: u64,
    current_time: u64,
): u64 {
    // Nothing vests before cliff
    if (current_time < cliff_time) return 0;
    
    // After cliff, calculate linear vesting
    calculate_linear_vested(total_amount, start_time, end_time, current_time)
}

/// Calculates effective time accounting for pause duration
public fun calculate_effective_time(
    current_time: u64,
    end_time: u64,
    paused_duration: u64,
): u64 {
    let effective_end = end_time + paused_duration;
    if (current_time > effective_end) {
        effective_end
    } else {
        current_time
    }
}

/// Validates stream/vesting parameters
public fun validate_time_parameters(
    start_time: u64,
    end_time: u64,
    cliff_time_opt: &Option<u64>,
    current_time: u64,
): bool {
    // End must be after start
    if (end_time <= start_time) return false;
    
    // Start must be in future or present
    if (start_time < current_time) return false;
    
    // If cliff exists, must be between start and end
    if (cliff_time_opt.is_some()) {
        let cliff = *cliff_time_opt.borrow();
        if (cliff < start_time || cliff > end_time) return false;
    };
    
    true
}

/// Calculates pause duration between two timestamps
public fun calculate_pause_duration(
    paused_at: u64,
    resumed_at: u64,
): u64 {
    if (resumed_at > paused_at) {
        resumed_at - paused_at
    } else {
        0
    }
}

/// Checks if withdrawal respects rate limiting
public fun check_rate_limit(
    last_withdrawal_time: u64,
    min_interval_ms: u64,
    current_time: u64,
): bool {
    if (min_interval_ms == 0 || last_withdrawal_time == 0) {
        true
    } else {
        current_time >= last_withdrawal_time + min_interval_ms
    }
}

/// Checks if withdrawal amount respects maximum limit
public fun check_withdrawal_limit(
    amount: u64,
    max_per_withdrawal: u64,
): bool {
    if (max_per_withdrawal == 0) {
        true
    } else {
        amount <= max_per_withdrawal
    }
}

/// Calculates available amount to claim
public fun calculate_claimable(
    total_amount: u64,
    claimed_amount: u64,
    start_time: u64,
    end_time: u64,
    current_time: u64,
    paused_duration: u64,
    cliff_time_opt: &Option<u64>,
): u64 {
    let effective_time = calculate_effective_time(
        current_time, 
        end_time, 
        paused_duration
    );
    
    let vested = if (cliff_time_opt.is_some()) {
        calculate_vested_with_cliff(
            total_amount,
            start_time,
            end_time + paused_duration,
            *cliff_time_opt.borrow(),
            effective_time
        )
    } else {
        calculate_linear_vested(
            total_amount,
            start_time,
            end_time + paused_duration,
            effective_time
        )
    };
    
    if (vested > claimed_amount) {
        vested - claimed_amount
    } else {
        0
    }
}

/// Splits vested and unvested amounts for cancellation
public fun split_vested_unvested(
    total_amount: u64,
    claimed_amount: u64,
    balance_remaining: u64,
    start_time: u64,
    end_time: u64,
    current_time: u64,
    paused_duration: u64,
    cliff_time_opt: &Option<u64>,
): (u64, u64, u64) {
    let effective_time = calculate_effective_time(
        current_time,
        end_time,
        paused_duration
    );
    
    let vested = if (cliff_time_opt.is_some()) {
        calculate_vested_with_cliff(
            total_amount,
            start_time,
            end_time + paused_duration,
            *cliff_time_opt.borrow(),
            effective_time
        )
    } else {
        calculate_linear_vested(
            total_amount,
            start_time,
            end_time + paused_duration,
            effective_time
        )
    };
    
    // Calculate amounts
    let unvested_claimed = if (claimed_amount > vested) {
        claimed_amount - vested
    } else {
        0
    };
    
    let to_pay_beneficiary = if (vested > claimed_amount) {
        let owed = vested - claimed_amount;
        if (owed > balance_remaining) {
            balance_remaining
        } else {
            owed
        }
    } else {
        0
    };
    
    let to_refund = if (balance_remaining > to_pay_beneficiary) {
        balance_remaining - to_pay_beneficiary
    } else {
        0
    };
    
    (to_pay_beneficiary, to_refund, unvested_claimed)
}

// === Test Helpers ===

#[test_only]
public fun test_linear_vesting() {
    // Test before start
    assert!(calculate_linear_vested(1000, 100, 200, 50) == 0);
    
    // Test at start
    assert!(calculate_linear_vested(1000, 100, 200, 100) == 0);
    
    // Test halfway
    assert!(calculate_linear_vested(1000, 100, 200, 150) == 500);
    
    // Test at end
    assert!(calculate_linear_vested(1000, 100, 200, 200) == 1000);
    
    // Test after end
    assert!(calculate_linear_vested(1000, 100, 200, 250) == 1000);
}

#[test_only]
public fun test_cliff_vesting() {
    // Test before cliff
    assert!(calculate_vested_with_cliff(1000, 100, 200, 130, 120) == 0);
    
    // Test at cliff
    assert!(calculate_vested_with_cliff(1000, 100, 200, 130, 130) == 300);
    
    // Test after cliff
    assert!(calculate_vested_with_cliff(1000, 100, 200, 130, 150) == 500);
}

#[test_only]
public fun test_effective_time() {
    // Test no pause
    assert!(calculate_effective_time(150, 200, 0) == 150);
    
    // Test with pause, before adjusted end
    assert!(calculate_effective_time(150, 200, 50) == 150);
    
    // Test with pause, after adjusted end
    assert!(calculate_effective_time(300, 200, 50) == 250);
}// ============================================================================
// FORK MODIFICATION NOTICE - Vault Management with Serialize-Then-Destroy Pattern
// ============================================================================
// This module manages multi-vault treasury operations with streaming support.
//
// CHANGES IN THIS FORK:
// - Actions use type markers: VaultDeposit, VaultSpend
// - Added hot potato result types (SpendResult) for zero-cost action chaining
// - Implemented serialize-then-destroy pattern for resource safety
// - Added destruction functions for all action structs
// - Actions serialize to bytes before adding to intent via add_typed_action()
// - Enhanced BCS validation: version checks + validate_all_bytes_consumed
// - Type-safe action validation through compile-time TypeName comparison
// ============================================================================
/// Members can create multiple vaults with different balances and managers (using roles).
/// This allows for a more flexible and granular way to manage funds.
///
/// === Fork Modifications (BSL 1.1 Licensed) ===
/// Enhanced vault module with comprehensive streaming functionality:
/// - Added generic stream management capabilities:
///   * Multiple beneficiaries support (primary + additional)
///   * Pause/resume functionality with duration tracking
///   * Stream metadata for extensibility
///   * Transferability and cancellability settings
///   * Beneficiary management (add/remove/transfer)
///   * Amount reduction capability
/// - Maintains backward compatibility with existing vault operations
/// - Enables other modules to build on top without duplicating stream state
/// - VaultStream: Time-based streaming with rate limiting for controlled treasury withdrawals
/// - Permissionless deposits: Anyone can add to existing coin types (enables revenue/donations)
/// - Stream management: Create, withdraw from, and cancel streams with proper vesting math
/// - All funds remain in vault until withdrawn (no separate vesting objects)
///
/// === Integration with Shared Utilities ===
/// As of the latest refactor, vault streams now use the shared stream_utils module
/// for all vesting calculations. This ensures:
/// - Consistent math with standalone vesting module
/// - Reduced code duplication and maintenance burden
/// - Unified approach to time-based fund releases
/// - Shared security validations and overflow protection
///
/// Note: The vesting.move module has been restored and enhanced to provide
/// standalone vesting functionality. Vault streams are for treasury-managed
/// streaming payments, while vestings are for independent token locks.
///
/// These changes enable DAOs to:
/// 1. Grant time-limited treasury access without full custody
/// 2. Implement salary/grant payments that vest over time
/// 3. Accept permissionless revenue deposits from protocols
/// 4. Enforce withdrawal limits and cooling periods for security
/// 5. Choose between vault-managed streams or standalone vestings

module account_actions::vault;

// === Imports ===

use std::{
    string::String,
    type_name::TypeName,
    option::Option,
    u128,
    u64,
};
use sui::{
    bag::{Self, Bag},
    balance::Balance,
    coin::{Self, Coin},
    table::{Self, Table},
    clock::Clock,
    event,
    object::{Self, ID},
    transfer,
    tx_context,
    bcs,
};
use account_protocol::{
    account::{Self, Account, Auth},
    intents::{Self, Expired, Intent},
    executable::{Self, Executable},
    version_witness::VersionWitness,
    bcs_validation,
    action_validation,
};
use account_actions::version;
use account_extensions::framework_action_types::{Self, VaultDeposit, VaultSpend};
use account_protocol::action_results::{Self, SpendResult};

// === Use Fun Aliases ===
// Removed - add_typed_action is now called directly

// === Errors ===

const EVaultNotEmpty: u64 = 0;
const EStreamNotFound: u64 = 1;
const EStreamNotStarted: u64 = 2;
const EStreamCliffNotReached: u64 = 3;
const EUnauthorizedBeneficiary: u64 = 4;
const EWrongCoinType: u64 = 5;
const EWithdrawalLimitExceeded: u64 = 6;
const EWithdrawalTooSoon: u64 = 7;
const EInsufficientVestedAmount: u64 = 8;
const EInvalidStreamParameters: u64 = 9;
const EIntentAmountMismatch: u64 = 10;
// === Fork additions ===
const EStreamPaused: u64 = 11;
const EStreamNotPaused: u64 = 12;
const ENotTransferable: u64 = 13;
const ENotCancellable: u64 = 14;
const EBeneficiaryAlreadyExists: u64 = 15;
const EBeneficiaryNotFound: u64 = 16;
const EUnsupportedActionVersion: u64 = 17;
const ECannotReduceBelowClaimed: u64 = 18;
const ETooManyBeneficiaries: u64 = 19;

// === Constants ===
const MAX_BENEFICIARIES: u64 = 100;

// === Structs ===

/// Dynamic Field key for the Vault.
public struct VaultKey(String) has copy, drop, store;
/// Dynamic field holding a budget with different coin types, key is name
public struct Vault has store {
    // heterogeneous array of Balances, TypeName -> Balance<CoinType>
    bag: Bag,
    // streams for time-based vesting withdrawals
    streams: Table<ID, VaultStream>,
}

/// Stream for time-based vesting from vault
/// === Fork Enhancement ===
/// Added generic stream management features:
/// - Multiple beneficiaries support
/// - Stream pausing/resuming
/// - Metadata for extensibility
/// - Transfer and reduction capabilities
public struct VaultStream has store {
    id: ID,
    coin_type: TypeName,
    beneficiary: address,  // Primary beneficiary
    // Core vesting parameters
    total_amount: u64,
    claimed_amount: u64,
    start_time: u64,
    end_time: u64,
    cliff_time: Option<u64>,
    // Rate limiting
    max_per_withdrawal: u64,
    min_interval_ms: u64,
    last_withdrawal_time: u64,
    // === Fork additions for generic stream management ===
    // Multiple beneficiaries support
    additional_beneficiaries: vector<address>,
    max_beneficiaries: u64,  // Configurable per stream
    // Pause functionality
    is_paused: bool,
    paused_at: Option<u64>,
    paused_duration: u64,  // Total time paused (affects vesting calculation)
    // Metadata for extensibility
    metadata: Option<String>,
    // Transfer settings
    is_transferable: bool,
    is_cancellable: bool,
}

// === Fork: Event Structs for Stream Operations ===

/// Emitted when a stream is created
public struct StreamCreated has copy, drop {
    stream_id: ID,
    beneficiary: address,
    total_amount: u64,
    coin_type: TypeName,
    start_time: u64,
    end_time: u64,
}

/// Emitted when funds are withdrawn from a stream
public struct StreamWithdrawal has copy, drop {
    stream_id: ID,
    beneficiary: address,
    amount: u64,
    remaining_vested: u64,
}

/// Emitted when a stream is cancelled
public struct StreamCancelled has copy, drop {
    stream_id: ID,
    refunded_amount: u64,
    final_payment: u64,
}

/// Emitted when a stream is paused
public struct StreamPaused has copy, drop {
    stream_id: ID,
    paused_at: u64,
}

/// Emitted when a stream is resumed
public struct StreamResumed has copy, drop {
    stream_id: ID,
    resumed_at: u64,
    pause_duration: u64,
}

/// Emitted when a beneficiary is added
public struct BeneficiaryAdded has copy, drop {
    stream_id: ID,
    new_beneficiary: address,
}

/// Emitted when a beneficiary is removed
public struct BeneficiaryRemoved has copy, drop {
    stream_id: ID,
    removed_beneficiary: address,
}

/// Emitted when a stream is transferred
public struct StreamTransferred has copy, drop {
    stream_id: ID,
    old_beneficiary: address,
    new_beneficiary: address,
}

/// Emitted when stream metadata is updated
public struct StreamMetadataUpdated has copy, drop {
    stream_id: ID,
}

/// Emitted when stream amount is reduced
public struct StreamAmountReduced has copy, drop {
    stream_id: ID,
    old_amount: u64,
    new_amount: u64,
}

/// Action to deposit an amount of this coin to the targeted Vault.
public struct DepositAction<phantom CoinType> has store {
    // vault name
    name: String,
    // exact amount to be deposited
    amount: u64,
}
/// Action to be used within intent making good use of the returned coin, similar to owned::withdraw.
public struct SpendAction<phantom CoinType> has store {
    // vault name
    name: String,
    // amount to withdraw
    amount: u64,
}

// === Public Functions ===

/// Authorized address can open a vault.
public fun open<Config>(
    auth: Auth,
    account: &mut Account<Config>,
    name: String,
    ctx: &mut TxContext
) {
    account.verify(auth);

    account.add_managed_data(VaultKey(name), Vault { 
        bag: bag::new(ctx),
        streams: table::new(ctx),
    }, version::current());
}

/// Deposits coins owned by a an authorized address into a vault.
public fun deposit<Config, CoinType: drop>(
    auth: Auth,
    account: &mut Account<Config>,
    name: String, 
    coin: Coin<CoinType>, 
) {
    account.verify(auth);

    let vault: &mut Vault = 
        account.borrow_managed_data_mut(VaultKey(name), version::current());

    if (vault.coin_type_exists<CoinType>()) {
        let balance_mut = vault.bag.borrow_mut<_, Balance<_>>(type_name::with_defining_ids<CoinType>());
        balance_mut.join(coin.into_balance());
    } else {
        vault.bag.add(type_name::with_defining_ids<CoinType>(), coin.into_balance());
    };
}

/// Permissionless deposit - anyone can add to existing coin types
/// Safe because it only increases DAO assets, never decreases
public fun deposit_permissionless<Config, CoinType: drop>(
    account: &mut Account<Config>,
    name: String,
    coin: Coin<CoinType>,
) {
    let vault: &mut Vault = 
        account.borrow_managed_data_mut(VaultKey(name), version::current());
    
    // Only allow deposits to existing coin types
    assert!(coin_type_exists<CoinType>(vault), EWrongCoinType);
    
    let balance_mut = vault.bag.borrow_mut<_, Balance<_>>(type_name::with_defining_ids<CoinType>());
    balance_mut.join(coin.into_balance());
}

/// Closes the vault if empty.
public fun close<Config>(
    auth: Auth,
    account: &mut Account<Config>,
    name: String,
) {
    account.verify(auth);

    let Vault { bag, streams } = 
        account.remove_managed_data(VaultKey(name), version::current());
    assert!(bag.is_empty(), EVaultNotEmpty);
    assert!(streams.is_empty(), EVaultNotEmpty);
    bag.destroy_empty();
    streams.destroy_empty();
}

/// Returns true if the vault exists.
public fun has_vault<Config>(
    account: &Account<Config>, 
    name: String
): bool {
    account.has_managed_data(VaultKey(name))
}

/// Returns a reference to the vault.
public fun borrow_vault<Config>(
    account: &Account<Config>, 
    name: String
): &Vault {
    account.borrow_managed_data(VaultKey(name), version::current())
}

/// Returns the number of coin types in the vault.
public fun size(vault: &Vault): u64 {
    vault.bag.length()
}

/// Returns true if the coin type exists in the vault.
public fun coin_type_exists<CoinType: drop>(vault: &Vault): bool {
    vault.bag.contains(type_name::with_defining_ids<CoinType>())
}

/// Returns the value of the coin type in the vault.
public fun coin_type_value<CoinType: drop>(vault: &Vault): u64 {
    vault.bag.borrow<TypeName, Balance<CoinType>>(type_name::with_defining_ids<CoinType>()).value()
}

// === Destruction Functions ===

/// Destroy a DepositAction after serialization
public fun destroy_deposit_action<CoinType>(action: DepositAction<CoinType>) {
    let DepositAction { name: _, amount: _ } = action;
}

/// Destroy a SpendAction after serialization
public fun destroy_spend_action<CoinType>(action: SpendAction<CoinType>) {
    let SpendAction { name: _, amount: _ } = action;
}

// Intent functions

/// Creates a DepositAction and adds it to an intent with descriptor.
public fun new_deposit<Outcome, CoinType, IW: drop>(
    intent: &mut Intent<Outcome>,
    name: String,
    amount: u64,
    intent_witness: IW,
) {
    // Create the action struct (no drop)
    let action = DepositAction<CoinType> { name, amount };

    // Serialize it
    let action_data = bcs::to_bytes(&action);

    // Add to intent with pre-serialized bytes
    intent.add_typed_action(
        framework_action_types::vault_deposit(),
        action_data,
        intent_witness
    );

    // Explicitly destroy the action struct
    destroy_deposit_action(action);
}

/// Processes a DepositAction and deposits a coin to the vault.
public fun do_deposit<Config, Outcome: store, CoinType: drop, IW: drop>(
    executable: &mut Executable<Outcome>,
    account: &mut Account<Config>,
    coin: Coin<CoinType>,
    version_witness: VersionWitness,
    _intent_witness: IW,
) {
    executable.intent().assert_is_account(account.addr());

    // Get BCS bytes from ActionSpec
    let specs = executable.intent().action_specs();
    let spec = specs.borrow(executable.action_idx());

    // CRITICAL: Assert that the action type is what we expect
    action_validation::assert_action_type<VaultDeposit>(spec);

    let action_data = intents::action_spec_data(spec);

    // Check version before deserialization
    let spec_version = intents::action_spec_version(spec);
    assert!(spec_version == 1, EUnsupportedActionVersion);

    // Create BCS reader and deserialize
    let mut reader = bcs::new(*action_data);
    let name = std::string::utf8(bcs::peel_vec_u8(&mut reader));
    let amount = bcs::peel_u64(&mut reader);

    // CRITICAL: Validate all bytes consumed to prevent trailing data attacks
    bcs_validation::validate_all_bytes_consumed(reader);

    assert!(amount == coin.value(), EIntentAmountMismatch);

    let vault: &mut Vault = account.borrow_managed_data_mut(VaultKey(name), version_witness);
    if (!vault.coin_type_exists<CoinType>()) {
        vault.bag.add(type_name::with_defining_ids<CoinType>(), coin.into_balance());
    } else {
        let balance_mut = vault.bag.borrow_mut<_, Balance<_>>(type_name::with_defining_ids<CoinType>());
        balance_mut.join(coin.into_balance());
    };

    // Increment action index
    executable::increment_action_idx(executable);
}

/// Deletes a DepositAction from an expired intent.
public fun delete_deposit<CoinType>(expired: &mut Expired) {
    let _spec = intents::remove_action_spec(expired);
    // ActionSpec has drop, so it's automatically cleaned up
    // No need to deserialize the data
}

/// Creates a SpendAction and adds it to an intent with descriptor.
public fun new_spend<Outcome, CoinType, IW: drop>(
    intent: &mut Intent<Outcome>,
    name: String,
    amount: u64,
    intent_witness: IW,
) {
    // Create the action struct (no drop)
    let action = SpendAction<CoinType> { name, amount };

    // Serialize it
    let action_data = bcs::to_bytes(&action);

    // Add to intent with pre-serialized bytes
    intent.add_typed_action(
        framework_action_types::vault_spend(),
        action_data,
        intent_witness
    );

    // Explicitly destroy the action struct
    destroy_spend_action(action);
}

/// Processes a SpendAction and takes a coin from the vault.
public fun do_spend<Config, Outcome: store, CoinType: drop, IW: drop>(
    executable: &mut Executable<Outcome>,
    account: &mut Account<Config>,
    version_witness: VersionWitness,
    _intent_witness: IW,
    ctx: &mut TxContext
): (Coin<CoinType>, SpendResult) {
    executable.intent().assert_is_account(account.addr());

    // Get BCS bytes from ActionSpec
    let specs = executable.intent().action_specs();
    let spec = specs.borrow(executable.action_idx());

    // CRITICAL: Assert that the action type is what we expect
    action_validation::assert_action_type<VaultSpend>(spec);

    let action_data = intents::action_spec_data(spec);

    // Check version before deserialization
    let spec_version = intents::action_spec_version(spec);
    assert!(spec_version == 1, EUnsupportedActionVersion);

    // Create BCS reader and deserialize
    let mut reader = bcs::new(*action_data);
    let name = std::string::utf8(bcs::peel_vec_u8(&mut reader));
    let amount = bcs::peel_u64(&mut reader);

    // CRITICAL: Validate all bytes consumed to prevent trailing data attacks
    bcs_validation::validate_all_bytes_consumed(reader);

    let vault: &mut Vault = account.borrow_managed_data_mut(VaultKey(name), version_witness);
    let balance_mut = vault.bag.borrow_mut<_, Balance<_>>(type_name::with_defining_ids<CoinType>());
    let coin = coin::take(balance_mut, amount, ctx);

    if (balance_mut.value() == 0)
        vault.bag.remove<_, Balance<CoinType>>(type_name::with_defining_ids<CoinType>()).destroy_zero();

    // Create result for hot potato chaining
    let result = action_results::new_spend_result(
        object::id(&coin),
        amount,
        name
    );

    // Increment action index
    executable::increment_action_idx(executable);
    (coin, result)
}

/// Deletes a SpendAction from an expired intent.
public fun delete_spend<CoinType>(expired: &mut Expired) {
    let _spec = intents::remove_action_spec(expired);
    // ActionSpec has drop, so it's automatically cleaned up
    // No need to deserialize the data
}

// ============================================================================
// FORK MODIFICATION NOTICE - Currency Management with Serialize-Then-Destroy Pattern
// ============================================================================
// This module manages TreasuryCap and CoinMetadata operations for Account.
//
// CHANGES IN THIS FORK:
// - Actions use type markers: CurrencyMint, CurrencyBurn, CurrencyUpdate, CurrencyDisable
// - Added hot potato result types (MintResult) for zero-cost action chaining
// - Implemented serialize-then-destroy pattern for all 4 action types
// - Added destruction functions: destroy_mint_action, destroy_burn_action, etc.
// - Actions serialize to bytes before adding to intent via add_typed_action()
// - Enhanced BCS validation: version checks + validate_all_bytes_consumed
// - Type-safe action validation through compile-time TypeName comparison
// ============================================================================
/// Authenticated users can lock a TreasuryCap in the Account to restrict minting and burning operations,
/// as well as modifying the CoinMetadata.

module account_actions::currency;

// === Imports ===

use std::{
    string::{Self, String},
    ascii,
    option,

};
use sui::{
    coin::{Self, Coin, TreasuryCap, CoinMetadata},
    url::{Self, Url},
    bcs,
    object,
};
use account_protocol::{
    action_validation,
    account::{Self, Account, Auth},
    intents::{Self, Expired, Intent},
    executable::{Self, Executable},
    version_witness::VersionWitness,
    bcs_validation,
};
use account_actions::{
    currency,
    version
};
use account_extensions::framework_action_types::{Self, CurrencyDisable, CurrencyMint, CurrencyBurn, CurrencyUpdate};
use account_protocol::action_results::{Self, MintResult};
// === Use Fun Aliases ===
// Removed - add_typed_action is now called directly

// === Errors ===

const ENoChange: u64 = 0;
const EWrongValue: u64 = 1;
const EMintDisabled: u64 = 2;
const EBurnDisabled: u64 = 3;
const ECannotUpdateName: u64 = 4;
const ECannotUpdateSymbol: u64 = 5;
const ECannotUpdateDescription: u64 = 6;
const ECannotUpdateIcon: u64 = 7;
const EMaxSupply: u64 = 8;
const EUnsupportedActionVersion: u64 = 9;

// === Structs ===    

/// Dynamic Object Field key for the TreasuryCap.
public struct TreasuryCapKey<phantom CoinType>() has copy, drop, store;
/// Dynamic Field key for the CurrencyRules.
public struct CurrencyRulesKey<phantom CoinType>() has copy, drop, store;
/// Dynamic Field wrapper restricting access to a TreasuryCap, permissions are disabled forever if set.
public struct CurrencyRules<phantom CoinType> has store {
    // coin can have a fixed supply, can_mint must be true to be able to mint more
    max_supply: Option<u64>,
    // total amount minted
    total_minted: u64,
    // total amount burned
    total_burned: u64,
    // permissions
    can_mint: bool,
    can_burn: bool,
    can_update_symbol: bool,
    can_update_name: bool,
    can_update_description: bool,
    can_update_icon: bool,
}

/// Action disabling permissions marked as true, cannot be reenabled.
public struct DisableAction<phantom CoinType> has store {
    mint: bool,
    burn: bool,
    update_symbol: bool,
    update_name: bool,
    update_description: bool,
    update_icon: bool,
}
/// Action minting new coins.
public struct MintAction<phantom CoinType> has store {
    amount: u64,
}
/// Action burning coins.
public struct BurnAction<phantom CoinType> has store {
    amount: u64,
}
/// Action updating a CoinMetadata object using a locked TreasuryCap.
public struct UpdateAction<phantom CoinType> has store { 
    symbol: Option<ascii::String>,
    name: Option<String>,
    description: Option<String>,
    icon_url: Option<ascii::String>,
}

// === Public functions ===

/// Authenticated users can lock a TreasuryCap.
public fun lock_cap<Config, CoinType>(
    auth: Auth,
    account: &mut Account<Config>,
    treasury_cap: TreasuryCap<CoinType>,
    max_supply: Option<u64>,
) {
    account.verify(auth);

    let rules = CurrencyRules<CoinType> { 
        max_supply,
        total_minted: 0,
        total_burned: 0,
        can_mint: true,
        can_burn: true,
        can_update_symbol: true,
        can_update_name: true,
        can_update_description: true,
        can_update_icon: true,
    };
    account.add_managed_data(CurrencyRulesKey<CoinType>(), rules, version::current());
    account.add_managed_asset(TreasuryCapKey<CoinType>(), treasury_cap, version::current());
}

/// Checks if a TreasuryCap exists for a given coin type.
public fun has_cap<Config, CoinType>(
    account: &Account<Config>
): bool {
    account.has_managed_asset(TreasuryCapKey<CoinType>())
}

/// Borrows the CurrencyRules for a given coin type.
public fun borrow_rules<Config, CoinType>(
    account: &Account<Config>
): &CurrencyRules<CoinType> {
    account.borrow_managed_data(CurrencyRulesKey<CoinType>(), version::current())
}

/// Returns the total supply of a given coin type.
public fun coin_type_supply<Config, CoinType>(account: &Account<Config>): u64 {
    let cap: &TreasuryCap<CoinType> = 
        account.borrow_managed_asset(TreasuryCapKey<CoinType>(), version::current());
    cap.total_supply()
}

/// Returns the maximum supply of a given coin type.
public fun max_supply<CoinType>(lock: &CurrencyRules<CoinType>): Option<u64> {
    lock.max_supply
}

/// Returns the total amount minted of a given coin type.
public fun total_minted<CoinType>(lock: &CurrencyRules<CoinType>): u64 {
    lock.total_minted
}

/// Returns the total amount burned of a given coin type.
public fun total_burned<CoinType>(lock: &CurrencyRules<CoinType>): u64 {
    lock.total_burned
}

/// Returns true if the coin type can mint.
public fun can_mint<CoinType>(lock: &CurrencyRules<CoinType>): bool {
    lock.can_mint
}

/// Returns true if the coin type can burn.
public fun can_burn<CoinType>(lock: &CurrencyRules<CoinType>): bool {
    lock.can_burn
}

/// Returns true if the coin type can update the symbol.
public fun can_update_symbol<CoinType>(lock: &CurrencyRules<CoinType>): bool {
    lock.can_update_symbol
}

/// Returns true if the coin type can update the name.
public fun can_update_name<CoinType>(lock: &CurrencyRules<CoinType>): bool {
    lock.can_update_name
}

/// Returns true if the coin type can update the description.
public fun can_update_description<CoinType>(lock: &CurrencyRules<CoinType>): bool {
    lock.can_update_description
}

/// Returns true if the coin type can update the icon.
public fun can_update_icon<CoinType>(lock: &CurrencyRules<CoinType>): bool {
    lock.can_update_icon
}

/// Anyone can burn coins they own if enabled.
public fun public_burn<Config, CoinType>(
    account: &mut Account<Config>, 
    coin: Coin<CoinType>
) {
    let rules_mut: &mut CurrencyRules<CoinType> = 
        account.borrow_managed_data_mut(CurrencyRulesKey<CoinType>(), version::current());
    assert!(rules_mut.can_burn, EBurnDisabled);
    rules_mut.total_burned = rules_mut.total_burned + coin.value();

    let cap_mut: &mut TreasuryCap<CoinType> = 
        account.borrow_managed_asset_mut(TreasuryCapKey<CoinType>(), version::current());
    cap_mut.burn(coin);
}

// === Destruction Functions ===

/// Destroy a DisableAction after serialization
public fun destroy_disable_action<CoinType>(action: DisableAction<CoinType>) {
    let DisableAction {
        mint: _,
        burn: _,
        update_symbol: _,
        update_name: _,
        update_description: _,
        update_icon: _
    } = action;
}

/// Destroy a MintAction after serialization
public fun destroy_mint_action<CoinType>(action: MintAction<CoinType>) {
    let MintAction { amount: _ } = action;
}

/// Destroy a BurnAction after serialization
public fun destroy_burn_action<CoinType>(action: BurnAction<CoinType>) {
    let BurnAction { amount: _ } = action;
}

/// Destroy an UpdateAction after serialization
public fun destroy_update_action<CoinType>(action: UpdateAction<CoinType>) {
    let UpdateAction {
        symbol: _,
        name: _,
        description: _,
        icon_url: _
    } = action;
}

// Intent functions

/// Creates a DisableAction and adds it to an intent.
public fun new_disable<Outcome, CoinType, IW: drop>(
    intent: &mut Intent<Outcome>,
    mint: bool,
    burn: bool,
    update_symbol: bool,
    update_name: bool,
    update_description: bool,
    update_icon: bool,
    intent_witness: IW,
) {
    assert!(mint || burn || update_symbol || update_name || update_description || update_icon, ENoChange);

    // Create the action struct (no drop)
    let action = DisableAction<CoinType> { mint, burn, update_symbol, update_name, update_description, update_icon };

    // Serialize it
    let action_data = bcs::to_bytes(&action);

    // Add to intent with pre-serialized bytes
    intent.add_typed_action(
        framework_action_types::currency_disable(),
        action_data,
        intent_witness
    );

    // Explicitly destroy the action struct
    destroy_disable_action(action);
}

/// Processes a DisableAction and disables the permissions marked as true.
public fun do_disable<Config, Outcome: store, CoinType, IW: drop>(
    executable: &mut Executable<Outcome>,
    account: &mut Account<Config>,
    version_witness: VersionWitness,
    _intent_witness: IW,
) {
    executable.intent().assert_is_account(account.addr());

    // Get BCS bytes from ActionSpec
    let specs = executable.intent().action_specs();
    let spec = specs.borrow(executable.action_idx());

    // CRITICAL: Assert that the action type is what we expect
    action_validation::assert_action_type<CurrencyDisable>(spec);


    let action_data = intents::action_spec_data(spec);

    // Check version before deserialization
    let spec_version = intents::action_spec_version(spec);
    assert!(spec_version == 1, EUnsupportedActionVersion);

    // Create BCS reader and deserialize
    let mut reader = bcs::new(*action_data);
    let mint = bcs::peel_bool(&mut reader);
    let burn = bcs::peel_bool(&mut reader);
    let update_symbol = bcs::peel_bool(&mut reader);
    let update_name = bcs::peel_bool(&mut reader);
    let update_description = bcs::peel_bool(&mut reader);
    let update_icon = bcs::peel_bool(&mut reader);

    // Validate all bytes consumed
    bcs_validation::validate_all_bytes_consumed(reader);

    let rules_mut: &mut CurrencyRules<CoinType> =
        account.borrow_managed_data_mut(CurrencyRulesKey<CoinType>(), version_witness);

    // if disabled, can be true or false, it has no effect
    if (mint) rules_mut.can_mint = false;
    if (burn) rules_mut.can_burn = false;
    if (update_symbol) rules_mut.can_update_symbol = false;
    if (update_name) rules_mut.can_update_name = false;
    if (update_description) rules_mut.can_update_description = false;
    if (update_icon) rules_mut.can_update_icon = false;

    // Increment action index
    executable::increment_action_idx(executable);
}

/// Deletes a DisableAction from an expired intent.
public fun delete_disable<CoinType>(expired: &mut Expired) {
    let _spec = intents::remove_action_spec(expired);
    // ActionSpec has drop, so it's automatically cleaned up
}

/// Creates an UpdateAction and adds it to an intent.
public fun new_update<Outcome, CoinType, IW: drop>(
    intent: &mut Intent<Outcome>,
    symbol: Option<ascii::String>,
    name: Option<String>,
    description: Option<String>,
    icon_url: Option<ascii::String>,
    intent_witness: IW,
) {
    assert!(symbol.is_some() || name.is_some() || description.is_some() || icon_url.is_some(), ENoChange);

    // Create the action struct (no drop)
    let action = UpdateAction<CoinType> { symbol, name, description, icon_url };

    // Serialize it
    let action_data = bcs::to_bytes(&action);

    // Add to intent with pre-serialized bytes
    intent.add_typed_action(
        framework_action_types::currency_update(),
        action_data,
        intent_witness
    );

    // Explicitly destroy the action struct
    destroy_update_action(action);
}

/// Processes an UpdateAction, updates the CoinMetadata.
public fun do_update<Config, Outcome: store, CoinType, IW: drop>(
    executable: &mut Executable<Outcome>,
    account: &mut Account<Config>,
    metadata: &mut CoinMetadata<CoinType>,
    version_witness: VersionWitness,
    _intent_witness: IW,
) {
    executable.intent().assert_is_account(account.addr());

    // Get BCS bytes from ActionSpec
    let specs = executable.intent().action_specs();
    let spec = specs.borrow(executable.action_idx());

    // CRITICAL: Assert that the action type is what we expect
    action_validation::assert_action_type<CurrencyUpdate>(spec);


    let action_data = intents::action_spec_data(spec);

    // Check version before deserialization
    let spec_version = intents::action_spec_version(spec);
    assert!(spec_version == 1, EUnsupportedActionVersion);

    // Create BCS reader and deserialize
    let mut reader = bcs::new(*action_data);

    // Deserialize Option fields
    let symbol = if (bcs::peel_bool(&mut reader)) {
        option::some(bcs::peel_vec_u8(&mut reader).to_ascii_string())
    } else {
        option::none()
    };

    let name = if (bcs::peel_bool(&mut reader)) {
        option::some(bcs::peel_vec_u8(&mut reader).to_string())
    } else {
        option::none()
    };

    let description = if (bcs::peel_bool(&mut reader)) {
        option::some(bcs::peel_vec_u8(&mut reader).to_string())
    } else {
        option::none()
    };

    let icon_url = if (bcs::peel_bool(&mut reader)) {
        option::some(bcs::peel_vec_u8(&mut reader).to_ascii_string())
    } else {
        option::none()
    };

    // Validate all bytes consumed
    bcs_validation::validate_all_bytes_consumed(reader);

    let rules_mut: &mut CurrencyRules<CoinType> =
        account.borrow_managed_data_mut(CurrencyRulesKey<CoinType>(), version_witness);

    if (!rules_mut.can_update_symbol) assert!(symbol.is_none(), ECannotUpdateSymbol);
    if (!rules_mut.can_update_name) assert!(name.is_none(), ECannotUpdateName);
    if (!rules_mut.can_update_description) assert!(description.is_none(), ECannotUpdateDescription);
    if (!rules_mut.can_update_icon) assert!(icon_url.is_none(), ECannotUpdateIcon);

    let (default_symbol, default_name, default_description, default_icon_url) =
        (metadata.get_symbol(), metadata.get_name(), metadata.get_description(), metadata.get_icon_url().extract().inner_url());
    let cap: &TreasuryCap<CoinType> =
        account.borrow_managed_asset(TreasuryCapKey<CoinType>(), version_witness);

    cap.update_symbol(metadata, symbol.get_with_default(default_symbol));
    cap.update_name(metadata, name.get_with_default(default_name));
    cap.update_description(metadata, description.get_with_default(default_description));
    cap.update_icon_url(metadata, icon_url.get_with_default(default_icon_url));

    // Increment action index
    executable::increment_action_idx(executable);
}

/// Deletes an UpdateAction from an expired intent.
public fun delete_update<CoinType>(expired: &mut Expired) {
    let _spec = intents::remove_action_spec(expired);
    // ActionSpec has drop, so it's automatically cleaned up
}

/// Creates a MintAction and adds it to an intent with descriptor.
public fun new_mint<Outcome, CoinType, IW: drop>(
    intent: &mut Intent<Outcome>,
    amount: u64,
    intent_witness: IW,
) {
    // Create the action struct (no drop)
    let action = MintAction<CoinType> { amount };

    // Serialize it
    let action_data = bcs::to_bytes(&action);

    // Add to intent with pre-serialized bytes
    intent.add_typed_action(
        framework_action_types::currency_mint(),
        action_data,
        intent_witness
    );

    // Explicitly destroy the action struct
    destroy_mint_action(action);
}

/// Processes a MintAction, mints and returns new coins.
public fun do_mint<Config, Outcome: store, CoinType, IW: drop>(
    executable: &mut Executable<Outcome>,
    account: &mut Account<Config>,
    version_witness: VersionWitness,
    _intent_witness: IW,
    ctx: &mut TxContext
): (Coin<CoinType>, MintResult) {
    executable.intent().assert_is_account(account.addr());

    // Get BCS bytes from ActionSpec
    let specs = executable.intent().action_specs();
    let spec = specs.borrow(executable.action_idx());

    // CRITICAL: Assert that the action type is what we expect
    action_validation::assert_action_type<CurrencyMint>(spec);


    let action_data = intents::action_spec_data(spec);

    // Check version before deserialization
    let spec_version = intents::action_spec_version(spec);
    assert!(spec_version == 1, EUnsupportedActionVersion);

    // Create BCS reader and deserialize
    let mut reader = bcs::new(*action_data);
    let amount = bcs::peel_u64(&mut reader);

    // Validate all bytes consumed
    bcs_validation::validate_all_bytes_consumed(reader);

    let total_supply = currency::coin_type_supply<_, CoinType>(account);
    let rules_mut: &mut CurrencyRules<CoinType> =
        account.borrow_managed_data_mut(CurrencyRulesKey<CoinType>(), version_witness);

    assert!(rules_mut.can_mint, EMintDisabled);
    if (rules_mut.max_supply.is_some()) assert!(amount + total_supply <= *rules_mut.max_supply.borrow(), EMaxSupply);

    rules_mut.total_minted = rules_mut.total_minted + amount;

    let cap_mut: &mut TreasuryCap<CoinType> =
        account.borrow_managed_asset_mut(TreasuryCapKey<CoinType>(), version_witness);

    // Mint the coin
    let coin = cap_mut.mint(amount, ctx);

    // Create result for hot potato chaining
    let result = action_results::new_mint_result(
        object::id(&coin),
        amount
    );

    // Increment action index
    executable::increment_action_idx(executable);

    (coin, result)
}

/// Deletes a MintAction from an expired intent.
public fun delete_mint<CoinType>(expired: &mut Expired) {
    let _spec = intents::remove_action_spec(expired);
    // ActionSpec has drop, so it's automatically cleaned up
}

/// Creates a BurnAction and adds it to an intent with descriptor.
public fun new_burn<Outcome, CoinType, IW: drop>(
    intent: &mut Intent<Outcome>,
    amount: u64,
    intent_witness: IW,
) {
    // Create the action struct
    let action = BurnAction<CoinType> { amount };

    // Serialize it
    let action_data = bcs::to_bytes(&action);

    // Add to intent with pre-serialized bytes
    intent.add_typed_action(
        framework_action_types::currency_burn(),
        action_data,
        intent_witness
    );

    // Explicitly destroy the action struct
    destroy_burn_action(action);
}

/// Processes a BurnAction, burns coins and returns the amount burned.
public fun do_burn<Config, Outcome: store, CoinType, IW: drop>(
    executable: &mut Executable<Outcome>,
    account: &mut Account<Config>,
    coin: Coin<CoinType>,
    version_witness: VersionWitness,
    _intent_witness: IW,
) {
    executable.intent().assert_is_account(account.addr());

    // Get BCS bytes from ActionSpec
    let specs = executable.intent().action_specs();
    let spec = specs.borrow(executable.action_idx());

    // CRITICAL: Assert that the action type is what we expect
    action_validation::assert_action_type<CurrencyBurn>(spec);


    let action_data = intents::action_spec_data(spec);

    // Check version before deserialization
    let spec_version = intents::action_spec_version(spec);
    assert!(spec_version == 1, EUnsupportedActionVersion);

    // Create BCS reader and deserialize
    let mut reader = bcs::new(*action_data);
    let amount = bcs::peel_u64(&mut reader);

    // Validate all bytes consumed
    bcs_validation::validate_all_bytes_consumed(reader);

    assert!(amount == coin.value(), EWrongValue);

    let rules_mut: &mut CurrencyRules<CoinType> =
        account.borrow_managed_data_mut(CurrencyRulesKey<CoinType>(), version_witness);
    assert!(rules_mut.can_burn, EBurnDisabled);

    rules_mut.total_burned = rules_mut.total_burned + amount;

    let cap_mut: &mut TreasuryCap<CoinType> =
        account.borrow_managed_asset_mut(TreasuryCapKey<CoinType>(), version_witness);

    // Increment action index
    executable::increment_action_idx(executable);

    cap_mut.burn(coin);
}

/// Deletes a BurnAction from an expired intent.
public fun delete_burn<CoinType>(expired: &mut Expired) {
    let _spec = intents::remove_action_spec(expired);
    // ActionSpec has drop, so it's automatically cleaned up
}

// ============================================================================
// FORK MODIFICATION NOTICE - Transfer with Serialize-Then-Destroy Pattern
// ============================================================================
// This module defines APIs to transfer assets owned or managed by Account.
//
// CHANGES IN THIS FORK:
// - TransferAction uses TransferObject type marker from framework_action_types
// - Implemented serialize-then-destroy pattern for resource safety
// - Added destroy_transfer_action function for explicit destruction
// - Actions serialize to bytes before adding to intent via add_typed_action()
// - Enhanced BCS validation: version checks + validate_all_bytes_consumed
// - Type-safe action validation through compile-time TypeName comparison
// ============================================================================
/// This module defines apis to transfer assets owned or managed by the account.
/// The intents can implement transfers for any action type (e.g. see owned or vault).

module account_actions::transfer;

// === Imports ===


use sui::bcs;
use account_protocol::{
    action_validation,
    intents::{Self, Expired, Intent},
    executable::{Self, Executable},
    bcs_validation,
};
use account_extensions::framework_action_types::{Self, TransferObject};

// === Use Fun Aliases ===
// Removed - add_typed_action is now called directly

// === Errors ===

const EUnsupportedActionVersion: u64 = 0;

// === Structs ===

/// Action used in combination with other actions (like WithdrawAction) to transfer objects to a recipient.
public struct TransferAction has store {
    // address to transfer to
    recipient: address,
}

// === Destruction Functions ===

/// Destroy a TransferAction after serialization
public fun destroy_transfer_action(action: TransferAction) {
    let TransferAction { recipient: _ } = action;
}

// === Public functions ===

/// Creates a TransferAction and adds it to an intent with descriptor.
public fun new_transfer<Outcome, IW: drop>(
    intent: &mut Intent<Outcome>,
    recipient: address,
    intent_witness: IW,
) {
    // Create the action struct (no drop)
    let action = TransferAction { recipient };

    // Serialize it
    let action_data = bcs::to_bytes(&action);

    // Add to intent with pre-serialized bytes
    intent.add_typed_action(
        framework_action_types::transfer_object(),
        action_data,
        intent_witness
    );

    // Explicitly destroy the action struct
    destroy_transfer_action(action);
}

/// Processes a TransferAction and transfers an object to a recipient.
public fun do_transfer<Outcome: store, T: key + store, IW: drop>(
    executable: &mut Executable<Outcome>,
    object: T,
    _intent_witness: IW,
) {
    // Get BCS bytes from ActionSpec
    let specs = executable.intent().action_specs();
    let spec = specs.borrow(executable.action_idx());

    // CRITICAL: Assert that the action type is what we expect
    action_validation::assert_action_type<TransferObject>(spec);


    let action_data = intents::action_spec_data(spec);

    // Check version before deserialization
    let spec_version = intents::action_spec_version(spec);
    assert!(spec_version == 1, EUnsupportedActionVersion);

    // Create BCS reader and deserialize
    let mut reader = bcs::new(*action_data);
    let recipient = bcs::peel_address(&mut reader);

    // Validate all bytes consumed
    bcs_validation::validate_all_bytes_consumed(reader);

    transfer::public_transfer(object, recipient);
    executable::increment_action_idx(executable);
}

/// Deletes a TransferAction from an expired intent.
public fun delete_transfer(expired: &mut Expired) {
    let _spec = intents::remove_action_spec(expired);
    // ActionSpec has drop, automatically cleaned up
}

// ============================================================================
// FORK MODIFICATION NOTICE - Access Control with Serialize-Then-Destroy Pattern
// ============================================================================
// This module manages capability-based access control for Account actions.
//
// CHANGES IN THIS FORK:
// - Actions use type markers: AccessControlBorrow, AccessControlReturn
// - Implemented serialize-then-destroy pattern for resource safety
// - Added destruction functions: destroy_borrow_action, destroy_return_action
// - Actions serialize to bytes before adding to intent via add_typed_action()
// - Enforces matching ReturnAction for every BorrowAction in intent
// - Type-safe action validation through compile-time TypeName comparison
// ============================================================================
/// Developers can restrict access to functions in their own package with a Cap that can be locked into an Account. 
/// The Cap can be borrowed upon approval and used in other move calls within the same ptb before being returned.
/// 
/// The Cap pattern uses the object type as a proof of access, the object ID is never checked.
/// Therefore, only one Cap of a given type can be locked into the Smart Account.
/// And any Cap of that type can be returned to the Smart Account after being borrowed.
/// 
/// A good practice to follow is to use a different Cap type for each function that needs to be restricted.
/// This way, the Cap borrowed can't be misused in another function, by the person executing the intent.
/// 
/// e.g.
/// 
/// public struct AdminCap has key, store {}
/// 
/// public fun foo(_: &AdminCap) { ... }

module account_actions::access_control;

// === Imports ===


use sui::bcs::{Self, BCS};
use account_protocol::{
    action_validation,
    account::{Account, Auth},
    intents::{Self, Expired, Intent},
    executable::{Self, Executable},
    version_witness::VersionWitness,
};
use account_actions::version;
use account_extensions::framework_action_types;

// === Use Fun Aliases ===
// Removed - add_typed_action is now called directly

// === Errors ===

/// BorrowAction requires a matching ReturnAction in the same intent to ensure capability is returned
const ENoReturn: u64 = 0;

// === Structs ===    

/// Dynamic Object Field key for the Cap.
public struct CapKey<phantom Cap>() has copy, drop, store;

/// Action giving access to the Cap.
public struct BorrowAction<phantom Cap> has drop, store {}
/// This hot potato is created upon approval to ensure the cap is returned.
public struct ReturnAction<phantom Cap> has drop, store {}

// === Public functions ===

/// Authenticated user can lock a Cap, the Cap must have at least store ability.
public fun lock_cap<Config, Cap: key + store>(
    auth: Auth,
    account: &mut Account<Config>,
    cap: Cap,
) {
    account.verify(auth);
    account.add_managed_asset(CapKey<Cap>(), cap, version::current());
}

/// Checks if there is a Cap locked for a given type.
public fun has_lock<Config, Cap>(
    account: &Account<Config>
): bool {
    account.has_managed_asset(CapKey<Cap>())
}

// === Destruction Functions ===

/// Destroy a BorrowAction after serialization
public fun destroy_borrow_action<Cap>(action: BorrowAction<Cap>) {
    let BorrowAction {} = action;
}

/// Destroy a ReturnAction after serialization
public fun destroy_return_action<Cap>(action: ReturnAction<Cap>) {
    let ReturnAction {} = action;
}

// Intent functions

/// Creates and returns a BorrowAction.
public fun new_borrow<Outcome, Cap, IW: drop>(
    intent: &mut Intent<Outcome>,
    intent_witness: IW,
) {
    // Create the action struct
    let action = BorrowAction<Cap> {};

    // Serialize it
    let action_data = bcs::to_bytes(&action);

    // Add to intent with pre-serialized bytes
    intent.add_typed_action(
        framework_action_types::access_control_borrow(),
        action_data,
        intent_witness
    );

    // Explicitly destroy the action struct
    destroy_borrow_action(action);
}

/// Processes a BorrowAction and returns a Borrowed hot potato and the Cap.
public fun do_borrow<Config, Outcome: store, Cap: key + store, IW: drop>(
    executable: &mut Executable<Outcome>,
    account: &mut Account<Config>,
    version_witness: VersionWitness,
    _intent_witness: IW,
): Cap {
    executable.intent().assert_is_account(account.addr());

    // Get BCS bytes from ActionSpec and verify it's a BorrowAction
    let specs = executable.intent().action_specs();
    let spec = specs.borrow(executable.action_idx());

    // CRITICAL: Assert that the action type is what we expect
    action_validation::assert_action_type<framework_action_types::AccessControlBorrow>(spec);


    let _action_data = intents::action_spec_data(spec);

    // CRITICAL: Verify that a matching ReturnAction exists in the intent
    // This ensures the borrowed capability will be returned
    let current_idx = executable.action_idx();
    let mut return_found = false;
    let return_action_type = action_validation::get_action_type_name<framework_action_types::AccessControlReturn>();

    // Search from the next action onwards
    let mut i = current_idx + 1;
    while (i < specs.length()) {
        let future_spec = specs.borrow(i);
        if (intents::action_spec_type(future_spec) == return_action_type) {
            return_found = true;
            break
        };
        i = i + 1;
    };

    assert!(return_found, ENoReturn);

    // For BorrowAction<Cap>, there's no data to deserialize (empty struct)
    // Just increment the action index
    executable::increment_action_idx(executable);

    account.remove_managed_asset(CapKey<Cap>(), version_witness)
}

/// Deletes a BorrowAction from an expired intent.
public fun delete_borrow<Cap>(expired: &mut Expired) {
    let _spec = intents::remove_action_spec(expired);
    // ActionSpec has drop, automatically cleaned up
}

/// Creates and returns a ReturnAction.
public fun new_return<Outcome, Cap, IW: drop>(
    intent: &mut Intent<Outcome>,
    intent_witness: IW,
) {
    // Create the action struct
    let action = ReturnAction<Cap> {};

    // Serialize it
    let action_data = bcs::to_bytes(&action);

    // Add to intent with pre-serialized bytes
    intent.add_typed_action(
        framework_action_types::access_control_return(),
        action_data,
        intent_witness
    );

    // Explicitly destroy the action struct
    destroy_return_action(action);
}

/// Returns a Cap to the Account and validates the ReturnAction.
public fun do_return<Config, Outcome: store, Cap: key + store, IW: drop>(
    executable: &mut Executable<Outcome>,
    account: &mut Account<Config>,
    cap: Cap,
    version_witness: VersionWitness,
    _intent_witness: IW,
) {
    executable.intent().assert_is_account(account.addr());

    // Get BCS bytes from ActionSpec and verify it's a ReturnAction
    let specs = executable.intent().action_specs();
    let spec = specs.borrow(executable.action_idx());

    // CRITICAL: Assert that the action type is what we expect
    action_validation::assert_action_type<framework_action_types::AccessControlReturn>(spec);


    let _action_data = intents::action_spec_data(spec);

    // For ReturnAction<Cap>, there's no data to deserialize (empty struct)
    // Just increment the action index
    executable::increment_action_idx(executable);

    account.add_managed_asset(CapKey<Cap>(), cap, version_witness);
}

/// Deletes a ReturnAction from an expired intent.
public fun delete_return<Cap>(expired: &mut Expired) {
    let _spec = intents::remove_action_spec(expired);
    // ActionSpec has drop, automatically cleaned up
}
// ============================================================================
// FORK MODIFICATION NOTICE - Vesting with Serialize-Then-Destroy Pattern
// ============================================================================
// This module provides comprehensive vesting functionality with streaming.
//
// CHANGES IN THIS FORK:
// - Actions use type markers: VestingCreate, VestingCancel
// - Implemented serialize-then-destroy pattern for both action types
// - Added destruction functions: destroy_create_vesting_action, destroy_cancel_vesting_action
// - Actions serialize to bytes before adding to intent via add_typed_action()
// - Comprehensive vesting features: cliff periods, multiple beneficiaries, pausable
// - Type-safe action validation through compile-time TypeName comparison
//
// COMPOSABILITY IMPROVEMENTS (2025-09-14):
// - claim_vesting() now returns Coin<CoinType> for PTB composability
// - Added claim_vesting_to() for direct transfers to recipients
// - Added claim_vesting_to_self() convenience function
// - Added batch claim functions: claim_two_vestings(), claim_three_vestings()
// - Fixed design flaw: separated authorization from payment destination
// ============================================================================
/// This module provides comprehensive vesting functionality similar to vault streams.
/// A vesting has configurable parameters for maximum flexibility:
/// - Multiple beneficiaries support
/// - Pause/resume functionality
/// - Metadata for extensibility
/// - Transfer and cancellation settings
/// - Cliff periods and rate limiting
///
/// === Fork Enhancement (BSL 1.1 Licensed) ===
/// Originally deleted from the Move framework, this module was restored and
/// significantly enhanced to provide feature parity with vault streams.
///
/// Major improvements from original:
/// 1. **Cancellability Control**: Added `is_cancelable` flag to create uncancelable vestings
/// 2. **Multiple Beneficiaries**: Support for primary + additional beneficiaries (up to 100)
/// 3. **Pause/Resume**: Vestings can be paused, extending the vesting period appropriately
/// 4. **Transfer Support**: Primary beneficiary role can be transferred if enabled
/// 5. **Rate Limiting**: Configurable withdrawal limits and minimum intervals
/// 6. **Cliff Periods**: Optional cliff before any vesting begins
/// 7. **Metadata**: Extensible metadata field for additional context
/// 8. **Shared Utilities**: Uses stream_utils module for consistent calculations
/// 9. **Action Descriptors**: Integrated with governance approval system
/// 10. **Comprehensive Events**: Full audit trail of all vesting operations
///
/// This refactor ensures DAOs can:
/// - Create employee vesting schedules that cannot be cancelled
/// - Implement investor token locks with cliff periods
/// - Pause vestings during disputes or investigations
/// - Support team vestings with multiple recipients
/// - Enforce withdrawal limits to prevent dumps
///
/// All calculations now use the shared stream_utils module to ensure
/// consistency with vault streams and prevent calculation divergence.

module account_actions::vesting;

// === Imports ===

use std::{
    string::{Self, String},
    option::{Self, Option},
    u64,

};
use sui::{
    balance::Balance,
    coin::{Self, Coin},
    clock::Clock,
    event,
    object::{Self, ID},
    transfer,
    tx_context,
    bcs::{Self, BCS},
};
use account_protocol::{
    action_validation,
    account::Account,
    intents::{Self, Expired, Intent},
    executable::{Self, Executable},
};
use account_extensions::framework_action_types::{Self, VestingCreate, VestingCancel};
use account_actions::stream_utils;

use fun account_protocol::intents::add_typed_action as Intent.add_typed_action;

// === Errors ===

const EBalanceNotEmpty: u64 = 0;
const ETooEarly: u64 = 1;
const EWrongVesting: u64 = 2;
const EVestingNotCancelable: u64 = 3;
const EVestingPaused: u64 = 4;
const EVestingNotPaused: u64 = 5;
const ENotTransferable: u64 = 6;
const EUnauthorizedBeneficiary: u64 = 7;
const EBeneficiaryAlreadyExists: u64 = 8;
const EBeneficiaryNotFound: u64 = 9;
const ECannotReduceBelowClaimed: u64 = 10;
const ETooManyBeneficiaries: u64 = 11;
const EInvalidVestingParameters: u64 = 12;
const ECliffNotReached: u64 = 13;
const EWithdrawalLimitExceeded: u64 = 14;
const EWithdrawalTooSoon: u64 = 15;
const EInvalidInput: u64 = 16;

// === Constants ===

// Use shared constant from stream_utils
const MAX_BENEFICIARIES: u64 = 100; // Matches stream_utils::max_beneficiaries()

// === Structs ===

/// Enhanced vesting with comprehensive features matching vault streams
public struct Vesting<phantom CoinType> has key {
    id: UID,
    // Core vesting parameters
    balance: Balance<CoinType>,
    claimed_amount: u64,
    start_timestamp: u64,
    end_timestamp: u64,
    cliff_time: Option<u64>,
    // Beneficiaries
    primary_beneficiary: address,
    additional_beneficiaries: vector<address>,
    max_beneficiaries: u64,
    // Rate limiting
    max_per_withdrawal: u64,
    min_interval_ms: u64,
    last_withdrawal_time: u64,
    // Control flags
    is_paused: bool,
    paused_at: Option<u64>,
    paused_duration: u64,
    is_transferable: bool,
    is_cancelable: bool,
    // Metadata
    metadata: Option<String>,
}

/// Cap enabling bearer to claim the vesting
public struct ClaimCap has key {
    id: UID,
    vesting_id: ID,
}

/// Action for creating a comprehensive vesting
public struct CreateVestingAction<phantom CoinType> has drop, store {
    amount: u64,
    start_timestamp: u64,
    end_timestamp: u64,
    cliff_time: Option<u64>,
    recipient: address,
    max_beneficiaries: u64,
    max_per_withdrawal: u64,
    min_interval_ms: u64,
    is_transferable: bool,
    is_cancelable: bool,
    metadata: Option<String>,
}

/// Action for canceling a vesting
public struct CancelVestingAction has drop, store {
    vesting_id: ID,
}

// === Events ===

/// Emitted when a vesting is created
public struct VestingCreated has copy, drop {
    vesting_id: ID,
    beneficiary: address,
    amount: u64,
    start_time: u64,
    end_time: u64,
}

/// Emitted when funds are claimed from vesting
public struct VestingClaimed has copy, drop {
    vesting_id: ID,
    beneficiary: address,
    amount: u64,
    remaining: u64,
}

/// Emitted when a vesting is cancelled
public struct VestingCancelled has copy, drop {
    vesting_id: ID,
    refunded_amount: u64,
    final_payment: u64,
}

/// Emitted when a vesting is paused
public struct VestingPaused has copy, drop {
    vesting_id: ID,
    paused_at: u64,
}

/// Emitted when a vesting is resumed
public struct VestingResumed has copy, drop {
    vesting_id: ID,
    resumed_at: u64,
    pause_duration: u64,
}

/// Emitted when a beneficiary is added
public struct BeneficiaryAdded has copy, drop {
    vesting_id: ID,
    new_beneficiary: address,
}

/// Emitted when a beneficiary is removed
public struct BeneficiaryRemoved has copy, drop {
    vesting_id: ID,
    removed_beneficiary: address,
}

/// Emitted when a vesting is transferred
public struct VestingTransferred has copy, drop {
    vesting_id: ID,
    old_beneficiary: address,
    new_beneficiary: address,
}

// === Destruction Functions ===

/// Destroy a CreateVestingAction after serialization
public fun destroy_create_vesting_action<CoinType>(action: CreateVestingAction<CoinType>) {
    let CreateVestingAction {
        amount: _,
        start_timestamp: _,
        end_timestamp: _,
        cliff_time: _,
        recipient: _,
        max_beneficiaries: _,
        max_per_withdrawal: _,
        min_interval_ms: _,
        is_transferable: _,
        is_cancelable: _,
        metadata: _,
    } = action;
}

/// Destroy a CancelVestingAction after serialization
public fun destroy_cancel_vesting_action(action: CancelVestingAction) {
    let CancelVestingAction { vesting_id: _ } = action;
}

// === Public Functions ===

/// Proposes to create a comprehensive vesting
public fun new_vesting<Config, Outcome, CoinType, IW: drop>(
    intent: &mut Intent<Outcome>, 
    _account: &Account<Config>, 
    amount: u64,
    start_timestamp: u64,
    end_timestamp: u64,
    cliff_time: Option<u64>,
    recipient: address,
    max_beneficiaries: u64,
    max_per_withdrawal: u64,
    min_interval_ms: u64,
    is_transferable: bool,
    is_cancelable: bool,
    metadata: Option<String>,
    intent_witness: IW,
) {
    // Create the action struct
    let action = CreateVestingAction<CoinType> {
        amount,
        start_timestamp,
        end_timestamp,
        cliff_time,
        recipient,
        max_beneficiaries,
        max_per_withdrawal,
        min_interval_ms,
        is_transferable,
        is_cancelable,
        metadata,
    };

    // Serialize it
    let action_data = bcs::to_bytes(&action);

    // Add to intent with pre-serialized bytes
    intent.add_typed_action(
        framework_action_types::vesting_create(),
        action_data,
        intent_witness
    );

    // Explicitly destroy the action struct
    destroy_create_vesting_action(action);
}

/// Creates the Vesting and ClaimCap objects from a CreateVestingAction
public fun do_vesting<Config, Outcome: store, CoinType, IW: drop>(
    executable: &mut Executable<Outcome>,
    _account: &mut Account<Config>,
    coin: Coin<CoinType>,
    clock: &Clock,
    _intent_witness: IW,
    ctx: &mut TxContext,
) {
    // Get BCS bytes from ActionSpec
    let specs = executable.intent().action_specs();
    let spec = specs.borrow(executable.action_idx());

    // CRITICAL: Assert that the action type is what we expect
    action_validation::assert_action_type<VestingCreate>(spec);


    let action_data = intents::action_spec_data(spec);

    // Create BCS reader and deserialize
    let mut reader = bcs::new(*action_data);
    let amount = bcs::peel_u64(&mut reader);
    let start_timestamp = bcs::peel_u64(&mut reader);
    let end_timestamp = bcs::peel_u64(&mut reader);
    let cliff_time = if (bcs::peel_bool(&mut reader)) {
        option::some(bcs::peel_u64(&mut reader))
    } else {
        option::none()
    };
    let recipient = bcs::peel_address(&mut reader);
    let max_beneficiaries = bcs::peel_u64(&mut reader);
    let max_per_withdrawal = bcs::peel_u64(&mut reader);
    let min_interval_ms = bcs::peel_u64(&mut reader);
    let is_transferable = bcs::peel_bool(&mut reader);
    let is_cancelable = bcs::peel_bool(&mut reader);
    let metadata = if (bcs::peel_bool(&mut reader)) {
        option::some(string::utf8(bcs::peel_vec_u8(&mut reader)))
    } else {
        option::none()
    };

    // Validate parameters
    assert!(amount > 0, EInvalidVestingParameters);
    assert!(end_timestamp > start_timestamp, EInvalidVestingParameters);
    assert!(start_timestamp >= clock.timestamp_ms(), EInvalidVestingParameters);
    if (cliff_time.is_some()) {
        let cliff = *cliff_time.borrow();
        assert!(cliff >= start_timestamp && cliff <= end_timestamp, EInvalidVestingParameters);
    };
    assert!(max_beneficiaries > 0 && max_beneficiaries <= MAX_BENEFICIARIES, EInvalidVestingParameters);

    let id = object::new(ctx);
    let vesting_id = id.to_inner();

    let vesting = Vesting<CoinType> {
        id,
        balance: coin.into_balance(),
        claimed_amount: 0,
        start_timestamp,
        end_timestamp,
        cliff_time,
        primary_beneficiary: recipient,
        additional_beneficiaries: vector::empty(),
        max_beneficiaries,
        max_per_withdrawal,
        min_interval_ms,
        last_withdrawal_time: 0,
        is_paused: false,
        paused_at: option::none(),
        paused_duration: 0,
        is_transferable,
        is_cancelable,
        metadata,
    };

    let claim_cap = ClaimCap {
        id: object::new(ctx),
        vesting_id,
    };

    // Emit creation event
    event::emit(VestingCreated {
        vesting_id,
        beneficiary: recipient,
        amount,
        start_time: start_timestamp,
        end_time: end_timestamp,
    });

    transfer::transfer(claim_cap, recipient);
    transfer::share_object(vesting);

    // Increment action index
    executable::increment_action_idx(executable);
}

/// Claims vested funds and returns the coin for composability
/// Caller must be an authorized beneficiary
public fun claim_vesting<CoinType>(
    vesting: &mut Vesting<CoinType>,
    amount: u64,
    clock: &Clock,
    ctx: &mut TxContext,
): Coin<CoinType> {
    // Check if sender is authorized beneficiary
    let sender = tx_context::sender(ctx);
    let is_authorized = vesting.primary_beneficiary == sender || 
                       vesting.additional_beneficiaries.contains(&sender);
    assert!(is_authorized, EUnauthorizedBeneficiary);
    
    // Check if vesting is paused
    assert!(!vesting.is_paused, EVestingPaused);
    
    let current_time = clock.timestamp_ms();
    
    // Check cliff if applicable
    if (vesting.cliff_time.is_some()) {
        let cliff = *vesting.cliff_time.borrow();
        assert!(current_time >= cliff, ECliffNotReached);
    } else {
        assert!(current_time >= vesting.start_timestamp, ETooEarly);
    };
    
    // Check rate limiting using shared utilities
    assert!(
        stream_utils::check_rate_limit(
            vesting.last_withdrawal_time,
            vesting.min_interval_ms,
            current_time
        ),
        EWithdrawalTooSoon
    );
    
    assert!(
        stream_utils::check_withdrawal_limit(
            amount,
            vesting.max_per_withdrawal
        ),
        EWithdrawalLimitExceeded
    );
    
    // Calculate claimable amount using shared utility
    let available = stream_utils::calculate_claimable(
        vesting.balance.value() + vesting.claimed_amount,
        vesting.claimed_amount,
        vesting.start_timestamp,
        vesting.end_timestamp,
        current_time,
        vesting.paused_duration,
        &vesting.cliff_time
    );
    assert!(amount <= available, EBalanceNotEmpty);
    
    // Update state
    vesting.claimed_amount = vesting.claimed_amount + amount;
    vesting.last_withdrawal_time = current_time;
    
    // Create payment coin
    let payment = coin::from_balance(vesting.balance.split(amount), ctx);
    
    // Emit event
    event::emit(VestingClaimed {
        vesting_id: object::id(vesting),
        beneficiary: sender,
        amount,
        remaining: vesting.balance.value(),
    });

    // Return the coin for composability
    payment
}

/// Convenience function: Claims vested funds and transfers to a specific recipient
/// This wraps the composable claim_vesting function for simple use cases
public fun claim_vesting_to<CoinType>(
    vesting: &mut Vesting<CoinType>,
    amount: u64,
    recipient: address,
    clock: &Clock,
    ctx: &mut TxContext,
) {
    let payment = claim_vesting(vesting, amount, clock, ctx);
    transfer::public_transfer(payment, recipient);
}

/// Convenience function: Claims vested funds and transfers to sender
/// This is the simplest way to claim for yourself
public fun claim_vesting_to_self<CoinType>(
    vesting: &mut Vesting<CoinType>,
    amount: u64,
    clock: &Clock,
    ctx: &mut TxContext,
) {
    claim_vesting_to(vesting, amount, tx_context::sender(ctx), clock, ctx);
}

/// Batch claim function: Claims from two vestings and combines the coins
/// This is useful for users with multiple vesting schedules who want to claim
/// and combine their vested tokens in a single transaction
public fun claim_two_vestings<CoinType>(
    vesting1: &mut Vesting<CoinType>,
    amount1: u64,
    vesting2: &mut Vesting<CoinType>,
    amount2: u64,
    clock: &Clock,
    ctx: &mut TxContext,
): Coin<CoinType> {
    // Claim from both vestings
    let mut coin1 = claim_vesting(vesting1, amount1, clock, ctx);
    let coin2 = claim_vesting(vesting2, amount2, clock, ctx);

    // Combine the coins
    coin1.join(coin2);
    coin1
}

/// Batch claim function: Claims from three vestings and combines the coins
public fun claim_three_vestings<CoinType>(
    vesting1: &mut Vesting<CoinType>,
    amount1: u64,
    vesting2: &mut Vesting<CoinType>,
    amount2: u64,
    vesting3: &mut Vesting<CoinType>,
    amount3: u64,
    clock: &Clock,
    ctx: &mut TxContext,
): Coin<CoinType> {
    // Claim from all three vestings
    let mut coin1 = claim_vesting(vesting1, amount1, clock, ctx);
    let coin2 = claim_vesting(vesting2, amount2, clock, ctx);
    let coin3 = claim_vesting(vesting3, amount3, clock, ctx);

    // Combine all coins
    coin1.join(coin2);
    coin1.join(coin3);
    coin1
}

/// Batch claim with transfer: Claims from two vestings and sends to recipient
public fun claim_two_vestings_to<CoinType>(
    vesting1: &mut Vesting<CoinType>,
    amount1: u64,
    vesting2: &mut Vesting<CoinType>,
    amount2: u64,
    recipient: address,
    clock: &Clock,
    ctx: &mut TxContext,
) {
    let combined = claim_two_vestings(vesting1, amount1, vesting2, amount2, clock, ctx);
    transfer::public_transfer(combined, recipient);
}

/// Cancels a vesting, returning unvested funds to the account
public fun cancel_vesting<Config, Outcome: store, CoinType, IW: drop>(
    executable: &mut Executable<Outcome>,
    account: &mut Account<Config>,
    vesting: Vesting<CoinType>,
    clock: &Clock,
    _intent_witness: IW,
    ctx: &mut TxContext,
) {
    // Get BCS bytes from ActionSpec
    let specs = executable.intent().action_specs();
    let spec = specs.borrow(executable.action_idx());
    let action_data = intents::action_spec_data(spec);

    // Create BCS reader and deserialize
    let mut reader = bcs::new(*action_data);
    let vesting_id = bcs::peel_address(&mut reader).to_id();

    assert!(object::id(&vesting) == vesting_id, EWrongVesting);
    assert!(vesting.is_cancelable, EVestingNotCancelable);

    let Vesting { 
        id, 
        mut balance, 
        claimed_amount,
        start_timestamp,
        end_timestamp,
        primary_beneficiary,
        paused_duration,
        cliff_time,
        additional_beneficiaries: _,
        max_beneficiaries: _,
        max_per_withdrawal: _,
        min_interval_ms: _,
        last_withdrawal_time: _,
        is_paused: _,
        paused_at: _,
        is_transferable: _,
        is_cancelable: _,
        metadata: _,
    } = vesting;
    
    let vesting_id = id.to_inner();
    id.delete();

    // Calculate vested/unvested split using shared utility
    let current_time = clock.timestamp_ms();
    let total_amount = balance.value() + claimed_amount;
    
    let (to_pay, to_refund, unvested_claimed) = stream_utils::split_vested_unvested(
        total_amount,
        claimed_amount,
        balance.value(),
        start_timestamp,
        end_timestamp,
        current_time,
        paused_duration,
        &cliff_time
    );

    // Pay remaining vested amount to beneficiary
    let final_payment = if (to_pay > 0) {
        let payment = coin::from_balance(balance.split(to_pay), ctx);
        transfer::public_transfer(payment, primary_beneficiary);
        to_pay
    } else {
        0
    };

    // Return unvested balance to account
    if (to_refund > 0) {
        let refund = coin::from_balance(balance, ctx);
        account.keep(refund, ctx);
    } else if (balance.value() > 0) {
        // Should not happen with correct calculation, but handle gracefully
        let leftover = coin::from_balance(balance, ctx);
        account.keep(leftover, ctx);
    } else {
        balance.destroy_zero();
    };

    // Emit cancellation event
    event::emit(VestingCancelled {
        vesting_id,
        refunded_amount: to_refund + unvested_claimed,
        final_payment,
    });

    // Increment action index
    executable::increment_action_idx(executable);
}

/// Pauses a vesting
public fun pause_vesting<CoinType>(
    vesting: &mut Vesting<CoinType>,
    clock: &Clock,
    ctx: &mut TxContext,
) {
    assert!(tx_context::sender(ctx) == vesting.primary_beneficiary, EUnauthorizedBeneficiary);
    assert!(!vesting.is_paused, EVestingNotPaused);
    
    let current_time = clock.timestamp_ms();
    vesting.is_paused = true;
    vesting.paused_at = option::some(current_time);
    
    event::emit(VestingPaused {
        vesting_id: object::id(vesting),
        paused_at: current_time,
    });
}

/// Resumes a paused vesting
public fun resume_vesting<CoinType>(
    vesting: &mut Vesting<CoinType>,
    clock: &Clock,
    ctx: &mut TxContext,
) {
    assert!(tx_context::sender(ctx) == vesting.primary_beneficiary, EUnauthorizedBeneficiary);
    assert!(vesting.is_paused, EVestingNotPaused);
    
    let current_time = clock.timestamp_ms();
    if (vesting.paused_at.is_some()) {
        let pause_start = *vesting.paused_at.borrow();
        let pause_duration = stream_utils::calculate_pause_duration(pause_start, current_time);
        vesting.paused_duration = vesting.paused_duration + pause_duration;
    };
    
    vesting.is_paused = false;
    vesting.paused_at = option::none();
    
    event::emit(VestingResumed {
        vesting_id: object::id(vesting),
        resumed_at: current_time,
        pause_duration: vesting.paused_duration,
    });
}

/// Adds a beneficiary to the vesting
public fun add_beneficiary<CoinType>(
    vesting: &mut Vesting<CoinType>,
    new_beneficiary: address,
    ctx: &mut TxContext,
) {
    assert!(tx_context::sender(ctx) == vesting.primary_beneficiary, EUnauthorizedBeneficiary);
    assert!(vesting.additional_beneficiaries.length() < vesting.max_beneficiaries - 1, ETooManyBeneficiaries);
    assert!(!vesting.additional_beneficiaries.contains(&new_beneficiary), EBeneficiaryAlreadyExists);
    assert!(new_beneficiary != vesting.primary_beneficiary, EBeneficiaryAlreadyExists);
    
    vesting.additional_beneficiaries.push_back(new_beneficiary);
    
    event::emit(BeneficiaryAdded {
        vesting_id: object::id(vesting),
        new_beneficiary,
    });
}

/// Removes a beneficiary from the vesting
public fun remove_beneficiary<CoinType>(
    vesting: &mut Vesting<CoinType>,
    beneficiary: address,
    ctx: &mut TxContext,
) {
    assert!(tx_context::sender(ctx) == vesting.primary_beneficiary, EUnauthorizedBeneficiary);
    
    let (found, index) = vesting.additional_beneficiaries.index_of(&beneficiary);
    assert!(found, EBeneficiaryNotFound);
    
    vesting.additional_beneficiaries.remove(index);
    
    event::emit(BeneficiaryRemoved {
        vesting_id: object::id(vesting),
        removed_beneficiary: beneficiary,
    });
}

/// Transfers the primary beneficiary role
public fun transfer_vesting<CoinType>(
    vesting: &mut Vesting<CoinType>,
    new_beneficiary: address,
    ctx: &mut TxContext,
) {
    assert!(tx_context::sender(ctx) == vesting.primary_beneficiary, EUnauthorizedBeneficiary);
    assert!(vesting.is_transferable, ENotTransferable);
    
    let old_beneficiary = vesting.primary_beneficiary;
    vesting.primary_beneficiary = new_beneficiary;
    
    // Remove new beneficiary from additional if present
    let (found, index) = vesting.additional_beneficiaries.index_of(&new_beneficiary);
    if (found) {
        vesting.additional_beneficiaries.remove(index);
    };
    
    event::emit(VestingTransferred {
        vesting_id: object::id(vesting),
        old_beneficiary,
        new_beneficiary,
    });
}

/// Updates vesting metadata
public fun update_metadata<CoinType>(
    vesting: &mut Vesting<CoinType>,
    metadata: Option<String>,
    ctx: &mut TxContext,
) {
    assert!(tx_context::sender(ctx) == vesting.primary_beneficiary, EUnauthorizedBeneficiary);
    vesting.metadata = metadata;
}

/// Proposes to cancel a vesting
public fun new_cancel_vesting<Config, Outcome, IW: drop>(
    intent: &mut Intent<Outcome>,
    _account: &Account<Config>,
    vesting_id: ID,
    intent_witness: IW,
) {
    // Create the action struct
    let action = CancelVestingAction { vesting_id };

    // Serialize it
    let action_data = bcs::to_bytes(&action);

    // Add to intent with pre-serialized bytes
    intent.add_typed_action(
        framework_action_types::vesting_cancel(),
        action_data,
        intent_witness
    );

    // Explicitly destroy the action struct
    destroy_cancel_vesting_action(action);
}

/// Deletes the CreateVestingAction
public fun delete_vesting_action<CoinType>(expired: &mut Expired) {
    use sui::bcs;
    use std::string;

    let spec = account_protocol::intents::remove_action_spec(expired);
    let action_data = account_protocol::intents::action_spec_data(&spec);
    let mut reader = bcs::new(*action_data);

    // We don't need the values, but we must peel them to consume the bytes
    let CreateVestingAction<CoinType> {
        amount: _,
        start_timestamp: _,
        end_timestamp: _,
        cliff_time: _,
        recipient: _,
        max_beneficiaries: _,
        max_per_withdrawal: _,
        min_interval_ms: _,
        is_transferable: _,
        is_cancelable: _,
        metadata: _,
    } = CreateVestingAction {
        amount: bcs::peel_u64(&mut reader),
        start_timestamp: bcs::peel_u64(&mut reader),
        end_timestamp: bcs::peel_u64(&mut reader),
        cliff_time: bcs::peel_option_u64(&mut reader),
        recipient: bcs::peel_address(&mut reader),
        max_beneficiaries: bcs::peel_u64(&mut reader),
        max_per_withdrawal: bcs::peel_u64(&mut reader),
        min_interval_ms: bcs::peel_u64(&mut reader),
        is_transferable: bcs::peel_bool(&mut reader),
        is_cancelable: bcs::peel_bool(&mut reader),
        metadata: (if (bcs::peel_bool(&mut reader)) {
            option::some(string::utf8(bcs::peel_vec_u8(&mut reader)))
        } else {
            option::none()
        }),
    };
}

/// Deletes the CancelVestingAction
public fun delete_cancel_vesting_action(expired: &mut Expired) {
    let _spec = intents::remove_action_spec(expired);
    // ActionSpec has drop, automatically cleaned up
}

// === Private Functions ===
// (Removed compute_vested - now using stream_utils::calculate_linear_vested)

// === Test Functions ===

#[test_only]
public fun balance<CoinType>(vesting: &Vesting<CoinType>): u64 {
    vesting.balance.value()
}

#[test_only]
public fun is_cancelable<CoinType>(vesting: &Vesting<CoinType>): bool {
    vesting.is_cancelable
}

#[test_only]
public fun is_transferable<CoinType>(vesting: &Vesting<CoinType>): bool {
    vesting.is_transferable
}

#[test_only]
public fun is_paused<CoinType>(vesting: &Vesting<CoinType>): bool {
    vesting.is_paused
}

#[test_only]
public fun beneficiaries_count<CoinType>(vesting: &Vesting<CoinType>): u64 {
    1 + vesting.additional_beneficiaries.length()
}
module account_actions::owned_intents;

// === Imports ===

use std::string::String;
use sui::{
    transfer::Receiving,
    coin::Coin,
};
use account_protocol::{
    account::{Account, Auth},
    executable::Executable,
    owned,
    intents::Params,
    intent_interface,
};
use account_actions::{
    transfer as acc_transfer,
    vault,
    version,
};

// === Aliases ===

use fun intent_interface::process_intent as Account.process_intent;

// === Errors ===

const EObjectsRecipientsNotSameLength: u64 = 0;
const ENoVault: u64 = 1;

// === Structs ===

/// Intent Witness defining the intent to withdraw a coin and deposit it into a vault.
public struct WithdrawAndTransferToVaultIntent() has copy, drop;
/// Intent Witness defining the intent to withdraw and transfer multiple objects.
public struct WithdrawAndTransferIntent() has copy, drop;

// === Public functions ===

/// Creates a WithdrawAndTransferToVaultIntent and adds it to an Account.
public fun request_withdraw_and_transfer_to_vault<Config, Outcome: store, CoinType: drop>(
    auth: Auth,
    account: &mut Account<Config>, 
    params: Params,
    outcome: Outcome,
    coin_id: ID,
    coin_amount: u64,
    vault_name: String,
    ctx: &mut TxContext
) {
    account.verify(auth);
    params.assert_single_execution();
    assert!(vault::has_vault(account, vault_name), ENoVault);

    intent_interface::build_intent!(
        account,
        params,
        outcome,
        b"".to_string(),
        version::current(),
        WithdrawAndTransferToVaultIntent(),
        ctx,
        |intent, iw| {
            owned::new_withdraw(intent, account, coin_id, iw);
            vault::new_deposit<_, CoinType, _>(intent, vault_name, coin_amount, iw);
        }
    );
}

/// Executes a WithdrawAndTransferToVaultIntent, deposits a coin owned by the account into a vault.
public fun execute_withdraw_and_transfer_to_vault<Config, Outcome: store, CoinType: drop>(
    executable: &mut Executable<Outcome>, 
    account: &mut Account<Config>, 
    receiving: Receiving<Coin<CoinType>>,
) {
    account.process_intent!(
        executable,
        version::current(),
        WithdrawAndTransferToVaultIntent(),
        |executable, iw| {
            let object = owned::do_withdraw(executable, account, receiving, iw);
            vault::do_deposit<_, _, CoinType, _>(executable, account, object, version::current(), iw);
        }
    );
}

/// Creates a WithdrawAndTransferIntent and adds it to an Account.
public fun request_withdraw_and_transfer<Config, Outcome: store>(
    auth: Auth,
    account: &mut Account<Config>, 
    params: Params,
    outcome: Outcome,
    object_ids: vector<ID>,
    recipients: vector<address>,
    ctx: &mut TxContext
) {
    account.verify(auth);
    params.assert_single_execution();
    assert!(object_ids.length() == recipients.length(), EObjectsRecipientsNotSameLength);

    intent_interface::build_intent!(
        account,
        params,
        outcome,
        b"".to_string(),
        version::current(),
        WithdrawAndTransferIntent(),
        ctx,
        |intent, iw| object_ids.zip_do!(recipients, |object_id, recipient| {
            owned::new_withdraw(intent, account, object_id, iw);
            acc_transfer::new_transfer(intent, recipient, iw);
        })
    );
}

/// Executes a WithdrawAndTransferIntent, transfers an object owned by the account. Can be looped over.
public fun execute_withdraw_and_transfer<Config, Outcome: store, T: key + store>(
    executable: &mut Executable<Outcome>, 
    account: &mut Account<Config>, 
    receiving: Receiving<T>,
) {
    account.process_intent!(
        executable,
        version::current(),
        WithdrawAndTransferIntent(),
        |executable, iw| {
            let object = owned::do_withdraw(executable, account, receiving, iw);
            acc_transfer::do_transfer(executable, object, iw);
        }
    );
}

module account_actions::kiosk_intents;

// === Imports ===

use std::string::String;
use sui::{
    kiosk::{Kiosk, KioskOwnerCap},
    transfer_policy::{TransferPolicy, TransferRequest},
};
use account_protocol::{
    account::{Account, Auth},
    intents::Params,
    executable::Executable,
    intent_interface,
};
use account_actions::{
    kiosk as acc_kiosk,
    version,
};

// === Aliases ===

use fun intent_interface::build_intent as Account.build_intent;
use fun intent_interface::process_intent as Account.process_intent;

// === Errors ===

const ENoLock: u64 = 0;
const ENftsPricesNotSameLength: u64 = 1;

// === Structs ===

/// Intent Witness defining the intent to take nfts from a kiosk managed by a account to another kiosk.
public struct TakeNftsIntent() has copy, drop;
/// Intent Witness defining the intent to list nfts in a kiosk managed by a account.
public struct ListNftsIntent() has copy, drop;

// === Public functions ===

/// Creates a TakeNftsIntent and adds it to an Account.
public fun request_take_nfts<Config, Outcome: store>(
    auth: Auth,
    account: &mut Account<Config>,
    params: Params,
    outcome: Outcome,
    kiosk_name: String,
    nft_ids: vector<ID>,
    recipient: address,
    ctx: &mut TxContext
) {
    account.verify(auth);
    params.assert_single_execution();
    assert!(acc_kiosk::has_lock(account, kiosk_name), ENoLock);

    account.build_intent!(
        params,
        outcome, 
        kiosk_name,
        version::current(),
        TakeNftsIntent(),
        ctx,
        |intent, iw| nft_ids.do!(|nft_id| acc_kiosk::new_take(intent, kiosk_name, nft_id, recipient, iw))
    );
}

/// Executes a TakeNftsIntent, takes nfts from a kiosk managed by a account to another kiosk. Can be looped over.
public fun execute_take_nfts<Config, Outcome: store, Nft: key + store>(
    executable: &mut Executable<Outcome>,
    account: &mut Account<Config>,
    account_kiosk: &mut Kiosk, 
    recipient_kiosk: &mut Kiosk, 
    recipient_cap: &KioskOwnerCap, 
    policy: &mut TransferPolicy<Nft>,
    ctx: &mut TxContext
): TransferRequest<Nft> {
    account.process_intent!(
        executable,
        version::current(),
        TakeNftsIntent(),
        |executable, iw| acc_kiosk::do_take<_, _, Nft, _>(
            executable, 
            account, 
            account_kiosk, 
            recipient_kiosk, 
            recipient_cap, 
            policy, 
            version::current(), 
            iw, 
            ctx
        ),
    )
}

/// Creates a ListNftsIntent and adds it to an Account.
public fun request_list_nfts<Config, Outcome: store>(
    auth: Auth,
    account: &mut Account<Config>,
    params: Params,
    outcome: Outcome,
    kiosk_name: String,
    nft_ids: vector<ID>,
    prices: vector<u64>,
    ctx: &mut TxContext
) {
    account.verify(auth);
    assert!(acc_kiosk::has_lock(account, kiosk_name), ENoLock);
    assert!(nft_ids.length() == prices.length(), ENftsPricesNotSameLength);

    account.build_intent!(
        params,
        outcome,
        kiosk_name,
        version::current(),
        ListNftsIntent(),
        ctx,
        |intent, iw| nft_ids.zip_do!(prices, |nft_id, price| acc_kiosk::new_list(intent, kiosk_name, nft_id, price, iw))
    );
}

/// Executes a ListNftsIntent, lists nfts in a kiosk managed by a account. Can be looped over.
public fun execute_list_nfts<Config, Outcome: store, Nft: key + store>(
    executable: &mut Executable<Outcome>,
    account: &mut Account<Config>,
    kiosk: &mut Kiosk,
) {
    account.process_intent!(
        executable,
        version::current(),
        ListNftsIntent(),
        |executable, iw| acc_kiosk::do_list<_, _, Nft, _>(executable, account, kiosk, version::current(), iw),
    );
}module account_actions::package_upgrade_intents;

// === Imports ===

use std::string::String;
use sui::{
    package::{Self, UpgradeTicket, UpgradeReceipt},
    clock::Clock,
};
use account_protocol::{
    account::{Account, Auth},
    executable::Executable,
    intents::Params,
    intent_interface,
};
use account_actions::{
    package_upgrade,
    version,
};

// === Aliases ===

use fun intent_interface::build_intent as Account.build_intent;
use fun intent_interface::process_intent as Account.process_intent;

// === Errors ===

const EInvalidPolicy: u64 = 1;
const EPolicyShouldRestrict: u64 = 2;
const ENoLock: u64 = 3;
const ETimeDelay: u64 = 4;

// === Structs ===

/// Intent Witness defining the intent to upgrade a package.
public struct UpgradePackageIntent() has copy, drop;
/// Intent Witness defining the intent to restrict an UpgradeCap.
public struct RestrictPolicyIntent() has copy, drop;

// === Public Functions ===

/// Creates an UpgradePackageIntent and adds it to an Account.
public fun request_upgrade_package<Config, Outcome: store>(
    auth: Auth,
    account: &mut Account<Config>, 
    params: Params,
    outcome: Outcome,
    package_name: String,
    digest: vector<u8>,
    ctx: &mut TxContext
) {
    account.verify(auth);
    params.assert_single_execution();

    assert!(package_upgrade::has_cap(account, package_name), ENoLock);
    assert!(
        params.execution_times()[0] >= params.creation_time() + package_upgrade::get_time_delay(account, package_name), 
        ETimeDelay
    );

    account.build_intent!(
        params,
        outcome,
        package_name,
        version::current(),
        UpgradePackageIntent(),
        ctx,
        |intent, iw| {
            package_upgrade::new_upgrade(intent, package_name, digest, iw);
            package_upgrade::new_commit(intent, package_name, iw);
        },
    );
}

/// Executes an UpgradePackageIntent, returns the UpgradeTicket for upgrading.
public fun execute_upgrade_package<Config, Outcome: store>(
    executable: &mut Executable<Outcome>,
    account: &mut Account<Config>,
    clock: &Clock,
): UpgradeTicket {
    account.process_intent!(
        executable,
        version::current(),
        UpgradePackageIntent(),
        |executable, iw| package_upgrade::do_upgrade(executable, account, clock, version::current(), iw)
    )
}    

/// Need to consume the ticket to upgrade the package before completing the intent.

public fun execute_commit_upgrade<Config, Outcome: store>(
    executable: &mut Executable<Outcome>,
    account: &mut Account<Config>,
    receipt: UpgradeReceipt,
) {
    account.process_intent!(
        executable,
        version::current(),
        UpgradePackageIntent(),
        |executable, iw| package_upgrade::do_commit(executable, account, receipt, version::current(), iw)
    )
}

/// Creates a RestrictPolicyIntent and adds it to an Account.
public fun request_restrict_policy<Config, Outcome: store>(
    auth: Auth,
    account: &mut Account<Config>, 
    params: Params,
    outcome: Outcome,
    package_name: String,
    policy: u8,
    ctx: &mut TxContext
) {
    account.verify(auth);
    params.assert_single_execution();

    let current_policy = package_upgrade::get_cap_policy(account, package_name);
    assert!(policy > current_policy, EPolicyShouldRestrict);
    assert!(
        policy == package::additive_policy() ||
        policy == package::dep_only_policy() ||
        policy == 255, // make immutable
        EInvalidPolicy
    );

    account.build_intent!(
        params,
        outcome,
        package_name,
        version::current(),
        RestrictPolicyIntent(),
        ctx,
        |intent, iw| package_upgrade::new_restrict(intent, package_name, policy, iw),
    );
}

/// Restricts the upgrade policy.
public fun execute_restrict_policy<Config, Outcome: store>(
    executable: &mut Executable<Outcome>,
    account: &mut Account<Config>,
) {
    account.process_intent!(
        executable,
        version::current(),
        RestrictPolicyIntent(),
        |executable, iw| package_upgrade::do_restrict(executable, account, version::current(), iw)
    );
}module account_actions::empty_intents;

// === Imports ===

use account_protocol::{
    account::{Account, Auth},
    executable::Executable,
    intents::Params,
    intent_interface,
};
use account_actions::version;

// === Aliases ===

use fun intent_interface::build_intent as Account.build_intent;
use fun intent_interface::process_intent as Account.process_intent;

// === Structs ===    

/// Intent Witness defining an intent with no action.
public struct EmptyIntent() has copy, drop;

// === Public functions ===

/// Creates an EmptyIntent and adds it to an Account.
public fun request_empty<Config, Outcome: store>(
    auth: Auth,
    account: &mut Account<Config>,
    params: Params,
    outcome: Outcome,
    ctx: &mut TxContext
) {
    account.verify(auth);

    account.build_intent!(
        params,
        outcome, 
        b"".to_string(),
        version::current(),
        EmptyIntent(),
        ctx,
        |_intent, _iw| {},
    );
}

/// Executes an EmptyIntent (to be able to delete it)
public fun execute_empty<Config, Outcome: store>(
    executable: &mut Executable<Outcome>,
    account: &mut Account<Config>,
) {
    account.process_intent!(
        executable, 
        version::current(), 
        EmptyIntent(), 
        |_executable, _iw| {},
    )
}// ============================================================================
// FORK MODIFICATION NOTICE - Vault Intents with Hot Potato Results
// ============================================================================
// Intent helper module for vault operations.
//
// CHANGES IN THIS FORK:
// - Updated to consume hot potato results (SpendResult) from do_spend
// - Added action_results::consume_spend_result() calls
// - Ensures proper cleanup of hot potato results in intent chains
// ============================================================================

module account_actions::vault_intents;

// === Imports ===

use std::string::String;
use account_protocol::{
    account::{Account, Auth},
    executable::Executable,
    intents::Params,
    intent_interface,
    action_results,
};
use account_actions::{
    transfer as acc_transfer,
    vault,
    version,
};

// === Aliases ===

use fun intent_interface::build_intent as Account.build_intent;
use fun intent_interface::process_intent as Account.process_intent;

// === Errors ===

const ENotSameLength: u64 = 0;
const EInsufficientFunds: u64 = 1;
const ECoinTypeDoesntExist: u64 = 2;

// === Structs ===

/// Intent Witness defining the vault spend and transfer intent, and associated role.
public struct SpendAndTransferIntent() has copy, drop;

// === Public Functions ===

/// Creates a SpendAndTransferIntent and adds it to an Account.
public fun request_spend_and_transfer<Config, Outcome: store, CoinType: drop>(
    auth: Auth,
    account: &mut Account<Config>, 
    params: Params,
    outcome: Outcome,
    vault_name: String,
    amounts: vector<u64>,
    recipients: vector<address>,
    ctx: &mut TxContext
) {
    account.verify(auth);
    assert!(amounts.length() == recipients.length(), ENotSameLength);
    
    let vault = vault::borrow_vault(account, vault_name);
    assert!(vault.coin_type_exists<CoinType>(), ECoinTypeDoesntExist);
    assert!(
        amounts.fold!(0u64, |sum, amount| sum + amount) <= vault.coin_type_value<CoinType>(), 
        EInsufficientFunds
    );
    
    account.build_intent!(
        params,
        outcome,
        vault_name,
        version::current(),
        SpendAndTransferIntent(),
        ctx,
        |intent, iw| amounts.zip_do!(recipients, |amount, recipient| {
            vault::new_spend<_, CoinType, _>(intent, vault_name, amount, iw);
            acc_transfer::new_transfer(intent, recipient, iw);
        })
    );
}

/// Executes a SpendAndTransferIntent, transfers coins from the vault to the recipients. Can be looped over.
public fun execute_spend_and_transfer<Config, Outcome: store, CoinType: drop>(
    executable: &mut Executable<Outcome>, 
    account: &mut Account<Config>, 
    ctx: &mut TxContext
) {
    account.process_intent!(
        executable,
        version::current(),
        SpendAndTransferIntent(),
        |executable, iw| {
            let (coin, result) = vault::do_spend<_, _, CoinType, _>(executable, account, version::current(), iw, ctx);
            // Consume the hot potato result
            action_results::consume_spend_result(result);
            acc_transfer::do_transfer(executable, coin, iw);
        }
    );
}

// ============================================================================
// FORK MODIFICATION NOTICE - Currency Intents with Hot Potato Results
// ============================================================================
// Intent helper module for currency operations.
//
// CHANGES IN THIS FORK:
// - Updated to consume hot potato results (MintResult) from do_mint
// - Added action_results::consume_mint_result() calls
// - Ensures proper cleanup of hot potato results in intent chains
// ============================================================================

module account_actions::currency_intents;

// === Imports ===

use std::{
    ascii,
    string::String,
    type_name,
};
use sui::{
    transfer::Receiving,
    coin::{Coin, CoinMetadata},
};
use account_protocol::{
    account::{Account, Auth},
    executable::Executable,
    intents::Params,
    owned,
    intent_interface,
    action_results
};
use account_actions::{
    transfer as acc_transfer,
    version,
    currency,
};

// === Aliases ===

use fun intent_interface::build_intent as Account.build_intent;
use fun intent_interface::process_intent as Account.process_intent;

// === Errors ===

const EAmountsRecipentsNotSameLength: u64 = 0;
const EMaxSupply: u64 = 1;
const ENoLock: u64 = 2;
const ECannotUpdateSymbol: u64 = 3;
const ECannotUpdateName: u64 = 4;
const ECannotUpdateDescription: u64 = 5;
const ECannotUpdateIcon: u64 = 6;
const EMintDisabled: u64 = 7;
const EBurnDisabled: u64 = 8;

// === Structs ===

/// Intent Witness defining the intent to disable one or more permissions.
public struct DisableRulesIntent() has copy, drop;
/// Intent Witness defining the intent to update the CoinMetadata associated with a locked TreasuryCap.
public struct UpdateMetadataIntent() has copy, drop;
/// Intent Witness defining the intent to transfer a minted coin.
public struct MintAndTransferIntent() has copy, drop;
/// Intent Witness defining the intent to burn coins from the account using a locked TreasuryCap.
public struct WithdrawAndBurnIntent() has copy, drop;

// === Public functions ===

/// Creates a DisableRulesIntent and adds it to an Account.
public fun request_disable_rules<Config, Outcome: store, CoinType>(
    auth: Auth,
    account: &mut Account<Config>,
    params: Params,
    outcome: Outcome,
    mint: bool,
    burn: bool,
    update_symbol: bool,
    update_name: bool,
    update_description: bool,
    update_icon: bool,
    ctx: &mut TxContext
) {
    account.verify(auth);
    params.assert_single_execution();
    assert!(currency::has_cap<_, CoinType>(account), ENoLock);

    account.build_intent!(
        params,
        outcome, 
        type_name_to_string<CoinType>(),
        version::current(),
        DisableRulesIntent(),   
        ctx,
        |intent, iw| currency::new_disable<_, CoinType, _>(
            intent, mint, burn, update_symbol, update_name, update_description, update_icon, iw
        ),
    );
}

/// Executes a DisableRulesIntent, disables rules for the coin forever.
public fun execute_disable_rules<Config, Outcome: store, CoinType>(
    executable: &mut Executable<Outcome>,
    account: &mut Account<Config>,
) {
    account.process_intent!(
        executable,
        version::current(),
        DisableRulesIntent(),
        |executable, iw| currency::do_disable<_, _, CoinType, _>(executable, account, version::current(), iw)
    );
}

/// Creates an UpdateMetadataIntent and adds it to an Account.
public fun request_update_metadata<Config, Outcome: store, CoinType>(
    auth: Auth,
    account: &mut Account<Config>,
    params: Params,
    outcome: Outcome,
    md_symbol: Option<ascii::String>,
    md_name: Option<String>,
    md_description: Option<String>,
    md_icon_url: Option<ascii::String>,
    ctx: &mut TxContext
) {
    account.verify(auth);
    params.assert_single_execution();

    let rules = currency::borrow_rules<_, CoinType>(account);
    if (!rules.can_update_symbol()) assert!(md_symbol.is_none(), ECannotUpdateSymbol);
    if (!rules.can_update_name()) assert!(md_name.is_none(), ECannotUpdateName);
    if (!rules.can_update_description()) assert!(md_description.is_none(), ECannotUpdateDescription);
    if (!rules.can_update_icon()) assert!(md_icon_url.is_none(), ECannotUpdateIcon);

    account.build_intent!(
        params,
        outcome, 
        type_name_to_string<CoinType>(),
        version::current(),
        UpdateMetadataIntent(),
        ctx,
        |intent, iw| currency::new_update<_, CoinType, _>(
            intent, md_symbol, md_name, md_description, md_icon_url, iw
        ),
    );
}

/// Executes an UpdateMetadataIntent, updates the CoinMetadata.
public fun execute_update_metadata<Config, Outcome: store, CoinType>(
    executable: &mut Executable<Outcome>,
    account: &mut Account<Config>,
    metadata: &mut CoinMetadata<CoinType>,
) {
    account.process_intent!(
        executable,
        version::current(),
        UpdateMetadataIntent(),
        |executable, iw| currency::do_update<_, _, CoinType, _>(executable, account, metadata, version::current(), iw)
    );
}

/// Creates a MintAndTransferIntent and adds it to an Account.
public fun request_mint_and_transfer<Config, Outcome: store, CoinType>(
    auth: Auth,
    account: &mut Account<Config>,
    params: Params,
    outcome: Outcome,
    amounts: vector<u64>,
    recipients: vector<address>,
    ctx: &mut TxContext
) {
    account.verify(auth);
    assert!(amounts.length() == recipients.length(), EAmountsRecipentsNotSameLength);

    let rules = currency::borrow_rules<_, CoinType>(account);
    assert!(rules.can_mint(), EMintDisabled);
    let sum = amounts.fold!(0, |sum, amount| sum + amount);
    if (rules.max_supply().is_some()) assert!(sum <= *rules.max_supply().borrow(), EMaxSupply);

    account.build_intent!(
        params,
        outcome, 
        type_name_to_string<CoinType>(),
        version::current(),
        MintAndTransferIntent(),
        ctx,
        |intent, iw| amounts.zip_do!(recipients, |amount, recipient| {
            currency::new_mint<_, CoinType, _>(intent, amount, iw);
            acc_transfer::new_transfer(intent, recipient, iw);
        })
    );
}

/// Executes a MintAndTransferIntent, sends managed coins. Can be looped over.
public fun execute_mint_and_transfer<Config, Outcome: store, CoinType>(
    executable: &mut Executable<Outcome>, 
    account: &mut Account<Config>, 
    ctx: &mut TxContext
) {
    account.process_intent!(
        executable,
        version::current(),
        MintAndTransferIntent(),
        |executable, iw| {
            let (coin, result) = currency::do_mint<_, _, CoinType, _>(executable, account, version::current(), iw, ctx);
            // Consume the hot potato result
            action_results::consume_mint_result(result);
            acc_transfer::do_transfer(executable, coin, iw);
        }
    );
}


/// Creates a WithdrawAndBurnIntent and adds it to an Account.
public fun request_withdraw_and_burn<Config, Outcome: store, CoinType>(
    auth: Auth,
    account: &mut Account<Config>,
    params: Params,
    outcome: Outcome,
    coin_id: ID,
    amount: u64,
    ctx: &mut TxContext
) {
    account.verify(auth);
    params.assert_single_execution();

    let rules = currency::borrow_rules<_, CoinType>(account);
    assert!(rules.can_burn(), EBurnDisabled);

    intent_interface::build_intent!(
        account,
        params,
        outcome, 
        type_name_to_string<CoinType>(),
        version::current(),
        WithdrawAndBurnIntent(), 
        ctx,
        |intent, iw| {
            owned::new_withdraw(intent, account, coin_id, iw);
            currency::new_burn<_, CoinType, _>(intent, amount, iw);
        }
    );
}


/// Executes a WithdrawAndBurnIntent, burns a coin owned by the account.
public fun execute_withdraw_and_burn<Config, Outcome: store, CoinType>(
    executable: &mut Executable<Outcome>,
    account: &mut Account<Config>,
    receiving: Receiving<Coin<CoinType>>,
) {
    account.process_intent!(
        executable,
        version::current(),
        WithdrawAndBurnIntent(),
        |executable, iw| {
            let coin = owned::do_withdraw(executable, account, receiving, iw);
            currency::do_burn<_, _, CoinType, _>(executable, account, coin, version::current(), iw);
        }
    );
}

// === Private functions ===

fun type_name_to_string<T>(): String {
    type_name::with_defining_ids<T>().into_string().to_string()
}module account_actions::access_control_intents;

// === Imports ===

use std::{
    string::String,
    type_name,
};
use account_protocol::{
    account::{Account, Auth},
    executable::Executable,
    intents::Params,
    intent_interface,
};
use account_actions::{
    access_control as ac,
    version,
};

// === Aliases ===

use fun intent_interface::build_intent as Account.build_intent;
use fun intent_interface::process_intent as Account.process_intent;

// === Errors ===

const ENoLock: u64 = 0;

// === Structs ===    

/// Intent Witness defining the intent to borrow an access cap.
public struct BorrowCapIntent() has copy, drop;

// === Public functions ===

/// Creates a BorrowCapIntent and adds it to an Account.
public fun request_borrow_cap<Config, Outcome: store, Cap>(
    auth: Auth,
    account: &mut Account<Config>,
    params: Params,
    outcome: Outcome,
    ctx: &mut TxContext
) {
    account.verify(auth);
    assert!(ac::has_lock<_, Cap>(account), ENoLock);

    account.build_intent!(
        params,
        outcome, 
        type_name_to_string<Cap>(),
        version::current(),
        BorrowCapIntent(),
        ctx,
        |intent, iw| {
            ac::new_borrow<_, Cap, _>(intent, iw);
            ac::new_return<_, Cap, _>(intent, iw);
        },
    );
}

/// Executes a BorrowCapIntent, returns a cap and a hot potato.
public fun execute_borrow_cap<Config, Outcome: store, Cap: key + store>(
    executable: &mut Executable<Outcome>,
    account: &mut Account<Config>,
): Cap {
    account.process_intent!(
        executable, 
        version::current(), 
        BorrowCapIntent(), 
        |executable, iw| ac::do_borrow(executable, account, version::current(), iw),
    )
}

/// Completes a BorrowCapIntent, destroys the executable and returns the cap to the account if the matching hot potato is returned.
public fun execute_return_cap<Config, Outcome: store, Cap: key + store>(
    executable: &mut Executable<Outcome>,
    account: &mut Account<Config>,
    cap: Cap,
) {
    account.process_intent!(
        executable, 
        version::current(), 
        BorrowCapIntent(), 
        |executable, iw| ac::do_return(executable, account, cap, version::current(), iw),
    )
}

// === Private functions ===

fun type_name_to_string<T>(): String {
    type_name::with_defining_ids<T>().into_string().to_string()
}